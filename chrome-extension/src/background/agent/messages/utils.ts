import { type BaseMessage, AIMessage, HumanMessage, SystemMessage, ToolMessage } from '@langchain/core/messages';

export function removeThinkTags(text: string): string {
  // Step 1: Remove well-formed <think>...</think>
  const thinkTagsRegex = /<think>[\s\S]*?<\/think>/g;
  let result = text.replace(thinkTagsRegex, '');

  // Step 2: If there's an unmatched closing tag </think>,
  // remove everything up to and including that.
  const strayCloseTagRegex = /[\s\S]*?<\/think>/g;
  result = result.replace(strayCloseTagRegex, '');

  return result.trim();
}

/**
 * Extract JSON from model output, handling both plain JSON and code-block-wrapped JSON.
 * @param content - The string content that potentially contains JSON.
 * @returns Parsed JSON object
 * @throws Error if JSON parsing fails
 */
export function extractJsonFromModelOutput(content: string): Record<string, unknown> {
  try {
    let processedContent = content;

    // If content is wrapped in code blocks, extract just the JSON part
    if (processedContent.includes('```')) {
      // Find the JSON content between code blocks
      const parts = processedContent.split('```');
      processedContent = parts[1];

      // Remove language identifier if present (e.g., 'json\n')
      if (processedContent.includes('\\n')) {
        const newlineIndex = processedContent.indexOf('\\n');
        processedContent = processedContent.substring(newlineIndex + 1);
      }
    }

    // Parse the cleaned content
    return JSON.parse(processedContent);
  } catch (e) {
    console.warn(`Failed to parse model output: ${content} ${e instanceof Error ? e.message : String(e)}`);
    throw new Error('Could not parse response.');
  }
}

/**
 * Convert input messages to a format that is compatible with the planner model
 * @param inputMessages - List of messages to convert
 * @param modelName - Name of the model to convert messages for
 * @returns Converted list of messages
 */
export function convertInputMessages(inputMessages: BaseMessage[], modelName: string | null): BaseMessage[] {
  if (modelName === null) {
    return inputMessages;
  }
  if (modelName === 'deepseek-reasoner' || modelName.includes('deepseek-r1')) {
    const convertedInputMessages = convertMessagesForNonFunctionCallingModels(inputMessages);
    let mergedInputMessages = mergeSuccessiveMessages(convertedInputMessages, HumanMessage);
    mergedInputMessages = mergeSuccessiveMessages(mergedInputMessages, AIMessage);
    return mergedInputMessages;
  }
  return inputMessages;
}

/**
 * Convert messages for non-function-calling models
 * @param inputMessages - List of messages to convert
 * @returns Converted list of messages
 */
function convertMessagesForNonFunctionCallingModels(inputMessages: BaseMessage[]): BaseMessage[] {
  const outputMessages: BaseMessage[] = [];

  for (const message of inputMessages) {
    if (message instanceof HumanMessage || message instanceof SystemMessage) {
      outputMessages.push(message);
    } else if (message instanceof ToolMessage) {
      outputMessages.push(new HumanMessage({ content: message.content }));
    } else if (message instanceof AIMessage) {
      if (message.tool_calls) {
        const toolCalls = JSON.stringify(message.tool_calls);
        outputMessages.push(new AIMessage({ content: toolCalls }));
      } else {
        outputMessages.push(message);
      }
    } else {
      throw new Error(`Unknown message type: ${message.constructor.name}`);
    }
  }

  return outputMessages;
}

/**
 * Merge successive messages of the same type into one message
 * Some models like deepseek-reasoner don't allow multiple human messages in a row
 * @param messages - List of messages to merge
 * @param classToMerge - Message class type to merge
 * @returns Merged list of messages
 */
function mergeSuccessiveMessages(
  messages: BaseMessage[],
  classToMerge: typeof HumanMessage | typeof AIMessage,
): BaseMessage[] {
  const mergedMessages: BaseMessage[] = [];
  let streak = 0;

  for (const message of messages) {
    if (message instanceof classToMerge) {
      streak += 1;
      if (streak > 1) {
        const lastMessage = mergedMessages[mergedMessages.length - 1];
        if (Array.isArray(message.content)) {
          // Handle array content case
          if (typeof lastMessage.content === 'string') {
            const textContent = message.content.find(
              item => typeof item === 'object' && 'type' in item && item.type === 'text',
            );
            if (textContent && 'text' in textContent) {
              lastMessage.content += textContent.text;
            }
          }
        } else {
          // Handle string content case
          if (typeof lastMessage.content === 'string' && typeof message.content === 'string') {
            lastMessage.content += message.content;
          }
        }
      } else {
        mergedMessages.push(message);
      }
    } else {
      mergedMessages.push(message);
      streak = 0;
    }
  }

  return mergedMessages;
}
