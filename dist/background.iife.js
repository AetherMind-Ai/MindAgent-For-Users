(function() {let __HMR_ID = "chrome-extension-hmr";
(function () {
  'use strict';

  const LOCAL_RELOAD_SOCKET_PORT = 8081;
  const LOCAL_RELOAD_SOCKET_URL = `ws://localhost:${LOCAL_RELOAD_SOCKET_PORT}`;

  const DO_UPDATE = 'do_update';
  const DONE_UPDATE = 'done_update';

  class MessageInterpreter {
    // eslint-disable-next-line @typescript-eslint/no-empty-function
     constructor() {}

    static send(message) {
      return JSON.stringify(message);
    }

    static receive(serializedMessage) {
      return JSON.parse(serializedMessage);
    }
  }

  function initClient({ id, onUpdate }) {
    const ws = new WebSocket(LOCAL_RELOAD_SOCKET_URL);

    ws.onopen = () => {
      ws.addEventListener('message', event => {
        const message = MessageInterpreter.receive(String(event.data));

        if (message.type === DO_UPDATE && message.id === id) {
          onUpdate();
          ws.send(MessageInterpreter.send({ type: DONE_UPDATE }));
          return;
        }
      });
    };
  }

  function addReload() {
    const reload = () => {
      chrome.runtime.reload();
    };

    initClient({
      // @ts-expect-error That's because of the dynamic code loading
      id: __HMR_ID,
      onUpdate: reload,
    });
  }

  addReload();

})();

})();
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __reflectGet = Reflect.get;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);
(function() {
  "use strict";
  var _a2, _b, _disposed, _stack, _c, _d, _disposed2, _stack2, _emitter, _handlers, _e, _code, _originalMessage, _functionName, _siteString, _isResolved, _isRejected, _value, _resolve, _taskPromise, _timeoutId, _timeoutError, _Deferred_instances, finish_fn, _promise, _f, _mutex, _onRelease, _g, _h, _locked, _acquirers, _pageScreenshotMutex, _screenshotOperationsCount, _i, _type, _message, _defaultValue, _get, _updated, _amendments, _ScriptInjector_instances, update_fn, get_fn, _handlers2, _ensureElementIsInTheViewport, _waitForEnabled, _waitForStableBoundingBox, _waitForEnabledIfNeeded, _waitForStableBoundingBoxIfNeeded, _ensureElementIsInTheViewportIfNeeded, _Locator_instances, click_fn, fill_fn, hover_fn, scroll_fn, _pageOrFrame, _func, _delegate, _predicate, _mapper, _pageOrFrame2, _selector, _waitForVisibilityIfNeeded, _locators, _HTTPRequest_instances, canBeIntercepted_fn, _defaultTimeout, _defaultNavigationTimeout, _world, _polling, _root, _fn, _args, _timeout, _timeoutError2, _result, _poller, _signal, _reruns, _onAbortSignal, _tasks, _disposed3, _j, _url, _realm, _frameId, _richlyEditable, _editable, _focusable, _hidden, _name, _role, _ignored, _cachedHasFocusableChild, _realm2, _AXNode_instances, isPlainTextField_fn, isTextOnlyObject_fn, hasFocusableChild_fn, _name2, _fn2, _initSource, _type2, _text, _args2, _stackTraceLocations, _frame, _element, _multiple, _handled, _callbacks, _idGenerator, _id, _error, _deferred, _timer, _label, _sessionId, _targetType, _callbacks2, _connection, _parentSessionId, _target, _rawErrors, _url2, _transport, _delay, _timeout2, _sessions, _closed, _manuallyAttached, _callbacks3, _rawErrors2, _Connection_instances, onClose_fn, _jsCoverage, _cssCoverage, _client, _enabled, _scriptURLs, _scriptSources, _subscriptions, _resetOnNavigation, _reportAnonymousScripts, _includeRawScriptCoverage, _JSCoverage_instances, onExecutionContextsCleared_fn, onScriptParsed_fn, _client2, _enabled2, _stylesheetURLs, _stylesheetSources, _eventListeners, _resetOnNavigation2, _CSSCoverage_instances, onExecutionContextsCleared_fn2, onStyleSheet_fn, _client3, _state, _clientProvider, _updater, _id2, _source, _frameToId, _client4, _timeoutSettings, _id3, _handled2, _updateDevicesHandle, _waitForDevicePromises, _DeviceRequestPrompt_instances, updateDevices_fn, _client5, _timeoutSettings2, _deviceRequestPrompDeferreds, _DeviceRequestPromptManager_instances, onDeviceRequestPrompted_fn, _disposed4, _remoteObject, _world2, _client6, _world3, _id4, _name3, _disposables, _bindings, _mutex2, _ExecutionContext_instances, addBinding_fn, onBindingCalled_fn, onConsoleAPI_fn, _bindingsInstalled, _puppeteerUtil, addBindingWithoutThrowing_fn, evaluate_fn, _context, _emitter2, _frameOrWorker, _IsolatedWorld_instances, onContextDisposed_fn, onContextConsoleApiCalled_fn, onContextBindingCalled_fn, executionContext_fn, waitForExecutionContext_fn, _expectedLifecycle, _frame2, _timeout3, _navigationRequest, _subscriptions2, _initialLoaderId, _terminationDeferred, _sameDocumentNavigationDeferred, _lifecycleDeferred, _newDocumentNavigationDeferred, _hasSameDocumentNavigation, _swapped, _navigationResponseReceived, _LifecycleWatcher_instances, onRequest_fn, onRequestFailed_fn, onResponse_fn, onFrameDetached_fn, navigatedWithinDocument_fn, navigated_fn, frameSwapped_fn, checkLifecycleComplete_fn, _frames, _parentIds, _childIds, _mainFrame, _isMainFrameStale, _waitRequests, _client7, _isNavigationRequest, _url3, _resourceType, _method, _hasPostData, _postData, _headers, _frame3, _initiator, _subjectName, _issuer, _validFrom, _validTo, _protocol, _sanList, _request, _contentPromise, _bodyLoadedDeferred, _remoteAddress, _status, _statusText, _fromDiskCache, _fromServiceWorker, _headers2, _securityDetails, _timing, _CdpHTTPResponse_instances, parseStatusTextFromExtraInfo_fn, _requestWillBeSentMap, _requestPausedMap, _httpRequestsMap, _responseReceivedExtraInfoMap, _queuedRedirectInfoMap, _queuedEventGroupMap, _frameManager, _networkEventManager, _extraHTTPHeaders, _credentials, _attemptedAuthentications, _userRequestInterceptionEnabled, _protocolRequestInterceptionEnabled, _userCacheDisabled, _emulatedNetworkConditions, _userAgent, _userAgentMetadata, _handlers3, _clients, _NetworkManager_instances, removeClient_fn, applyExtraHTTPHeaders_fn, applyToAllClients_fn, applyNetworkConditions_fn, applyUserAgent_fn, applyProtocolRequestInterception_fn, applyProtocolCacheDisabled_fn, onRequestWillBeSent_fn, onAuthRequired_fn, onRequestPaused_fn, patchRequestEventHeaders_fn, onRequestWithoutNetworkInstrumentation_fn, onRequest_fn2, onRequestServedFromCache_fn, handleRequestRedirect_fn, emitResponseEvent_fn, onResponseReceived_fn, onResponseReceivedExtraInfo_fn, forgetRequest_fn, onLoadingFinished_fn, emitLoadingFinished_fn, onLoadingFailed_fn, emitLoadingFailed_fn, maybeReassignOOPIFRequestClient_fn, _page, _networkManager, _timeoutSettings3, _isolatedWorlds, _client8, _scriptsToEvaluateOnNewDocument, _bindings2, _frameNavigatedReceived, _deviceRequestPromptManagerMap, _frameTreeHandled, _FrameManager_instances, onClientDisconnect_fn, onLifecycleEvent_fn, onFrameStartedLoading_fn, onFrameStoppedLoading_fn, handleFrameTree_fn, onFrameAttached_fn, onFrameNavigated_fn, createIsolatedWorld_fn, onFrameNavigatedWithinDocument_fn, onFrameDetached_fn2, onExecutionContextCreated_fn, removeFramesRecursively_fn, _client9, _pressedKeys, _CdpKeyboard_instances, modifierBit_fn, keyDescriptionForString_fn, _client10, _keyboard, __state, _CdpMouse_instances, state_get, _transactions, createTransaction_fn, withTransaction_fn, _started, _touchScreen, _touchPoint, _client11, _keyboard2, _client12, _keyboard3, _client13, _recording, _path, _world4, _client14, _id5, _targetType2, _closed2, _targetManager, _primaryTargetClient, _primaryTarget, _tabTargetClient, _tabTarget, _keyboard4, _mouse, _touchscreen, _frameManager2, _emulationManager, _tracing, _bindings3, _exposedFunctions, _coverage, _viewport, _workers, _fileChooserDeferreds, _sessionCloseDeferred, _serviceWorkerBypassed, _userDragInterceptionEnabled, _CdpPage_instances, attachExistingTargets_fn, onActivation_fn, onSecondaryTarget_fn, setupPrimaryTargetListeners_fn, _onDetachedFromTarget, _onAttachedToTarget, initialize_fn, onFileChooser_fn, onTargetCrashed_fn, onLogEntryAdded_fn, emitMetrics_fn, buildMetricsObject_fn, handleException_fn, onConsoleAPI_fn2, onBindingCalled_fn2, addConsoleMessage_fn, onDialog_fn, go_fn, _connection2, _browser, _id6, _browserContext, _session, _targetInfo, _targetManager2, _sessionFactory, _childTargets, _k, _defaultViewport, _workerPromise, _connection3, _discoveredTargetsByTargetId, _attachedTargetsByTargetId, _attachedTargetsBySessionId, _ignoredTargets, _targetFilterCallback, _targetFactory, _attachedToTargetListenersBySession, _detachedFromTargetListenersBySession, _initializeDeferred, _targetsIdsForInit, _waitForInitiallyDiscoveredTargets, _discoveryFilter, _storeExistingTargetsForInit, _TargetManager_instances, setupAttachmentListeners_fn, removeAttachmentListeners_fn, _onSessionDetached, _onTargetCreated, _onTargetDestroyed, _onTargetInfoChanged, _onAttachedToTarget2, finishInitializationIfReady_fn, _onDetachedFromTarget2, _defaultViewport2, _process, _connection4, _closeCallback, _targetFilterCallback2, _isPageTargetCallback, _defaultContext, _contexts, _targetManager3, _emitDisconnected, _CdpBrowser_instances, setIsPageTargetCallback_fn, _createTarget, _onAttachedToTarget3, _onDetachedFromTarget3, _onTargetChanged, _onTargetDiscovered, getVersion_fn, _tabId, _debuggerEventHandler, _ExtensionTransport_instances, dispatchResponse_fn, _ws, _detached, _connection5, _sessionId2, _url4, _transport2, _delay2, _timeout4, _closed3, _callbacks4, _emitters, _cdp, _adapters, _browserCdpConnection, _closed4, _client15, _browserClient, _forwardMessage, _onMessage, _workers2, _WindowRealm_instances, initialize_fn2, _workers3, _DedicatedWorkerRealm_instances, initialize_fn3, _workers4, _SharedWorkerRealm_instances, initialize_fn4, _BidiDeserializer_static, deserializeNumber_fn, deserializeTuple_fn, _prompt, _remoteValue, _disposed5, _frame4, _apply, _isolate, _channel, _scripts, _disposables2, _ExposeableFunction_instances, initialize_fn5, connection_get, _handleMessage, getRealm_fn, findFrame_fn, _redirectChain, _response, _frame5, _request2, _BidiHTTPRequest_instances, initialize_fn6, hasInternalHeaderOverwrite_get, extraHTTPHeaders_get, userAgentHeaders_get, _authenticationHandled, _handleAuthentication, _BidiSerializer_static, serializeNumber_fn, serializeObject_fn, _BidiRealm_instances, evaluate_fn2, _frame6, _BidiFrameRealm_instances, initialize_fn7, _bindingsInstalled2, _worker, _frame7, _realm3, _page2, _page3, _lastMovePoint, _started2, _x, _y, _bidiId, _page4, _touchScreen2, _properties, _page5, _browser2, _page6, _frame8, _page7, _worker2, _ws2;
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  function getAugmentedNamespace(n) {
    if (n.__esModule) return n;
    var f = n.default;
    if (typeof f == "function") {
      var a = function a2() {
        if (this instanceof a2) {
          return Reflect.construct(f, arguments, this.constructor);
        }
        return f.apply(this, arguments);
      };
      a.prototype = f.prototype;
    } else a = {};
    Object.defineProperty(a, "__esModule", { value: true });
    Object.keys(n).forEach(function(k) {
      var d = Object.getOwnPropertyDescriptor(n, k);
      Object.defineProperty(a, k, d.get ? d : {
        enumerable: true,
        get: function() {
          return n[k];
        }
      });
    });
    return a;
  }
  var browserPolyfill$1 = { exports: {} };
  var browserPolyfill = browserPolyfill$1.exports;
  var hasRequiredBrowserPolyfill;
  function requireBrowserPolyfill() {
    if (hasRequiredBrowserPolyfill) return browserPolyfill$1.exports;
    hasRequiredBrowserPolyfill = 1;
    (function(module, exports) {
      (function(global2, factory) {
        {
          factory(module);
        }
      })(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : browserPolyfill, function(module2) {
        if (!(globalThis.chrome && globalThis.chrome.runtime && globalThis.chrome.runtime.id)) {
          throw new Error("This script should only be loaded in a browser extension.");
        }
        if (!(globalThis.browser && globalThis.browser.runtime && globalThis.browser.runtime.id)) {
          const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = "The message port closed before a response was received.";
          const wrapAPIs = (extensionAPIs) => {
            const apiMetadata = {
              "alarms": {
                "clear": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "clearAll": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "get": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "getAll": {
                  "minArgs": 0,
                  "maxArgs": 0
                }
              },
              "bookmarks": {
                "create": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "get": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getChildren": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getRecent": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getSubTree": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getTree": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "move": {
                  "minArgs": 2,
                  "maxArgs": 2
                },
                "remove": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removeTree": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "search": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "update": {
                  "minArgs": 2,
                  "maxArgs": 2
                }
              },
              "browserAction": {
                "disable": {
                  "minArgs": 0,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                },
                "enable": {
                  "minArgs": 0,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                },
                "getBadgeBackgroundColor": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getBadgeText": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getPopup": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getTitle": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "openPopup": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "setBadgeBackgroundColor": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                },
                "setBadgeText": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                },
                "setIcon": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "setPopup": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                },
                "setTitle": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                }
              },
              "browsingData": {
                "remove": {
                  "minArgs": 2,
                  "maxArgs": 2
                },
                "removeCache": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removeCookies": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removeDownloads": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removeFormData": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removeHistory": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removeLocalStorage": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removePasswords": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removePluginData": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "settings": {
                  "minArgs": 0,
                  "maxArgs": 0
                }
              },
              "commands": {
                "getAll": {
                  "minArgs": 0,
                  "maxArgs": 0
                }
              },
              "contextMenus": {
                "remove": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removeAll": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "update": {
                  "minArgs": 2,
                  "maxArgs": 2
                }
              },
              "cookies": {
                "get": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getAll": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getAllCookieStores": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "remove": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "set": {
                  "minArgs": 1,
                  "maxArgs": 1
                }
              },
              "devtools": {
                "inspectedWindow": {
                  "eval": {
                    "minArgs": 1,
                    "maxArgs": 2,
                    "singleCallbackArg": false
                  }
                },
                "panels": {
                  "create": {
                    "minArgs": 3,
                    "maxArgs": 3,
                    "singleCallbackArg": true
                  },
                  "elements": {
                    "createSidebarPane": {
                      "minArgs": 1,
                      "maxArgs": 1
                    }
                  }
                }
              },
              "downloads": {
                "cancel": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "download": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "erase": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getFileIcon": {
                  "minArgs": 1,
                  "maxArgs": 2
                },
                "open": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                },
                "pause": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removeFile": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "resume": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "search": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "show": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                }
              },
              "extension": {
                "isAllowedFileSchemeAccess": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "isAllowedIncognitoAccess": {
                  "minArgs": 0,
                  "maxArgs": 0
                }
              },
              "history": {
                "addUrl": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "deleteAll": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "deleteRange": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "deleteUrl": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getVisits": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "search": {
                  "minArgs": 1,
                  "maxArgs": 1
                }
              },
              "i18n": {
                "detectLanguage": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getAcceptLanguages": {
                  "minArgs": 0,
                  "maxArgs": 0
                }
              },
              "identity": {
                "launchWebAuthFlow": {
                  "minArgs": 1,
                  "maxArgs": 1
                }
              },
              "idle": {
                "queryState": {
                  "minArgs": 1,
                  "maxArgs": 1
                }
              },
              "management": {
                "get": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getAll": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "getSelf": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "setEnabled": {
                  "minArgs": 2,
                  "maxArgs": 2
                },
                "uninstallSelf": {
                  "minArgs": 0,
                  "maxArgs": 1
                }
              },
              "notifications": {
                "clear": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "create": {
                  "minArgs": 1,
                  "maxArgs": 2
                },
                "getAll": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "getPermissionLevel": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "update": {
                  "minArgs": 2,
                  "maxArgs": 2
                }
              },
              "pageAction": {
                "getPopup": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getTitle": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "hide": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                },
                "setIcon": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "setPopup": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                },
                "setTitle": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                },
                "show": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                }
              },
              "permissions": {
                "contains": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getAll": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "remove": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "request": {
                  "minArgs": 1,
                  "maxArgs": 1
                }
              },
              "runtime": {
                "getBackgroundPage": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "getPlatformInfo": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "openOptionsPage": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "requestUpdateCheck": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "sendMessage": {
                  "minArgs": 1,
                  "maxArgs": 3
                },
                "sendNativeMessage": {
                  "minArgs": 2,
                  "maxArgs": 2
                },
                "setUninstallURL": {
                  "minArgs": 1,
                  "maxArgs": 1
                }
              },
              "sessions": {
                "getDevices": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "getRecentlyClosed": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "restore": {
                  "minArgs": 0,
                  "maxArgs": 1
                }
              },
              "storage": {
                "local": {
                  "clear": {
                    "minArgs": 0,
                    "maxArgs": 0
                  },
                  "get": {
                    "minArgs": 0,
                    "maxArgs": 1
                  },
                  "getBytesInUse": {
                    "minArgs": 0,
                    "maxArgs": 1
                  },
                  "remove": {
                    "minArgs": 1,
                    "maxArgs": 1
                  },
                  "set": {
                    "minArgs": 1,
                    "maxArgs": 1
                  }
                },
                "managed": {
                  "get": {
                    "minArgs": 0,
                    "maxArgs": 1
                  },
                  "getBytesInUse": {
                    "minArgs": 0,
                    "maxArgs": 1
                  }
                },
                "sync": {
                  "clear": {
                    "minArgs": 0,
                    "maxArgs": 0
                  },
                  "get": {
                    "minArgs": 0,
                    "maxArgs": 1
                  },
                  "getBytesInUse": {
                    "minArgs": 0,
                    "maxArgs": 1
                  },
                  "remove": {
                    "minArgs": 1,
                    "maxArgs": 1
                  },
                  "set": {
                    "minArgs": 1,
                    "maxArgs": 1
                  }
                }
              },
              "tabs": {
                "captureVisibleTab": {
                  "minArgs": 0,
                  "maxArgs": 2
                },
                "create": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "detectLanguage": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "discard": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "duplicate": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "executeScript": {
                  "minArgs": 1,
                  "maxArgs": 2
                },
                "get": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getCurrent": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "getZoom": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "getZoomSettings": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "goBack": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "goForward": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "highlight": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "insertCSS": {
                  "minArgs": 1,
                  "maxArgs": 2
                },
                "move": {
                  "minArgs": 2,
                  "maxArgs": 2
                },
                "query": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "reload": {
                  "minArgs": 0,
                  "maxArgs": 2
                },
                "remove": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removeCSS": {
                  "minArgs": 1,
                  "maxArgs": 2
                },
                "sendMessage": {
                  "minArgs": 2,
                  "maxArgs": 3
                },
                "setZoom": {
                  "minArgs": 1,
                  "maxArgs": 2
                },
                "setZoomSettings": {
                  "minArgs": 1,
                  "maxArgs": 2
                },
                "update": {
                  "minArgs": 1,
                  "maxArgs": 2
                }
              },
              "topSites": {
                "get": {
                  "minArgs": 0,
                  "maxArgs": 0
                }
              },
              "webNavigation": {
                "getAllFrames": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getFrame": {
                  "minArgs": 1,
                  "maxArgs": 1
                }
              },
              "webRequest": {
                "handlerBehaviorChanged": {
                  "minArgs": 0,
                  "maxArgs": 0
                }
              },
              "windows": {
                "create": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "get": {
                  "minArgs": 1,
                  "maxArgs": 2
                },
                "getAll": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "getCurrent": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "getLastFocused": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "remove": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "update": {
                  "minArgs": 2,
                  "maxArgs": 2
                }
              }
            };
            if (Object.keys(apiMetadata).length === 0) {
              throw new Error("api-metadata.json has not been included in browser-polyfill");
            }
            class DefaultWeakMap extends WeakMap {
              constructor(createItem, items = void 0) {
                super(items);
                this.createItem = createItem;
              }
              get(key) {
                if (!this.has(key)) {
                  this.set(key, this.createItem(key));
                }
                return super.get(key);
              }
            }
            const isThenable = (value) => {
              return value && typeof value === "object" && typeof value.then === "function";
            };
            const makeCallback = (promise, metadata) => {
              return (...callbackArgs) => {
                if (extensionAPIs.runtime.lastError) {
                  promise.reject(new Error(extensionAPIs.runtime.lastError.message));
                } else if (metadata.singleCallbackArg || callbackArgs.length <= 1 && metadata.singleCallbackArg !== false) {
                  promise.resolve(callbackArgs[0]);
                } else {
                  promise.resolve(callbackArgs);
                }
              };
            };
            const pluralizeArguments = (numArgs) => numArgs == 1 ? "argument" : "arguments";
            const wrapAsyncFunction = (name, metadata) => {
              return function asyncFunctionWrapper(target, ...args) {
                if (args.length < metadata.minArgs) {
                  throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
                }
                if (args.length > metadata.maxArgs) {
                  throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
                }
                return new Promise((resolve, reject) => {
                  if (metadata.fallbackToNoCallback) {
                    try {
                      target[name](...args, makeCallback({
                        resolve,
                        reject
                      }, metadata));
                    } catch (cbError) {
                      console.warn(`${name} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `, cbError);
                      target[name](...args);
                      metadata.fallbackToNoCallback = false;
                      metadata.noCallback = true;
                      resolve();
                    }
                  } else if (metadata.noCallback) {
                    target[name](...args);
                    resolve();
                  } else {
                    target[name](...args, makeCallback({
                      resolve,
                      reject
                    }, metadata));
                  }
                });
              };
            };
            const wrapMethod = (target, method, wrapper) => {
              return new Proxy(method, {
                apply(targetMethod, thisObj, args) {
                  return wrapper.call(thisObj, target, ...args);
                }
              });
            };
            let hasOwnProperty2 = Function.call.bind(Object.prototype.hasOwnProperty);
            const wrapObject = (target, wrappers = {}, metadata = {}) => {
              let cache2 = /* @__PURE__ */ Object.create(null);
              let handlers = {
                has(proxyTarget2, prop) {
                  return prop in target || prop in cache2;
                },
                get(proxyTarget2, prop, receiver) {
                  if (prop in cache2) {
                    return cache2[prop];
                  }
                  if (!(prop in target)) {
                    return void 0;
                  }
                  let value = target[prop];
                  if (typeof value === "function") {
                    if (typeof wrappers[prop] === "function") {
                      value = wrapMethod(target, target[prop], wrappers[prop]);
                    } else if (hasOwnProperty2(metadata, prop)) {
                      let wrapper = wrapAsyncFunction(prop, metadata[prop]);
                      value = wrapMethod(target, target[prop], wrapper);
                    } else {
                      value = value.bind(target);
                    }
                  } else if (typeof value === "object" && value !== null && (hasOwnProperty2(wrappers, prop) || hasOwnProperty2(metadata, prop))) {
                    value = wrapObject(value, wrappers[prop], metadata[prop]);
                  } else if (hasOwnProperty2(metadata, "*")) {
                    value = wrapObject(value, wrappers[prop], metadata["*"]);
                  } else {
                    Object.defineProperty(cache2, prop, {
                      configurable: true,
                      enumerable: true,
                      get() {
                        return target[prop];
                      },
                      set(value2) {
                        target[prop] = value2;
                      }
                    });
                    return value;
                  }
                  cache2[prop] = value;
                  return value;
                },
                set(proxyTarget2, prop, value, receiver) {
                  if (prop in cache2) {
                    cache2[prop] = value;
                  } else {
                    target[prop] = value;
                  }
                  return true;
                },
                defineProperty(proxyTarget2, prop, desc) {
                  return Reflect.defineProperty(cache2, prop, desc);
                },
                deleteProperty(proxyTarget2, prop) {
                  return Reflect.deleteProperty(cache2, prop);
                }
              };
              let proxyTarget = Object.create(target);
              return new Proxy(proxyTarget, handlers);
            };
            const wrapEvent = (wrapperMap) => ({
              addListener(target, listener, ...args) {
                target.addListener(wrapperMap.get(listener), ...args);
              },
              hasListener(target, listener) {
                return target.hasListener(wrapperMap.get(listener));
              },
              removeListener(target, listener) {
                target.removeListener(wrapperMap.get(listener));
              }
            });
            const onRequestFinishedWrappers = new DefaultWeakMap((listener) => {
              if (typeof listener !== "function") {
                return listener;
              }
              return function onRequestFinished(req) {
                const wrappedReq = wrapObject(req, {}, {
                  getContent: {
                    minArgs: 0,
                    maxArgs: 0
                  }
                });
                listener(wrappedReq);
              };
            });
            const onMessageWrappers = new DefaultWeakMap((listener) => {
              if (typeof listener !== "function") {
                return listener;
              }
              return function onMessage(message, sender, sendResponse) {
                let didCallSendResponse = false;
                let wrappedSendResponse;
                let sendResponsePromise = new Promise((resolve) => {
                  wrappedSendResponse = function(response) {
                    didCallSendResponse = true;
                    resolve(response);
                  };
                });
                let result;
                try {
                  result = listener(message, sender, wrappedSendResponse);
                } catch (err) {
                  result = Promise.reject(err);
                }
                const isResultThenable = result !== true && isThenable(result);
                if (result !== true && !isResultThenable && !didCallSendResponse) {
                  return false;
                }
                const sendPromisedResult = (promise) => {
                  promise.then((msg) => {
                    sendResponse(msg);
                  }, (error) => {
                    let message2;
                    if (error && (error instanceof Error || typeof error.message === "string")) {
                      message2 = error.message;
                    } else {
                      message2 = "An unexpected error occurred";
                    }
                    sendResponse({
                      __mozWebExtensionPolyfillReject__: true,
                      message: message2
                    });
                  }).catch((err) => {
                    console.error("Failed to send onMessage rejected reply", err);
                  });
                };
                if (isResultThenable) {
                  sendPromisedResult(result);
                } else {
                  sendPromisedResult(sendResponsePromise);
                }
                return true;
              };
            });
            const wrappedSendMessageCallback = ({
              reject,
              resolve
            }, reply) => {
              if (extensionAPIs.runtime.lastError) {
                if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {
                  resolve();
                } else {
                  reject(new Error(extensionAPIs.runtime.lastError.message));
                }
              } else if (reply && reply.__mozWebExtensionPolyfillReject__) {
                reject(new Error(reply.message));
              } else {
                resolve(reply);
              }
            };
            const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {
              if (args.length < metadata.minArgs) {
                throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
              }
              if (args.length > metadata.maxArgs) {
                throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
              }
              return new Promise((resolve, reject) => {
                const wrappedCb = wrappedSendMessageCallback.bind(null, {
                  resolve,
                  reject
                });
                args.push(wrappedCb);
                apiNamespaceObj.sendMessage(...args);
              });
            };
            const staticWrappers = {
              devtools: {
                network: {
                  onRequestFinished: wrapEvent(onRequestFinishedWrappers)
                }
              },
              runtime: {
                onMessage: wrapEvent(onMessageWrappers),
                onMessageExternal: wrapEvent(onMessageWrappers),
                sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
                  minArgs: 1,
                  maxArgs: 3
                })
              },
              tabs: {
                sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
                  minArgs: 2,
                  maxArgs: 3
                })
              }
            };
            const settingMetadata = {
              clear: {
                minArgs: 1,
                maxArgs: 1
              },
              get: {
                minArgs: 1,
                maxArgs: 1
              },
              set: {
                minArgs: 1,
                maxArgs: 1
              }
            };
            apiMetadata.privacy = {
              network: {
                "*": settingMetadata
              },
              services: {
                "*": settingMetadata
              },
              websites: {
                "*": settingMetadata
              }
            };
            return wrapObject(extensionAPIs, staticWrappers, apiMetadata);
          };
          module2.exports = wrapAPIs(chrome);
        } else {
          module2.exports = globalThis.browser;
        }
      });
    })(browserPolyfill$1);
    return browserPolyfill$1.exports;
  }
  requireBrowserPolyfill();
  var AgentNameEnum = /* @__PURE__ */ ((AgentNameEnum2) => {
    AgentNameEnum2["Planner"] = "planner";
    AgentNameEnum2["Navigator"] = "navigator";
    AgentNameEnum2["Validator"] = "validator";
    return AgentNameEnum2;
  })(AgentNameEnum || {});
  var ProviderTypeEnum = /* @__PURE__ */ ((ProviderTypeEnum2) => {
    ProviderTypeEnum2["OpenAI"] = "openai";
    ProviderTypeEnum2["Anthropic"] = "anthropic";
    ProviderTypeEnum2["DeepSeek"] = "deepseek";
    ProviderTypeEnum2["Gemini"] = "gemini";
    ProviderTypeEnum2["Grok"] = "grok";
    ProviderTypeEnum2["Ollama"] = "ollama";
    ProviderTypeEnum2["AzureOpenAI"] = "azure_openai";
    ProviderTypeEnum2["OpenRouter"] = "openrouter";
    ProviderTypeEnum2["CustomOpenAI"] = "custom_openai";
    return ProviderTypeEnum2;
  })(ProviderTypeEnum || {});
  const llmProviderModelNames = {
    [
      "openai"
      /* OpenAI */
    ]: ["gpt-4.1", "gpt-4.1-mini", "gpt-4.1-nano", "gpt-4o", "gpt-4o-mini", "o4-mini", "o3"],
    [
      "anthropic"
      /* Anthropic */
    ]: ["claude-3-7-sonnet-latest", "claude-3-5-sonnet-latest", "claude-3-5-haiku-latest"],
    [
      "deepseek"
      /* DeepSeek */
    ]: ["deepseek-chat", "deepseek-reasoner"],
    [
      "gemini"
      /* Gemini */
    ]: [
      "gemini-2.5-flash-preview-04-17",
      "gemini-2.5-pro-exp-03-25",
      "gemini-2.5-pro-preview-03-25",
      "gemini-2.0-flash"
      // 'gemini-2.0-flash-thinking-exp-01-21', // TODO: not support function calling for now
    ],
    [
      "grok"
      /* Grok */
    ]: ["grok-3", "grok-3-fast", "grok-3-mini", "grok-3-mini-fast"],
    [
      "ollama"
      /* Ollama */
    ]: ["qwen3:14b", "falcon3:10b", "qwen2.5-coder:14b", "mistral-small:24b"],
    [
      "azure_openai"
      /* AzureOpenAI */
    ]: ["gpt-4.1", "gpt-4.1-mini", "gpt-4.1-nano", "gpt-4o", "gpt-4o-mini", "o4-mini", "o3"],
    [
      "openrouter"
      /* OpenRouter */
    ]: [
      "openai/gpt-4.1",
      "openai/gpt-4.1-mini",
      "openai/o4-mini",
      "openai/gpt-4o-2024-11-20",
      "google/gemini-2.5-flash-preview"
    ]
    // Custom OpenAI providers don't have predefined models as they are user-defined
  };
  const llmProviderParameters = {
    [
      "openai"
      /* OpenAI */
    ]: {
      [
        "planner"
        /* Planner */
      ]: {
        temperature: 0.7,
        topP: 0.9
      },
      [
        "navigator"
        /* Navigator */
      ]: {
        temperature: 0.3,
        topP: 0.85
      },
      [
        "validator"
        /* Validator */
      ]: {
        temperature: 0.1,
        topP: 0.8
      }
    },
    [
      "anthropic"
      /* Anthropic */
    ]: {
      [
        "planner"
        /* Planner */
      ]: {
        temperature: 0.3,
        topP: 0.6
      },
      [
        "navigator"
        /* Navigator */
      ]: {
        temperature: 0.2,
        topP: 0.5
      },
      [
        "validator"
        /* Validator */
      ]: {
        temperature: 0.1,
        topP: 0.5
      }
    },
    [
      "gemini"
      /* Gemini */
    ]: {
      [
        "planner"
        /* Planner */
      ]: {
        temperature: 0.7,
        topP: 0.9
      },
      [
        "navigator"
        /* Navigator */
      ]: {
        temperature: 0.3,
        topP: 0.85
      },
      [
        "validator"
        /* Validator */
      ]: {
        temperature: 0.1,
        topP: 0.8
      }
    },
    [
      "grok"
      /* Grok */
    ]: {
      [
        "planner"
        /* Planner */
      ]: {
        temperature: 0.7,
        topP: 0.9
      },
      [
        "navigator"
        /* Navigator */
      ]: {
        temperature: 0.3,
        topP: 0.85
      },
      [
        "validator"
        /* Validator */
      ]: {
        temperature: 0.1,
        topP: 0.8
      }
    },
    [
      "ollama"
      /* Ollama */
    ]: {
      [
        "planner"
        /* Planner */
      ]: {
        temperature: 0.3,
        topP: 0.9
      },
      [
        "navigator"
        /* Navigator */
      ]: {
        temperature: 0.1,
        topP: 0.85
      },
      [
        "validator"
        /* Validator */
      ]: {
        temperature: 0.1,
        topP: 0.8
      }
    },
    [
      "azure_openai"
      /* AzureOpenAI */
    ]: {
      [
        "planner"
        /* Planner */
      ]: {
        temperature: 0.7,
        topP: 0.9
      },
      [
        "navigator"
        /* Navigator */
      ]: {
        temperature: 0.3,
        topP: 0.85
      },
      [
        "validator"
        /* Validator */
      ]: {
        temperature: 0.1,
        topP: 0.8
      }
    },
    [
      "openrouter"
      /* OpenRouter */
    ]: {
      [
        "planner"
        /* Planner */
      ]: {
        temperature: 0.7,
        topP: 0.9
      },
      [
        "navigator"
        /* Navigator */
      ]: {
        temperature: 0.3,
        topP: 0.85
      },
      [
        "validator"
        /* Validator */
      ]: {
        temperature: 0.1,
        topP: 0.8
      }
    }
  };
  var StorageEnum = /* @__PURE__ */ ((StorageEnum2) => {
    StorageEnum2["Local"] = "local";
    StorageEnum2["Sync"] = "sync";
    StorageEnum2["Managed"] = "managed";
    StorageEnum2["Session"] = "session";
    return StorageEnum2;
  })(StorageEnum || {});
  var SessionAccessLevelEnum = /* @__PURE__ */ ((SessionAccessLevelEnum2) => {
    SessionAccessLevelEnum2["ExtensionPagesOnly"] = "TRUSTED_CONTEXTS";
    SessionAccessLevelEnum2["ExtensionPagesAndContentScripts"] = "TRUSTED_AND_UNTRUSTED_CONTEXTS";
    return SessionAccessLevelEnum2;
  })(SessionAccessLevelEnum || {});
  var __async$3 = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  const chrome$1 = globalThis.chrome;
  function updateCache(valueOrUpdate, cache2) {
    return __async$3(this, null, function* () {
      function isFunction2(value) {
        return typeof value === "function";
      }
      function returnsPromise(func) {
        return func instanceof Promise;
      }
      if (isFunction2(valueOrUpdate)) {
        if (returnsPromise(valueOrUpdate)) {
          return valueOrUpdate(cache2);
        } else {
          return valueOrUpdate(cache2);
        }
      } else {
        return valueOrUpdate;
      }
    });
  }
  let globalSessionAccessLevelFlag = false;
  function checkStoragePermission(storageEnum) {
    if (!chrome$1) {
      return;
    }
    if (chrome$1.storage[storageEnum] === void 0) {
      throw new Error(`Check your storage permission in manifest.json: ${storageEnum} is not defined`);
    }
  }
  function createStorage(key, fallback, config2) {
    var _a3, _b2, _c2, _d2, _e2, _f2;
    let cache2 = null;
    let initedCache = false;
    let listeners = [];
    const storageEnum = (_a3 = config2 == null ? void 0 : config2.storageEnum) != null ? _a3 : StorageEnum.Local;
    const liveUpdate = (_b2 = config2 == null ? void 0 : config2.liveUpdate) != null ? _b2 : false;
    const serialize = (_d2 = (_c2 = config2 == null ? void 0 : config2.serialization) == null ? void 0 : _c2.serialize) != null ? _d2 : (v) => v;
    const deserialize = (_f2 = (_e2 = config2 == null ? void 0 : config2.serialization) == null ? void 0 : _e2.deserialize) != null ? _f2 : (v) => v;
    if (globalSessionAccessLevelFlag === false && storageEnum === StorageEnum.Session && (config2 == null ? void 0 : config2.sessionAccessForContentScripts) === true) {
      checkStoragePermission(storageEnum);
      chrome$1 == null ? void 0 : chrome$1.storage[storageEnum].setAccessLevel({
        accessLevel: SessionAccessLevelEnum.ExtensionPagesAndContentScripts
      }).catch((error) => {
        console.warn(error);
        console.warn("Please call setAccessLevel into different context, like a background script.");
      });
      globalSessionAccessLevelFlag = true;
    }
    const get2 = () => __async$3(this, null, function* () {
      var _a22;
      checkStoragePermission(storageEnum);
      const value = yield chrome$1 == null ? void 0 : chrome$1.storage[storageEnum].get([key]);
      if (!value) {
        return fallback;
      }
      return (_a22 = deserialize(value[key])) != null ? _a22 : fallback;
    });
    const _emitChange = () => {
      listeners.forEach((listener) => listener());
    };
    const set = (valueOrUpdate) => __async$3(this, null, function* () {
      if (!initedCache) {
        cache2 = yield get2();
      }
      cache2 = yield updateCache(valueOrUpdate, cache2);
      yield chrome$1 == null ? void 0 : chrome$1.storage[storageEnum].set({ [key]: serialize(cache2) });
      _emitChange();
    });
    const subscribe = (listener) => {
      listeners = [...listeners, listener];
      return () => {
        listeners = listeners.filter((l) => l !== listener);
      };
    };
    const getSnapshot = () => {
      return cache2;
    };
    get2().then((data) => {
      cache2 = data;
      initedCache = true;
      _emitChange();
    });
    function _updateFromStorageOnChanged(changes) {
      return __async$3(this, null, function* () {
        if (changes[key] === void 0) return;
        const valueOrUpdate = deserialize(changes[key].newValue);
        if (cache2 === valueOrUpdate) return;
        cache2 = yield updateCache(valueOrUpdate, cache2);
        _emitChange();
      });
    }
    if (liveUpdate) {
      chrome$1 == null ? void 0 : chrome$1.storage[storageEnum].onChanged.addListener(_updateFromStorageOnChanged);
    }
    return {
      get: get2,
      set,
      getSnapshot,
      subscribe
    };
  }
  var __defProp$5 = Object.defineProperty;
  var __defProps$2 = Object.defineProperties;
  var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
  var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
  var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$2 = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$2.call(b, prop))
        __defNormalProp$5(a, prop, b[prop]);
    if (__getOwnPropSymbols$2)
      for (var prop of __getOwnPropSymbols$2(b)) {
        if (__propIsEnum$2.call(b, prop))
          __defNormalProp$5(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
  var __async$2 = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  const storage$2 = createStorage(
    "llm-api-keys",
    { providers: {} },
    {
      storageEnum: StorageEnum.Local,
      liveUpdate: true
    }
  );
  function getProviderTypeByProviderId(providerId) {
    if (providerId === ProviderTypeEnum.AzureOpenAI) {
      return ProviderTypeEnum.AzureOpenAI;
    }
    if (typeof providerId === "string" && providerId.startsWith(`${ProviderTypeEnum.AzureOpenAI}_`)) {
      return ProviderTypeEnum.AzureOpenAI;
    }
    switch (providerId) {
      case ProviderTypeEnum.OpenAI:
      case ProviderTypeEnum.Anthropic:
      case ProviderTypeEnum.DeepSeek:
      case ProviderTypeEnum.Gemini:
      case ProviderTypeEnum.Grok:
      case ProviderTypeEnum.Ollama:
      case ProviderTypeEnum.OpenRouter:
        return providerId;
      default:
        return ProviderTypeEnum.CustomOpenAI;
    }
  }
  function getDefaultDisplayNameFromProviderId(providerId) {
    switch (providerId) {
      case ProviderTypeEnum.OpenAI:
        return "OpenAI";
      case ProviderTypeEnum.Anthropic:
        return "Anthropic";
      case ProviderTypeEnum.DeepSeek:
        return "DeepSeek";
      case ProviderTypeEnum.Gemini:
        return "Gemini";
      case ProviderTypeEnum.Grok:
        return "Grok";
      case ProviderTypeEnum.Ollama:
        return "Ollama";
      case ProviderTypeEnum.AzureOpenAI:
        return "Azure OpenAI";
      case ProviderTypeEnum.OpenRouter:
        return "OpenRouter";
      default:
        return providerId;
    }
  }
  function ensureBackwardCompatibility(providerId, config2) {
    const updatedConfig = __spreadValues$2({}, config2);
    if (!updatedConfig.name) {
      updatedConfig.name = getDefaultDisplayNameFromProviderId(providerId);
    }
    if (!updatedConfig.type) {
      updatedConfig.type = getProviderTypeByProviderId(providerId);
    }
    if (updatedConfig.type === ProviderTypeEnum.AzureOpenAI) {
      if (updatedConfig.azureApiVersion === void 0) {
        updatedConfig.azureApiVersion = "2024-02-15-preview";
      }
      if (!updatedConfig.azureDeploymentNames) {
        updatedConfig.azureDeploymentNames = [];
      }
      if (Object.prototype.hasOwnProperty.call(updatedConfig, "modelNames")) {
        delete updatedConfig.modelNames;
      }
    } else {
      if (!updatedConfig.modelNames) {
        updatedConfig.modelNames = llmProviderModelNames[providerId] || [];
      }
    }
    if (!updatedConfig.createdAt) {
      updatedConfig.createdAt = (/* @__PURE__ */ new Date("03/04/2025")).getTime();
    }
    return updatedConfig;
  }
  const llmProviderStore = __spreadProps$2(__spreadValues$2({}, storage$2), {
    setProvider(providerId, config2) {
      return __async$2(this, null, function* () {
        var _a3, _b2, _c2, _d2;
        if (!providerId) {
          throw new Error("Provider id cannot be empty");
        }
        if (config2.apiKey === void 0) {
          throw new Error("API key must be provided (can be empty for local models)");
        }
        const providerType = config2.type || getProviderTypeByProviderId(providerId);
        if (providerType === ProviderTypeEnum.AzureOpenAI) {
          if (!((_a3 = config2.baseUrl) == null ? void 0 : _a3.trim())) {
            throw new Error("Azure Endpoint (baseUrl) is required");
          }
          if (!config2.azureDeploymentNames || config2.azureDeploymentNames.length === 0) {
            throw new Error("At least one Azure Deployment Name is required");
          }
          if (!((_b2 = config2.azureApiVersion) == null ? void 0 : _b2.trim())) {
            throw new Error("Azure API Version is required");
          }
          if (!((_c2 = config2.apiKey) == null ? void 0 : _c2.trim())) {
            throw new Error("API Key is required for Azure OpenAI");
          }
        } else if (providerType !== ProviderTypeEnum.CustomOpenAI && providerType !== ProviderTypeEnum.Ollama) {
          if (!((_d2 = config2.apiKey) == null ? void 0 : _d2.trim())) {
            throw new Error(`API Key is required for ${getDefaultDisplayNameFromProviderId(providerId)}`);
          }
        }
        if (providerType !== ProviderTypeEnum.AzureOpenAI) {
          if (!config2.modelNames || config2.modelNames.length === 0) {
            console.warn(`Provider ${providerId} of type ${providerType} is being saved without model names.`);
          }
        }
        const completeConfig = __spreadValues$2({
          apiKey: config2.apiKey || "",
          baseUrl: config2.baseUrl,
          name: config2.name || getDefaultDisplayNameFromProviderId(providerId),
          type: providerType,
          createdAt: config2.createdAt || Date.now()
        }, providerType === ProviderTypeEnum.AzureOpenAI ? {
          azureDeploymentNames: config2.azureDeploymentNames || [],
          azureApiVersion: config2.azureApiVersion
        } : {
          modelNames: config2.modelNames || []
        });
        console.log(`[llmProviderStore.setProvider] Saving config for ${providerId}:`, JSON.stringify(completeConfig));
        const current = (yield storage$2.get()) || { providers: {} };
        yield storage$2.set({
          providers: __spreadProps$2(__spreadValues$2({}, current.providers), {
            [providerId]: completeConfig
          })
        });
      });
    },
    getProvider(providerId) {
      return __async$2(this, null, function* () {
        const data = (yield storage$2.get()) || { providers: {} };
        const config2 = data.providers[providerId];
        return config2 ? ensureBackwardCompatibility(providerId, config2) : void 0;
      });
    },
    removeProvider(providerId) {
      return __async$2(this, null, function* () {
        const current = (yield storage$2.get()) || { providers: {} };
        const newProviders = __spreadValues$2({}, current.providers);
        delete newProviders[providerId];
        yield storage$2.set({ providers: newProviders });
      });
    },
    hasProvider(providerId) {
      return __async$2(this, null, function* () {
        const data = (yield storage$2.get()) || { providers: {} };
        return providerId in data.providers;
      });
    },
    getAllProviders() {
      return __async$2(this, null, function* () {
        const data = yield storage$2.get();
        const providers = __spreadValues$2({}, data.providers);
        for (const [providerId, config2] of Object.entries(providers)) {
          providers[providerId] = ensureBackwardCompatibility(providerId, config2);
        }
        return providers;
      });
    }
  });
  var __defProp$4 = Object.defineProperty;
  var __defProps$1 = Object.defineProperties;
  var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
  var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
  var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$1 = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$1.call(b, prop))
        __defNormalProp$4(a, prop, b[prop]);
    if (__getOwnPropSymbols$1)
      for (var prop of __getOwnPropSymbols$1(b)) {
        if (__propIsEnum$1.call(b, prop))
          __defNormalProp$4(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
  var __async$1 = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  const storage$1 = createStorage(
    "agent-models",
    { agents: {} },
    {
      storageEnum: StorageEnum.Local,
      liveUpdate: true
    }
  );
  function validateModelConfig(config2) {
    if (!config2.provider || !config2.modelName) {
      throw new Error("Provider and model name must be specified");
    }
  }
  function getModelParameters(agent, provider) {
    var _a3;
    const providerParams = (_a3 = llmProviderParameters[provider]) == null ? void 0 : _a3[agent];
    return providerParams != null ? providerParams : { temperature: 0.1, topP: 0.1 };
  }
  const agentModelStore = __spreadProps$1(__spreadValues$1({}, storage$1), {
    setAgentModel: (agent, config2) => __async$1(void 0, null, function* () {
      validateModelConfig(config2);
      const defaultParams = getModelParameters(agent, config2.provider);
      const mergedConfig = __spreadProps$1(__spreadValues$1({}, config2), {
        parameters: __spreadValues$1(__spreadValues$1({}, defaultParams), config2.parameters)
      });
      yield storage$1.set((current) => ({
        agents: __spreadProps$1(__spreadValues$1({}, current.agents), {
          [agent]: mergedConfig
        })
      }));
    }),
    getAgentModel: (agent) => __async$1(void 0, null, function* () {
      const data = yield storage$1.get();
      const config2 = data.agents[agent];
      if (!config2) return void 0;
      const defaultParams = getModelParameters(agent, config2.provider);
      return __spreadProps$1(__spreadValues$1({}, config2), {
        parameters: __spreadValues$1(__spreadValues$1({}, defaultParams), config2.parameters)
      });
    }),
    resetAgentModel: (agent) => __async$1(void 0, null, function* () {
      yield storage$1.set((current) => {
        const newAgents = __spreadValues$1({}, current.agents);
        delete newAgents[agent];
        return { agents: newAgents };
      });
    }),
    hasAgentModel: (agent) => __async$1(void 0, null, function* () {
      const data = yield storage$1.get();
      return agent in data.agents;
    }),
    getConfiguredAgents: () => __async$1(void 0, null, function* () {
      const data = yield storage$1.get();
      return Object.keys(data.agents);
    }),
    getAllAgentModels: () => __async$1(void 0, null, function* () {
      const data = yield storage$1.get();
      return data.agents;
    })
  });
  var __defProp$3 = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp$3(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp$3(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  const DEFAULT_GENERAL_SETTINGS = {
    maxSteps: 100,
    maxActionsPerStep: 5,
    maxFailures: 3,
    useVision: false,
    useVisionForPlanner: false,
    planningInterval: 3
  };
  const storage = createStorage("general-settings", DEFAULT_GENERAL_SETTINGS, {
    storageEnum: StorageEnum.Local,
    liveUpdate: true
  });
  const generalSettingsStore = __spreadProps(__spreadValues({}, storage), {
    updateSettings(settings) {
      return __async(this, null, function* () {
        const currentSettings = (yield storage.get()) || DEFAULT_GENERAL_SETTINGS;
        yield storage.set(__spreadValues(__spreadValues({}, currentSettings), settings));
      });
    },
    getSettings() {
      return __async(this, null, function* () {
        const settings = yield storage.get();
        return settings || DEFAULT_GENERAL_SETTINGS;
      });
    },
    resetToDefaults() {
      return __async(this, null, function* () {
        yield storage.set(DEFAULT_GENERAL_SETTINGS);
      });
    }
  });
  const DEFAULT_BROWSER_CONTEXT_CONFIG = {
    minimumWaitPageLoadTime: 0.25,
    waitForNetworkIdlePageLoadTime: 0.5,
    maximumWaitPageLoadTime: 5,
    waitBetweenActions: 0.5,
    browserWindowSize: { width: 1280, height: 1100 },
    highlightElements: true,
    viewportExpansion: 0,
    allowedDomains: null,
    includeDynamicAttributes: true,
    homePageUrl: "https://www.google.com"
  };
  class BrowserError extends Error {
    /**
     * Base class for all browser errors
     */
    constructor(message) {
      super(message);
      this.name = "BrowserError";
    }
  }
  class URLNotAllowedError extends BrowserError {
    /**
     * Error raised when a URL is not allowed
     */
    constructor(message) {
      super(message);
      this.name = "URLNotAllowedError";
    }
  }
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1) throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g2;
    return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
      return this;
    }), g2;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g2 && (g2 = 0, op[0] && (_ = 0)), _) try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i2 >= o.length) o = void 0;
        return { value: o && o[i2++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i2.next()).done) ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"])) m.call(i2);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  }
  function __spreadArray(to, from2, pack) {
    if (arguments.length === 2) for (var i2 = 0, l = from2.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from2)) {
        if (!ar) ar = Array.prototype.slice.call(from2, 0, i2);
        ar[i2] = from2[i2];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from2));
  }
  function __await$1(v) {
    return this instanceof __await$1 ? (this.v = v, this) : new __await$1(v);
  }
  function __asyncGenerator$1(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g2 = generator.apply(thisArg, _arguments || []), i2, q = [];
    return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2;
    function verb(n) {
      if (g2[n]) i2[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
    }
    function resume(n, v) {
      try {
        step(g2[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await$1 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
  }
  function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i2;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2);
    function verb(n) {
      i2[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  }
  function isFunction(value) {
    return typeof value === "function";
  }
  function createErrorClass(createImpl) {
    var _super = function(instance) {
      Error.call(instance);
      instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
  }
  var UnsubscriptionError = createErrorClass(function(_super) {
    return function UnsubscriptionErrorImpl(errors) {
      _super(this);
      this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i2) {
        return i2 + 1 + ") " + err.toString();
      }).join("\n  ") : "";
      this.name = "UnsubscriptionError";
      this.errors = errors;
    };
  });
  function arrRemove(arr2, item) {
    if (arr2) {
      var index = arr2.indexOf(item);
      0 <= index && arr2.splice(index, 1);
    }
  }
  var Subscription = function() {
    function Subscription2(initialTeardown) {
      this.initialTeardown = initialTeardown;
      this.closed = false;
      this._parentage = null;
      this._finalizers = null;
    }
    Subscription2.prototype.unsubscribe = function() {
      var e_1, _a3, e_2, _b2;
      var errors;
      if (!this.closed) {
        this.closed = true;
        var _parentage = this._parentage;
        if (_parentage) {
          this._parentage = null;
          if (Array.isArray(_parentage)) {
            try {
              for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                var parent_1 = _parentage_1_1.value;
                parent_1.remove(this);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_parentage_1_1 && !_parentage_1_1.done && (_a3 = _parentage_1.return)) _a3.call(_parentage_1);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
          } else {
            _parentage.remove(this);
          }
        }
        var initialFinalizer = this.initialTeardown;
        if (isFunction(initialFinalizer)) {
          try {
            initialFinalizer();
          } catch (e) {
            errors = e instanceof UnsubscriptionError ? e.errors : [e];
          }
        }
        var _finalizers = this._finalizers;
        if (_finalizers) {
          this._finalizers = null;
          try {
            for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
              var finalizer = _finalizers_1_1.value;
              try {
                execFinalizer(finalizer);
              } catch (err) {
                errors = errors !== null && errors !== void 0 ? errors : [];
                if (err instanceof UnsubscriptionError) {
                  errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                } else {
                  errors.push(err);
                }
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_finalizers_1_1 && !_finalizers_1_1.done && (_b2 = _finalizers_1.return)) _b2.call(_finalizers_1);
            } finally {
              if (e_2) throw e_2.error;
            }
          }
        }
        if (errors) {
          throw new UnsubscriptionError(errors);
        }
      }
    };
    Subscription2.prototype.add = function(teardown) {
      var _a3;
      if (teardown && teardown !== this) {
        if (this.closed) {
          execFinalizer(teardown);
        } else {
          if (teardown instanceof Subscription2) {
            if (teardown.closed || teardown._hasParent(this)) {
              return;
            }
            teardown._addParent(this);
          }
          (this._finalizers = (_a3 = this._finalizers) !== null && _a3 !== void 0 ? _a3 : []).push(teardown);
        }
      }
    };
    Subscription2.prototype._hasParent = function(parent) {
      var _parentage = this._parentage;
      return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
    };
    Subscription2.prototype._addParent = function(parent) {
      var _parentage = this._parentage;
      this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
    };
    Subscription2.prototype._removeParent = function(parent) {
      var _parentage = this._parentage;
      if (_parentage === parent) {
        this._parentage = null;
      } else if (Array.isArray(_parentage)) {
        arrRemove(_parentage, parent);
      }
    };
    Subscription2.prototype.remove = function(teardown) {
      var _finalizers = this._finalizers;
      _finalizers && arrRemove(_finalizers, teardown);
      if (teardown instanceof Subscription2) {
        teardown._removeParent(this);
      }
    };
    Subscription2.EMPTY = function() {
      var empty = new Subscription2();
      empty.closed = true;
      return empty;
    }();
    return Subscription2;
  }();
  var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
  function isSubscription(value) {
    return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
  }
  function execFinalizer(finalizer) {
    if (isFunction(finalizer)) {
      finalizer();
    } else {
      finalizer.unsubscribe();
    }
  }
  var config = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: void 0,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false
  };
  var timeoutProvider = {
    setTimeout: function(handler, timeout2) {
      var args = [];
      for (var _i2 = 2; _i2 < arguments.length; _i2++) {
        args[_i2 - 2] = arguments[_i2];
      }
      return setTimeout.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
    },
    clearTimeout: function(handle) {
      return clearTimeout(handle);
    },
    delegate: void 0
  };
  function reportUnhandledError(err) {
    timeoutProvider.setTimeout(function() {
      {
        throw err;
      }
    });
  }
  function noop() {
  }
  function errorContext(cb) {
    {
      cb();
    }
  }
  var Subscriber = function(_super) {
    __extends(Subscriber2, _super);
    function Subscriber2(destination) {
      var _this = _super.call(this) || this;
      _this.isStopped = false;
      if (destination) {
        _this.destination = destination;
        if (isSubscription(destination)) {
          destination.add(_this);
        }
      } else {
        _this.destination = EMPTY_OBSERVER;
      }
      return _this;
    }
    Subscriber2.create = function(next, error, complete) {
      return new SafeSubscriber(next, error, complete);
    };
    Subscriber2.prototype.next = function(value) {
      if (this.isStopped) ;
      else {
        this._next(value);
      }
    };
    Subscriber2.prototype.error = function(err) {
      if (this.isStopped) ;
      else {
        this.isStopped = true;
        this._error(err);
      }
    };
    Subscriber2.prototype.complete = function() {
      if (this.isStopped) ;
      else {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber2.prototype.unsubscribe = function() {
      if (!this.closed) {
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
        this.destination = null;
      }
    };
    Subscriber2.prototype._next = function(value) {
      this.destination.next(value);
    };
    Subscriber2.prototype._error = function(err) {
      try {
        this.destination.error(err);
      } finally {
        this.unsubscribe();
      }
    };
    Subscriber2.prototype._complete = function() {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    };
    return Subscriber2;
  }(Subscription);
  var _bind = Function.prototype.bind;
  function bind(fn, thisArg) {
    return _bind.call(fn, thisArg);
  }
  var ConsumerObserver = function() {
    function ConsumerObserver2(partialObserver) {
      this.partialObserver = partialObserver;
    }
    ConsumerObserver2.prototype.next = function(value) {
      var partialObserver = this.partialObserver;
      if (partialObserver.next) {
        try {
          partialObserver.next(value);
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    ConsumerObserver2.prototype.error = function(err) {
      var partialObserver = this.partialObserver;
      if (partialObserver.error) {
        try {
          partialObserver.error(err);
        } catch (error) {
          handleUnhandledError(error);
        }
      } else {
        handleUnhandledError(err);
      }
    };
    ConsumerObserver2.prototype.complete = function() {
      var partialObserver = this.partialObserver;
      if (partialObserver.complete) {
        try {
          partialObserver.complete();
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    return ConsumerObserver2;
  }();
  var SafeSubscriber = function(_super) {
    __extends(SafeSubscriber2, _super);
    function SafeSubscriber2(observerOrNext, error, complete) {
      var _this = _super.call(this) || this;
      var partialObserver;
      if (isFunction(observerOrNext) || !observerOrNext) {
        partialObserver = {
          next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
          error: error !== null && error !== void 0 ? error : void 0,
          complete: complete !== null && complete !== void 0 ? complete : void 0
        };
      } else {
        var context_1;
        if (_this && config.useDeprecatedNextContext) {
          context_1 = Object.create(observerOrNext);
          context_1.unsubscribe = function() {
            return _this.unsubscribe();
          };
          partialObserver = {
            next: observerOrNext.next && bind(observerOrNext.next, context_1),
            error: observerOrNext.error && bind(observerOrNext.error, context_1),
            complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
          };
        } else {
          partialObserver = observerOrNext;
        }
      }
      _this.destination = new ConsumerObserver(partialObserver);
      return _this;
    }
    return SafeSubscriber2;
  }(Subscriber);
  function handleUnhandledError(error) {
    {
      reportUnhandledError(error);
    }
  }
  function defaultErrorHandler(err) {
    throw err;
  }
  var EMPTY_OBSERVER = {
    closed: true,
    next: noop,
    error: defaultErrorHandler,
    complete: noop
  };
  var observable = function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  }();
  function identity(x) {
    return x;
  }
  function pipe() {
    var fns = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      fns[_i2] = arguments[_i2];
    }
    return pipeFromArray(fns);
  }
  function pipeFromArray(fns) {
    if (fns.length === 0) {
      return identity;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return function piped(input) {
      return fns.reduce(function(prev, fn) {
        return fn(prev);
      }, input);
    };
  }
  var Observable = function() {
    function Observable2(subscribe) {
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    Observable2.prototype.lift = function(operator) {
      var observable2 = new Observable2();
      observable2.source = this;
      observable2.operator = operator;
      return observable2;
    };
    Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
      var _this = this;
      var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
      errorContext(function() {
        var _a3 = _this, operator = _a3.operator, source2 = _a3.source;
        subscriber.add(operator ? operator.call(subscriber, source2) : source2 ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
      });
      return subscriber;
    };
    Observable2.prototype._trySubscribe = function(sink) {
      try {
        return this._subscribe(sink);
      } catch (err) {
        sink.error(err);
      }
    };
    Observable2.prototype.forEach = function(next, promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var subscriber = new SafeSubscriber({
          next: function(value) {
            try {
              next(value);
            } catch (err) {
              reject(err);
              subscriber.unsubscribe();
            }
          },
          error: reject,
          complete: resolve
        });
        _this.subscribe(subscriber);
      });
    };
    Observable2.prototype._subscribe = function(subscriber) {
      var _a3;
      return (_a3 = this.source) === null || _a3 === void 0 ? void 0 : _a3.subscribe(subscriber);
    };
    Observable2.prototype[observable] = function() {
      return this;
    };
    Observable2.prototype.pipe = function() {
      var operations = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        operations[_i2] = arguments[_i2];
      }
      return pipeFromArray(operations)(this);
    };
    Observable2.prototype.toPromise = function(promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var value;
        _this.subscribe(function(x) {
          return value = x;
        }, function(err) {
          return reject(err);
        }, function() {
          return resolve(value);
        });
      });
    };
    Observable2.create = function(subscribe) {
      return new Observable2(subscribe);
    };
    return Observable2;
  }();
  function getPromiseCtor(promiseCtor) {
    var _a3;
    return (_a3 = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a3 !== void 0 ? _a3 : Promise;
  }
  function isObserver(value) {
    return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
  }
  function isSubscriber(value) {
    return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
  }
  function hasLift(source2) {
    return isFunction(source2 === null || source2 === void 0 ? void 0 : source2.lift);
  }
  function operate(init) {
    return function(source2) {
      if (hasLift(source2)) {
        return source2.lift(function(liftedSource) {
          try {
            return init(liftedSource, this);
          } catch (err) {
            this.error(err);
          }
        });
      }
      throw new TypeError("Unable to lift unknown Observable type");
    };
  }
  function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
  }
  var OperatorSubscriber = function(_super) {
    __extends(OperatorSubscriber2, _super);
    function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
      var _this = _super.call(this, destination) || this;
      _this.onFinalize = onFinalize;
      _this.shouldUnsubscribe = shouldUnsubscribe;
      _this._next = onNext ? function(value) {
        try {
          onNext(value);
        } catch (err) {
          destination.error(err);
        }
      } : _super.prototype._next;
      _this._error = onError ? function(err) {
        try {
          onError(err);
        } catch (err2) {
          destination.error(err2);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._error;
      _this._complete = onComplete ? function() {
        try {
          onComplete();
        } catch (err) {
          destination.error(err);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._complete;
      return _this;
    }
    OperatorSubscriber2.prototype.unsubscribe = function() {
      var _a3;
      if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
        var closed_1 = this.closed;
        _super.prototype.unsubscribe.call(this);
        !closed_1 && ((_a3 = this.onFinalize) === null || _a3 === void 0 ? void 0 : _a3.call(this));
      }
    };
    return OperatorSubscriber2;
  }(Subscriber);
  var ObjectUnsubscribedError = createErrorClass(function(_super) {
    return function ObjectUnsubscribedErrorImpl() {
      _super(this);
      this.name = "ObjectUnsubscribedError";
      this.message = "object unsubscribed";
    };
  });
  var Subject = function(_super) {
    __extends(Subject2, _super);
    function Subject2() {
      var _this = _super.call(this) || this;
      _this.closed = false;
      _this.currentObservers = null;
      _this.observers = [];
      _this.isStopped = false;
      _this.hasError = false;
      _this.thrownError = null;
      return _this;
    }
    Subject2.prototype.lift = function(operator) {
      var subject = new AnonymousSubject(this, this);
      subject.operator = operator;
      return subject;
    };
    Subject2.prototype._throwIfClosed = function() {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }
    };
    Subject2.prototype.next = function(value) {
      var _this = this;
      errorContext(function() {
        var e_1, _a3;
        _this._throwIfClosed();
        if (!_this.isStopped) {
          if (!_this.currentObservers) {
            _this.currentObservers = Array.from(_this.observers);
          }
          try {
            for (var _b2 = __values(_this.currentObservers), _c2 = _b2.next(); !_c2.done; _c2 = _b2.next()) {
              var observer = _c2.value;
              observer.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c2 && !_c2.done && (_a3 = _b2.return)) _a3.call(_b2);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        }
      });
    };
    Subject2.prototype.error = function(err) {
      var _this = this;
      errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.hasError = _this.isStopped = true;
          _this.thrownError = err;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().error(err);
          }
        }
      });
    };
    Subject2.prototype.complete = function() {
      var _this = this;
      errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.isStopped = true;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().complete();
          }
        }
      });
    };
    Subject2.prototype.unsubscribe = function() {
      this.isStopped = this.closed = true;
      this.observers = this.currentObservers = null;
    };
    Object.defineProperty(Subject2.prototype, "observed", {
      get: function() {
        var _a3;
        return ((_a3 = this.observers) === null || _a3 === void 0 ? void 0 : _a3.length) > 0;
      },
      enumerable: false,
      configurable: true
    });
    Subject2.prototype._trySubscribe = function(subscriber) {
      this._throwIfClosed();
      return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._checkFinalizedStatuses(subscriber);
      return this._innerSubscribe(subscriber);
    };
    Subject2.prototype._innerSubscribe = function(subscriber) {
      var _this = this;
      var _a3 = this, hasError = _a3.hasError, isStopped = _a3.isStopped, observers = _a3.observers;
      if (hasError || isStopped) {
        return EMPTY_SUBSCRIPTION;
      }
      this.currentObservers = null;
      observers.push(subscriber);
      return new Subscription(function() {
        _this.currentObservers = null;
        arrRemove(observers, subscriber);
      });
    };
    Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
      var _a3 = this, hasError = _a3.hasError, thrownError = _a3.thrownError, isStopped = _a3.isStopped;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped) {
        subscriber.complete();
      }
    };
    Subject2.prototype.asObservable = function() {
      var observable2 = new Observable();
      observable2.source = this;
      return observable2;
    };
    Subject2.create = function(destination, source2) {
      return new AnonymousSubject(destination, source2);
    };
    return Subject2;
  }(Observable);
  var AnonymousSubject = function(_super) {
    __extends(AnonymousSubject2, _super);
    function AnonymousSubject2(destination, source2) {
      var _this = _super.call(this) || this;
      _this.destination = destination;
      _this.source = source2;
      return _this;
    }
    AnonymousSubject2.prototype.next = function(value) {
      var _a3, _b2;
      (_b2 = (_a3 = this.destination) === null || _a3 === void 0 ? void 0 : _a3.next) === null || _b2 === void 0 ? void 0 : _b2.call(_a3, value);
    };
    AnonymousSubject2.prototype.error = function(err) {
      var _a3, _b2;
      (_b2 = (_a3 = this.destination) === null || _a3 === void 0 ? void 0 : _a3.error) === null || _b2 === void 0 ? void 0 : _b2.call(_a3, err);
    };
    AnonymousSubject2.prototype.complete = function() {
      var _a3, _b2;
      (_b2 = (_a3 = this.destination) === null || _a3 === void 0 ? void 0 : _a3.complete) === null || _b2 === void 0 ? void 0 : _b2.call(_a3);
    };
    AnonymousSubject2.prototype._subscribe = function(subscriber) {
      var _a3, _b2;
      return (_b2 = (_a3 = this.source) === null || _a3 === void 0 ? void 0 : _a3.subscribe(subscriber)) !== null && _b2 !== void 0 ? _b2 : EMPTY_SUBSCRIPTION;
    };
    return AnonymousSubject2;
  }(Subject);
  var dateTimestampProvider = {
    now: function() {
      return (dateTimestampProvider.delegate || Date).now();
    },
    delegate: void 0
  };
  var ReplaySubject = function(_super) {
    __extends(ReplaySubject2, _super);
    function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
      if (_bufferSize === void 0) {
        _bufferSize = Infinity;
      }
      if (_windowTime === void 0) {
        _windowTime = Infinity;
      }
      if (_timestampProvider === void 0) {
        _timestampProvider = dateTimestampProvider;
      }
      var _this = _super.call(this) || this;
      _this._bufferSize = _bufferSize;
      _this._windowTime = _windowTime;
      _this._timestampProvider = _timestampProvider;
      _this._buffer = [];
      _this._infiniteTimeWindow = true;
      _this._infiniteTimeWindow = _windowTime === Infinity;
      _this._bufferSize = Math.max(1, _bufferSize);
      _this._windowTime = Math.max(1, _windowTime);
      return _this;
    }
    ReplaySubject2.prototype.next = function(value) {
      var _a3 = this, isStopped = _a3.isStopped, _buffer = _a3._buffer, _infiniteTimeWindow = _a3._infiniteTimeWindow, _timestampProvider = _a3._timestampProvider, _windowTime = _a3._windowTime;
      if (!isStopped) {
        _buffer.push(value);
        !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
      }
      this._trimBuffer();
      _super.prototype.next.call(this, value);
    };
    ReplaySubject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._trimBuffer();
      var subscription = this._innerSubscribe(subscriber);
      var _a3 = this, _infiniteTimeWindow = _a3._infiniteTimeWindow, _buffer = _a3._buffer;
      var copy = _buffer.slice();
      for (var i2 = 0; i2 < copy.length && !subscriber.closed; i2 += _infiniteTimeWindow ? 1 : 2) {
        subscriber.next(copy[i2]);
      }
      this._checkFinalizedStatuses(subscriber);
      return subscription;
    };
    ReplaySubject2.prototype._trimBuffer = function() {
      var _a3 = this, _bufferSize = _a3._bufferSize, _timestampProvider = _a3._timestampProvider, _buffer = _a3._buffer, _infiniteTimeWindow = _a3._infiniteTimeWindow;
      var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
      _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
      if (!_infiniteTimeWindow) {
        var now = _timestampProvider.now();
        var last2 = 0;
        for (var i2 = 1; i2 < _buffer.length && _buffer[i2] <= now; i2 += 2) {
          last2 = i2;
        }
        last2 && _buffer.splice(0, last2 + 1);
      }
    };
    return ReplaySubject2;
  }(Subject);
  var Action$1 = function(_super) {
    __extends(Action2, _super);
    function Action2(scheduler, work) {
      return _super.call(this) || this;
    }
    Action2.prototype.schedule = function(state, delay2) {
      return this;
    };
    return Action2;
  }(Subscription);
  var intervalProvider = {
    setInterval: function(handler, timeout2) {
      var args = [];
      for (var _i2 = 2; _i2 < arguments.length; _i2++) {
        args[_i2 - 2] = arguments[_i2];
      }
      return setInterval.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
    },
    clearInterval: function(handle) {
      return clearInterval(handle);
    },
    delegate: void 0
  };
  var AsyncAction = function(_super) {
    __extends(AsyncAction2, _super);
    function AsyncAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      _this.pending = false;
      return _this;
    }
    AsyncAction2.prototype.schedule = function(state, delay2) {
      var _a3;
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (this.closed) {
        return this;
      }
      this.state = state;
      var id = this.id;
      var scheduler = this.scheduler;
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, delay2);
      }
      this.pending = true;
      this.delay = delay2;
      this.id = (_a3 = this.id) !== null && _a3 !== void 0 ? _a3 : this.requestAsyncId(scheduler, this.id, delay2);
      return this;
    };
    AsyncAction2.prototype.requestAsyncId = function(scheduler, _id7, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
    };
    AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 != null && this.delay === delay2 && this.pending === false) {
        return id;
      }
      if (id != null) {
        intervalProvider.clearInterval(id);
      }
      return void 0;
    };
    AsyncAction2.prototype.execute = function(state, delay2) {
      if (this.closed) {
        return new Error("executing a cancelled action");
      }
      this.pending = false;
      var error = this._execute(state, delay2);
      if (error) {
        return error;
      } else if (this.pending === false && this.id != null) {
        this.id = this.recycleAsyncId(this.scheduler, this.id, null);
      }
    };
    AsyncAction2.prototype._execute = function(state, _delay3) {
      var errored = false;
      var errorValue;
      try {
        this.work(state);
      } catch (e) {
        errored = true;
        errorValue = e ? e : new Error("Scheduled action threw falsy error");
      }
      if (errored) {
        this.unsubscribe();
        return errorValue;
      }
    };
    AsyncAction2.prototype.unsubscribe = function() {
      if (!this.closed) {
        var _a3 = this, id = _a3.id, scheduler = _a3.scheduler;
        var actions = scheduler.actions;
        this.work = this.state = this.scheduler = null;
        this.pending = false;
        arrRemove(actions, this);
        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
        _super.prototype.unsubscribe.call(this);
      }
    };
    return AsyncAction2;
  }(Action$1);
  var Scheduler = function() {
    function Scheduler2(schedulerActionCtor, now) {
      if (now === void 0) {
        now = Scheduler2.now;
      }
      this.schedulerActionCtor = schedulerActionCtor;
      this.now = now;
    }
    Scheduler2.prototype.schedule = function(work, delay2, state) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      return new this.schedulerActionCtor(this, work).schedule(state, delay2);
    };
    Scheduler2.now = dateTimestampProvider.now;
    return Scheduler2;
  }();
  var AsyncScheduler = function(_super) {
    __extends(AsyncScheduler2, _super);
    function AsyncScheduler2(SchedulerAction, now) {
      if (now === void 0) {
        now = Scheduler.now;
      }
      var _this = _super.call(this, SchedulerAction, now) || this;
      _this.actions = [];
      _this._active = false;
      return _this;
    }
    AsyncScheduler2.prototype.flush = function(action) {
      var actions = this.actions;
      if (this._active) {
        actions.push(action);
        return;
      }
      var error;
      this._active = true;
      do {
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      } while (action = actions.shift());
      this._active = false;
      if (error) {
        while (action = actions.shift()) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    return AsyncScheduler2;
  }(Scheduler);
  var asyncScheduler = new AsyncScheduler(AsyncAction);
  var async = asyncScheduler;
  var EMPTY = new Observable(function(subscriber) {
    return subscriber.complete();
  });
  function isScheduler(value) {
    return value && isFunction(value.schedule);
  }
  function last(arr2) {
    return arr2[arr2.length - 1];
  }
  function popResultSelector(args) {
    return isFunction(last(args)) ? args.pop() : void 0;
  }
  function popScheduler(args) {
    return isScheduler(last(args)) ? args.pop() : void 0;
  }
  function popNumber(args, defaultValue) {
    return typeof last(args) === "number" ? args.pop() : defaultValue;
  }
  var isArrayLike = function(x) {
    return x && typeof x.length === "number" && typeof x !== "function";
  };
  function isPromise(value) {
    return isFunction(value === null || value === void 0 ? void 0 : value.then);
  }
  function isInteropObservable(input) {
    return isFunction(input[observable]);
  }
  function isAsyncIterable$1(obj) {
    return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
  }
  function createInvalidObservableTypeError(input) {
    return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
  }
  function getSymbolIterator() {
    if (typeof Symbol !== "function" || !Symbol.iterator) {
      return "@@iterator";
    }
    return Symbol.iterator;
  }
  var iterator = getSymbolIterator();
  function isIterable(input) {
    return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
  }
  function readableStreamLikeToAsyncGenerator(readableStream) {
    return __asyncGenerator$1(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
      var reader, _a3, value, done;
      return __generator(this, function(_b2) {
        switch (_b2.label) {
          case 0:
            reader = readableStream.getReader();
            _b2.label = 1;
          case 1:
            _b2.trys.push([1, , 9, 10]);
            _b2.label = 2;
          case 2:
            return [4, __await$1(reader.read())];
          case 3:
            _a3 = _b2.sent(), value = _a3.value, done = _a3.done;
            if (!done) return [3, 5];
            return [4, __await$1(void 0)];
          case 4:
            return [2, _b2.sent()];
          case 5:
            return [4, __await$1(value)];
          case 6:
            return [4, _b2.sent()];
          case 7:
            _b2.sent();
            return [3, 2];
          case 8:
            return [3, 10];
          case 9:
            reader.releaseLock();
            return [7];
          case 10:
            return [2];
        }
      });
    });
  }
  function isReadableStreamLike(obj) {
    return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
  }
  function innerFrom(input) {
    if (input instanceof Observable) {
      return input;
    }
    if (input != null) {
      if (isInteropObservable(input)) {
        return fromInteropObservable(input);
      }
      if (isArrayLike(input)) {
        return fromArrayLike(input);
      }
      if (isPromise(input)) {
        return fromPromise(input);
      }
      if (isAsyncIterable$1(input)) {
        return fromAsyncIterable(input);
      }
      if (isIterable(input)) {
        return fromIterable(input);
      }
      if (isReadableStreamLike(input)) {
        return fromReadableStreamLike(input);
      }
    }
    throw createInvalidObservableTypeError(input);
  }
  function fromInteropObservable(obj) {
    return new Observable(function(subscriber) {
      var obs = obj[observable]();
      if (isFunction(obs.subscribe)) {
        return obs.subscribe(subscriber);
      }
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    });
  }
  function fromArrayLike(array) {
    return new Observable(function(subscriber) {
      for (var i2 = 0; i2 < array.length && !subscriber.closed; i2++) {
        subscriber.next(array[i2]);
      }
      subscriber.complete();
    });
  }
  function fromPromise(promise) {
    return new Observable(function(subscriber) {
      promise.then(function(value) {
        if (!subscriber.closed) {
          subscriber.next(value);
          subscriber.complete();
        }
      }, function(err) {
        return subscriber.error(err);
      }).then(null, reportUnhandledError);
    });
  }
  function fromIterable(iterable) {
    return new Observable(function(subscriber) {
      var e_1, _a3;
      try {
        for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
          var value = iterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (iterable_1_1 && !iterable_1_1.done && (_a3 = iterable_1.return)) _a3.call(iterable_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      subscriber.complete();
    });
  }
  function fromAsyncIterable(asyncIterable) {
    return new Observable(function(subscriber) {
      process$1(asyncIterable, subscriber).catch(function(err) {
        return subscriber.error(err);
      });
    });
  }
  function fromReadableStreamLike(readableStream) {
    return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
  }
  function process$1(asyncIterable, subscriber) {
    var asyncIterable_1, asyncIterable_1_1;
    var e_2, _a3;
    return __awaiter(this, void 0, void 0, function() {
      var value, e_2_1;
      return __generator(this, function(_b2) {
        switch (_b2.label) {
          case 0:
            _b2.trys.push([0, 5, 6, 11]);
            asyncIterable_1 = __asyncValues(asyncIterable);
            _b2.label = 1;
          case 1:
            return [4, asyncIterable_1.next()];
          case 2:
            if (!(asyncIterable_1_1 = _b2.sent(), !asyncIterable_1_1.done)) return [3, 4];
            value = asyncIterable_1_1.value;
            subscriber.next(value);
            if (subscriber.closed) {
              return [2];
            }
            _b2.label = 3;
          case 3:
            return [3, 1];
          case 4:
            return [3, 11];
          case 5:
            e_2_1 = _b2.sent();
            e_2 = { error: e_2_1 };
            return [3, 11];
          case 6:
            _b2.trys.push([6, , 9, 10]);
            if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a3 = asyncIterable_1.return))) return [3, 8];
            return [4, _a3.call(asyncIterable_1)];
          case 7:
            _b2.sent();
            _b2.label = 8;
          case 8:
            return [3, 10];
          case 9:
            if (e_2) throw e_2.error;
            return [7];
          case 10:
            return [7];
          case 11:
            subscriber.complete();
            return [2];
        }
      });
    });
  }
  function executeSchedule(parentSubscription, scheduler, work, delay2, repeat) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (repeat === void 0) {
      repeat = false;
    }
    var scheduleSubscription = scheduler.schedule(function() {
      work();
      if (repeat) {
        parentSubscription.add(this.schedule(null, delay2));
      } else {
        this.unsubscribe();
      }
    }, delay2);
    parentSubscription.add(scheduleSubscription);
    if (!repeat) {
      return scheduleSubscription;
    }
  }
  function observeOn(scheduler, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return operate(function(source2, subscriber) {
      source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.next(value);
        }, delay2);
      }, function() {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.complete();
        }, delay2);
      }, function(err) {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.error(err);
        }, delay2);
      }));
    });
  }
  function subscribeOn(scheduler, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return operate(function(source2, subscriber) {
      subscriber.add(scheduler.schedule(function() {
        return source2.subscribe(subscriber);
      }, delay2));
    });
  }
  function scheduleObservable(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
  }
  function schedulePromise(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
  }
  function scheduleArray(input, scheduler) {
    return new Observable(function(subscriber) {
      var i2 = 0;
      return scheduler.schedule(function() {
        if (i2 === input.length) {
          subscriber.complete();
        } else {
          subscriber.next(input[i2++]);
          if (!subscriber.closed) {
            this.schedule();
          }
        }
      });
    });
  }
  function scheduleIterable(input, scheduler) {
    return new Observable(function(subscriber) {
      var iterator2;
      executeSchedule(subscriber, scheduler, function() {
        iterator2 = input[iterator]();
        executeSchedule(subscriber, scheduler, function() {
          var _a3;
          var value;
          var done;
          try {
            _a3 = iterator2.next(), value = _a3.value, done = _a3.done;
          } catch (err) {
            subscriber.error(err);
            return;
          }
          if (done) {
            subscriber.complete();
          } else {
            subscriber.next(value);
          }
        }, 0, true);
      });
      return function() {
        return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
      };
    });
  }
  function scheduleAsyncIterable(input, scheduler) {
    if (!input) {
      throw new Error("Iterable cannot be null");
    }
    return new Observable(function(subscriber) {
      executeSchedule(subscriber, scheduler, function() {
        var iterator2 = input[Symbol.asyncIterator]();
        executeSchedule(subscriber, scheduler, function() {
          iterator2.next().then(function(result) {
            if (result.done) {
              subscriber.complete();
            } else {
              subscriber.next(result.value);
            }
          });
        }, 0, true);
      });
    });
  }
  function scheduleReadableStreamLike(input, scheduler) {
    return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
  }
  function scheduled(input, scheduler) {
    if (input != null) {
      if (isInteropObservable(input)) {
        return scheduleObservable(input, scheduler);
      }
      if (isArrayLike(input)) {
        return scheduleArray(input, scheduler);
      }
      if (isPromise(input)) {
        return schedulePromise(input, scheduler);
      }
      if (isAsyncIterable$1(input)) {
        return scheduleAsyncIterable(input, scheduler);
      }
      if (isIterable(input)) {
        return scheduleIterable(input, scheduler);
      }
      if (isReadableStreamLike(input)) {
        return scheduleReadableStreamLike(input, scheduler);
      }
    }
    throw createInvalidObservableTypeError(input);
  }
  function from(input, scheduler) {
    return scheduler ? scheduled(input, scheduler) : innerFrom(input);
  }
  function of() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var scheduler = popScheduler(args);
    return from(args, scheduler);
  }
  var EmptyError = createErrorClass(function(_super) {
    return function EmptyErrorImpl() {
      _super(this);
      this.name = "EmptyError";
      this.message = "no elements in sequence";
    };
  });
  function firstValueFrom(source2, config2) {
    return new Promise(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          resolve(value);
          subscriber.unsubscribe();
        },
        error: reject,
        complete: function() {
          {
            reject(new EmptyError());
          }
        }
      });
      source2.subscribe(subscriber);
    });
  }
  function isValidDate(value) {
    return value instanceof Date && !isNaN(value);
  }
  function map(project, thisArg) {
    return operate(function(source2, subscriber) {
      var index = 0;
      source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
        subscriber.next(project.call(thisArg, value, index++));
      }));
    });
  }
  var isArray = Array.isArray;
  function callOrApply(fn, args) {
    return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
  }
  function mapOneOrManyArgs(fn) {
    return map(function(args) {
      return callOrApply(fn, args);
    });
  }
  var isArray2 = Array.isArray;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectProto = Object.prototype;
  var getKeys = Object.keys;
  function argsArgArrayOrObject(args) {
    if (args.length === 1) {
      var first_1 = args[0];
      if (isArray2(first_1)) {
        return { args: first_1, keys: null };
      }
      if (isPOJO(first_1)) {
        var keys = getKeys(first_1);
        return {
          args: keys.map(function(key) {
            return first_1[key];
          }),
          keys
        };
      }
    }
    return { args, keys: null };
  }
  function isPOJO(obj) {
    return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
  }
  function createObject(keys, values) {
    return keys.reduce(function(result, key, i2) {
      return result[key] = values[i2], result;
    }, {});
  }
  function combineLatest() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var scheduler = popScheduler(args);
    var resultSelector = popResultSelector(args);
    var _a3 = argsArgArrayOrObject(args), observables = _a3.args, keys = _a3.keys;
    if (observables.length === 0) {
      return from([], scheduler);
    }
    var result = new Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
      return createObject(keys, values);
    } : identity));
    return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
  }
  function combineLatestInit(observables, scheduler, valueTransform) {
    if (valueTransform === void 0) {
      valueTransform = identity;
    }
    return function(subscriber) {
      maybeSchedule(scheduler, function() {
        var length = observables.length;
        var values = new Array(length);
        var active = length;
        var remainingFirstValues = length;
        var _loop_1 = function(i22) {
          maybeSchedule(scheduler, function() {
            var source2 = from(observables[i22], scheduler);
            var hasFirstValue = false;
            source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
              values[i22] = value;
              if (!hasFirstValue) {
                hasFirstValue = true;
                remainingFirstValues--;
              }
              if (!remainingFirstValues) {
                subscriber.next(valueTransform(values.slice()));
              }
            }, function() {
              if (!--active) {
                subscriber.complete();
              }
            }));
          }, subscriber);
        };
        for (var i2 = 0; i2 < length; i2++) {
          _loop_1(i2);
        }
      }, subscriber);
    };
  }
  function maybeSchedule(scheduler, execute, subscription) {
    if (scheduler) {
      executeSchedule(subscription, scheduler, execute);
    } else {
      execute();
    }
  }
  function mergeInternals(source2, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
    var buffer = [];
    var active = 0;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      if (isComplete && !buffer.length && !active) {
        subscriber.complete();
      }
    };
    var outerNext = function(value) {
      return active < concurrent ? doInnerSub(value) : buffer.push(value);
    };
    var doInnerSub = function(value) {
      expand && subscriber.next(value);
      active++;
      var innerComplete = false;
      innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
        onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
        if (expand) {
          outerNext(innerValue);
        } else {
          subscriber.next(innerValue);
        }
      }, function() {
        innerComplete = true;
      }, void 0, function() {
        if (innerComplete) {
          try {
            active--;
            var _loop_1 = function() {
              var bufferedValue = buffer.shift();
              if (innerSubScheduler) ;
              else {
                doInnerSub(bufferedValue);
              }
            };
            while (buffer.length && active < concurrent) {
              _loop_1();
            }
            checkComplete();
          } catch (err) {
            subscriber.error(err);
          }
        }
      }));
    };
    source2.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
      isComplete = true;
      checkComplete();
    }));
    return function() {
      additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
    };
  }
  function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    if (isFunction(resultSelector)) {
      return mergeMap(function(a, i2) {
        return map(function(b, ii) {
          return resultSelector(a, b, i2, ii);
        })(innerFrom(project(a, i2)));
      }, concurrent);
    } else if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return operate(function(source2, subscriber) {
      return mergeInternals(source2, subscriber, project, concurrent);
    });
  }
  function mergeAll(concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    return mergeMap(identity, concurrent);
  }
  function concatAll() {
    return mergeAll(1);
  }
  function concat$1() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    return concatAll()(from(args, popScheduler(args)));
  }
  function defer(observableFactory) {
    return new Observable(function(subscriber) {
      innerFrom(observableFactory()).subscribe(subscriber);
    });
  }
  var nodeEventEmitterMethods = ["addListener", "removeListener"];
  var eventTargetMethods = ["addEventListener", "removeEventListener"];
  var jqueryMethods = ["on", "off"];
  function fromEvent(target, eventName, options, resultSelector) {
    if (isFunction(options)) {
      resultSelector = options;
      options = void 0;
    }
    if (resultSelector) {
      return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
    }
    var _a3 = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
      return function(handler) {
        return target[methodName](eventName, handler, options);
      };
    }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a3[0], remove = _a3[1];
    if (!add) {
      if (isArrayLike(target)) {
        return mergeMap(function(subTarget) {
          return fromEvent(subTarget, eventName, options);
        })(innerFrom(target));
      }
    }
    if (!add) {
      throw new TypeError("Invalid event target");
    }
    return new Observable(function(subscriber) {
      var handler = function() {
        var args = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          args[_i2] = arguments[_i2];
        }
        return subscriber.next(1 < args.length ? args : args[0]);
      };
      add(handler);
      return function() {
        return remove(handler);
      };
    });
  }
  function toCommonHandlerRegistry(target, eventName) {
    return function(methodName) {
      return function(handler) {
        return target[methodName](eventName, handler);
      };
    };
  }
  function isNodeStyleEventEmitter(target) {
    return isFunction(target.addListener) && isFunction(target.removeListener);
  }
  function isJQueryStyleEventEmitter(target) {
    return isFunction(target.on) && isFunction(target.off);
  }
  function isEventTarget(target) {
    return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
  }
  function timer(dueTime, intervalOrScheduler, scheduler) {
    if (dueTime === void 0) {
      dueTime = 0;
    }
    if (scheduler === void 0) {
      scheduler = async;
    }
    return new Observable(function(subscriber) {
      var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
      if (due < 0) {
        due = 0;
      }
      var n = 0;
      return scheduler.schedule(function() {
        if (!subscriber.closed) {
          subscriber.next(n++);
          {
            subscriber.complete();
          }
        }
      }, due);
    });
  }
  function merge() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var scheduler = popScheduler(args);
    var concurrent = popNumber(args, Infinity);
    var sources = args;
    return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler));
  }
  var NEVER$2 = new Observable(noop);
  var isArray3 = Array.isArray;
  function argsOrArgArray(args) {
    return args.length === 1 && isArray3(args[0]) ? args[0] : args;
  }
  function filter(predicate, thisArg) {
    return operate(function(source2, subscriber) {
      var index = 0;
      source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
        return predicate.call(thisArg, value, index++) && subscriber.next(value);
      }));
    });
  }
  function race() {
    var sources = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      sources[_i2] = arguments[_i2];
    }
    sources = argsOrArgArray(sources);
    return sources.length === 1 ? innerFrom(sources[0]) : new Observable(raceInit(sources));
  }
  function raceInit(sources) {
    return function(subscriber) {
      var subscriptions = [];
      var _loop_1 = function(i22) {
        subscriptions.push(innerFrom(sources[i22]).subscribe(createOperatorSubscriber(subscriber, function(value) {
          if (subscriptions) {
            for (var s = 0; s < subscriptions.length; s++) {
              s !== i22 && subscriptions[s].unsubscribe();
            }
            subscriptions = null;
          }
          subscriber.next(value);
        })));
      };
      for (var i2 = 0; subscriptions && !subscriber.closed && i2 < sources.length; i2++) {
        _loop_1(i2);
      }
    };
  }
  function catchError(selector) {
    return operate(function(source2, subscriber) {
      var innerSub = null;
      var syncUnsub = false;
      var handledResult;
      innerSub = source2.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
        handledResult = innerFrom(selector(err, catchError(selector)(source2)));
        if (innerSub) {
          innerSub.unsubscribe();
          innerSub = null;
          handledResult.subscribe(subscriber);
        } else {
          syncUnsub = true;
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      }
    });
  }
  function defaultIfEmpty(defaultValue) {
    return operate(function(source2, subscriber) {
      var hasValue = false;
      source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        subscriber.next(value);
      }, function() {
        if (!hasValue) {
          subscriber.next(defaultValue);
        }
        subscriber.complete();
      }));
    });
  }
  function take(count) {
    return count <= 0 ? function() {
      return EMPTY;
    } : operate(function(source2, subscriber) {
      var seen = 0;
      source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (++seen <= count) {
          subscriber.next(value);
          if (count <= seen) {
            subscriber.complete();
          }
        }
      }));
    });
  }
  function ignoreElements() {
    return operate(function(source2, subscriber) {
      source2.subscribe(createOperatorSubscriber(subscriber, noop));
    });
  }
  function mapTo(value) {
    return map(function() {
      return value;
    });
  }
  function delayWhen(delayDurationSelector, subscriptionDelay) {
    return mergeMap(function(value, index) {
      return innerFrom(delayDurationSelector(value, index)).pipe(take(1), mapTo(value));
    });
  }
  function throwIfEmpty(errorFactory) {
    if (errorFactory === void 0) {
      errorFactory = defaultErrorFactory;
    }
    return operate(function(source2, subscriber) {
      var hasValue = false;
      source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        subscriber.next(value);
      }, function() {
        return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
      }));
    });
  }
  function defaultErrorFactory() {
    return new EmptyError();
  }
  function first(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source2) {
      return source2.pipe(predicate ? filter(function(v, i2) {
        return predicate(v, i2, source2);
      }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
        return new EmptyError();
      }));
    };
  }
  function mergeScan(accumulator, seed, concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    return operate(function(source2, subscriber) {
      var state = seed;
      return mergeInternals(source2, subscriber, function(value, index) {
        return accumulator(state, value, index);
      }, concurrent, function(value) {
        state = value;
      }, false, void 0, function() {
        return state = null;
      });
    });
  }
  function raceWith() {
    var otherSources = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      otherSources[_i2] = arguments[_i2];
    }
    return !otherSources.length ? identity : operate(function(source2, subscriber) {
      raceInit(__spreadArray([source2], __read(otherSources)))(subscriber);
    });
  }
  function retry$2(configOrCount) {
    if (configOrCount === void 0) {
      configOrCount = Infinity;
    }
    var config2;
    if (configOrCount && typeof configOrCount === "object") {
      config2 = configOrCount;
    } else {
      config2 = {
        count: configOrCount
      };
    }
    var _a3 = config2.count, count = _a3 === void 0 ? Infinity : _a3, delay2 = config2.delay, _b2 = config2.resetOnSuccess, resetOnSuccess = _b2 === void 0 ? false : _b2;
    return count <= 0 ? identity : operate(function(source2, subscriber) {
      var soFar = 0;
      var innerSub;
      var subscribeForRetry = function() {
        var syncUnsub = false;
        innerSub = source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
          if (resetOnSuccess) {
            soFar = 0;
          }
          subscriber.next(value);
        }, void 0, function(err) {
          if (soFar++ < count) {
            var resub_1 = function() {
              if (innerSub) {
                innerSub.unsubscribe();
                innerSub = null;
                subscribeForRetry();
              } else {
                syncUnsub = true;
              }
            };
            if (delay2 != null) {
              var notifier = typeof delay2 === "number" ? timer(delay2) : innerFrom(delay2(err, soFar));
              var notifierSubscriber_1 = createOperatorSubscriber(subscriber, function() {
                notifierSubscriber_1.unsubscribe();
                resub_1();
              }, function() {
                subscriber.complete();
              });
              notifier.subscribe(notifierSubscriber_1);
            } else {
              resub_1();
            }
          } else {
            subscriber.error(err);
          }
        }));
        if (syncUnsub) {
          innerSub.unsubscribe();
          innerSub = null;
          subscribeForRetry();
        }
      };
      subscribeForRetry();
    });
  }
  function startWith() {
    var values = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      values[_i2] = arguments[_i2];
    }
    var scheduler = popScheduler(values);
    return operate(function(source2, subscriber) {
      (scheduler ? concat$1(values, source2, scheduler) : concat$1(values, source2)).subscribe(subscriber);
    });
  }
  function switchMap(project, resultSelector) {
    return operate(function(source2, subscriber) {
      var innerSubscriber = null;
      var index = 0;
      var isComplete = false;
      var checkComplete = function() {
        return isComplete && !innerSubscriber && subscriber.complete();
      };
      source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
        innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
        var innerIndex = 0;
        var outerIndex = index++;
        innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function(innerValue) {
          return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
        }, function() {
          innerSubscriber = null;
          checkComplete();
        }));
      }, function() {
        isComplete = true;
        checkComplete();
      }));
    });
  }
  function takeUntil(notifier) {
    return operate(function(source2, subscriber) {
      innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
        return subscriber.complete();
      }, noop));
      !subscriber.closed && source2.subscribe(subscriber);
    });
  }
  function tap(observerOrNext, error, complete) {
    var tapObserver = isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
    return tapObserver ? operate(function(source2, subscriber) {
      var _a3;
      (_a3 = tapObserver.subscribe) === null || _a3 === void 0 ? void 0 : _a3.call(tapObserver);
      var isUnsub = true;
      source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
        var _a22;
        (_a22 = tapObserver.next) === null || _a22 === void 0 ? void 0 : _a22.call(tapObserver, value);
        subscriber.next(value);
      }, function() {
        var _a22;
        isUnsub = false;
        (_a22 = tapObserver.complete) === null || _a22 === void 0 ? void 0 : _a22.call(tapObserver);
        subscriber.complete();
      }, function(err) {
        var _a22;
        isUnsub = false;
        (_a22 = tapObserver.error) === null || _a22 === void 0 ? void 0 : _a22.call(tapObserver, err);
        subscriber.error(err);
      }, function() {
        var _a22, _b2;
        if (isUnsub) {
          (_a22 = tapObserver.unsubscribe) === null || _a22 === void 0 ? void 0 : _a22.call(tapObserver);
        }
        (_b2 = tapObserver.finalize) === null || _b2 === void 0 ? void 0 : _b2.call(tapObserver);
      }));
    }) : identity;
  }
  function mitt_default(n) {
    return { all: n = n || /* @__PURE__ */ new Map(), on: function(t, e) {
      var i2 = n.get(t);
      i2 ? i2.push(e) : n.set(t, [e]);
    }, off: function(t, e) {
      var i2 = n.get(t);
      i2 && (e ? i2.splice(i2.indexOf(e) >>> 0, 1) : n.set(t, []));
    }, emit: function(t, e) {
      var i2 = n.get(t);
      i2 && i2.slice().map(function(n2) {
        n2(e);
      }), (i2 = n.get("*")) && i2.slice().map(function(n2) {
        n2(t, e);
      });
    } };
  }
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  Symbol.dispose ?? (Symbol.dispose = Symbol("dispose"));
  Symbol.asyncDispose ?? (Symbol.asyncDispose = Symbol("asyncDispose"));
  const disposeSymbol = Symbol.dispose;
  const asyncDisposeSymbol = Symbol.asyncDispose;
  _b = disposeSymbol, _a2 = Symbol.toStringTag;
  const _DisposableStack = class _DisposableStack {
    constructor() {
      __privateAdd(this, _disposed, false);
      __privateAdd(this, _stack, []);
      __publicField(this, _b, this.dispose);
      __publicField(this, _a2, "DisposableStack");
    }
    /**
     * Returns a value indicating whether this stack has been disposed.
     */
    get disposed() {
      return __privateGet(this, _disposed);
    }
    /**
     * Disposes each resource in the stack in the reverse order that they were added.
     */
    dispose() {
      if (__privateGet(this, _disposed)) {
        return;
      }
      __privateSet(this, _disposed, true);
      for (const resource of __privateGet(this, _stack).reverse()) {
        resource[disposeSymbol]();
      }
    }
    /**
     * Adds a disposable resource to the stack, returning the resource.
     *
     * @param value - The resource to add. `null` and `undefined` will not be added,
     * but will be returned.
     * @returns The provided `value`.
     */
    use(value) {
      if (value) {
        __privateGet(this, _stack).push(value);
      }
      return value;
    }
    /**
     * Adds a value and associated disposal callback as a resource to the stack.
     *
     * @param value - The value to add.
     * @param onDispose - The callback to use in place of a `[disposeSymbol]()`
     * method. Will be invoked with `value` as the first parameter.
     * @returns The provided `value`.
     */
    adopt(value, onDispose) {
      __privateGet(this, _stack).push({
        [disposeSymbol]() {
          onDispose(value);
        }
      });
      return value;
    }
    /**
     * Adds a callback to be invoked when the stack is disposed.
     */
    defer(onDispose) {
      __privateGet(this, _stack).push({
        [disposeSymbol]() {
          onDispose();
        }
      });
    }
    /**
     * Move all resources out of this stack and into a new `DisposableStack`, and
     * marks this stack as disposed.
     *
     * @example
     *
     * ```ts
     * class C {
     *   #res1: Disposable;
     *   #res2: Disposable;
     *   #disposables: DisposableStack;
     *   constructor() {
     *     // stack will be disposed when exiting constructor for any reason
     *     using stack = new DisposableStack();
     *
     *     // get first resource
     *     this.#res1 = stack.use(getResource1());
     *
     *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.
     *     this.#res2 = stack.use(getResource2());
     *
     *     // all operations succeeded, move resources out of `stack` so that
     *     // they aren't disposed when constructor exits
     *     this.#disposables = stack.move();
     *   }
     *
     *   [disposeSymbol]() {
     *     this.#disposables.dispose();
     *   }
     * }
     * ```
     */
    move() {
      if (__privateGet(this, _disposed)) {
        throw new ReferenceError("a disposed stack can not use anything new");
      }
      const stack = new _DisposableStack();
      __privateSet(stack, _stack, __privateGet(this, _stack));
      __privateSet(this, _disposed, true);
      return stack;
    }
  };
  _disposed = new WeakMap();
  _stack = new WeakMap();
  let DisposableStack = _DisposableStack;
  _d = asyncDisposeSymbol, _c = Symbol.toStringTag;
  const _AsyncDisposableStack = class _AsyncDisposableStack {
    constructor() {
      __privateAdd(this, _disposed2, false);
      __privateAdd(this, _stack2, []);
      __publicField(this, _d, this.dispose);
      __publicField(this, _c, "AsyncDisposableStack");
    }
    /**
     * Returns a value indicating whether this stack has been disposed.
     */
    get disposed() {
      return __privateGet(this, _disposed2);
    }
    /**
     * Disposes each resource in the stack in the reverse order that they were added.
     */
    async dispose() {
      if (__privateGet(this, _disposed2)) {
        return;
      }
      __privateSet(this, _disposed2, true);
      for (const resource of __privateGet(this, _stack2).reverse()) {
        await resource[asyncDisposeSymbol]();
      }
    }
    /**
     * Adds a disposable resource to the stack, returning the resource.
     *
     * @param value - The resource to add. `null` and `undefined` will not be added,
     * but will be returned.
     * @returns The provided `value`.
     */
    use(value) {
      if (value) {
        __privateGet(this, _stack2).push(value);
      }
      return value;
    }
    /**
     * Adds a value and associated disposal callback as a resource to the stack.
     *
     * @param value - The value to add.
     * @param onDispose - The callback to use in place of a `[disposeSymbol]()`
     * method. Will be invoked with `value` as the first parameter.
     * @returns The provided `value`.
     */
    adopt(value, onDispose) {
      __privateGet(this, _stack2).push({
        [asyncDisposeSymbol]() {
          return onDispose(value);
        }
      });
      return value;
    }
    /**
     * Adds a callback to be invoked when the stack is disposed.
     */
    defer(onDispose) {
      __privateGet(this, _stack2).push({
        [asyncDisposeSymbol]() {
          return onDispose();
        }
      });
    }
    /**
     * Move all resources out of this stack and into a new `DisposableStack`, and
     * marks this stack as disposed.
     *
     * @example
     *
     * ```ts
     * class C {
     *   #res1: Disposable;
     *   #res2: Disposable;
     *   #disposables: DisposableStack;
     *   constructor() {
     *     // stack will be disposed when exiting constructor for any reason
     *     using stack = new DisposableStack();
     *
     *     // get first resource
     *     this.#res1 = stack.use(getResource1());
     *
     *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.
     *     this.#res2 = stack.use(getResource2());
     *
     *     // all operations succeeded, move resources out of `stack` so that
     *     // they aren't disposed when constructor exits
     *     this.#disposables = stack.move();
     *   }
     *
     *   [disposeSymbol]() {
     *     this.#disposables.dispose();
     *   }
     * }
     * ```
     */
    move() {
      if (__privateGet(this, _disposed2)) {
        throw new ReferenceError("a disposed stack can not use anything new");
      }
      const stack = new _AsyncDisposableStack();
      __privateSet(stack, _stack2, __privateGet(this, _stack2));
      __privateSet(this, _disposed2, true);
      return stack;
    }
  };
  _disposed2 = new WeakMap();
  _stack2 = new WeakMap();
  let AsyncDisposableStack = _AsyncDisposableStack;
  /**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  let EventEmitter$1 = (_e = class {
    /**
     * If you pass an emitter, the returned emitter will wrap the passed emitter.
     *
     * @internal
     */
    constructor(emitter = mitt_default(/* @__PURE__ */ new Map())) {
      __privateAdd(this, _emitter);
      __privateAdd(this, _handlers, /* @__PURE__ */ new Map());
      __privateSet(this, _emitter, emitter);
    }
    /**
     * Bind an event listener to fire when an event occurs.
     * @param type - the event type you'd like to listen to. Can be a string or symbol.
     * @param handler - the function to be called when the event occurs.
     * @returns `this` to enable you to chain method calls.
     */
    on(type, handler) {
      const handlers = __privateGet(this, _handlers).get(type);
      if (handlers === void 0) {
        __privateGet(this, _handlers).set(type, [handler]);
      } else {
        handlers.push(handler);
      }
      __privateGet(this, _emitter).on(type, handler);
      return this;
    }
    /**
     * Remove an event listener from firing.
     * @param type - the event type you'd like to stop listening to.
     * @param handler - the function that should be removed.
     * @returns `this` to enable you to chain method calls.
     */
    off(type, handler) {
      const handlers = __privateGet(this, _handlers).get(type) ?? [];
      if (handler === void 0) {
        for (const handler2 of handlers) {
          __privateGet(this, _emitter).off(type, handler2);
        }
        __privateGet(this, _handlers).delete(type);
        return this;
      }
      const index = handlers.lastIndexOf(handler);
      if (index > -1) {
        __privateGet(this, _emitter).off(type, ...handlers.splice(index, 1));
      }
      return this;
    }
    /**
     * Emit an event and call any associated listeners.
     *
     * @param type - the event you'd like to emit
     * @param eventData - any data you'd like to emit with the event
     * @returns `true` if there are any listeners, `false` if there are not.
     */
    emit(type, event) {
      __privateGet(this, _emitter).emit(type, event);
      return this.listenerCount(type) > 0;
    }
    /**
     * Like `on` but the listener will only be fired once and then it will be removed.
     * @param type - the event you'd like to listen to
     * @param handler - the handler function to run when the event occurs
     * @returns `this` to enable you to chain method calls.
     */
    once(type, handler) {
      const onceHandler = (eventData) => {
        handler(eventData);
        this.off(type, onceHandler);
      };
      return this.on(type, onceHandler);
    }
    /**
     * Gets the number of listeners for a given event.
     *
     * @param type - the event to get the listener count for
     * @returns the number of listeners bound to the given event
     */
    listenerCount(type) {
      var _a3;
      return ((_a3 = __privateGet(this, _handlers).get(type)) == null ? void 0 : _a3.length) || 0;
    }
    /**
     * Removes all listeners. If given an event argument, it will remove only
     * listeners for that event.
     *
     * @param type - the event to remove listeners for.
     * @returns `this` to enable you to chain method calls.
     */
    removeAllListeners(type) {
      if (type !== void 0) {
        return this.off(type);
      }
      this[disposeSymbol]();
      return this;
    }
    /**
     * @internal
     */
    [disposeSymbol]() {
      for (const [type, handlers] of __privateGet(this, _handlers)) {
        for (const handler of handlers) {
          __privateGet(this, _emitter).off(type, handler);
        }
      }
      __privateGet(this, _handlers).clear();
    }
  }, _emitter = new WeakMap(), _handlers = new WeakMap(), _e);
  /**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  const isNode$2 = !!(typeof process !== "undefined" && process.version);
  const environment = {
    value: {
      get fs() {
        throw new Error("fs is not available in this environment");
      },
      get ScreenRecorder() {
        throw new Error("ScreenRecorder is not available in this environment");
      }
    }
  };
  const packageVersion = "24.1.1";
  /**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  const assert$1 = (value, message) => {
    if (!value) {
      throw new Error(message);
    }
  };
  /**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  function stringToTypedArray(string, base64Encoded = false) {
    if (base64Encoded) {
      const binaryString = atob(string);
      return Uint8Array.from(binaryString, (m) => {
        return m.codePointAt(0);
      });
    }
    return new TextEncoder().encode(string);
  }
  function stringToBase64(str2) {
    return typedArrayToBase64(new TextEncoder().encode(str2));
  }
  function typedArrayToBase64(typedArray) {
    const chunkSize = 65534;
    const chunks = [];
    for (let i2 = 0; i2 < typedArray.length; i2 += chunkSize) {
      const chunk = typedArray.subarray(i2, i2 + chunkSize);
      chunks.push(String.fromCodePoint.apply(null, chunk));
    }
    const binaryString = chunks.join("");
    return btoa(binaryString);
  }
  function mergeUint8Arrays(items) {
    let length = 0;
    for (const item of items) {
      length += item.length;
    }
    const result = new Uint8Array(length);
    let offset = 0;
    for (const item of items) {
      result.set(item, offset);
      offset += item.length;
    }
    return result;
  }
  /**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  let debugModule = null;
  async function importDebug() {
    if (!debugModule) {
      debugModule = (await Promise.resolve().then(() => browser$2)).default;
    }
    return debugModule;
  }
  const debug$3 = (prefix) => {
    if (isNode$2) {
      return async (...logArgs) => {
        (await importDebug())(prefix)(logArgs);
      };
    }
    return (...logArgs) => {
      const debugLevel = globalThis.__PUPPETEER_DEBUG;
      if (!debugLevel) {
        return;
      }
      const everythingShouldBeLogged = debugLevel === "*";
      const prefixMatchesDebugLevel = everythingShouldBeLogged || /**
       * If the debug level is `foo*`, that means we match any prefix that
       * starts with `foo`. If the level is `foo`, we match only the prefix
       * `foo`.
       */
      (debugLevel.endsWith("*") ? prefix.startsWith(debugLevel) : prefix === debugLevel);
      if (!prefixMatchesDebugLevel) {
        return;
      }
      console.log(`${prefix}:`, ...logArgs);
    };
  };
  /**
   * @license
   * Copyright 2018 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class PuppeteerError extends Error {
    /**
     * @internal
     */
    constructor(message, options) {
      super(message, options);
      this.name = this.constructor.name;
    }
    /**
     * @internal
     */
    get [Symbol.toStringTag]() {
      return this.constructor.name;
    }
  }
  class TimeoutError extends PuppeteerError {
  }
  class TouchError extends PuppeteerError {
  }
  class ProtocolError extends PuppeteerError {
    constructor() {
      super(...arguments);
      __privateAdd(this, _code);
      __privateAdd(this, _originalMessage, "");
    }
    set code(code) {
      __privateSet(this, _code, code);
    }
    /**
     * @readonly
     * @public
     */
    get code() {
      return __privateGet(this, _code);
    }
    set originalMessage(originalMessage) {
      __privateSet(this, _originalMessage, originalMessage);
    }
    /**
     * @readonly
     * @public
     */
    get originalMessage() {
      return __privateGet(this, _originalMessage);
    }
  }
  _code = new WeakMap();
  _originalMessage = new WeakMap();
  class UnsupportedOperation extends PuppeteerError {
  }
  class TargetCloseError extends ProtocolError {
  }
  /**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  const paperFormats = {
    letter: {
      cm: { width: 21.59, height: 27.94 },
      in: { width: 8.5, height: 11 }
    },
    legal: {
      cm: { width: 21.59, height: 35.56 },
      in: { width: 8.5, height: 14 }
    },
    tabloid: {
      cm: { width: 27.94, height: 43.18 },
      in: { width: 11, height: 17 }
    },
    ledger: {
      cm: { width: 43.18, height: 27.94 },
      in: { width: 17, height: 11 }
    },
    a0: {
      cm: { width: 84.1, height: 118.9 },
      in: { width: 33.1102, height: 46.811 }
    },
    a1: {
      cm: { width: 59.4, height: 84.1 },
      in: { width: 23.3858, height: 33.1102 }
    },
    a2: {
      cm: { width: 42, height: 59.4 },
      in: { width: 16.5354, height: 23.3858 }
    },
    a3: {
      cm: { width: 29.7, height: 42 },
      in: { width: 11.6929, height: 16.5354 }
    },
    a4: {
      cm: { width: 21, height: 29.7 },
      in: { width: 8.2677, height: 11.6929 }
    },
    a5: {
      cm: { width: 14.8, height: 21 },
      in: { width: 5.8268, height: 8.2677 }
    },
    a6: {
      cm: { width: 10.5, height: 14.8 },
      in: { width: 4.1339, height: 5.8268 }
    }
  };
  /**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  const debugError = debug$3("puppeteer:error");
  const DEFAULT_VIEWPORT = Object.freeze({ width: 800, height: 600 });
  const SOURCE_URL = Symbol("Source URL for Puppeteer evaluation scripts");
  const _PuppeteerURL = class _PuppeteerURL {
    constructor() {
      __privateAdd(this, _functionName);
      __privateAdd(this, _siteString);
    }
    static fromCallSite(functionName, site) {
      const url = new _PuppeteerURL();
      __privateSet(url, _functionName, functionName);
      __privateSet(url, _siteString, site.toString());
      return url;
    }
    get functionName() {
      return __privateGet(this, _functionName);
    }
    get siteString() {
      return __privateGet(this, _siteString);
    }
    toString() {
      return `pptr:${[
        __privateGet(this, _functionName),
        encodeURIComponent(__privateGet(this, _siteString))
      ].join(";")}`;
    }
  };
  _functionName = new WeakMap();
  _siteString = new WeakMap();
  __publicField(_PuppeteerURL, "INTERNAL_URL", "pptr:internal");
  __publicField(_PuppeteerURL, "parse", (url) => {
    url = url.slice("pptr:".length);
    const [functionName = "", siteString = ""] = url.split(";");
    const puppeteerUrl = new _PuppeteerURL();
    __privateSet(puppeteerUrl, _functionName, functionName);
    __privateSet(puppeteerUrl, _siteString, decodeURIComponent(siteString));
    return puppeteerUrl;
  });
  __publicField(_PuppeteerURL, "isPuppeteerURL", (url) => {
    return url.startsWith("pptr:");
  });
  let PuppeteerURL = _PuppeteerURL;
  const withSourcePuppeteerURLIfNone = (functionName, object) => {
    if (Object.prototype.hasOwnProperty.call(object, SOURCE_URL)) {
      return object;
    }
    const original = Error.prepareStackTrace;
    Error.prepareStackTrace = (_, stack) => {
      return stack[2];
    };
    const site = new Error().stack;
    Error.prepareStackTrace = original;
    return Object.assign(object, {
      [SOURCE_URL]: PuppeteerURL.fromCallSite(functionName, site)
    });
  };
  const getSourcePuppeteerURLIfAvailable = (object) => {
    if (Object.prototype.hasOwnProperty.call(object, SOURCE_URL)) {
      return object[SOURCE_URL];
    }
    return void 0;
  };
  const isString = (obj) => {
    return typeof obj === "string" || obj instanceof String;
  };
  const isNumber = (obj) => {
    return typeof obj === "number" || obj instanceof Number;
  };
  const isPlainObject = (obj) => {
    return typeof obj === "object" && (obj == null ? void 0 : obj.constructor) === Object;
  };
  const isRegExp = (obj) => {
    return typeof obj === "object" && (obj == null ? void 0 : obj.constructor) === RegExp;
  };
  const isDate = (obj) => {
    return typeof obj === "object" && (obj == null ? void 0 : obj.constructor) === Date;
  };
  function evaluationString(fun, ...args) {
    if (isString(fun)) {
      assert$1(args.length === 0, "Cannot evaluate a string with arguments");
      return fun;
    }
    function serializeArgument(arg) {
      if (Object.is(arg, void 0)) {
        return "undefined";
      }
      return JSON.stringify(arg);
    }
    return `(${fun})(${args.map(serializeArgument).join(",")})`;
  }
  async function getReadableAsTypedArray(readable, path) {
    const buffers = [];
    const reader = readable.getReader();
    if (path) {
      const fileHandle = await environment.value.fs.promises.open(path, "w+");
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            break;
          }
          buffers.push(value);
          await fileHandle.writeFile(value);
        }
      } finally {
        await fileHandle.close();
      }
    } else {
      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          break;
        }
        buffers.push(value);
      }
    }
    try {
      const concat2 = mergeUint8Arrays(buffers);
      if (concat2.length === 0) {
        return null;
      }
      return concat2;
    } catch (error) {
      debugError(error);
      return null;
    }
  }
  async function getReadableFromProtocolStream(client2, handle) {
    return new ReadableStream({
      async pull(controller) {
        function getUnit8Array(data2, isBase64) {
          if (isBase64) {
            return Uint8Array.from(atob(data2), (m) => {
              return m.codePointAt(0);
            });
          }
          const encoder = new TextEncoder();
          return encoder.encode(data2);
        }
        const { data, base64Encoded, eof } = await client2.send("IO.read", {
          handle
        });
        controller.enqueue(getUnit8Array(data, base64Encoded ?? false));
        if (eof) {
          await client2.send("IO.close", { handle });
          controller.close();
        }
      }
    });
  }
  function validateDialogType(type) {
    let dialogType = null;
    const validDialogTypes = /* @__PURE__ */ new Set([
      "alert",
      "confirm",
      "prompt",
      "beforeunload"
    ]);
    if (validDialogTypes.has(type)) {
      dialogType = type;
    }
    assert$1(dialogType, `Unknown javascript dialog type: ${type}`);
    return dialogType;
  }
  function timeout(ms2, cause) {
    return ms2 === 0 ? NEVER$2 : timer(ms2).pipe(map(() => {
      throw new TimeoutError(`Timed out after waiting ${ms2}ms`, { cause });
    }));
  }
  const UTILITY_WORLD_NAME = "__puppeteer_utility_world__" + packageVersion;
  const SOURCE_URL_REGEX = /^[\x20\t]*\/\/[@#] sourceURL=\s{0,10}(\S*?)\s{0,10}$/m;
  function getSourceUrlComment(url) {
    return `//# sourceURL=${url}`;
  }
  const NETWORK_IDLE_TIME = 500;
  function parsePDFOptions(options = {}, lengthUnit = "in") {
    var _a3, _b2, _c2, _d2;
    const defaults2 = {
      scale: 1,
      displayHeaderFooter: false,
      headerTemplate: "",
      footerTemplate: "",
      printBackground: false,
      landscape: false,
      pageRanges: "",
      preferCSSPageSize: false,
      omitBackground: false,
      outline: false,
      tagged: true,
      waitForFonts: true
    };
    let width = 8.5;
    let height = 11;
    if (options.format) {
      const format = paperFormats[options.format.toLowerCase()][lengthUnit];
      assert$1(format, "Unknown paper format: " + options.format);
      width = format.width;
      height = format.height;
    } else {
      width = convertPrintParameterToInches(options.width, lengthUnit) ?? width;
      height = convertPrintParameterToInches(options.height, lengthUnit) ?? height;
    }
    const margin = {
      top: convertPrintParameterToInches((_a3 = options.margin) == null ? void 0 : _a3.top, lengthUnit) || 0,
      left: convertPrintParameterToInches((_b2 = options.margin) == null ? void 0 : _b2.left, lengthUnit) || 0,
      bottom: convertPrintParameterToInches((_c2 = options.margin) == null ? void 0 : _c2.bottom, lengthUnit) || 0,
      right: convertPrintParameterToInches((_d2 = options.margin) == null ? void 0 : _d2.right, lengthUnit) || 0
    };
    if (options.outline) {
      options.tagged = true;
    }
    return {
      ...defaults2,
      ...options,
      width,
      height,
      margin
    };
  }
  const unitToPixels = {
    px: 1,
    in: 96,
    cm: 37.8,
    mm: 3.78
  };
  function convertPrintParameterToInches(parameter, lengthUnit = "in") {
    if (typeof parameter === "undefined") {
      return void 0;
    }
    let pixels;
    if (isNumber(parameter)) {
      pixels = parameter;
    } else if (isString(parameter)) {
      const text = parameter;
      let unit = text.substring(text.length - 2).toLowerCase();
      let valueText = "";
      if (unit in unitToPixels) {
        valueText = text.substring(0, text.length - 2);
      } else {
        unit = "px";
        valueText = text;
      }
      const value = Number(valueText);
      assert$1(!isNaN(value), "Failed to parse parameter value: " + text);
      pixels = value * unitToPixels[unit];
    } else {
      throw new Error("page.pdf() Cannot handle parameter type: " + typeof parameter);
    }
    return pixels / unitToPixels[lengthUnit];
  }
  function fromEmitterEvent(emitter, eventName) {
    return new Observable((subscriber) => {
      const listener = (event) => {
        subscriber.next(event);
      };
      emitter.on(eventName, listener);
      return () => {
        emitter.off(eventName, listener);
      };
    });
  }
  function fromAbortSignal(signal, cause) {
    return signal ? fromEvent(signal, "abort").pipe(map(() => {
      if (signal.reason instanceof Error) {
        signal.reason.cause = cause;
        throw signal.reason;
      }
      throw new Error(signal.reason, { cause });
    })) : NEVER$2;
  }
  function filterAsync(predicate) {
    return mergeMap((value) => {
      return from(Promise.resolve(predicate(value))).pipe(filter((isMatch) => {
        return isMatch;
      }), map(() => {
        return value;
      }));
    });
  }
  const WEB_PERMISSION_TO_PROTOCOL_PERMISSION = /* @__PURE__ */ new Map([
    ["geolocation", "geolocation"],
    ["midi", "midi"],
    ["notifications", "notifications"],
    // TODO: push isn't a valid type?
    // ['push', 'push'],
    ["camera", "videoCapture"],
    ["microphone", "audioCapture"],
    ["background-sync", "backgroundSync"],
    ["ambient-light-sensor", "sensors"],
    ["accelerometer", "sensors"],
    ["gyroscope", "sensors"],
    ["magnetometer", "sensors"],
    ["accessibility-events", "accessibilityEvents"],
    ["clipboard-read", "clipboardReadWrite"],
    ["clipboard-write", "clipboardReadWrite"],
    ["clipboard-sanitized-write", "clipboardSanitizedWrite"],
    ["payment-handler", "paymentHandler"],
    ["persistent-storage", "durableStorage"],
    ["idle-detection", "idleDetection"],
    // chrome-specific permissions we have.
    ["midi-sysex", "midiSysex"]
  ]);
  let Browser$1 = class Browser extends EventEmitter$1 {
    /**
     * @internal
     */
    constructor() {
      super();
    }
    /**
     * Waits until a {@link Target | target} matching the given `predicate`
     * appears and returns it.
     *
     * This will look all open {@link BrowserContext | browser contexts}.
     *
     * @example Finding a target for a page opened via `window.open`:
     *
     * ```ts
     * await page.evaluate(() => window.open('https://www.example.com/'));
     * const newWindowTarget = await browser.waitForTarget(
     *   target => target.url() === 'https://www.example.com/',
     * );
     * ```
     */
    async waitForTarget(predicate, options = {}) {
      const { timeout: ms2 = 3e4, signal } = options;
      return await firstValueFrom(merge(fromEmitterEvent(
        this,
        "targetcreated"
        /* BrowserEvent.TargetCreated */
      ), fromEmitterEvent(
        this,
        "targetchanged"
        /* BrowserEvent.TargetChanged */
      ), from(this.targets())).pipe(filterAsync(predicate), raceWith(fromAbortSignal(signal), timeout(ms2))));
    }
    /**
     * Gets a list of all open {@link Page | pages} inside this {@link Browser}.
     *
     * If there are multiple {@link BrowserContext | browser contexts}, this
     * returns all {@link Page | pages} in all
     * {@link BrowserContext | browser contexts}.
     *
     * @remarks Non-visible {@link Page | pages}, such as `"background_page"`,
     * will not be listed here. You can find them using {@link Target.page}.
     */
    async pages() {
      const contextPages = await Promise.all(this.browserContexts().map((context) => {
        return context.pages();
      }));
      return contextPages.reduce((acc, x) => {
        return acc.concat(x);
      }, []);
    }
    /**
     * Returns all cookies in the default {@link BrowserContext}.
     *
     * @remarks
     *
     * Shortcut for
     * {@link BrowserContext.cookies | browser.defaultBrowserContext().cookies()}.
     */
    async cookies() {
      return await this.defaultBrowserContext().cookies();
    }
    /**
     * Sets cookies in the default {@link BrowserContext}.
     *
     * @remarks
     *
     * Shortcut for
     * {@link BrowserContext.setCookie | browser.defaultBrowserContext().setCookie()}.
     */
    async setCookie(...cookies) {
      return await this.defaultBrowserContext().setCookie(...cookies);
    }
    /**
     * Removes cookies from the default {@link BrowserContext}.
     *
     * @remarks
     *
     * Shortcut for
     * {@link BrowserContext.deleteCookie | browser.defaultBrowserContext().deleteCookie()}.
     */
    async deleteCookie(...cookies) {
      return await this.defaultBrowserContext().deleteCookie(...cookies);
    }
    /**
     * Whether Puppeteer is connected to this {@link Browser | browser}.
     *
     * @deprecated Use {@link Browser | Browser.connected}.
     */
    isConnected() {
      return this.connected;
    }
    /** @internal */
    [disposeSymbol]() {
      if (this.process()) {
        return void this.close().catch(debugError);
      }
      return void this.disconnect().catch(debugError);
    }
    /** @internal */
    [asyncDisposeSymbol]() {
      if (this.process()) {
        return this.close();
      }
      return this.disconnect();
    }
  };
  /**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  let Deferred$1 = (_f = class {
    constructor(opts) {
      __privateAdd(this, _Deferred_instances);
      __privateAdd(this, _isResolved, false);
      __privateAdd(this, _isRejected, false);
      __privateAdd(this, _value);
      // SAFETY: This is ensured by #taskPromise.
      __privateAdd(this, _resolve);
      // TODO: Switch to Promise.withResolvers with Node 22
      __privateAdd(this, _taskPromise, new Promise((resolve) => {
        __privateSet(this, _resolve, resolve);
      }));
      __privateAdd(this, _timeoutId);
      __privateAdd(this, _timeoutError);
      __privateAdd(this, _promise);
      if (opts && opts.timeout > 0) {
        __privateSet(this, _timeoutError, new TimeoutError(opts.message));
        __privateSet(this, _timeoutId, setTimeout(() => {
          this.reject(__privateGet(this, _timeoutError));
        }, opts.timeout));
      }
    }
    static create(opts) {
      return new _f(opts);
    }
    static async race(awaitables) {
      const deferredWithTimeout = /* @__PURE__ */ new Set();
      try {
        const promises = awaitables.map((value) => {
          if (value instanceof _f) {
            if (__privateGet(value, _timeoutId)) {
              deferredWithTimeout.add(value);
            }
            return value.valueOrThrow();
          }
          return value;
        });
        return await Promise.race(promises);
      } finally {
        for (const deferred of deferredWithTimeout) {
          deferred.reject(new Error("Timeout cleared"));
        }
      }
    }
    resolve(value) {
      if (__privateGet(this, _isRejected) || __privateGet(this, _isResolved)) {
        return;
      }
      __privateSet(this, _isResolved, true);
      __privateMethod(this, _Deferred_instances, finish_fn).call(this, value);
    }
    reject(error) {
      if (__privateGet(this, _isRejected) || __privateGet(this, _isResolved)) {
        return;
      }
      __privateSet(this, _isRejected, true);
      __privateMethod(this, _Deferred_instances, finish_fn).call(this, error);
    }
    resolved() {
      return __privateGet(this, _isResolved);
    }
    finished() {
      return __privateGet(this, _isResolved) || __privateGet(this, _isRejected);
    }
    value() {
      return __privateGet(this, _value);
    }
    valueOrThrow() {
      if (!__privateGet(this, _promise)) {
        __privateSet(this, _promise, (async () => {
          await __privateGet(this, _taskPromise);
          if (__privateGet(this, _isRejected)) {
            throw __privateGet(this, _value);
          }
          return __privateGet(this, _value);
        })());
      }
      return __privateGet(this, _promise);
    }
  }, _isResolved = new WeakMap(), _isRejected = new WeakMap(), _value = new WeakMap(), _resolve = new WeakMap(), _taskPromise = new WeakMap(), _timeoutId = new WeakMap(), _timeoutError = new WeakMap(), _Deferred_instances = new WeakSet(), finish_fn = function(value) {
    clearTimeout(__privateGet(this, _timeoutId));
    __privateSet(this, _value, value);
    __privateGet(this, _resolve).call(this);
  }, _promise = new WeakMap(), _f);
  /**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  let Mutex$1 = (_h = class {
    constructor() {
      __privateAdd(this, _locked, false);
      __privateAdd(this, _acquirers, []);
    }
    // This is FIFO.
    async acquire(onRelease) {
      if (!__privateGet(this, _locked)) {
        __privateSet(this, _locked, true);
        return new _h.Guard(this);
      }
      const deferred = Deferred$1.create();
      __privateGet(this, _acquirers).push(deferred.resolve.bind(deferred));
      await deferred.valueOrThrow();
      return new _h.Guard(this, onRelease);
    }
    release() {
      const resolve = __privateGet(this, _acquirers).shift();
      if (!resolve) {
        __privateSet(this, _locked, false);
        return;
      }
      resolve();
    }
  }, _locked = new WeakMap(), _acquirers = new WeakMap(), __publicField(_h, "Guard", (_g = class {
    constructor(mutex, onRelease) {
      __privateAdd(this, _mutex);
      __privateAdd(this, _onRelease);
      __privateSet(this, _mutex, mutex);
      __privateSet(this, _onRelease, onRelease);
    }
    [disposeSymbol]() {
      var _a3;
      (_a3 = __privateGet(this, _onRelease)) == null ? void 0 : _a3.call(this);
      return __privateGet(this, _mutex).release();
    }
  }, _mutex = new WeakMap(), _onRelease = new WeakMap(), _g)), _h);
  /**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  let BrowserContext$1 = (_i = class extends EventEmitter$1 {
    /**
     * @internal
     */
    constructor() {
      super();
      /**
       * If defined, indicates an ongoing screenshot opereation.
       */
      __privateAdd(this, _pageScreenshotMutex);
      __privateAdd(this, _screenshotOperationsCount, 0);
    }
    /**
     * @internal
     */
    startScreenshot() {
      const mutex = __privateGet(this, _pageScreenshotMutex) || new Mutex$1();
      __privateSet(this, _pageScreenshotMutex, mutex);
      __privateWrapper(this, _screenshotOperationsCount)._++;
      return mutex.acquire(() => {
        __privateWrapper(this, _screenshotOperationsCount)._--;
        if (__privateGet(this, _screenshotOperationsCount) === 0) {
          __privateSet(this, _pageScreenshotMutex, void 0);
        }
      });
    }
    /**
     * @internal
     */
    waitForScreenshotOperations() {
      var _a3;
      return (_a3 = __privateGet(this, _pageScreenshotMutex)) == null ? void 0 : _a3.acquire();
    }
    /**
     * Waits until a {@link Target | target} matching the given `predicate`
     * appears and returns it.
     *
     * This will look all open {@link BrowserContext | browser contexts}.
     *
     * @example Finding a target for a page opened via `window.open`:
     *
     * ```ts
     * await page.evaluate(() => window.open('https://www.example.com/'));
     * const newWindowTarget = await browserContext.waitForTarget(
     *   target => target.url() === 'https://www.example.com/',
     * );
     * ```
     */
    async waitForTarget(predicate, options = {}) {
      const { timeout: ms2 = 3e4 } = options;
      return await firstValueFrom(merge(fromEmitterEvent(
        this,
        "targetcreated"
        /* BrowserContextEvent.TargetCreated */
      ), fromEmitterEvent(
        this,
        "targetchanged"
        /* BrowserContextEvent.TargetChanged */
      ), from(this.targets())).pipe(filterAsync(predicate), raceWith(timeout(ms2))));
    }
    /**
     * Removes cookie in the browser context
     * @param cookies - {@link Cookie | cookie} to remove
     */
    async deleteCookie(...cookies) {
      return await this.setCookie(...cookies.map((cookie) => {
        return {
          ...cookie,
          expires: 1
        };
      }));
    }
    /**
     * Whether this {@link BrowserContext | browser context} is closed.
     */
    get closed() {
      return !this.browser().browserContexts().includes(this);
    }
    /**
     * Identifier for this {@link BrowserContext | browser context}.
     */
    get id() {
      return void 0;
    }
    /** @internal */
    [disposeSymbol]() {
      return void this.close().catch(debugError);
    }
    /** @internal */
    [asyncDisposeSymbol]() {
      return this.close();
    }
  }, _pageScreenshotMutex = new WeakMap(), _screenshotOperationsCount = new WeakMap(), _i);
  var CDPSessionEvent;
  (function(CDPSessionEvent2) {
    CDPSessionEvent2.Disconnected = Symbol("CDPSession.Disconnected");
    CDPSessionEvent2.Swapped = Symbol("CDPSession.Swapped");
    CDPSessionEvent2.Ready = Symbol("CDPSession.Ready");
    CDPSessionEvent2.SessionAttached = "sessionattached";
    CDPSessionEvent2.SessionDetached = "sessiondetached";
  })(CDPSessionEvent || (CDPSessionEvent = {}));
  class CDPSession extends EventEmitter$1 {
    /**
     * @internal
     */
    constructor() {
      super();
    }
    /**
     * Parent session in terms of CDP's auto-attach mechanism.
     *
     * @internal
     */
    parentSession() {
      return void 0;
    }
  }
  /**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class Dialog {
    /**
     * @internal
     */
    constructor(type, message, defaultValue = "") {
      __privateAdd(this, _type);
      __privateAdd(this, _message);
      __privateAdd(this, _defaultValue);
      /**
       * @internal
       */
      __publicField(this, "handled", false);
      __privateSet(this, _type, type);
      __privateSet(this, _message, message);
      __privateSet(this, _defaultValue, defaultValue);
    }
    /**
     * The type of the dialog.
     */
    type() {
      return __privateGet(this, _type);
    }
    /**
     * The message displayed in the dialog.
     */
    message() {
      return __privateGet(this, _message);
    }
    /**
     * The default value of the prompt, or an empty string if the dialog
     * is not a `prompt`.
     */
    defaultValue() {
      return __privateGet(this, _defaultValue);
    }
    /**
     * A promise that resolves when the dialog has been accepted.
     *
     * @param promptText - optional text that will be entered in the dialog
     * prompt. Has no effect if the dialog's type is not `prompt`.
     *
     */
    async accept(promptText) {
      assert$1(!this.handled, "Cannot accept dialog which is already handled!");
      this.handled = true;
      await this.handle({
        accept: true,
        text: promptText
      });
    }
    /**
     * A promise which will resolve once the dialog has been dismissed
     */
    async dismiss() {
      assert$1(!this.handled, "Cannot dismiss dialog which is already handled!");
      this.handled = true;
      await this.handle({
        accept: false
      });
    }
  }
  _type = new WeakMap();
  _message = new WeakMap();
  _defaultValue = new WeakMap();
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  const _isElementHandle = Symbol("_isElementHandle");
  /**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  function isErrorLike(obj) {
    return typeof obj === "object" && obj !== null && "name" in obj && "message" in obj;
  }
  function rewriteError$1(error, message, originalMessage) {
    error.message = message;
    error.originalMessage = originalMessage ?? error.originalMessage;
    return error;
  }
  function createProtocolErrorMessage(object) {
    let message = object.error.message;
    if (object.error && typeof object.error === "object" && "data" in object.error) {
      message += ` ${object.error.data}`;
    }
    return message;
  }
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  const createdFunctions = /* @__PURE__ */ new Map();
  const createFunction = (functionValue) => {
    let fn = createdFunctions.get(functionValue);
    if (fn) {
      return fn;
    }
    fn = new Function(`return ${functionValue}`)();
    createdFunctions.set(functionValue, fn);
    return fn;
  };
  function stringifyFunction(fn) {
    let value = fn.toString();
    try {
      new Function(`(${value})`);
    } catch (err) {
      if (err.message.includes(`Refused to evaluate a string as JavaScript because 'unsafe-eval' is not an allowed source of script in the following Content Security Policy directive`)) {
        return value;
      }
      let prefix = "function ";
      if (value.startsWith("async ")) {
        prefix = `async ${prefix}`;
        value = value.substring("async ".length);
      }
      value = `${prefix}${value}`;
      try {
        new Function(`(${value})`);
      } catch {
        throw new Error("Passed function cannot be serialized!");
      }
    }
    return value;
  }
  const interpolateFunction = (fn, replacements) => {
    let value = stringifyFunction(fn);
    for (const [name, jsValue] of Object.entries(replacements)) {
      value = value.replace(
        new RegExp(`PLACEHOLDER\\(\\s*(?:'${name}'|"${name}")\\s*\\)`, "g"),
        // Wrapping this ensures tersers that accidentally inline PLACEHOLDER calls
        // are still valid. Without, we may get calls like ()=>{...}() which is
        // not valid.
        `(${jsValue})`
      );
    }
    return createFunction(value);
  };
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var __addDisposableResource$i = function(env, value, async2) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async2) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async2) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({ value, dispose, async: async2 });
    } else if (async2) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources$i = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  const DEFAULT_BATCH_SIZE = 20;
  async function* fastTransposeIteratorHandle(iterator2, size) {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
      const array = __addDisposableResource$i(env_1, await iterator2.evaluateHandle(async (iterator3, size2) => {
        const results = [];
        while (results.length < size2) {
          const result = await iterator3.next();
          if (result.done) {
            break;
          }
          results.push(result.value);
        }
        return results;
      }, size), false);
      const properties = await array.getProperties();
      const handles = properties.values();
      const stack = __addDisposableResource$i(env_1, new DisposableStack(), false);
      stack.defer(() => {
        for (const handle_1 of handles) {
          const env_2 = { stack: [], error: void 0, hasError: false };
          try {
            const handle = __addDisposableResource$i(env_2, handle_1, false);
            handle[disposeSymbol]();
          } catch (e_2) {
            env_2.error = e_2;
            env_2.hasError = true;
          } finally {
            __disposeResources$i(env_2);
          }
        }
      });
      yield* handles;
      return properties.size === 0;
    } catch (e_1) {
      env_1.error = e_1;
      env_1.hasError = true;
    } finally {
      __disposeResources$i(env_1);
    }
  }
  async function* transposeIteratorHandle(iterator2) {
    let size = DEFAULT_BATCH_SIZE;
    while (!(yield* fastTransposeIteratorHandle(iterator2, size))) {
      size <<= 1;
    }
  }
  async function* transposeIterableHandle(handle) {
    const env_3 = { stack: [], error: void 0, hasError: false };
    try {
      const generatorHandle = __addDisposableResource$i(env_3, await handle.evaluateHandle((iterable) => {
        return async function* () {
          yield* iterable;
        }();
      }), false);
      yield* transposeIteratorHandle(generatorHandle);
    } catch (e_3) {
      env_3.error = e_3;
      env_3.hasError = true;
    } finally {
      __disposeResources$i(env_3);
    }
  }
  /**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  const _LazyArg = class _LazyArg {
    constructor(get2) {
      __privateAdd(this, _get);
      __privateSet(this, _get, get2);
    }
    async get(context) {
      return await __privateGet(this, _get).call(this, context);
    }
  };
  _get = new WeakMap();
  __publicField(_LazyArg, "create", (get2) => {
    return new _LazyArg(get2);
  });
  let LazyArg = _LazyArg;
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var __addDisposableResource$h = function(env, value, async2) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async2) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async2) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({ value, dispose, async: async2 });
    } else if (async2) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources$h = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  class QueryHandler {
    static get _querySelector() {
      if (this.querySelector) {
        return this.querySelector;
      }
      if (!this.querySelectorAll) {
        throw new Error("Cannot create default `querySelector`.");
      }
      return this.querySelector = interpolateFunction(async (node, selector, PuppeteerUtil) => {
        const querySelectorAll = PLACEHOLDER("querySelectorAll");
        const results = querySelectorAll(node, selector, PuppeteerUtil);
        for await (const result of results) {
          return result;
        }
        return null;
      }, {
        querySelectorAll: stringifyFunction(this.querySelectorAll)
      });
    }
    static get _querySelectorAll() {
      if (this.querySelectorAll) {
        return this.querySelectorAll;
      }
      if (!this.querySelector) {
        throw new Error("Cannot create default `querySelectorAll`.");
      }
      return this.querySelectorAll = interpolateFunction(async function* (node, selector, PuppeteerUtil) {
        const querySelector = PLACEHOLDER("querySelector");
        const result = await querySelector(node, selector, PuppeteerUtil);
        if (result) {
          yield result;
        }
      }, {
        querySelector: stringifyFunction(this.querySelector)
      });
    }
    /**
     * Queries for multiple nodes given a selector and {@link ElementHandle}.
     *
     * Akin to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll | Document.querySelectorAll()}.
     */
    static async *queryAll(element, selector) {
      const env_1 = { stack: [], error: void 0, hasError: false };
      try {
        const handle = __addDisposableResource$h(env_1, await element.evaluateHandle(this._querySelectorAll, selector, LazyArg.create((context) => {
          return context.puppeteerUtil;
        })), false);
        yield* transposeIterableHandle(handle);
      } catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
      } finally {
        __disposeResources$h(env_1);
      }
    }
    /**
     * Queries for a single node given a selector and {@link ElementHandle}.
     *
     * Akin to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector}.
     */
    static async queryOne(element, selector) {
      const env_2 = { stack: [], error: void 0, hasError: false };
      try {
        const result = __addDisposableResource$h(env_2, await element.evaluateHandle(this._querySelector, selector, LazyArg.create((context) => {
          return context.puppeteerUtil;
        })), false);
        if (!(_isElementHandle in result)) {
          return null;
        }
        return result.move();
      } catch (e_2) {
        env_2.error = e_2;
        env_2.hasError = true;
      } finally {
        __disposeResources$h(env_2);
      }
    }
    /**
     * Waits until a single node appears for a given selector and
     * {@link ElementHandle}.
     *
     * This will always query the handle in the Puppeteer world and migrate the
     * result to the main world.
     */
    static async waitFor(elementOrFrame, selector, options) {
      const env_3 = { stack: [], error: void 0, hasError: false };
      try {
        let frame;
        const element = __addDisposableResource$h(env_3, await (async () => {
          if (!(_isElementHandle in elementOrFrame)) {
            frame = elementOrFrame;
            return;
          }
          frame = elementOrFrame.frame;
          return await frame.isolatedRealm().adoptHandle(elementOrFrame);
        })(), false);
        const { visible = false, hidden = false, timeout: timeout2, signal } = options;
        const polling = visible || hidden ? "raf" : options.polling;
        try {
          const env_4 = { stack: [], error: void 0, hasError: false };
          try {
            signal == null ? void 0 : signal.throwIfAborted();
            const handle = __addDisposableResource$h(env_4, await frame.isolatedRealm().waitForFunction(async (PuppeteerUtil, query, selector2, root2, visible2) => {
              const querySelector = PuppeteerUtil.createFunction(query);
              const node = await querySelector(root2 ?? document, selector2, PuppeteerUtil);
              return PuppeteerUtil.checkVisibility(node, visible2);
            }, {
              polling,
              root: element,
              timeout: timeout2,
              signal
            }, LazyArg.create((context) => {
              return context.puppeteerUtil;
            }), stringifyFunction(this._querySelector), selector, element, visible ? true : hidden ? false : void 0), false);
            if (signal == null ? void 0 : signal.aborted) {
              throw signal.reason;
            }
            if (!(_isElementHandle in handle)) {
              return null;
            }
            return await frame.mainRealm().transferHandle(handle);
          } catch (e_3) {
            env_4.error = e_3;
            env_4.hasError = true;
          } finally {
            __disposeResources$h(env_4);
          }
        } catch (error) {
          if (!isErrorLike(error)) {
            throw error;
          }
          if (error.name === "AbortError") {
            throw error;
          }
          error.message = `Waiting for selector \`${selector}\` failed: ${error.message}`;
          throw error;
        }
      } catch (e_4) {
        env_3.error = e_4;
        env_3.hasError = true;
      } finally {
        __disposeResources$h(env_3);
      }
    }
  }
  // Either one of these may be implemented, but at least one must be.
  __publicField(QueryHandler, "querySelectorAll");
  __publicField(QueryHandler, "querySelector");
  class AsyncIterableUtil {
    static async *map(iterable, map2) {
      for await (const value of iterable) {
        yield await map2(value);
      }
    }
    static async *flatMap(iterable, map2) {
      for await (const value of iterable) {
        yield* map2(value);
      }
    }
    static async collect(iterable) {
      const result = [];
      for await (const value of iterable) {
        result.push(value);
      }
      return result;
    }
    static async first(iterable) {
      for await (const value of iterable) {
        return value;
      }
      return;
    }
  }
  /**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  const isKnownAttribute = (attribute) => {
    return ["name", "role"].includes(attribute);
  };
  const ATTRIBUTE_REGEXP = /\[\s*(?<attribute>\w+)\s*=\s*(?<quote>"|')(?<value>\\.|.*?(?=\k<quote>))\k<quote>\s*\]/g;
  const parseARIASelector = (selector) => {
    if (selector.length > 1e4) {
      throw new Error(`Selector ${selector} is too long`);
    }
    const queryOptions = {};
    const defaultName = selector.replace(ATTRIBUTE_REGEXP, (_, attribute, __, value) => {
      assert$1(isKnownAttribute(attribute), `Unknown aria attribute "${attribute}" in selector`);
      queryOptions[attribute] = value;
      return "";
    });
    if (defaultName && !queryOptions.name) {
      queryOptions.name = defaultName;
    }
    return queryOptions;
  };
  const _ARIAQueryHandler = class _ARIAQueryHandler extends QueryHandler {
    static async *queryAll(element, selector) {
      const { name, role } = parseARIASelector(selector);
      yield* element.queryAXTree(name, role);
    }
  };
  __publicField(_ARIAQueryHandler, "querySelector", async (node, selector, { ariaQuerySelector }) => {
    return await ariaQuerySelector(node, selector);
  });
  __publicField(_ARIAQueryHandler, "queryOne", async (element, selector) => {
    return await AsyncIterableUtil.first(_ARIAQueryHandler.queryAll(element, selector)) ?? null;
  });
  let ARIAQueryHandler = _ARIAQueryHandler;
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class CSSQueryHandler extends QueryHandler {
  }
  __publicField(CSSQueryHandler, "querySelector", (element, selector, { cssQuerySelector }) => {
    return cssQuerySelector(element, selector);
  });
  __publicField(CSSQueryHandler, "querySelectorAll", (element, selector, { cssQuerySelectorAll }) => {
    return cssQuerySelectorAll(element, selector);
  });
  const source = '"use strict";var g=Object.defineProperty;var X=Object.getOwnPropertyDescriptor;var B=Object.getOwnPropertyNames;var Y=Object.prototype.hasOwnProperty;var l=(t,e)=>{for(var r in e)g(t,r,{get:e[r],enumerable:!0})},J=(t,e,r,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of B(e))!Y.call(t,n)&&n!==r&&g(t,n,{get:()=>e[n],enumerable:!(o=X(e,n))||o.enumerable});return t};var z=t=>J(g({},"__esModule",{value:!0}),t);var pe={};l(pe,{default:()=>he});module.exports=z(pe);var N=class extends Error{constructor(e,r){super(e,r),this.name=this.constructor.name}get[Symbol.toStringTag](){return this.constructor.name}},p=class extends N{};var c=class t{static create(e){return new t(e)}static async race(e){let r=new Set;try{let o=e.map(n=>n instanceof t?(n.#n&&r.add(n),n.valueOrThrow()):n);return await Promise.race(o)}finally{for(let o of r)o.reject(new Error("Timeout cleared"))}}#e=!1;#r=!1;#o;#t;#a=new Promise(e=>{this.#t=e});#n;#i;constructor(e){e&&e.timeout>0&&(this.#i=new p(e.message),this.#n=setTimeout(()=>{this.reject(this.#i)},e.timeout))}#l(e){clearTimeout(this.#n),this.#o=e,this.#t()}resolve(e){this.#r||this.#e||(this.#e=!0,this.#l(e))}reject(e){this.#r||this.#e||(this.#r=!0,this.#l(e))}resolved(){return this.#e}finished(){return this.#e||this.#r}value(){return this.#o}#s;valueOrThrow(){return this.#s||(this.#s=(async()=>{if(await this.#a,this.#r)throw this.#o;return this.#o})()),this.#s}};var L=new Map,F=t=>{let e=L.get(t);return e||(e=new Function(`return ${t}`)(),L.set(t,e),e)};var x={};l(x,{ariaQuerySelector:()=>G,ariaQuerySelectorAll:()=>b});var G=(t,e)=>globalThis.__ariaQuerySelector(t,e),b=async function*(t,e){yield*await globalThis.__ariaQuerySelectorAll(t,e)};var E={};l(E,{cssQuerySelector:()=>K,cssQuerySelectorAll:()=>Z});var K=(t,e)=>t.querySelector(e),Z=function(t,e){return t.querySelectorAll(e)};var A={};l(A,{customQuerySelectors:()=>P});var v=class{#e=new Map;register(e,r){if(!r.queryOne&&r.queryAll){let o=r.queryAll;r.queryOne=(n,i)=>{for(let s of o(n,i))return s;return null}}else if(r.queryOne&&!r.queryAll){let o=r.queryOne;r.queryAll=(n,i)=>{let s=o(n,i);return s?[s]:[]}}else if(!r.queryOne||!r.queryAll)throw new Error("At least one query method must be defined.");this.#e.set(e,{querySelector:r.queryOne,querySelectorAll:r.queryAll})}unregister(e){this.#e.delete(e)}get(e){return this.#e.get(e)}clear(){this.#e.clear()}},P=new v;var R={};l(R,{pierceQuerySelector:()=>ee,pierceQuerySelectorAll:()=>te});var ee=(t,e)=>{let r=null,o=n=>{let i=document.createTreeWalker(n,NodeFilter.SHOW_ELEMENT);do{let s=i.currentNode;s.shadowRoot&&o(s.shadowRoot),!(s instanceof ShadowRoot)&&s!==n&&!r&&s.matches(e)&&(r=s)}while(!r&&i.nextNode())};return t instanceof Document&&(t=t.documentElement),o(t),r},te=(t,e)=>{let r=[],o=n=>{let i=document.createTreeWalker(n,NodeFilter.SHOW_ELEMENT);do{let s=i.currentNode;s.shadowRoot&&o(s.shadowRoot),!(s instanceof ShadowRoot)&&s!==n&&s.matches(e)&&r.push(s)}while(i.nextNode())};return t instanceof Document&&(t=t.documentElement),o(t),r};var u=(t,e)=>{if(!t)throw new Error(e)};var y=class{#e;#r;#o;#t;constructor(e,r){this.#e=e,this.#r=r}async start(){let e=this.#t=c.create(),r=await this.#e();if(r){e.resolve(r);return}this.#o=new MutationObserver(async()=>{let o=await this.#e();o&&(e.resolve(o),await this.stop())}),this.#o.observe(this.#r,{childList:!0,subtree:!0,attributes:!0})}async stop(){u(this.#t,"Polling never started."),this.#t.finished()||this.#t.reject(new Error("Polling stopped")),this.#o&&(this.#o.disconnect(),this.#o=void 0)}result(){return u(this.#t,"Polling never started."),this.#t.valueOrThrow()}},w=class{#e;#r;constructor(e){this.#e=e}async start(){let e=this.#r=c.create(),r=await this.#e();if(r){e.resolve(r);return}let o=async()=>{if(e.finished())return;let n=await this.#e();if(!n){window.requestAnimationFrame(o);return}e.resolve(n),await this.stop()};window.requestAnimationFrame(o)}async stop(){u(this.#r,"Polling never started."),this.#r.finished()||this.#r.reject(new Error("Polling stopped"))}result(){return u(this.#r,"Polling never started."),this.#r.valueOrThrow()}},S=class{#e;#r;#o;#t;constructor(e,r){this.#e=e,this.#r=r}async start(){let e=this.#t=c.create(),r=await this.#e();if(r){e.resolve(r);return}this.#o=setInterval(async()=>{let o=await this.#e();o&&(e.resolve(o),await this.stop())},this.#r)}async stop(){u(this.#t,"Polling never started."),this.#t.finished()||this.#t.reject(new Error("Polling stopped")),this.#o&&(clearInterval(this.#o),this.#o=void 0)}result(){return u(this.#t,"Polling never started."),this.#t.valueOrThrow()}};var _={};l(_,{PCombinator:()=>H,pQuerySelector:()=>fe,pQuerySelectorAll:()=>$});var a=class{static async*map(e,r){for await(let o of e)yield await r(o)}static async*flatMap(e,r){for await(let o of e)yield*r(o)}static async collect(e){let r=[];for await(let o of e)r.push(o);return r}static async first(e){for await(let r of e)return r}};var C={};l(C,{textQuerySelectorAll:()=>m});var re=new Set(["checkbox","image","radio"]),oe=t=>t instanceof HTMLSelectElement||t instanceof HTMLTextAreaElement||t instanceof HTMLInputElement&&!re.has(t.type),ne=new Set(["SCRIPT","STYLE"]),f=t=>!ne.has(t.nodeName)&&!document.head?.contains(t),I=new WeakMap,j=t=>{for(;t;)I.delete(t),t instanceof ShadowRoot?t=t.host:t=t.parentNode},W=new WeakSet,se=new MutationObserver(t=>{for(let e of t)j(e.target)}),d=t=>{let e=I.get(t);if(e||(e={full:"",immediate:[]},!f(t)))return e;let r="";if(oe(t))e.full=t.value,e.immediate.push(t.value),t.addEventListener("input",o=>{j(o.target)},{once:!0,capture:!0});else{for(let o=t.firstChild;o;o=o.nextSibling){if(o.nodeType===Node.TEXT_NODE){e.full+=o.nodeValue??"",r+=o.nodeValue??"";continue}r&&e.immediate.push(r),r="",o.nodeType===Node.ELEMENT_NODE&&(e.full+=d(o).full)}r&&e.immediate.push(r),t instanceof Element&&t.shadowRoot&&(e.full+=d(t.shadowRoot).full),W.has(t)||(se.observe(t,{childList:!0,characterData:!0,subtree:!0}),W.add(t))}return I.set(t,e),e};var m=function*(t,e){let r=!1;for(let o of t.childNodes)if(o instanceof Element&&f(o)){let n;o.shadowRoot?n=m(o.shadowRoot,e):n=m(o,e);for(let i of n)yield i,r=!0}r||t instanceof Element&&f(t)&&d(t).full.includes(e)&&(yield t)};var k={};l(k,{checkVisibility:()=>le,pierce:()=>T,pierceAll:()=>O});var ie=["hidden","collapse"],le=(t,e)=>{if(!t)return e===!1;if(e===void 0)return t;let r=t.nodeType===Node.TEXT_NODE?t.parentElement:t,o=window.getComputedStyle(r),n=o&&!ie.includes(o.visibility)&&!ae(r);return e===n?t:!1};function ae(t){let e=t.getBoundingClientRect();return e.width===0||e.height===0}var ce=t=>"shadowRoot"in t&&t.shadowRoot instanceof ShadowRoot;function*T(t){ce(t)?yield t.shadowRoot:yield t}function*O(t){t=T(t).next().value,yield t;let e=[document.createTreeWalker(t,NodeFilter.SHOW_ELEMENT)];for(let r of e){let o;for(;o=r.nextNode();)o.shadowRoot&&(yield o.shadowRoot,e.push(document.createTreeWalker(o.shadowRoot,NodeFilter.SHOW_ELEMENT)))}}var Q={};l(Q,{xpathQuerySelectorAll:()=>q});var q=function*(t,e,r=-1){let n=(t.ownerDocument||document).evaluate(e,t,null,XPathResult.ORDERED_NODE_ITERATOR_TYPE),i=[],s;for(;(s=n.iterateNext())&&(i.push(s),!(r&&i.length===r)););for(let h=0;h<i.length;h++)s=i[h],yield s,delete i[h]};var ue=/[-\\w\\P{ASCII}*]/u,H=(r=>(r.Descendent=">>>",r.Child=">>>>",r))(H||{}),V=t=>"querySelectorAll"in t,M=class{#e;#r=[];#o=void 0;elements;constructor(e,r){this.elements=[e],this.#e=r,this.#t()}async run(){if(typeof this.#o=="string")switch(this.#o.trimStart()){case":scope":this.#t();break}for(;this.#o!==void 0;this.#t()){let e=this.#o;typeof e=="string"?e[0]&&ue.test(e[0])?this.elements=a.flatMap(this.elements,async function*(r){V(r)&&(yield*r.querySelectorAll(e))}):this.elements=a.flatMap(this.elements,async function*(r){if(!r.parentElement){if(!V(r))return;yield*r.querySelectorAll(e);return}let o=0;for(let n of r.parentElement.children)if(++o,n===r)break;yield*r.parentElement.querySelectorAll(`:scope>:nth-child(${o})${e}`)}):this.elements=a.flatMap(this.elements,async function*(r){switch(e.name){case"text":yield*m(r,e.value);break;case"xpath":yield*q(r,e.value);break;case"aria":yield*b(r,e.value);break;default:let o=P.get(e.name);if(!o)throw new Error(`Unknown selector type: ${e.name}`);yield*o.querySelectorAll(r,e.value)}})}}#t(){if(this.#r.length!==0){this.#o=this.#r.shift();return}if(this.#e.length===0){this.#o=void 0;return}let e=this.#e.shift();switch(e){case">>>>":{this.elements=a.flatMap(this.elements,T),this.#t();break}case">>>":{this.elements=a.flatMap(this.elements,O),this.#t();break}default:this.#r=e,this.#t();break}}},D=class{#e=new WeakMap;calculate(e,r=[]){if(e===null)return r;e instanceof ShadowRoot&&(e=e.host);let o=this.#e.get(e);if(o)return[...o,...r];let n=0;for(let s=e.previousSibling;s;s=s.previousSibling)++n;let i=this.calculate(e.parentNode,[n]);return this.#e.set(e,i),[...i,...r]}},U=(t,e)=>{if(t.length+e.length===0)return 0;let[r=-1,...o]=t,[n=-1,...i]=e;return r===n?U(o,i):r<n?-1:1},de=async function*(t){let e=new Set;for await(let o of t)e.add(o);let r=new D;yield*[...e.values()].map(o=>[o,r.calculate(o)]).sort(([,o],[,n])=>U(o,n)).map(([o])=>o)},$=function(t,e){let r=JSON.parse(e);if(r.some(o=>{let n=0;return o.some(i=>(typeof i=="string"?++n:n=0,n>1))}))throw new Error("Multiple deep combinators found in sequence.");return de(a.flatMap(r,o=>{let n=new M(t,o);return n.run(),n.elements}))},fe=async function(t,e){for await(let r of $(t,e))return r;return null};var me=Object.freeze({...x,...A,...R,..._,...C,...k,...Q,...E,Deferred:c,createFunction:F,createTextContent:d,IntervalPoller:S,isSuitableNodeForTextMatching:f,MutationPoller:y,RAFPoller:w}),he=me;\n';
  /**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class ScriptInjector {
    constructor() {
      __privateAdd(this, _ScriptInjector_instances);
      __privateAdd(this, _updated, false);
      __privateAdd(this, _amendments, /* @__PURE__ */ new Set());
    }
    // Appends a statement of the form `(PuppeteerUtil) => {...}`.
    append(statement) {
      __privateMethod(this, _ScriptInjector_instances, update_fn).call(this, () => {
        __privateGet(this, _amendments).add(statement);
      });
    }
    pop(statement) {
      __privateMethod(this, _ScriptInjector_instances, update_fn).call(this, () => {
        __privateGet(this, _amendments).delete(statement);
      });
    }
    inject(inject, force = false) {
      if (__privateGet(this, _updated) || force) {
        inject(__privateMethod(this, _ScriptInjector_instances, get_fn).call(this));
      }
      __privateSet(this, _updated, false);
    }
  }
  _updated = new WeakMap();
  _amendments = new WeakMap();
  _ScriptInjector_instances = new WeakSet();
  update_fn = function(callback) {
    callback();
    __privateSet(this, _updated, true);
  };
  get_fn = function() {
    return `(() => {
      const module = {};
      ${source}
      ${[...__privateGet(this, _amendments)].map((statement) => {
      return `(${statement})(module.exports.default);`;
    }).join("")}
      return module.exports.default;
    })()`;
  };
  const scriptInjector = new ScriptInjector();
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class CustomQueryHandlerRegistry {
    constructor() {
      __privateAdd(this, _handlers2, /* @__PURE__ */ new Map());
    }
    get(name) {
      const handler = __privateGet(this, _handlers2).get(name);
      return handler ? handler[1] : void 0;
    }
    /**
     * Registers a {@link CustomQueryHandler | custom query handler}.
     *
     * @remarks
     * After registration, the handler can be used everywhere where a selector is
     * expected by prepending the selection string with `<name>/`. The name is
     * only allowed to consist of lower- and upper case latin letters.
     *
     * @example
     *
     * ```ts
     * Puppeteer.customQueryHandlers.register('lit', { … });
     * const aHandle = await page.$('lit/…');
     * ```
     *
     * @param name - Name to register under.
     * @param queryHandler - {@link CustomQueryHandler | Custom query handler} to
     * register.
     */
    register(name, handler) {
      var _a3;
      assert$1(!__privateGet(this, _handlers2).has(name), `Cannot register over existing handler: ${name}`);
      assert$1(/^[a-zA-Z]+$/.test(name), `Custom query handler names may only contain [a-zA-Z]`);
      assert$1(handler.queryAll || handler.queryOne, `At least one query method must be implemented.`);
      const Handler = (_a3 = class extends QueryHandler {
      }, __publicField(_a3, "querySelectorAll", interpolateFunction((node, selector, PuppeteerUtil) => {
        return PuppeteerUtil.customQuerySelectors.get(PLACEHOLDER("name")).querySelectorAll(node, selector);
      }, { name: JSON.stringify(name) })), __publicField(_a3, "querySelector", interpolateFunction((node, selector, PuppeteerUtil) => {
        return PuppeteerUtil.customQuerySelectors.get(PLACEHOLDER("name")).querySelector(node, selector);
      }, { name: JSON.stringify(name) })), _a3);
      const registerScript = interpolateFunction((PuppeteerUtil) => {
        PuppeteerUtil.customQuerySelectors.register(PLACEHOLDER("name"), {
          queryAll: PLACEHOLDER("queryAll"),
          queryOne: PLACEHOLDER("queryOne")
        });
      }, {
        name: JSON.stringify(name),
        queryAll: handler.queryAll ? stringifyFunction(handler.queryAll) : String(void 0),
        queryOne: handler.queryOne ? stringifyFunction(handler.queryOne) : String(void 0)
      }).toString();
      __privateGet(this, _handlers2).set(name, [registerScript, Handler]);
      scriptInjector.append(registerScript);
    }
    /**
     * Unregisters the {@link CustomQueryHandler | custom query handler} for the
     * given name.
     *
     * @throws `Error` if there is no handler under the given name.
     */
    unregister(name) {
      const handler = __privateGet(this, _handlers2).get(name);
      if (!handler) {
        throw new Error(`Cannot unregister unknown handler: ${name}`);
      }
      scriptInjector.pop(handler[0]);
      __privateGet(this, _handlers2).delete(name);
    }
    /**
     * Gets the names of all {@link CustomQueryHandler | custom query handlers}.
     */
    names() {
      return [...__privateGet(this, _handlers2).keys()];
    }
    /**
     * Unregisters all custom query handlers.
     */
    clear() {
      for (const [registerScript] of __privateGet(this, _handlers2)) {
        scriptInjector.pop(registerScript);
      }
      __privateGet(this, _handlers2).clear();
    }
  }
  _handlers2 = new WeakMap();
  const customQueryHandlers = new CustomQueryHandlerRegistry();
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class PierceQueryHandler extends QueryHandler {
  }
  __publicField(PierceQueryHandler, "querySelector", (element, selector, { pierceQuerySelector }) => {
    return pierceQuerySelector(element, selector);
  });
  __publicField(PierceQueryHandler, "querySelectorAll", (element, selector, { pierceQuerySelectorAll }) => {
    return pierceQuerySelectorAll(element, selector);
  });
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class PQueryHandler extends QueryHandler {
  }
  __publicField(PQueryHandler, "querySelectorAll", (element, selector, { pQuerySelectorAll }) => {
    return pQuerySelectorAll(element, selector);
  });
  __publicField(PQueryHandler, "querySelector", (element, selector, { pQuerySelector }) => {
    return pQuerySelector(element, selector);
  });
  var TOKENS = {
    attribute: /\[\s*(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?(?<name>[-\w\P{ASCII}]+)\s*(?:(?<operator>\W?=)\s*(?<value>.+?)\s*(\s(?<caseSensitive>[iIsS]))?\s*)?\]/gu,
    id: /#(?<name>[-\w\P{ASCII}]+)/gu,
    class: /\.(?<name>[-\w\P{ASCII}]+)/gu,
    comma: /\s*,\s*/g,
    combinator: /\s*[\s>+~]\s*/g,
    "pseudo-element": /::(?<name>[-\w\P{ASCII}]+)(?:\((?<argument>¶*)\))?/gu,
    "pseudo-class": /:(?<name>[-\w\P{ASCII}]+)(?:\((?<argument>¶*)\))?/gu,
    universal: /(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?\*/gu,
    type: /(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?(?<name>[-\w\P{ASCII}]+)/gu
    // this must be last
  };
  var TRIM_TOKENS = /* @__PURE__ */ new Set(["combinator", "comma"]);
  var getArgumentPatternByType = (type) => {
    switch (type) {
      case "pseudo-element":
      case "pseudo-class":
        return new RegExp(TOKENS[type].source.replace("(?<argument>¶*)", "(?<argument>.*)"), "gu");
      default:
        return TOKENS[type];
    }
  };
  function gobbleParens(text, offset) {
    let nesting = 0;
    let result = "";
    for (; offset < text.length; offset++) {
      const char = text[offset];
      switch (char) {
        case "(":
          ++nesting;
          break;
        case ")":
          --nesting;
          break;
      }
      result += char;
      if (nesting === 0) {
        return result;
      }
    }
    return result;
  }
  function tokenizeBy(text, grammar = TOKENS) {
    if (!text) {
      return [];
    }
    const tokens = [text];
    for (const [type, pattern] of Object.entries(grammar)) {
      for (let i2 = 0; i2 < tokens.length; i2++) {
        const token = tokens[i2];
        if (typeof token !== "string") {
          continue;
        }
        pattern.lastIndex = 0;
        const match = pattern.exec(token);
        if (!match) {
          continue;
        }
        const from2 = match.index - 1;
        const args = [];
        const content = match[0];
        const before = token.slice(0, from2 + 1);
        if (before) {
          args.push(before);
        }
        args.push({
          ...match.groups,
          type,
          content
        });
        const after = token.slice(from2 + content.length + 1);
        if (after) {
          args.push(after);
        }
        tokens.splice(i2, 1, ...args);
      }
    }
    let offset = 0;
    for (const token of tokens) {
      switch (typeof token) {
        case "string":
          throw new Error(`Unexpected sequence ${token} found at index ${offset}`);
        case "object":
          offset += token.content.length;
          token.pos = [offset - token.content.length, offset];
          if (TRIM_TOKENS.has(token.type)) {
            token.content = token.content.trim() || " ";
          }
          break;
      }
    }
    return tokens;
  }
  var STRING_PATTERN = /(['"])([^\\\n]+?)\1/g;
  var ESCAPE_PATTERN = /\\./g;
  function tokenize$1(selector, grammar = TOKENS) {
    selector = selector.trim();
    if (selector === "") {
      return [];
    }
    const replacements = [];
    selector = selector.replace(ESCAPE_PATTERN, (value, offset) => {
      replacements.push({ value, offset });
      return "".repeat(value.length);
    });
    selector = selector.replace(STRING_PATTERN, (value, quote, content, offset) => {
      replacements.push({ value, offset });
      return `${quote}${"".repeat(content.length)}${quote}`;
    });
    {
      let pos = 0;
      let offset;
      while ((offset = selector.indexOf("(", pos)) > -1) {
        const value = gobbleParens(selector, offset);
        replacements.push({ value, offset });
        selector = `${selector.substring(0, offset)}(${"¶".repeat(value.length - 2)})${selector.substring(offset + value.length)}`;
        pos = offset + value.length;
      }
    }
    const tokens = tokenizeBy(selector, grammar);
    const changedTokens = /* @__PURE__ */ new Set();
    for (const replacement of replacements.reverse()) {
      for (const token of tokens) {
        const { offset, value } = replacement;
        if (!(token.pos[0] <= offset && offset + value.length <= token.pos[1])) {
          continue;
        }
        const { content } = token;
        const tokenOffset = offset - token.pos[0];
        token.content = content.slice(0, tokenOffset) + value + content.slice(tokenOffset + value.length);
        if (token.content !== content) {
          changedTokens.add(token);
        }
      }
    }
    for (const token of changedTokens) {
      const pattern = getArgumentPatternByType(token.type);
      if (!pattern) {
        throw new Error(`Unknown token type: ${token.type}`);
      }
      pattern.lastIndex = 0;
      const match = pattern.exec(token.content);
      if (!match) {
        throw new Error(`Unable to parse content for ${token.type}: ${token.content}`);
      }
      Object.assign(token, match.groups);
    }
    return tokens;
  }
  function stringify$3(listOrNode) {
    if (Array.isArray(listOrNode)) {
      return listOrNode.map((token) => token.content).join("");
    }
    switch (listOrNode.type) {
      case "list":
        return listOrNode.list.map(stringify$3).join(",");
      case "relative":
        return listOrNode.combinator + stringify$3(listOrNode.right);
      case "complex":
        return stringify$3(listOrNode.left) + listOrNode.combinator + stringify$3(listOrNode.right);
      case "compound":
        return listOrNode.list.map(stringify$3).join("");
      default:
        return listOrNode.content;
    }
  }
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  TOKENS["nesting"] = /&/g;
  TOKENS["combinator"] = /\s*(>>>>?|[\s>+~])\s*/g;
  const ESCAPE_REGEXP = /\\[\s\S]/g;
  const unquote = (text) => {
    if (text.length <= 1) {
      return text;
    }
    if ((text[0] === '"' || text[0] === "'") && text.endsWith(text[0])) {
      text = text.slice(1, -1);
    }
    return text.replace(ESCAPE_REGEXP, (match) => {
      return match[1];
    });
  };
  function parsePSelectors(selector) {
    let isPureCSS = true;
    let hasAria = false;
    let hasPseudoClasses = false;
    const tokens = tokenize$1(selector);
    if (tokens.length === 0) {
      return [[], isPureCSS, hasPseudoClasses, false];
    }
    let compoundSelector = [];
    let complexSelector = [compoundSelector];
    const selectors = [complexSelector];
    const storage2 = [];
    for (const token of tokens) {
      switch (token.type) {
        case "combinator":
          switch (token.content) {
            case ">>>":
              isPureCSS = false;
              if (storage2.length) {
                compoundSelector.push(stringify$3(storage2));
                storage2.splice(0);
              }
              compoundSelector = [];
              complexSelector.push(
                ">>>"
                /* PCombinator.Descendent */
              );
              complexSelector.push(compoundSelector);
              continue;
            case ">>>>":
              isPureCSS = false;
              if (storage2.length) {
                compoundSelector.push(stringify$3(storage2));
                storage2.splice(0);
              }
              compoundSelector = [];
              complexSelector.push(
                ">>>>"
                /* PCombinator.Child */
              );
              complexSelector.push(compoundSelector);
              continue;
          }
          break;
        case "pseudo-element":
          if (!token.name.startsWith("-p-")) {
            break;
          }
          isPureCSS = false;
          if (storage2.length) {
            compoundSelector.push(stringify$3(storage2));
            storage2.splice(0);
          }
          const name = token.name.slice(3);
          if (name === "aria") {
            hasAria = true;
          }
          compoundSelector.push({
            name,
            value: unquote(token.argument ?? "")
          });
          continue;
        case "pseudo-class":
          hasPseudoClasses = true;
          break;
        case "comma":
          if (storage2.length) {
            compoundSelector.push(stringify$3(storage2));
            storage2.splice(0);
          }
          compoundSelector = [];
          complexSelector = [compoundSelector];
          selectors.push(complexSelector);
          continue;
      }
      storage2.push(token);
    }
    if (storage2.length) {
      compoundSelector.push(stringify$3(storage2));
    }
    return [selectors, isPureCSS, hasPseudoClasses, hasAria];
  }
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class TextQueryHandler extends QueryHandler {
  }
  __publicField(TextQueryHandler, "querySelectorAll", (element, selector, { textQuerySelectorAll }) => {
    return textQuerySelectorAll(element, selector);
  });
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class XPathQueryHandler extends QueryHandler {
  }
  __publicField(XPathQueryHandler, "querySelectorAll", (element, selector, { xpathQuerySelectorAll }) => {
    return xpathQuerySelectorAll(element, selector);
  });
  __publicField(XPathQueryHandler, "querySelector", (element, selector, { xpathQuerySelectorAll }) => {
    for (const result of xpathQuerySelectorAll(element, selector, 1)) {
      return result;
    }
    return null;
  });
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  const BUILTIN_QUERY_HANDLERS = {
    aria: ARIAQueryHandler,
    pierce: PierceQueryHandler,
    xpath: XPathQueryHandler,
    text: TextQueryHandler
  };
  const QUERY_SEPARATORS = ["=", "/"];
  function getQueryHandlerAndSelector(selector) {
    for (const handlerMap of [
      customQueryHandlers.names().map((name) => {
        return [name, customQueryHandlers.get(name)];
      }),
      Object.entries(BUILTIN_QUERY_HANDLERS)
    ]) {
      for (const [name, QueryHandler2] of handlerMap) {
        for (const separator of QUERY_SEPARATORS) {
          const prefix = `${name}${separator}`;
          if (selector.startsWith(prefix)) {
            selector = selector.slice(prefix.length);
            return {
              updatedSelector: selector,
              polling: name === "aria" ? "raf" : "mutation",
              QueryHandler: QueryHandler2
            };
          }
        }
      }
    }
    try {
      const [pSelector, isPureCSS, hasPseudoClasses, hasAria] = parsePSelectors(selector);
      if (isPureCSS) {
        return {
          updatedSelector: selector,
          polling: hasPseudoClasses ? "raf" : "mutation",
          QueryHandler: CSSQueryHandler
        };
      }
      return {
        updatedSelector: JSON.stringify(pSelector),
        polling: hasAria ? "raf" : "mutation",
        QueryHandler: PQueryHandler
      };
    } catch {
      return {
        updatedSelector: selector,
        polling: "mutation",
        QueryHandler: CSSQueryHandler
      };
    }
  }
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var __addDisposableResource$g = function(env, value, async2) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async2) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async2) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({ value, dispose, async: async2 });
    } else if (async2) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources$g = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  const instances = /* @__PURE__ */ new WeakSet();
  function moveable(Class, _) {
    let hasDispose = false;
    if (Class.prototype[disposeSymbol]) {
      const dispose = Class.prototype[disposeSymbol];
      Class.prototype[disposeSymbol] = function() {
        if (instances.has(this)) {
          instances.delete(this);
          return;
        }
        return dispose.call(this);
      };
      hasDispose = true;
    }
    if (Class.prototype[asyncDisposeSymbol]) {
      const asyncDispose = Class.prototype[asyncDisposeSymbol];
      Class.prototype[asyncDisposeSymbol] = function() {
        if (instances.has(this)) {
          instances.delete(this);
          return;
        }
        return asyncDispose.call(this);
      };
      hasDispose = true;
    }
    if (hasDispose) {
      Class.prototype.move = function() {
        instances.add(this);
        return this;
      };
    }
    return Class;
  }
  function throwIfDisposed(message = (value) => {
    return `Attempted to use disposed ${value.constructor.name}.`;
  }) {
    return (target, _) => {
      return function(...args) {
        if (this.disposed) {
          throw new Error(message(this));
        }
        return target.call(this, ...args);
      };
    };
  }
  function inertIfDisposed(target, _) {
    return function(...args) {
      if (this.disposed) {
        return;
      }
      return target.call(this, ...args);
    };
  }
  function invokeAtMostOnceForArguments(target, _) {
    const cache2 = /* @__PURE__ */ new WeakMap();
    let cacheDepth = -1;
    return function(...args) {
      if (cacheDepth === -1) {
        cacheDepth = args.length;
      }
      if (cacheDepth !== args.length) {
        throw new Error("Memoized method was called with the wrong number of arguments");
      }
      let freshArguments = false;
      let cacheIterator = cache2;
      for (const arg of args) {
        if (cacheIterator.has(arg)) {
          cacheIterator = cacheIterator.get(arg);
        } else {
          freshArguments = true;
          cacheIterator.set(arg, /* @__PURE__ */ new WeakMap());
          cacheIterator = cacheIterator.get(arg);
        }
      }
      if (!freshArguments) {
        return;
      }
      return target.call(this, ...args);
    };
  }
  function guarded(getKey = function() {
    return this;
  }) {
    return (target, _) => {
      const mutexes = /* @__PURE__ */ new WeakMap();
      return async function(...args) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
          const key = getKey.call(this);
          let mutex = mutexes.get(key);
          if (!mutex) {
            mutex = new Mutex$1();
            mutexes.set(key, mutex);
          }
          const _2 = __addDisposableResource$g(env_1, await mutex.acquire(), true);
          return await target.call(this, ...args);
        } catch (e_1) {
          env_1.error = e_1;
          env_1.hasError = true;
        } finally {
          const result_1 = __disposeResources$g(env_1);
          if (result_1)
            await result_1;
        }
      };
    };
  }
  const bubbleHandlers = /* @__PURE__ */ new WeakMap();
  const bubbleInitializer = function(events2) {
    const handlers = bubbleHandlers.get(this) ?? /* @__PURE__ */ new Map();
    if (handlers.has(events2)) {
      return;
    }
    const handler = events2 !== void 0 ? (type, event) => {
      if (events2.includes(type)) {
        this.emit(type, event);
      }
    } : (type, event) => {
      this.emit(type, event);
    };
    handlers.set(events2, handler);
    bubbleHandlers.set(this, handlers);
  };
  function bubble(events2) {
    return ({ set, get: get2 }, context) => {
      context.addInitializer(function() {
        return bubbleInitializer.apply(this, [events2]);
      });
      return {
        set(emitter) {
          const handler = bubbleHandlers.get(this).get(events2);
          const oldEmitter = get2.call(this);
          if (oldEmitter !== void 0) {
            oldEmitter.off("*", handler);
          }
          if (emitter === void 0) {
            return;
          }
          emitter.on("*", handler);
          set.call(this, emitter);
        },
        init(emitter) {
          if (emitter === void 0) {
            return emitter;
          }
          bubbleInitializer.apply(this, [events2]);
          const handler = bubbleHandlers.get(this).get(events2);
          emitter.on("*", handler);
          return emitter;
        }
      };
    };
  }
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var __runInitializers$k = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i2 = 0; i2 < initializers.length; i2++) {
      value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate$k = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind2 = contextIn.kind, key = kind2 === "getter" ? "get" : kind2 === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function(f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i2])(kind2 === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind2 === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_ = accept(result.get)) descriptor.get = _;
        if (_ = accept(result.set)) descriptor.set = _;
        if (_ = accept(result.init)) initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind2 === "field") initializers.unshift(_);
        else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  var __addDisposableResource$f = function(env, value, async2) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async2) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async2) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({ value, dispose, async: async2 });
    } else if (async2) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources$f = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  let JSHandle = (() => {
    var _a3;
    let _classDecorators = [moveable];
    let _classDescriptor;
    let _classExtraInitializers = [];
    let _classThis;
    let _instanceExtraInitializers = [];
    let _getProperty_decorators;
    let _getProperties_decorators;
    _a3 = class {
      /**
       * @internal
       */
      constructor() {
        __runInitializers$k(this, _instanceExtraInitializers);
      }
      /**
       * Evaluates the given function with the current handle as its first argument.
       */
      async evaluate(pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
        return await this.realm.evaluate(pageFunction, this, ...args);
      }
      /**
       * Evaluates the given function with the current handle as its first argument.
       *
       */
      async evaluateHandle(pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
        return await this.realm.evaluateHandle(pageFunction, this, ...args);
      }
      /**
       * @internal
       */
      async getProperty(propertyName) {
        return await this.evaluateHandle((object, propertyName2) => {
          return object[propertyName2];
        }, propertyName);
      }
      /**
       * Gets a map of handles representing the properties of the current handle.
       *
       * @example
       *
       * ```ts
       * const listHandle = await page.evaluateHandle(() => document.body.children);
       * const properties = await listHandle.getProperties();
       * const children = [];
       * for (const property of properties.values()) {
       *   const element = property.asElement();
       *   if (element) {
       *     children.push(element);
       *   }
       * }
       * children; // holds elementHandles to all children of document.body
       * ```
       */
      async getProperties() {
        const propertyNames = await this.evaluate((object) => {
          var _a4;
          const enumerableProperties = [];
          const descriptors = Object.getOwnPropertyDescriptors(object);
          for (const propertyName in descriptors) {
            if ((_a4 = descriptors[propertyName]) == null ? void 0 : _a4.enumerable) {
              enumerableProperties.push(propertyName);
            }
          }
          return enumerableProperties;
        });
        const map2 = /* @__PURE__ */ new Map();
        const results = await Promise.all(propertyNames.map((key) => {
          return this.getProperty(key);
        }));
        for (const [key, value] of Object.entries(propertyNames)) {
          const env_1 = { stack: [], error: void 0, hasError: false };
          try {
            const handle = __addDisposableResource$f(env_1, results[key], false);
            if (handle) {
              map2.set(value, handle.move());
            }
          } catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
          } finally {
            __disposeResources$f(env_1);
          }
        }
        return map2;
      }
      /** @internal */
      [(_getProperty_decorators = [throwIfDisposed()], _getProperties_decorators = [throwIfDisposed()], disposeSymbol)]() {
        return void this.dispose().catch(debugError);
      }
      /** @internal */
      [asyncDisposeSymbol]() {
        return this.dispose();
      }
    }, _classThis = _a3, (() => {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      __esDecorate$k(_a3, null, _getProperty_decorators, { kind: "method", name: "getProperty", static: false, private: false, access: { has: (obj) => "getProperty" in obj, get: (obj) => obj.getProperty }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$k(_a3, null, _getProperties_decorators, { kind: "method", name: "getProperties", static: false, private: false, access: { has: (obj) => "getProperties" in obj, get: (obj) => obj.getProperties }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$k(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
      __runInitializers$k(_classThis, _classExtraInitializers);
    })(), _a3;
    return _classThis;
  })();
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var __runInitializers$j = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i2 = 0; i2 < initializers.length; i2++) {
      value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate$j = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind2 = contextIn.kind, key = kind2 === "getter" ? "get" : kind2 === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function(f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i2])(kind2 === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind2 === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_ = accept(result.get)) descriptor.get = _;
        if (_ = accept(result.set)) descriptor.set = _;
        if (_ = accept(result.init)) initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind2 === "field") initializers.unshift(_);
        else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  var __addDisposableResource$e = function(env, value, async2) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async2) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async2) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({ value, dispose, async: async2 });
    } else if (async2) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources$e = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  var __setFunctionName$3 = function(f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
  };
  function bindIsolatedHandle(target, _) {
    return async function(...args) {
      if (this.realm === this.frame.isolatedRealm()) {
        return await target.call(this, ...args);
      }
      let adoptedThis;
      if (this["isolatedHandle"]) {
        adoptedThis = this["isolatedHandle"];
      } else {
        this["isolatedHandle"] = adoptedThis = await this.frame.isolatedRealm().adoptHandle(this);
      }
      const result = await target.call(adoptedThis, ...args);
      if (result === adoptedThis) {
        return this;
      }
      if (result instanceof JSHandle) {
        return await this.realm.transferHandle(result);
      }
      if (Array.isArray(result)) {
        await Promise.all(result.map(async (item, index, result2) => {
          if (item instanceof JSHandle) {
            result2[index] = await this.realm.transferHandle(item);
          }
        }));
      }
      if (result instanceof Map) {
        await Promise.all([...result.entries()].map(async ([key, value]) => {
          if (value instanceof JSHandle) {
            result.set(key, await this.realm.transferHandle(value));
          }
        }));
      }
      return result;
    };
  }
  let ElementHandle = (() => {
    var _ElementHandle_instances, $$_get, $$impl_fn, checkVisibility_fn, clickableBox_fn, intersectBoundingBoxesWithFrame_fn, getTopLeftCornerOfFrame_fn, nonEmptyVisibleBoundingBox_fn, asSVGElementHandle_fn, getOwnerSVGElement_fn, _a3;
    let _classSuper = JSHandle;
    let _instanceExtraInitializers = [];
    let _getProperty_decorators;
    let _getProperties_decorators;
    let _jsonValue_decorators;
    let _$_decorators;
    let _$$_decorators;
    let _private_$$_decorators;
    let _private_$$_descriptor;
    let _waitForSelector_decorators;
    let _isVisible_decorators;
    let _isHidden_decorators;
    let _toElement_decorators;
    let _clickablePoint_decorators;
    let _hover_decorators;
    let _click_decorators;
    let _drag_decorators;
    let _dragEnter_decorators;
    let _dragOver_decorators;
    let _drop_decorators;
    let _dragAndDrop_decorators;
    let _select_decorators;
    let _tap_decorators;
    let _touchStart_decorators;
    let _touchMove_decorators;
    let _touchEnd_decorators;
    let _focus_decorators;
    let _type_decorators;
    let _press_decorators;
    let _boundingBox_decorators;
    let _boxModel_decorators;
    let _screenshot_decorators;
    let _isIntersectingViewport_decorators;
    let _scrollIntoView_decorators;
    return _a3 = class extends _classSuper {
      /**
       * @internal
       */
      constructor(handle) {
        super();
        __privateAdd(this, _ElementHandle_instances);
        /**
         * @internal
         * Cached isolatedHandle to prevent
         * trying to adopt it multiple times
         */
        __publicField(this, "isolatedHandle", __runInitializers$j(this, _instanceExtraInitializers));
        /**
         * @internal
         */
        __publicField(this, "handle");
        this.handle = handle;
        this[_isElementHandle] = true;
      }
      /**
       * @internal
       */
      get id() {
        return this.handle.id;
      }
      /**
       * @internal
       */
      get disposed() {
        return this.handle.disposed;
      }
      /**
       * @internal
       */
      async getProperty(propertyName) {
        return await this.handle.getProperty(propertyName);
      }
      /**
       * @internal
       */
      async getProperties() {
        return await this.handle.getProperties();
      }
      /**
       * @internal
       */
      async evaluate(pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
        return await this.handle.evaluate(pageFunction, ...args);
      }
      /**
       * @internal
       */
      async evaluateHandle(pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
        return await this.handle.evaluateHandle(pageFunction, ...args);
      }
      /**
       * @internal
       */
      async jsonValue() {
        return await this.handle.jsonValue();
      }
      /**
       * @internal
       */
      toString() {
        return this.handle.toString();
      }
      /**
       * @internal
       */
      remoteObject() {
        return this.handle.remoteObject();
      }
      /**
       * @internal
       */
      async dispose() {
        var _a4;
        await Promise.all([this.handle.dispose(), (_a4 = this.isolatedHandle) == null ? void 0 : _a4.dispose()]);
      }
      /**
       * @internal
       */
      asElement() {
        return this;
      }
      /**
       * Queries the current element for an element matching the given selector.
       *
       * @param selector -
       * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
       * to query the page for.
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
       * can be passed as-is and a
       * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
       * allows quering by
       * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
       * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
       * and
       * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
       * and
       * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
       * Alternatively, you can specify the selector type using a
       * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
       * @returns A {@link ElementHandle | element handle} to the first element
       * matching the given selector. Otherwise, `null`.
       */
      async $(selector) {
        const { updatedSelector, QueryHandler: QueryHandler2 } = getQueryHandlerAndSelector(selector);
        return await QueryHandler2.queryOne(this, updatedSelector);
      }
      /**
       * Queries the current element for all elements matching the given selector.
       *
       * @param selector -
       * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
       * to query the page for.
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
       * can be passed as-is and a
       * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
       * allows quering by
       * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
       * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
       * and
       * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
       * and
       * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
       * Alternatively, you can specify the selector type using a
       * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
       * @returns An array of {@link ElementHandle | element handles} that point to
       * elements matching the given selector.
       */
      async $$(selector, options) {
        if ((options == null ? void 0 : options.isolate) === false) {
          return await __privateMethod(this, _ElementHandle_instances, $$impl_fn).call(this, selector);
        }
        return await __privateGet(this, _ElementHandle_instances, $$_get).call(this, selector);
      }
      /**
       * Runs the given function on the first element matching the given selector in
       * the current element.
       *
       * If the given function returns a promise, then this method will wait till
       * the promise resolves.
       *
       * @example
       *
       * ```ts
       * const tweetHandle = await page.$('.tweet');
       * expect(await tweetHandle.$eval('.like', node => node.innerText)).toBe(
       *   '100',
       * );
       * expect(await tweetHandle.$eval('.retweets', node => node.innerText)).toBe(
       *   '10',
       * );
       * ```
       *
       * @param selector -
       * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
       * to query the page for.
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
       * can be passed as-is and a
       * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
       * allows quering by
       * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
       * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
       * and
       * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
       * and
       * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
       * Alternatively, you can specify the selector type using a
       * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
       * @param pageFunction - The function to be evaluated in this element's page's
       * context. The first element matching the selector will be passed in as the
       * first argument.
       * @param args - Additional arguments to pass to `pageFunction`.
       * @returns A promise to the result of the function.
       */
      async $eval(selector, pageFunction, ...args) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
          pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
          const elementHandle = __addDisposableResource$e(env_1, await this.$(selector), false);
          if (!elementHandle) {
            throw new Error(`Error: failed to find element matching selector "${selector}"`);
          }
          return await elementHandle.evaluate(pageFunction, ...args);
        } catch (e_1) {
          env_1.error = e_1;
          env_1.hasError = true;
        } finally {
          __disposeResources$e(env_1);
        }
      }
      /**
       * Runs the given function on an array of elements matching the given selector
       * in the current element.
       *
       * If the given function returns a promise, then this method will wait till
       * the promise resolves.
       *
       * @example
       * HTML:
       *
       * ```html
       * <div class="feed">
       *   <div class="tweet">Hello!</div>
       *   <div class="tweet">Hi!</div>
       * </div>
       * ```
       *
       * JavaScript:
       *
       * ```ts
       * const feedHandle = await page.$('.feed');
       * expect(
       *   await feedHandle.$$eval('.tweet', nodes => nodes.map(n => n.innerText)),
       * ).toEqual(['Hello!', 'Hi!']);
       * ```
       *
       * @param selector -
       * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
       * to query the page for.
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
       * can be passed as-is and a
       * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
       * allows quering by
       * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
       * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
       * and
       * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
       * and
       * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
       * Alternatively, you can specify the selector type using a
       * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
       * @param pageFunction - The function to be evaluated in the element's page's
       * context. An array of elements matching the given selector will be passed to
       * the function as its first argument.
       * @param args - Additional arguments to pass to `pageFunction`.
       * @returns A promise to the result of the function.
       */
      async $$eval(selector, pageFunction, ...args) {
        const env_2 = { stack: [], error: void 0, hasError: false };
        try {
          pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
          const results = await this.$$(selector);
          const elements = __addDisposableResource$e(env_2, await this.evaluateHandle((_, ...elements2) => {
            return elements2;
          }, ...results), false);
          const [result] = await Promise.all([
            elements.evaluate(pageFunction, ...args),
            ...results.map((results2) => {
              return results2.dispose();
            })
          ]);
          return result;
        } catch (e_2) {
          env_2.error = e_2;
          env_2.hasError = true;
        } finally {
          __disposeResources$e(env_2);
        }
      }
      /**
       * Wait for an element matching the given selector to appear in the current
       * element.
       *
       * Unlike {@link Frame.waitForSelector}, this method does not work across
       * navigations or if the element is detached from DOM.
       *
       * @example
       *
       * ```ts
       * import puppeteer from 'puppeteer';
       *
       * (async () => {
       *   const browser = await puppeteer.launch();
       *   const page = await browser.newPage();
       *   let currentURL;
       *   page
       *     .mainFrame()
       *     .waitForSelector('img')
       *     .then(() => console.log('First URL with image: ' + currentURL));
       *
       *   for (currentURL of [
       *     'https://example.com',
       *     'https://google.com',
       *     'https://bbc.com',
       *   ]) {
       *     await page.goto(currentURL);
       *   }
       *   await browser.close();
       * })();
       * ```
       *
       * @param selector - The selector to query and wait for.
       * @param options - Options for customizing waiting behavior.
       * @returns An element matching the given selector.
       * @throws Throws if an element matching the given selector doesn't appear.
       */
      async waitForSelector(selector, options = {}) {
        const { updatedSelector, QueryHandler: QueryHandler2, polling } = getQueryHandlerAndSelector(selector);
        return await QueryHandler2.waitFor(this, updatedSelector, {
          polling,
          ...options
        });
      }
      /**
       * An element is considered to be visible if all of the following is
       * true:
       *
       * - the element has
       *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle | computed styles}.
       *
       * - the element has a non-empty
       *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect | bounding client rect}.
       *
       * - the element's {@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility | visibility}
       *   is not `hidden` or `collapse`.
       */
      async isVisible() {
        return await __privateMethod(this, _ElementHandle_instances, checkVisibility_fn).call(this, true);
      }
      /**
       * An element is considered to be hidden if at least one of the following is true:
       *
       * - the element has no
       *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle | computed styles}.
       *
       * - the element has an empty
       *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect | bounding client rect}.
       *
       * - the element's {@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility | visibility}
       *   is `hidden` or `collapse`.
       */
      async isHidden() {
        return await __privateMethod(this, _ElementHandle_instances, checkVisibility_fn).call(this, false);
      }
      /**
       * Converts the current handle to the given element type.
       *
       * @example
       *
       * ```ts
       * const element: ElementHandle<Element> = await page.$(
       *   '.class-name-of-anchor',
       * );
       * // DO NOT DISPOSE `element`, this will be always be the same handle.
       * const anchor: ElementHandle<HTMLAnchorElement> =
       *   await element.toElement('a');
       * ```
       *
       * @param tagName - The tag name of the desired element type.
       * @throws An error if the handle does not match. **The handle will not be
       * automatically disposed.**
       */
      async toElement(tagName) {
        const isMatchingTagName = await this.evaluate((node, tagName2) => {
          return node.nodeName === tagName2.toUpperCase();
        }, tagName);
        if (!isMatchingTagName) {
          throw new Error(`Element is not a(n) \`${tagName}\` element`);
        }
        return this;
      }
      /**
       * Returns the middle point within an element unless a specific offset is provided.
       */
      async clickablePoint(offset) {
        const box = await __privateMethod(this, _ElementHandle_instances, clickableBox_fn).call(this);
        if (!box) {
          throw new Error("Node is either not clickable or not an Element");
        }
        if (offset !== void 0) {
          return {
            x: box.x + offset.x,
            y: box.y + offset.y
          };
        }
        return {
          x: box.x + box.width / 2,
          y: box.y + box.height / 2
        };
      }
      /**
       * This method scrolls element into view if needed, and then
       * uses {@link Page.mouse} to hover over the center of the element.
       * If the element is detached from DOM, the method throws an error.
       */
      async hover() {
        await this.scrollIntoViewIfNeeded();
        const { x, y } = await this.clickablePoint();
        await this.frame.page().mouse.move(x, y);
      }
      /**
       * This method scrolls element into view if needed, and then
       * uses {@link Page.mouse} to click in the center of the element.
       * If the element is detached from DOM, the method throws an error.
       */
      async click(options = {}) {
        await this.scrollIntoViewIfNeeded();
        const { x, y } = await this.clickablePoint(options.offset);
        await this.frame.page().mouse.click(x, y, options);
      }
      /**
       * Drags an element over the given element or point.
       *
       * @returns DEPRECATED. When drag interception is enabled, the drag payload is
       * returned.
       */
      async drag(target) {
        await this.scrollIntoViewIfNeeded();
        const page = this.frame.page();
        if (page.isDragInterceptionEnabled()) {
          const source2 = await this.clickablePoint();
          if (target instanceof _a3) {
            target = await target.clickablePoint();
          }
          return await page.mouse.drag(source2, target);
        }
        try {
          if (!page._isDragging) {
            page._isDragging = true;
            await this.hover();
            await page.mouse.down();
          }
          if (target instanceof _a3) {
            await target.hover();
          } else {
            await page.mouse.move(target.x, target.y);
          }
        } catch (error) {
          page._isDragging = false;
          throw error;
        }
      }
      /**
       * @deprecated Do not use. `dragenter` will automatically be performed during dragging.
       */
      async dragEnter(data = { items: [], dragOperationsMask: 1 }) {
        const page = this.frame.page();
        await this.scrollIntoViewIfNeeded();
        const target = await this.clickablePoint();
        await page.mouse.dragEnter(target, data);
      }
      /**
       * @deprecated Do not use. `dragover` will automatically be performed during dragging.
       */
      async dragOver(data = { items: [], dragOperationsMask: 1 }) {
        const page = this.frame.page();
        await this.scrollIntoViewIfNeeded();
        const target = await this.clickablePoint();
        await page.mouse.dragOver(target, data);
      }
      /**
       * @internal
       */
      async drop(dataOrElement = {
        items: [],
        dragOperationsMask: 1
      }) {
        const page = this.frame.page();
        if ("items" in dataOrElement) {
          await this.scrollIntoViewIfNeeded();
          const destination = await this.clickablePoint();
          await page.mouse.drop(destination, dataOrElement);
        } else {
          await dataOrElement.drag(this);
          page._isDragging = false;
          await page.mouse.up();
        }
      }
      /**
       * @deprecated Use `ElementHandle.drop` instead.
       */
      async dragAndDrop(target, options) {
        const page = this.frame.page();
        assert$1(page.isDragInterceptionEnabled(), "Drag Interception is not enabled!");
        await this.scrollIntoViewIfNeeded();
        const startPoint = await this.clickablePoint();
        const targetPoint = await target.clickablePoint();
        await page.mouse.dragAndDrop(startPoint, targetPoint, options);
      }
      /**
       * Triggers a `change` and `input` event once all the provided options have been
       * selected. If there's no `<select>` element matching `selector`, the method
       * throws an error.
       *
       * @example
       *
       * ```ts
       * handle.select('blue'); // single selection
       * handle.select('red', 'green', 'blue'); // multiple selections
       * ```
       *
       * @param values - Values of options to select. If the `<select>` has the
       * `multiple` attribute, all values are considered, otherwise only the first
       * one is taken into account.
       */
      async select(...values) {
        for (const value of values) {
          assert$1(isString(value), 'Values must be strings. Found value "' + value + '" of type "' + typeof value + '"');
        }
        return await this.evaluate((element, vals) => {
          const values2 = new Set(vals);
          if (!(element instanceof HTMLSelectElement)) {
            throw new Error("Element is not a <select> element.");
          }
          const selectedValues = /* @__PURE__ */ new Set();
          if (!element.multiple) {
            for (const option of element.options) {
              option.selected = false;
            }
            for (const option of element.options) {
              if (values2.has(option.value)) {
                option.selected = true;
                selectedValues.add(option.value);
                break;
              }
            }
          } else {
            for (const option of element.options) {
              option.selected = values2.has(option.value);
              if (option.selected) {
                selectedValues.add(option.value);
              }
            }
          }
          element.dispatchEvent(new Event("input", { bubbles: true }));
          element.dispatchEvent(new Event("change", { bubbles: true }));
          return [...selectedValues.values()];
        }, values);
      }
      /**
       * This method scrolls element into view if needed, and then uses
       * {@link Touchscreen.tap} to tap in the center of the element.
       * If the element is detached from DOM, the method throws an error.
       */
      async tap() {
        await this.scrollIntoViewIfNeeded();
        const { x, y } = await this.clickablePoint();
        await this.frame.page().touchscreen.tap(x, y);
      }
      /**
       * This method scrolls the element into view if needed, and then
       * starts a touch in the center of the element.
       * @returns A {@link TouchHandle} representing the touch that was started
       */
      async touchStart() {
        await this.scrollIntoViewIfNeeded();
        const { x, y } = await this.clickablePoint();
        return await this.frame.page().touchscreen.touchStart(x, y);
      }
      /**
       * This method scrolls the element into view if needed, and then
       * moves the touch to the center of the element.
       * @param touch - An optional {@link TouchHandle}. If provided, this touch
       * will be moved. If not provided, the first active touch will be moved.
       */
      async touchMove(touch) {
        await this.scrollIntoViewIfNeeded();
        const { x, y } = await this.clickablePoint();
        if (touch) {
          return await touch.move(x, y);
        }
        await this.frame.page().touchscreen.touchMove(x, y);
      }
      async touchEnd() {
        await this.scrollIntoViewIfNeeded();
        await this.frame.page().touchscreen.touchEnd();
      }
      /**
       * Calls {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus | focus} on the element.
       */
      async focus() {
        await this.evaluate((element) => {
          if (!(element instanceof HTMLElement)) {
            throw new Error("Cannot focus non-HTMLElement");
          }
          return element.focus();
        });
      }
      /**
       * Focuses the element, and then sends a `keydown`, `keypress`/`input`, and
       * `keyup` event for each character in the text.
       *
       * To press a special key, like `Control` or `ArrowDown`,
       * use {@link ElementHandle.press}.
       *
       * @example
       *
       * ```ts
       * await elementHandle.type('Hello'); // Types instantly
       * await elementHandle.type('World', {delay: 100}); // Types slower, like a user
       * ```
       *
       * @example
       * An example of typing into a text field and then submitting the form:
       *
       * ```ts
       * const elementHandle = await page.$('input');
       * await elementHandle.type('some text');
       * await elementHandle.press('Enter');
       * ```
       *
       * @param options - Delay in milliseconds. Defaults to 0.
       */
      async type(text, options) {
        await this.focus();
        await this.frame.page().keyboard.type(text, options);
      }
      /**
       * Focuses the element, and then uses {@link Keyboard.down} and {@link Keyboard.up}.
       *
       * @remarks
       * If `key` is a single character and no modifier keys besides `Shift`
       * are being held down, a `keypress`/`input` event will also be generated.
       * The `text` option can be specified to force an input event to be generated.
       *
       * **NOTE** Modifier keys DO affect `elementHandle.press`. Holding down `Shift`
       * will type the text in upper case.
       *
       * @param key - Name of key to press, such as `ArrowLeft`.
       * See {@link KeyInput} for a list of all key names.
       */
      async press(key, options) {
        await this.focus();
        await this.frame.page().keyboard.press(key, options);
      }
      /**
       * This method returns the bounding box of the element (relative to the main frame),
       * or `null` if the element is {@link https://drafts.csswg.org/css-display-4/#box-generation | not part of the layout}
       * (example: `display: none`).
       */
      async boundingBox() {
        const box = await this.evaluate((element) => {
          if (!(element instanceof Element)) {
            return null;
          }
          if (element.getClientRects().length === 0) {
            return null;
          }
          const rect = element.getBoundingClientRect();
          return { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        });
        if (!box) {
          return null;
        }
        const offset = await __privateMethod(this, _ElementHandle_instances, getTopLeftCornerOfFrame_fn).call(this);
        if (!offset) {
          return null;
        }
        return {
          x: box.x + offset.x,
          y: box.y + offset.y,
          height: box.height,
          width: box.width
        };
      }
      /**
       * This method returns boxes of the element,
       * or `null` if the element is {@link https://drafts.csswg.org/css-display-4/#box-generation | not part of the layout}
       * (example: `display: none`).
       *
       * @remarks
       *
       * Boxes are represented as an array of points;
       * Each Point is an object `{x, y}`. Box points are sorted clock-wise.
       */
      async boxModel() {
        const model = await this.evaluate((element) => {
          if (!(element instanceof Element)) {
            return null;
          }
          if (element.getClientRects().length === 0) {
            return null;
          }
          const rect = element.getBoundingClientRect();
          const style = window.getComputedStyle(element);
          const offsets = {
            padding: {
              left: parseInt(style.paddingLeft, 10),
              top: parseInt(style.paddingTop, 10),
              right: parseInt(style.paddingRight, 10),
              bottom: parseInt(style.paddingBottom, 10)
            },
            margin: {
              left: -parseInt(style.marginLeft, 10),
              top: -parseInt(style.marginTop, 10),
              right: -parseInt(style.marginRight, 10),
              bottom: -parseInt(style.marginBottom, 10)
            },
            border: {
              left: parseInt(style.borderLeft, 10),
              top: parseInt(style.borderTop, 10),
              right: parseInt(style.borderRight, 10),
              bottom: parseInt(style.borderBottom, 10)
            }
          };
          const border = [
            { x: rect.left, y: rect.top },
            { x: rect.left + rect.width, y: rect.top },
            { x: rect.left + rect.width, y: rect.top + rect.height },
            { x: rect.left, y: rect.top + rect.height }
          ];
          const padding = transformQuadWithOffsets(border, offsets.border);
          const content = transformQuadWithOffsets(padding, offsets.padding);
          const margin = transformQuadWithOffsets(border, offsets.margin);
          return {
            content,
            padding,
            border,
            margin,
            width: rect.width,
            height: rect.height
          };
          function transformQuadWithOffsets(quad, offsets2) {
            return [
              {
                x: quad[0].x + offsets2.left,
                y: quad[0].y + offsets2.top
              },
              {
                x: quad[1].x - offsets2.right,
                y: quad[1].y + offsets2.top
              },
              {
                x: quad[2].x - offsets2.right,
                y: quad[2].y - offsets2.bottom
              },
              {
                x: quad[3].x + offsets2.left,
                y: quad[3].y - offsets2.bottom
              }
            ];
          }
        });
        if (!model) {
          return null;
        }
        const offset = await __privateMethod(this, _ElementHandle_instances, getTopLeftCornerOfFrame_fn).call(this);
        if (!offset) {
          return null;
        }
        for (const attribute of [
          "content",
          "padding",
          "border",
          "margin"
        ]) {
          for (const point of model[attribute]) {
            point.x += offset.x;
            point.y += offset.y;
          }
        }
        return model;
      }
      async screenshot(options = {}) {
        const { scrollIntoView = true, clip } = options;
        const page = this.frame.page();
        if (scrollIntoView) {
          await this.scrollIntoViewIfNeeded();
        }
        const elementClip = await __privateMethod(this, _ElementHandle_instances, nonEmptyVisibleBoundingBox_fn).call(this);
        const [pageLeft, pageTop] = await this.evaluate(() => {
          if (!window.visualViewport) {
            throw new Error("window.visualViewport is not supported.");
          }
          return [
            window.visualViewport.pageLeft,
            window.visualViewport.pageTop
          ];
        });
        elementClip.x += pageLeft;
        elementClip.y += pageTop;
        if (clip) {
          elementClip.x += clip.x;
          elementClip.y += clip.y;
          elementClip.height = clip.height;
          elementClip.width = clip.width;
        }
        return await page.screenshot({ ...options, clip: elementClip });
      }
      /**
       * @internal
       */
      async assertConnectedElement() {
        const error = await this.evaluate(async (element) => {
          if (!element.isConnected) {
            return "Node is detached from document";
          }
          if (element.nodeType !== Node.ELEMENT_NODE) {
            return "Node is not of type HTMLElement";
          }
          return;
        });
        if (error) {
          throw new Error(error);
        }
      }
      /**
       * @internal
       */
      async scrollIntoViewIfNeeded() {
        if (await this.isIntersectingViewport({
          threshold: 1
        })) {
          return;
        }
        await this.scrollIntoView();
      }
      /**
       * Resolves to true if the element is visible in the current viewport. If an
       * element is an SVG, we check if the svg owner element is in the viewport
       * instead. See https://crbug.com/963246.
       *
       * @param options - Threshold for the intersection between 0 (no intersection) and 1
       * (full intersection). Defaults to 1.
       */
      async isIntersectingViewport(options = {}) {
        var _a4;
        const env_5 = { stack: [], error: void 0, hasError: false };
        try {
          await this.assertConnectedElement();
          const handle = await __privateMethod(this, _ElementHandle_instances, asSVGElementHandle_fn).call(this);
          const target = __addDisposableResource$e(env_5, handle && await __privateMethod(_a4 = handle, _ElementHandle_instances, getOwnerSVGElement_fn).call(_a4), false);
          return await (target ?? this).evaluate(async (element, threshold) => {
            const visibleRatio = await new Promise((resolve) => {
              const observer = new IntersectionObserver((entries) => {
                resolve(entries[0].intersectionRatio);
                observer.disconnect();
              });
              observer.observe(element);
            });
            return threshold === 1 ? visibleRatio === 1 : visibleRatio > threshold;
          }, options.threshold ?? 0);
        } catch (e_5) {
          env_5.error = e_5;
          env_5.hasError = true;
        } finally {
          __disposeResources$e(env_5);
        }
      }
      /**
       * Scrolls the element into view using either the automation protocol client
       * or by calling element.scrollIntoView.
       */
      async scrollIntoView() {
        await this.assertConnectedElement();
        await this.evaluate(async (element) => {
          element.scrollIntoView({
            block: "center",
            inline: "center",
            behavior: "instant"
          });
        });
      }
    }, _ElementHandle_instances = new WeakSet(), $$_get = function() {
      return _private_$$_descriptor.value;
    }, $$impl_fn = async function(selector) {
      const { updatedSelector, QueryHandler: QueryHandler2 } = getQueryHandlerAndSelector(selector);
      return await AsyncIterableUtil.collect(QueryHandler2.queryAll(this, updatedSelector));
    }, checkVisibility_fn = async function(visibility) {
      return await this.evaluate(async (element, PuppeteerUtil, visibility2) => {
        return Boolean(PuppeteerUtil.checkVisibility(element, visibility2));
      }, LazyArg.create((context) => {
        return context.puppeteerUtil;
      }), visibility);
    }, clickableBox_fn = async function() {
      var _a4;
      const boxes = await this.evaluate((element) => {
        if (!(element instanceof Element)) {
          return null;
        }
        return [...element.getClientRects()].map((rect) => {
          return { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        });
      });
      if (!(boxes == null ? void 0 : boxes.length)) {
        return null;
      }
      await __privateMethod(this, _ElementHandle_instances, intersectBoundingBoxesWithFrame_fn).call(this, boxes);
      let frame = this.frame;
      let parentFrame;
      while (parentFrame = frame == null ? void 0 : frame.parentFrame()) {
        const env_3 = { stack: [], error: void 0, hasError: false };
        try {
          const handle = __addDisposableResource$e(env_3, await frame.frameElement(), false);
          if (!handle) {
            throw new Error("Unsupported frame type");
          }
          const parentBox = await handle.evaluate((element) => {
            if (element.getClientRects().length === 0) {
              return null;
            }
            const rect = element.getBoundingClientRect();
            const style = window.getComputedStyle(element);
            return {
              left: rect.left + parseInt(style.paddingLeft, 10) + parseInt(style.borderLeftWidth, 10),
              top: rect.top + parseInt(style.paddingTop, 10) + parseInt(style.borderTopWidth, 10)
            };
          });
          if (!parentBox) {
            return null;
          }
          for (const box2 of boxes) {
            box2.x += parentBox.left;
            box2.y += parentBox.top;
          }
          await __privateMethod(_a4 = handle, _ElementHandle_instances, intersectBoundingBoxesWithFrame_fn).call(_a4, boxes);
          frame = parentFrame;
        } catch (e_3) {
          env_3.error = e_3;
          env_3.hasError = true;
        } finally {
          __disposeResources$e(env_3);
        }
      }
      const box = boxes.find((box2) => {
        return box2.width >= 1 && box2.height >= 1;
      });
      if (!box) {
        return null;
      }
      return {
        x: box.x,
        y: box.y,
        height: box.height,
        width: box.width
      };
    }, intersectBoundingBoxesWithFrame_fn = async function(boxes) {
      const { documentWidth, documentHeight } = await this.frame.isolatedRealm().evaluate(() => {
        return {
          documentWidth: document.documentElement.clientWidth,
          documentHeight: document.documentElement.clientHeight
        };
      });
      for (const box of boxes) {
        intersectBoundingBox(box, documentWidth, documentHeight);
      }
    }, getTopLeftCornerOfFrame_fn = async function() {
      const point = { x: 0, y: 0 };
      let frame = this.frame;
      let parentFrame;
      while (parentFrame = frame == null ? void 0 : frame.parentFrame()) {
        const env_4 = { stack: [], error: void 0, hasError: false };
        try {
          const handle = __addDisposableResource$e(env_4, await frame.frameElement(), false);
          if (!handle) {
            throw new Error("Unsupported frame type");
          }
          const parentBox = await handle.evaluate((element) => {
            if (element.getClientRects().length === 0) {
              return null;
            }
            const rect = element.getBoundingClientRect();
            const style = window.getComputedStyle(element);
            return {
              left: rect.left + parseInt(style.paddingLeft, 10) + parseInt(style.borderLeftWidth, 10),
              top: rect.top + parseInt(style.paddingTop, 10) + parseInt(style.borderTopWidth, 10)
            };
          });
          if (!parentBox) {
            return null;
          }
          point.x += parentBox.left;
          point.y += parentBox.top;
          frame = parentFrame;
        } catch (e_4) {
          env_4.error = e_4;
          env_4.hasError = true;
        } finally {
          __disposeResources$e(env_4);
        }
      }
      return point;
    }, nonEmptyVisibleBoundingBox_fn = async function() {
      const box = await this.boundingBox();
      assert$1(box, "Node is either not visible or not an HTMLElement");
      assert$1(box.width !== 0, "Node has 0 width.");
      assert$1(box.height !== 0, "Node has 0 height.");
      return box;
    }, asSVGElementHandle_fn = async function() {
      if (await this.evaluate((element) => {
        return element instanceof SVGElement;
      })) {
        return this;
      } else {
        return null;
      }
    }, getOwnerSVGElement_fn = async function() {
      return await this.evaluateHandle((element) => {
        if (element instanceof SVGSVGElement) {
          return element;
        }
        return element.ownerSVGElement;
      });
    }, (() => {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      _getProperty_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _getProperties_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _jsonValue_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _$_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _$$_decorators = [throwIfDisposed()];
      _private_$$_decorators = [bindIsolatedHandle];
      _waitForSelector_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _isVisible_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _isHidden_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _toElement_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _clickablePoint_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _hover_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _click_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _drag_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _dragEnter_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _dragOver_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _drop_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _dragAndDrop_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _select_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _tap_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _touchStart_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _touchMove_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _touchEnd_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _focus_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _type_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _press_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _boundingBox_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _boxModel_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _screenshot_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _isIntersectingViewport_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _scrollIntoView_decorators = [throwIfDisposed(), bindIsolatedHandle];
      __esDecorate$j(_a3, null, _getProperty_decorators, { kind: "method", name: "getProperty", static: false, private: false, access: { has: (obj) => "getProperty" in obj, get: (obj) => obj.getProperty }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, null, _getProperties_decorators, { kind: "method", name: "getProperties", static: false, private: false, access: { has: (obj) => "getProperties" in obj, get: (obj) => obj.getProperties }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, null, _jsonValue_decorators, { kind: "method", name: "jsonValue", static: false, private: false, access: { has: (obj) => "jsonValue" in obj, get: (obj) => obj.jsonValue }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, null, _$_decorators, { kind: "method", name: "$", static: false, private: false, access: { has: (obj) => "$" in obj, get: (obj) => obj.$ }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, null, _$$_decorators, { kind: "method", name: "$$", static: false, private: false, access: { has: (obj) => "$$" in obj, get: (obj) => obj.$$ }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, _private_$$_descriptor = { value: __setFunctionName$3(async function(selector) {
        return await __privateMethod(this, _ElementHandle_instances, $$impl_fn).call(this, selector);
      }, "#$$") }, _private_$$_decorators, { kind: "method", name: "#$$", static: false, private: true, access: { has: (obj) => __privateIn(_ElementHandle_instances, obj), get: (obj) => __privateGet(obj, _ElementHandle_instances, $$_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, null, _waitForSelector_decorators, { kind: "method", name: "waitForSelector", static: false, private: false, access: { has: (obj) => "waitForSelector" in obj, get: (obj) => obj.waitForSelector }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, null, _isVisible_decorators, { kind: "method", name: "isVisible", static: false, private: false, access: { has: (obj) => "isVisible" in obj, get: (obj) => obj.isVisible }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, null, _isHidden_decorators, { kind: "method", name: "isHidden", static: false, private: false, access: { has: (obj) => "isHidden" in obj, get: (obj) => obj.isHidden }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, null, _toElement_decorators, { kind: "method", name: "toElement", static: false, private: false, access: { has: (obj) => "toElement" in obj, get: (obj) => obj.toElement }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, null, _clickablePoint_decorators, { kind: "method", name: "clickablePoint", static: false, private: false, access: { has: (obj) => "clickablePoint" in obj, get: (obj) => obj.clickablePoint }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, null, _hover_decorators, { kind: "method", name: "hover", static: false, private: false, access: { has: (obj) => "hover" in obj, get: (obj) => obj.hover }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, null, _click_decorators, { kind: "method", name: "click", static: false, private: false, access: { has: (obj) => "click" in obj, get: (obj) => obj.click }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, null, _drag_decorators, { kind: "method", name: "drag", static: false, private: false, access: { has: (obj) => "drag" in obj, get: (obj) => obj.drag }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, null, _dragEnter_decorators, { kind: "method", name: "dragEnter", static: false, private: false, access: { has: (obj) => "dragEnter" in obj, get: (obj) => obj.dragEnter }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, null, _dragOver_decorators, { kind: "method", name: "dragOver", static: false, private: false, access: { has: (obj) => "dragOver" in obj, get: (obj) => obj.dragOver }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, null, _drop_decorators, { kind: "method", name: "drop", static: false, private: false, access: { has: (obj) => "drop" in obj, get: (obj) => obj.drop }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, null, _dragAndDrop_decorators, { kind: "method", name: "dragAndDrop", static: false, private: false, access: { has: (obj) => "dragAndDrop" in obj, get: (obj) => obj.dragAndDrop }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, null, _select_decorators, { kind: "method", name: "select", static: false, private: false, access: { has: (obj) => "select" in obj, get: (obj) => obj.select }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, null, _tap_decorators, { kind: "method", name: "tap", static: false, private: false, access: { has: (obj) => "tap" in obj, get: (obj) => obj.tap }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, null, _touchStart_decorators, { kind: "method", name: "touchStart", static: false, private: false, access: { has: (obj) => "touchStart" in obj, get: (obj) => obj.touchStart }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, null, _touchMove_decorators, { kind: "method", name: "touchMove", static: false, private: false, access: { has: (obj) => "touchMove" in obj, get: (obj) => obj.touchMove }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, null, _touchEnd_decorators, { kind: "method", name: "touchEnd", static: false, private: false, access: { has: (obj) => "touchEnd" in obj, get: (obj) => obj.touchEnd }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, null, _focus_decorators, { kind: "method", name: "focus", static: false, private: false, access: { has: (obj) => "focus" in obj, get: (obj) => obj.focus }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, null, _type_decorators, { kind: "method", name: "type", static: false, private: false, access: { has: (obj) => "type" in obj, get: (obj) => obj.type }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, null, _press_decorators, { kind: "method", name: "press", static: false, private: false, access: { has: (obj) => "press" in obj, get: (obj) => obj.press }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, null, _boundingBox_decorators, { kind: "method", name: "boundingBox", static: false, private: false, access: { has: (obj) => "boundingBox" in obj, get: (obj) => obj.boundingBox }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, null, _boxModel_decorators, { kind: "method", name: "boxModel", static: false, private: false, access: { has: (obj) => "boxModel" in obj, get: (obj) => obj.boxModel }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, null, _screenshot_decorators, { kind: "method", name: "screenshot", static: false, private: false, access: { has: (obj) => "screenshot" in obj, get: (obj) => obj.screenshot }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, null, _isIntersectingViewport_decorators, { kind: "method", name: "isIntersectingViewport", static: false, private: false, access: { has: (obj) => "isIntersectingViewport" in obj, get: (obj) => obj.isIntersectingViewport }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$j(_a3, null, _scrollIntoView_decorators, { kind: "method", name: "scrollIntoView", static: false, private: false, access: { has: (obj) => "scrollIntoView" in obj, get: (obj) => obj.scrollIntoView }, metadata: _metadata }, null, _instanceExtraInitializers);
      if (_metadata) Object.defineProperty(_a3, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    })(), _a3;
  })();
  function intersectBoundingBox(box, width, height) {
    box.width = Math.max(box.x >= 0 ? Math.min(width - box.x, box.width) : Math.min(width, box.width + box.x), 0);
    box.height = Math.max(box.y >= 0 ? Math.min(height - box.y, box.height) : Math.min(height, box.height + box.y), 0);
  }
  var __addDisposableResource$d = function(env, value, async2) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async2) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async2) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({ value, dispose, async: async2 });
    } else if (async2) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources$d = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  var LocatorEvent;
  (function(LocatorEvent2) {
    LocatorEvent2["Action"] = "action";
  })(LocatorEvent || (LocatorEvent = {}));
  class Locator extends EventEmitter$1 {
    constructor() {
      super(...arguments);
      __privateAdd(this, _Locator_instances);
      /**
       * @internal
       */
      __publicField(this, "visibility", null);
      /**
       * @internal
       */
      __publicField(this, "_timeout", 3e4);
      __privateAdd(this, _ensureElementIsInTheViewport, true);
      __privateAdd(this, _waitForEnabled, true);
      __privateAdd(this, _waitForStableBoundingBox, true);
      /**
       * @internal
       */
      __publicField(this, "operators", {
        conditions: (conditions, signal) => {
          return mergeMap((handle) => {
            return merge(...conditions.map((condition) => {
              return condition(handle, signal);
            })).pipe(defaultIfEmpty(handle));
          });
        },
        retryAndRaceWithSignalAndTimer: (signal, cause) => {
          const candidates = [];
          if (signal) {
            candidates.push(fromAbortSignal(signal, cause));
          }
          candidates.push(timeout(this._timeout, cause));
          return pipe(retry$2({ delay: RETRY_DELAY }), raceWith(...candidates));
        }
      });
      /**
       * If the element has a "disabled" property, wait for the element to be
       * enabled.
       */
      __privateAdd(this, _waitForEnabledIfNeeded, (handle, signal) => {
        if (!__privateGet(this, _waitForEnabled)) {
          return EMPTY;
        }
        return from(handle.frame.waitForFunction((element) => {
          if (!(element instanceof HTMLElement)) {
            return true;
          }
          const isNativeFormControl = [
            "BUTTON",
            "INPUT",
            "SELECT",
            "TEXTAREA",
            "OPTION",
            "OPTGROUP"
          ].includes(element.nodeName);
          return !isNativeFormControl || !element.hasAttribute("disabled");
        }, {
          timeout: this._timeout,
          signal
        }, handle)).pipe(ignoreElements());
      });
      /**
       * Compares the bounding box of the element for two consecutive animation
       * frames and waits till they are the same.
       */
      __privateAdd(this, _waitForStableBoundingBoxIfNeeded, (handle) => {
        if (!__privateGet(this, _waitForStableBoundingBox)) {
          return EMPTY;
        }
        return defer(() => {
          return from(handle.evaluate((element) => {
            return new Promise((resolve) => {
              window.requestAnimationFrame(() => {
                const rect1 = element.getBoundingClientRect();
                window.requestAnimationFrame(() => {
                  const rect2 = element.getBoundingClientRect();
                  resolve([
                    {
                      x: rect1.x,
                      y: rect1.y,
                      width: rect1.width,
                      height: rect1.height
                    },
                    {
                      x: rect2.x,
                      y: rect2.y,
                      width: rect2.width,
                      height: rect2.height
                    }
                  ]);
                });
              });
            });
          }));
        }).pipe(first(([rect1, rect2]) => {
          return rect1.x === rect2.x && rect1.y === rect2.y && rect1.width === rect2.width && rect1.height === rect2.height;
        }), retry$2({ delay: RETRY_DELAY }), ignoreElements());
      });
      /**
       * Checks if the element is in the viewport and auto-scrolls it if it is not.
       */
      __privateAdd(this, _ensureElementIsInTheViewportIfNeeded, (handle) => {
        if (!__privateGet(this, _ensureElementIsInTheViewport)) {
          return EMPTY;
        }
        return from(handle.isIntersectingViewport({ threshold: 0 })).pipe(filter((isIntersectingViewport) => {
          return !isIntersectingViewport;
        }), mergeMap(() => {
          return from(handle.scrollIntoView());
        }), mergeMap(() => {
          return defer(() => {
            return from(handle.isIntersectingViewport({ threshold: 0 }));
          }).pipe(first(identity), retry$2({ delay: RETRY_DELAY }), ignoreElements());
        }));
      });
    }
    /**
     * Creates a race between multiple locators trying to locate elements in
     * parallel but ensures that only a single element receives the action.
     *
     * @public
     */
    static race(locators) {
      return RaceLocator.create(locators);
    }
    // Determines when the locator will timeout for actions.
    get timeout() {
      return this._timeout;
    }
    /**
     * Creates a new locator instance by cloning the current locator and setting
     * the total timeout for the locator actions.
     *
     * Pass `0` to disable timeout.
     *
     * @defaultValue `Page.getDefaultTimeout()`
     */
    setTimeout(timeout2) {
      const locator = this._clone();
      locator._timeout = timeout2;
      return locator;
    }
    /**
     * Creates a new locator instance by cloning the current locator with the
     * visibility property changed to the specified value.
     */
    setVisibility(visibility) {
      const locator = this._clone();
      locator.visibility = visibility;
      return locator;
    }
    /**
     * Creates a new locator instance by cloning the current locator and
     * specifying whether to wait for input elements to become enabled before the
     * action. Applicable to `click` and `fill` actions.
     *
     * @defaultValue `true`
     */
    setWaitForEnabled(value) {
      const locator = this._clone();
      __privateSet(locator, _waitForEnabled, value);
      return locator;
    }
    /**
     * Creates a new locator instance by cloning the current locator and
     * specifying whether the locator should scroll the element into viewport if
     * it is not in the viewport already.
     *
     * @defaultValue `true`
     */
    setEnsureElementIsInTheViewport(value) {
      const locator = this._clone();
      __privateSet(locator, _ensureElementIsInTheViewport, value);
      return locator;
    }
    /**
     * Creates a new locator instance by cloning the current locator and
     * specifying whether the locator has to wait for the element's bounding box
     * to be same between two consecutive animation frames.
     *
     * @defaultValue `true`
     */
    setWaitForStableBoundingBox(value) {
      const locator = this._clone();
      __privateSet(locator, _waitForStableBoundingBox, value);
      return locator;
    }
    /**
     * @internal
     */
    copyOptions(locator) {
      this._timeout = locator._timeout;
      this.visibility = locator.visibility;
      __privateSet(this, _waitForEnabled, __privateGet(locator, _waitForEnabled));
      __privateSet(this, _ensureElementIsInTheViewport, __privateGet(locator, _ensureElementIsInTheViewport));
      __privateSet(this, _waitForStableBoundingBox, __privateGet(locator, _waitForStableBoundingBox));
      return this;
    }
    /**
     * Clones the locator.
     */
    clone() {
      return this._clone();
    }
    /**
     * Waits for the locator to get a handle from the page.
     *
     * @public
     */
    async waitHandle(options) {
      const cause = new Error("Locator.waitHandle");
      return await firstValueFrom(this._wait(options).pipe(this.operators.retryAndRaceWithSignalAndTimer(options == null ? void 0 : options.signal, cause)));
    }
    /**
     * Waits for the locator to get the serialized value from the page.
     *
     * Note this requires the value to be JSON-serializable.
     *
     * @public
     */
    async wait(options) {
      const env_1 = { stack: [], error: void 0, hasError: false };
      try {
        const handle = __addDisposableResource$d(env_1, await this.waitHandle(options), false);
        return await handle.jsonValue();
      } catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
      } finally {
        __disposeResources$d(env_1);
      }
    }
    /**
     * Maps the locator using the provided mapper.
     *
     * @public
     */
    map(mapper) {
      return new MappedLocator(this._clone(), (handle) => {
        return handle.evaluateHandle(mapper);
      });
    }
    /**
     * Creates an expectation that is evaluated against located values.
     *
     * If the expectations do not match, then the locator will retry.
     *
     * @public
     */
    filter(predicate) {
      return new FilteredLocator(this._clone(), async (handle, signal) => {
        await handle.frame.waitForFunction(predicate, { signal, timeout: this._timeout }, handle);
        return true;
      });
    }
    /**
     * Creates an expectation that is evaluated against located handles.
     *
     * If the expectations do not match, then the locator will retry.
     *
     * @internal
     */
    filterHandle(predicate) {
      return new FilteredLocator(this._clone(), predicate);
    }
    /**
     * Maps the locator using the provided mapper.
     *
     * @internal
     */
    mapHandle(mapper) {
      return new MappedLocator(this._clone(), mapper);
    }
    /**
     * Clicks the located element.
     */
    click(options) {
      return firstValueFrom(__privateMethod(this, _Locator_instances, click_fn).call(this, options));
    }
    /**
     * Fills out the input identified by the locator using the provided value. The
     * type of the input is determined at runtime and the appropriate fill-out
     * method is chosen based on the type. `contenteditable`, select, textarea and
     * input elements are supported.
     */
    fill(value, options) {
      return firstValueFrom(__privateMethod(this, _Locator_instances, fill_fn).call(this, value, options));
    }
    /**
     * Hovers over the located element.
     */
    hover(options) {
      return firstValueFrom(__privateMethod(this, _Locator_instances, hover_fn).call(this, options));
    }
    /**
     * Scrolls the located element.
     */
    scroll(options) {
      return firstValueFrom(__privateMethod(this, _Locator_instances, scroll_fn).call(this, options));
    }
  }
  _ensureElementIsInTheViewport = new WeakMap();
  _waitForEnabled = new WeakMap();
  _waitForStableBoundingBox = new WeakMap();
  _waitForEnabledIfNeeded = new WeakMap();
  _waitForStableBoundingBoxIfNeeded = new WeakMap();
  _ensureElementIsInTheViewportIfNeeded = new WeakMap();
  _Locator_instances = new WeakSet();
  click_fn = function(options) {
    const signal = options == null ? void 0 : options.signal;
    const cause = new Error("Locator.click");
    return this._wait(options).pipe(this.operators.conditions([
      __privateGet(this, _ensureElementIsInTheViewportIfNeeded),
      __privateGet(this, _waitForStableBoundingBoxIfNeeded),
      __privateGet(this, _waitForEnabledIfNeeded)
    ], signal), tap(() => {
      return this.emit(LocatorEvent.Action, void 0);
    }), mergeMap((handle) => {
      return from(handle.click(options)).pipe(catchError((err) => {
        void handle.dispose().catch(debugError);
        throw err;
      }));
    }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));
  };
  fill_fn = function(value, options) {
    const signal = options == null ? void 0 : options.signal;
    const cause = new Error("Locator.fill");
    return this._wait(options).pipe(this.operators.conditions([
      __privateGet(this, _ensureElementIsInTheViewportIfNeeded),
      __privateGet(this, _waitForStableBoundingBoxIfNeeded),
      __privateGet(this, _waitForEnabledIfNeeded)
    ], signal), tap(() => {
      return this.emit(LocatorEvent.Action, void 0);
    }), mergeMap((handle) => {
      return from(handle.evaluate((el) => {
        if (el instanceof HTMLSelectElement) {
          return "select";
        }
        if (el instanceof HTMLTextAreaElement) {
          return "typeable-input";
        }
        if (el instanceof HTMLInputElement) {
          if ((/* @__PURE__ */ new Set([
            "textarea",
            "text",
            "url",
            "tel",
            "search",
            "password",
            "number",
            "email"
          ])).has(el.type)) {
            return "typeable-input";
          } else {
            return "other-input";
          }
        }
        if (el.isContentEditable) {
          return "contenteditable";
        }
        return "unknown";
      })).pipe(mergeMap((inputType) => {
        switch (inputType) {
          case "select":
            return from(handle.select(value).then(noop));
          case "contenteditable":
          case "typeable-input":
            return from(handle.evaluate((input, newValue) => {
              const currentValue = input.isContentEditable ? input.innerText : input.value;
              if (newValue.length <= currentValue.length || !newValue.startsWith(input.value)) {
                if (input.isContentEditable) {
                  input.innerText = "";
                } else {
                  input.value = "";
                }
                return newValue;
              }
              const originalValue = input.isContentEditable ? input.innerText : input.value;
              if (input.isContentEditable) {
                input.innerText = "";
                input.innerText = originalValue;
              } else {
                input.value = "";
                input.value = originalValue;
              }
              return newValue.substring(originalValue.length);
            }, value)).pipe(mergeMap((textToType) => {
              return from(handle.type(textToType));
            }));
          case "other-input":
            return from(handle.focus()).pipe(mergeMap(() => {
              return from(handle.evaluate((input, value2) => {
                input.value = value2;
                input.dispatchEvent(new Event("input", { bubbles: true }));
                input.dispatchEvent(new Event("change", { bubbles: true }));
              }, value));
            }));
          case "unknown":
            throw new Error(`Element cannot be filled out.`);
        }
      })).pipe(catchError((err) => {
        void handle.dispose().catch(debugError);
        throw err;
      }));
    }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));
  };
  hover_fn = function(options) {
    const signal = options == null ? void 0 : options.signal;
    const cause = new Error("Locator.hover");
    return this._wait(options).pipe(this.operators.conditions([
      __privateGet(this, _ensureElementIsInTheViewportIfNeeded),
      __privateGet(this, _waitForStableBoundingBoxIfNeeded)
    ], signal), tap(() => {
      return this.emit(LocatorEvent.Action, void 0);
    }), mergeMap((handle) => {
      return from(handle.hover()).pipe(catchError((err) => {
        void handle.dispose().catch(debugError);
        throw err;
      }));
    }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));
  };
  scroll_fn = function(options) {
    const signal = options == null ? void 0 : options.signal;
    const cause = new Error("Locator.scroll");
    return this._wait(options).pipe(this.operators.conditions([
      __privateGet(this, _ensureElementIsInTheViewportIfNeeded),
      __privateGet(this, _waitForStableBoundingBoxIfNeeded)
    ], signal), tap(() => {
      return this.emit(LocatorEvent.Action, void 0);
    }), mergeMap((handle) => {
      return from(handle.evaluate((el, scrollTop, scrollLeft) => {
        if (scrollTop !== void 0) {
          el.scrollTop = scrollTop;
        }
        if (scrollLeft !== void 0) {
          el.scrollLeft = scrollLeft;
        }
      }, options == null ? void 0 : options.scrollTop, options == null ? void 0 : options.scrollLeft)).pipe(catchError((err) => {
        void handle.dispose().catch(debugError);
        throw err;
      }));
    }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));
  };
  const _FunctionLocator = class _FunctionLocator extends Locator {
    constructor(pageOrFrame, func) {
      super();
      __privateAdd(this, _pageOrFrame);
      __privateAdd(this, _func);
      __privateSet(this, _pageOrFrame, pageOrFrame);
      __privateSet(this, _func, func);
    }
    static create(pageOrFrame, func) {
      return new _FunctionLocator(pageOrFrame, func).setTimeout("getDefaultTimeout" in pageOrFrame ? pageOrFrame.getDefaultTimeout() : pageOrFrame.page().getDefaultTimeout());
    }
    _clone() {
      return new _FunctionLocator(__privateGet(this, _pageOrFrame), __privateGet(this, _func));
    }
    _wait(options) {
      const signal = options == null ? void 0 : options.signal;
      return defer(() => {
        return from(__privateGet(this, _pageOrFrame).waitForFunction(__privateGet(this, _func), {
          timeout: this.timeout,
          signal
        }));
      }).pipe(throwIfEmpty());
    }
  };
  _pageOrFrame = new WeakMap();
  _func = new WeakMap();
  let FunctionLocator = _FunctionLocator;
  class DelegatedLocator extends Locator {
    constructor(delegate) {
      super();
      __privateAdd(this, _delegate);
      __privateSet(this, _delegate, delegate);
      this.copyOptions(__privateGet(this, _delegate));
    }
    get delegate() {
      return __privateGet(this, _delegate);
    }
    setTimeout(timeout2) {
      const locator = super.setTimeout(timeout2);
      __privateSet(locator, _delegate, __privateGet(this, _delegate).setTimeout(timeout2));
      return locator;
    }
    setVisibility(visibility) {
      const locator = super.setVisibility(visibility);
      __privateSet(locator, _delegate, __privateGet(locator, _delegate).setVisibility(visibility));
      return locator;
    }
    setWaitForEnabled(value) {
      const locator = super.setWaitForEnabled(value);
      __privateSet(locator, _delegate, __privateGet(this, _delegate).setWaitForEnabled(value));
      return locator;
    }
    setEnsureElementIsInTheViewport(value) {
      const locator = super.setEnsureElementIsInTheViewport(value);
      __privateSet(locator, _delegate, __privateGet(this, _delegate).setEnsureElementIsInTheViewport(value));
      return locator;
    }
    setWaitForStableBoundingBox(value) {
      const locator = super.setWaitForStableBoundingBox(value);
      __privateSet(locator, _delegate, __privateGet(this, _delegate).setWaitForStableBoundingBox(value));
      return locator;
    }
  }
  _delegate = new WeakMap();
  const _FilteredLocator = class _FilteredLocator extends DelegatedLocator {
    constructor(base, predicate) {
      super(base);
      __privateAdd(this, _predicate);
      __privateSet(this, _predicate, predicate);
    }
    _clone() {
      return new _FilteredLocator(this.delegate.clone(), __privateGet(this, _predicate)).copyOptions(this);
    }
    _wait(options) {
      return this.delegate._wait(options).pipe(mergeMap((handle) => {
        return from(Promise.resolve(__privateGet(this, _predicate).call(this, handle, options == null ? void 0 : options.signal))).pipe(filter((value) => {
          return value;
        }), map(() => {
          return handle;
        }));
      }), throwIfEmpty());
    }
  };
  _predicate = new WeakMap();
  let FilteredLocator = _FilteredLocator;
  const _MappedLocator = class _MappedLocator extends DelegatedLocator {
    constructor(base, mapper) {
      super(base);
      __privateAdd(this, _mapper);
      __privateSet(this, _mapper, mapper);
    }
    _clone() {
      return new _MappedLocator(this.delegate.clone(), __privateGet(this, _mapper)).copyOptions(this);
    }
    _wait(options) {
      return this.delegate._wait(options).pipe(mergeMap((handle) => {
        return from(Promise.resolve(__privateGet(this, _mapper).call(this, handle, options == null ? void 0 : options.signal)));
      }));
    }
  };
  _mapper = new WeakMap();
  let MappedLocator = _MappedLocator;
  const _NodeLocator = class _NodeLocator extends Locator {
    constructor(pageOrFrame, selector) {
      super();
      __privateAdd(this, _pageOrFrame2);
      __privateAdd(this, _selector);
      /**
       * Waits for the element to become visible or hidden. visibility === 'visible'
       * means that the element has a computed style, the visibility property other
       * than 'hidden' or 'collapse' and non-empty bounding box. visibility ===
       * 'hidden' means the opposite of that.
       */
      __privateAdd(this, _waitForVisibilityIfNeeded, (handle) => {
        if (!this.visibility) {
          return EMPTY;
        }
        return (() => {
          switch (this.visibility) {
            case "hidden":
              return defer(() => {
                return from(handle.isHidden());
              });
            case "visible":
              return defer(() => {
                return from(handle.isVisible());
              });
          }
        })().pipe(first(identity), retry$2({ delay: RETRY_DELAY }), ignoreElements());
      });
      __privateSet(this, _pageOrFrame2, pageOrFrame);
      __privateSet(this, _selector, selector);
    }
    static create(pageOrFrame, selector) {
      return new _NodeLocator(pageOrFrame, selector).setTimeout("getDefaultTimeout" in pageOrFrame ? pageOrFrame.getDefaultTimeout() : pageOrFrame.page().getDefaultTimeout());
    }
    _clone() {
      return new _NodeLocator(__privateGet(this, _pageOrFrame2), __privateGet(this, _selector)).copyOptions(this);
    }
    _wait(options) {
      const signal = options == null ? void 0 : options.signal;
      return defer(() => {
        return from(__privateGet(this, _pageOrFrame2).waitForSelector(__privateGet(this, _selector), {
          visible: false,
          timeout: this._timeout,
          signal
        }));
      }).pipe(filter((value) => {
        return value !== null;
      }), throwIfEmpty(), this.operators.conditions([__privateGet(this, _waitForVisibilityIfNeeded)], signal));
    }
  };
  _pageOrFrame2 = new WeakMap();
  _selector = new WeakMap();
  _waitForVisibilityIfNeeded = new WeakMap();
  let NodeLocator = _NodeLocator;
  function checkLocatorArray(locators) {
    for (const locator of locators) {
      if (!(locator instanceof Locator)) {
        throw new Error("Unknown locator for race candidate");
      }
    }
    return locators;
  }
  const _RaceLocator = class _RaceLocator extends Locator {
    constructor(locators) {
      super();
      __privateAdd(this, _locators);
      __privateSet(this, _locators, locators);
    }
    static create(locators) {
      const array = checkLocatorArray(locators);
      return new _RaceLocator(array);
    }
    _clone() {
      return new _RaceLocator(__privateGet(this, _locators).map((locator) => {
        return locator.clone();
      })).copyOptions(this);
    }
    _wait(options) {
      return race(...__privateGet(this, _locators).map((locator) => {
        return locator._wait(options);
      }));
    }
  };
  _locators = new WeakMap();
  let RaceLocator = _RaceLocator;
  const RETRY_DELAY = 100;
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var __runInitializers$i = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i2 = 0; i2 < initializers.length; i2++) {
      value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate$i = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind2 = contextIn.kind, key = kind2 === "getter" ? "get" : kind2 === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function(f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i2])(kind2 === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind2 === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_ = accept(result.get)) descriptor.get = _;
        if (_ = accept(result.set)) descriptor.set = _;
        if (_ = accept(result.init)) initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind2 === "field") initializers.unshift(_);
        else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  var __addDisposableResource$c = function(env, value, async2) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async2) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async2) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({ value, dispose, async: async2 });
    } else if (async2) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources$c = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  var FrameEvent;
  (function(FrameEvent2) {
    FrameEvent2.FrameNavigated = Symbol("Frame.FrameNavigated");
    FrameEvent2.FrameSwapped = Symbol("Frame.FrameSwapped");
    FrameEvent2.LifecycleEvent = Symbol("Frame.LifecycleEvent");
    FrameEvent2.FrameNavigatedWithinDocument = Symbol("Frame.FrameNavigatedWithinDocument");
    FrameEvent2.FrameDetached = Symbol("Frame.FrameDetached");
    FrameEvent2.FrameSwappedByActivation = Symbol("Frame.FrameSwappedByActivation");
  })(FrameEvent || (FrameEvent = {}));
  const throwIfDetached = throwIfDisposed((frame) => {
    return `Attempted to use detached Frame '${frame._id}'.`;
  });
  let Frame = (() => {
    var __document, _Frame_instances, document_fn, _a3;
    let _classSuper = EventEmitter$1;
    let _instanceExtraInitializers = [];
    let _frameElement_decorators;
    let _evaluateHandle_decorators;
    let _evaluate_decorators;
    let _locator_decorators;
    let _$_decorators;
    let _$$_decorators;
    let _$eval_decorators;
    let _$$eval_decorators;
    let _waitForSelector_decorators;
    let _waitForFunction_decorators;
    let _content_decorators;
    let _addScriptTag_decorators;
    let _addStyleTag_decorators;
    let _click_decorators;
    let _focus_decorators;
    let _hover_decorators;
    let _select_decorators;
    let _tap_decorators;
    let _type_decorators;
    let _title_decorators;
    return _a3 = class extends _classSuper {
      /**
       * @internal
       */
      constructor() {
        super();
        __privateAdd(this, _Frame_instances);
        /**
         * @internal
         */
        __publicField(this, "_id", __runInitializers$i(this, _instanceExtraInitializers));
        /**
         * @internal
         */
        __publicField(this, "_parentId");
        /**
         * @internal
         */
        __publicField(this, "_name");
        /**
         * @internal
         */
        __publicField(this, "_hasStartedLoading", false);
        __privateAdd(this, __document);
      }
      /**
       * Used to clear the document handle that has been destroyed.
       *
       * @internal
       */
      clearDocumentHandle() {
        __privateSet(this, __document, void 0);
      }
      /**
       * @returns The frame element associated with this frame (if any).
       */
      async frameElement() {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
          const parentFrame = this.parentFrame();
          if (!parentFrame) {
            return null;
          }
          const list = __addDisposableResource$c(env_1, await parentFrame.isolatedRealm().evaluateHandle(() => {
            return document.querySelectorAll("iframe,frame");
          }), false);
          for await (const iframe_1 of transposeIterableHandle(list)) {
            const env_2 = { stack: [], error: void 0, hasError: false };
            try {
              const iframe = __addDisposableResource$c(env_2, iframe_1, false);
              const frame = await iframe.contentFrame();
              if ((frame == null ? void 0 : frame._id) === this._id) {
                return await parentFrame.mainRealm().adoptHandle(iframe);
              }
            } catch (e_1) {
              env_2.error = e_1;
              env_2.hasError = true;
            } finally {
              __disposeResources$c(env_2);
            }
          }
          return null;
        } catch (e_2) {
          env_1.error = e_2;
          env_1.hasError = true;
        } finally {
          __disposeResources$c(env_1);
        }
      }
      /**
       * Behaves identically to {@link Page.evaluateHandle} except it's run within
       * the context of this frame.
       *
       * See {@link Page.evaluateHandle} for details.
       */
      async evaluateHandle(pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
        return await this.mainRealm().evaluateHandle(pageFunction, ...args);
      }
      /**
       * Behaves identically to {@link Page.evaluate} except it's run within
       * the context of this frame.
       *
       * See {@link Page.evaluate} for details.
       */
      async evaluate(pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
        return await this.mainRealm().evaluate(pageFunction, ...args);
      }
      /**
       * @internal
       */
      locator(selectorOrFunc) {
        if (typeof selectorOrFunc === "string") {
          return NodeLocator.create(this, selectorOrFunc);
        } else {
          return FunctionLocator.create(this, selectorOrFunc);
        }
      }
      /**
       * Queries the frame for an element matching the given selector.
       *
       * @param selector -
       * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
       * to query the page for.
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
       * can be passed as-is and a
       * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
       * allows quering by
       * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
       * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
       * and
       * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
       * and
       * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
       * Alternatively, you can specify the selector type using a
       * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
       *
       * @returns A {@link ElementHandle | element handle} to the first element
       * matching the given selector. Otherwise, `null`.
       */
      async $(selector) {
        const document2 = await __privateMethod(this, _Frame_instances, document_fn).call(this);
        return await document2.$(selector);
      }
      /**
       * Queries the frame for all elements matching the given selector.
       *
       * @param selector -
       * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
       * to query the page for.
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
       * can be passed as-is and a
       * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
       * allows quering by
       * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
       * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
       * and
       * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
       * and
       * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
       * Alternatively, you can specify the selector type using a
       * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
       *
       * @returns An array of {@link ElementHandle | element handles} that point to
       * elements matching the given selector.
       */
      async $$(selector, options) {
        const document2 = await __privateMethod(this, _Frame_instances, document_fn).call(this);
        return await document2.$$(selector, options);
      }
      /**
       * Runs the given function on the first element matching the given selector in
       * the frame.
       *
       * If the given function returns a promise, then this method will wait till
       * the promise resolves.
       *
       * @example
       *
       * ```ts
       * const searchValue = await frame.$eval('#search', el => el.value);
       * ```
       *
       * @param selector -
       * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
       * to query the page for.
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
       * can be passed as-is and a
       * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
       * allows quering by
       * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
       * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
       * and
       * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
       * and
       * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
       * Alternatively, you can specify the selector type using a
       * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
       * @param pageFunction - The function to be evaluated in the frame's context.
       * The first element matching the selector will be passed to the function as
       * its first argument.
       * @param args - Additional arguments to pass to `pageFunction`.
       * @returns A promise to the result of the function.
       */
      async $eval(selector, pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
        const document2 = await __privateMethod(this, _Frame_instances, document_fn).call(this);
        return await document2.$eval(selector, pageFunction, ...args);
      }
      /**
       * Runs the given function on an array of elements matching the given selector
       * in the frame.
       *
       * If the given function returns a promise, then this method will wait till
       * the promise resolves.
       *
       * @example
       *
       * ```ts
       * const divsCounts = await frame.$$eval('div', divs => divs.length);
       * ```
       *
       * @param selector -
       * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
       * to query the page for.
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
       * can be passed as-is and a
       * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
       * allows quering by
       * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
       * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
       * and
       * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
       * and
       * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
       * Alternatively, you can specify the selector type using a
       * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
       * @param pageFunction - The function to be evaluated in the frame's context.
       * An array of elements matching the given selector will be passed to the
       * function as its first argument.
       * @param args - Additional arguments to pass to `pageFunction`.
       * @returns A promise to the result of the function.
       */
      async $$eval(selector, pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
        const document2 = await __privateMethod(this, _Frame_instances, document_fn).call(this);
        return await document2.$$eval(selector, pageFunction, ...args);
      }
      /**
       * Waits for an element matching the given selector to appear in the frame.
       *
       * This method works across navigations.
       *
       * @example
       *
       * ```ts
       * import puppeteer from 'puppeteer';
       *
       * (async () => {
       *   const browser = await puppeteer.launch();
       *   const page = await browser.newPage();
       *   let currentURL;
       *   page
       *     .mainFrame()
       *     .waitForSelector('img')
       *     .then(() => console.log('First URL with image: ' + currentURL));
       *
       *   for (currentURL of [
       *     'https://example.com',
       *     'https://google.com',
       *     'https://bbc.com',
       *   ]) {
       *     await page.goto(currentURL);
       *   }
       *   await browser.close();
       * })();
       * ```
       *
       * @param selector - The selector to query and wait for.
       * @param options - Options for customizing waiting behavior.
       * @returns An element matching the given selector.
       * @throws Throws if an element matching the given selector doesn't appear.
       */
      async waitForSelector(selector, options = {}) {
        const { updatedSelector, QueryHandler: QueryHandler2, polling } = getQueryHandlerAndSelector(selector);
        return await QueryHandler2.waitFor(this, updatedSelector, {
          polling,
          ...options
        });
      }
      /**
       * @example
       * The `waitForFunction` can be used to observe viewport size change:
       *
       * ```ts
       * import puppeteer from 'puppeteer';
       *
       * (async () => {
       * .  const browser = await puppeteer.launch();
       * .  const page = await browser.newPage();
       * .  const watchDog = page.mainFrame().waitForFunction('window.innerWidth < 100');
       * .  page.setViewport({width: 50, height: 50});
       * .  await watchDog;
       * .  await browser.close();
       * })();
       * ```
       *
       * To pass arguments from Node.js to the predicate of `page.waitForFunction` function:
       *
       * ```ts
       * const selector = '.foo';
       * await frame.waitForFunction(
       *   selector => !!document.querySelector(selector),
       *   {}, // empty options object
       *   selector,
       * );
       * ```
       *
       * @param pageFunction - the function to evaluate in the frame context.
       * @param options - options to configure the polling method and timeout.
       * @param args - arguments to pass to the `pageFunction`.
       * @returns the promise which resolve when the `pageFunction` returns a truthy value.
       */
      async waitForFunction(pageFunction, options = {}, ...args) {
        return await this.mainRealm().waitForFunction(pageFunction, options, ...args);
      }
      /**
       * The full HTML contents of the frame, including the DOCTYPE.
       */
      async content() {
        return await this.evaluate(() => {
          let content = "";
          for (const node of document.childNodes) {
            switch (node) {
              case document.documentElement:
                content += document.documentElement.outerHTML;
                break;
              default:
                content += new XMLSerializer().serializeToString(node);
                break;
            }
          }
          return content;
        });
      }
      /**
       * @internal
       */
      async setFrameContent(content) {
        return await this.evaluate((html) => {
          document.open();
          document.write(html);
          document.close();
        }, content);
      }
      /**
       * The frame's `name` attribute as specified in the tag.
       *
       * @remarks
       * If the name is empty, it returns the `id` attribute instead.
       *
       * @remarks
       * This value is calculated once when the frame is created, and will not
       * update if the attribute is changed later.
       *
       * @deprecated Use
       *
       * ```ts
       * const element = await frame.frameElement();
       * const nameOrId = await element.evaluate(frame => frame.name ?? frame.id);
       * ```
       */
      name() {
        return this._name || "";
      }
      /**
       * Is`true` if the frame has been detached. Otherwise, `false`.
       *
       * @deprecated Use the `detached` getter.
       */
      isDetached() {
        return this.detached;
      }
      /**
       * @internal
       */
      get disposed() {
        return this.detached;
      }
      /**
       * Adds a `<script>` tag into the page with the desired url or content.
       *
       * @param options - Options for the script.
       * @returns An {@link ElementHandle | element handle} to the injected
       * `<script>` element.
       */
      async addScriptTag(options) {
        let { content = "", type } = options;
        const { path } = options;
        if (+!!options.url + +!!path + +!!content !== 1) {
          throw new Error("Exactly one of `url`, `path`, or `content` must be specified.");
        }
        if (path) {
          content = await environment.value.fs.promises.readFile(path, "utf8");
          content += `//# sourceURL=${path.replace(/\n/g, "")}`;
        }
        type = type ?? "text/javascript";
        return await this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async ({ url, id, type: type2, content: content2 }) => {
          return await new Promise((resolve, reject) => {
            const script = document.createElement("script");
            script.type = type2;
            script.text = content2;
            script.addEventListener("error", (event) => {
              reject(new Error(event.message ?? "Could not load script"));
            }, { once: true });
            if (id) {
              script.id = id;
            }
            if (url) {
              script.src = url;
              script.addEventListener("load", () => {
                resolve(script);
              }, { once: true });
              document.head.appendChild(script);
            } else {
              document.head.appendChild(script);
              resolve(script);
            }
          });
        }, { ...options, type, content }));
      }
      /**
       * @internal
       */
      async addStyleTag(options) {
        let { content = "" } = options;
        const { path } = options;
        if (+!!options.url + +!!path + +!!content !== 1) {
          throw new Error("Exactly one of `url`, `path`, or `content` must be specified.");
        }
        if (path) {
          content = await environment.value.fs.promises.readFile(path, "utf8");
          content += "/*# sourceURL=" + path.replace(/\n/g, "") + "*/";
          options.content = content;
        }
        return await this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async ({ url, content: content2 }) => {
          return await new Promise((resolve, reject) => {
            let element;
            if (!url) {
              element = document.createElement("style");
              element.appendChild(document.createTextNode(content2));
            } else {
              const link = document.createElement("link");
              link.rel = "stylesheet";
              link.href = url;
              element = link;
            }
            element.addEventListener("load", () => {
              resolve(element);
            }, { once: true });
            element.addEventListener("error", (event) => {
              reject(new Error(event.message ?? "Could not load style"));
            }, { once: true });
            document.head.appendChild(element);
            return element;
          });
        }, options));
      }
      /**
       * Clicks the first element found that matches `selector`.
       *
       * @remarks
       * If `click()` triggers a navigation event and there's a separate
       * `page.waitForNavigation()` promise to be resolved, you may end up with a
       * race condition that yields unexpected results. The correct pattern for
       * click and wait for navigation is the following:
       *
       * ```ts
       * const [response] = await Promise.all([
       *   page.waitForNavigation(waitOptions),
       *   frame.click(selector, clickOptions),
       * ]);
       * ```
       *
       * @param selector - The selector to query for.
       */
      async click(selector, options = {}) {
        const env_3 = { stack: [], error: void 0, hasError: false };
        try {
          const handle = __addDisposableResource$c(env_3, await this.$(selector), false);
          assert$1(handle, `No element found for selector: ${selector}`);
          await handle.click(options);
          await handle.dispose();
        } catch (e_3) {
          env_3.error = e_3;
          env_3.hasError = true;
        } finally {
          __disposeResources$c(env_3);
        }
      }
      /**
       * Focuses the first element that matches the `selector`.
       *
       * @param selector - The selector to query for.
       * @throws Throws if there's no element matching `selector`.
       */
      async focus(selector) {
        const env_4 = { stack: [], error: void 0, hasError: false };
        try {
          const handle = __addDisposableResource$c(env_4, await this.$(selector), false);
          assert$1(handle, `No element found for selector: ${selector}`);
          await handle.focus();
        } catch (e_4) {
          env_4.error = e_4;
          env_4.hasError = true;
        } finally {
          __disposeResources$c(env_4);
        }
      }
      /**
       * Hovers the pointer over the center of the first element that matches the
       * `selector`.
       *
       * @param selector - The selector to query for.
       * @throws Throws if there's no element matching `selector`.
       */
      async hover(selector) {
        const env_5 = { stack: [], error: void 0, hasError: false };
        try {
          const handle = __addDisposableResource$c(env_5, await this.$(selector), false);
          assert$1(handle, `No element found for selector: ${selector}`);
          await handle.hover();
        } catch (e_5) {
          env_5.error = e_5;
          env_5.hasError = true;
        } finally {
          __disposeResources$c(env_5);
        }
      }
      /**
       * Selects a set of value on the first `<select>` element that matches the
       * `selector`.
       *
       * @example
       *
       * ```ts
       * frame.select('select#colors', 'blue'); // single selection
       * frame.select('select#colors', 'red', 'green', 'blue'); // multiple selections
       * ```
       *
       * @param selector - The selector to query for.
       * @param values - The array of values to select. If the `<select>` has the
       * `multiple` attribute, all values are considered, otherwise only the first
       * one is taken into account.
       * @returns the list of values that were successfully selected.
       * @throws Throws if there's no `<select>` matching `selector`.
       */
      async select(selector, ...values) {
        const env_6 = { stack: [], error: void 0, hasError: false };
        try {
          const handle = __addDisposableResource$c(env_6, await this.$(selector), false);
          assert$1(handle, `No element found for selector: ${selector}`);
          return await handle.select(...values);
        } catch (e_6) {
          env_6.error = e_6;
          env_6.hasError = true;
        } finally {
          __disposeResources$c(env_6);
        }
      }
      /**
       * Taps the first element that matches the `selector`.
       *
       * @param selector - The selector to query for.
       * @throws Throws if there's no element matching `selector`.
       */
      async tap(selector) {
        const env_7 = { stack: [], error: void 0, hasError: false };
        try {
          const handle = __addDisposableResource$c(env_7, await this.$(selector), false);
          assert$1(handle, `No element found for selector: ${selector}`);
          await handle.tap();
        } catch (e_7) {
          env_7.error = e_7;
          env_7.hasError = true;
        } finally {
          __disposeResources$c(env_7);
        }
      }
      /**
       * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character
       * in the text.
       *
       * @remarks
       * To press a special key, like `Control` or `ArrowDown`, use
       * {@link Keyboard.press}.
       *
       * @example
       *
       * ```ts
       * await frame.type('#mytextarea', 'Hello'); // Types instantly
       * await frame.type('#mytextarea', 'World', {delay: 100}); // Types slower, like a user
       * ```
       *
       * @param selector - the selector for the element to type into. If there are
       * multiple the first will be used.
       * @param text - text to type into the element
       * @param options - takes one option, `delay`, which sets the time to wait
       * between key presses in milliseconds. Defaults to `0`.
       */
      async type(selector, text, options) {
        const env_8 = { stack: [], error: void 0, hasError: false };
        try {
          const handle = __addDisposableResource$c(env_8, await this.$(selector), false);
          assert$1(handle, `No element found for selector: ${selector}`);
          await handle.type(text, options);
        } catch (e_8) {
          env_8.error = e_8;
          env_8.hasError = true;
        } finally {
          __disposeResources$c(env_8);
        }
      }
      /**
       * The frame's title.
       */
      async title() {
        return await this.isolatedRealm().evaluate(() => {
          return document.title;
        });
      }
    }, __document = new WeakMap(), _Frame_instances = new WeakSet(), /**
     * @internal
     */
    document_fn = function() {
      if (!__privateGet(this, __document)) {
        __privateSet(this, __document, this.mainRealm().evaluateHandle(() => {
          return document;
        }));
      }
      return __privateGet(this, __document);
    }, (() => {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      _frameElement_decorators = [throwIfDetached];
      _evaluateHandle_decorators = [throwIfDetached];
      _evaluate_decorators = [throwIfDetached];
      _locator_decorators = [throwIfDetached];
      _$_decorators = [throwIfDetached];
      _$$_decorators = [throwIfDetached];
      _$eval_decorators = [throwIfDetached];
      _$$eval_decorators = [throwIfDetached];
      _waitForSelector_decorators = [throwIfDetached];
      _waitForFunction_decorators = [throwIfDetached];
      _content_decorators = [throwIfDetached];
      _addScriptTag_decorators = [throwIfDetached];
      _addStyleTag_decorators = [throwIfDetached];
      _click_decorators = [throwIfDetached];
      _focus_decorators = [throwIfDetached];
      _hover_decorators = [throwIfDetached];
      _select_decorators = [throwIfDetached];
      _tap_decorators = [throwIfDetached];
      _type_decorators = [throwIfDetached];
      _title_decorators = [throwIfDetached];
      __esDecorate$i(_a3, null, _frameElement_decorators, { kind: "method", name: "frameElement", static: false, private: false, access: { has: (obj) => "frameElement" in obj, get: (obj) => obj.frameElement }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$i(_a3, null, _evaluateHandle_decorators, { kind: "method", name: "evaluateHandle", static: false, private: false, access: { has: (obj) => "evaluateHandle" in obj, get: (obj) => obj.evaluateHandle }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$i(_a3, null, _evaluate_decorators, { kind: "method", name: "evaluate", static: false, private: false, access: { has: (obj) => "evaluate" in obj, get: (obj) => obj.evaluate }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$i(_a3, null, _locator_decorators, { kind: "method", name: "locator", static: false, private: false, access: { has: (obj) => "locator" in obj, get: (obj) => obj.locator }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$i(_a3, null, _$_decorators, { kind: "method", name: "$", static: false, private: false, access: { has: (obj) => "$" in obj, get: (obj) => obj.$ }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$i(_a3, null, _$$_decorators, { kind: "method", name: "$$", static: false, private: false, access: { has: (obj) => "$$" in obj, get: (obj) => obj.$$ }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$i(_a3, null, _$eval_decorators, { kind: "method", name: "$eval", static: false, private: false, access: { has: (obj) => "$eval" in obj, get: (obj) => obj.$eval }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$i(_a3, null, _$$eval_decorators, { kind: "method", name: "$$eval", static: false, private: false, access: { has: (obj) => "$$eval" in obj, get: (obj) => obj.$$eval }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$i(_a3, null, _waitForSelector_decorators, { kind: "method", name: "waitForSelector", static: false, private: false, access: { has: (obj) => "waitForSelector" in obj, get: (obj) => obj.waitForSelector }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$i(_a3, null, _waitForFunction_decorators, { kind: "method", name: "waitForFunction", static: false, private: false, access: { has: (obj) => "waitForFunction" in obj, get: (obj) => obj.waitForFunction }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$i(_a3, null, _content_decorators, { kind: "method", name: "content", static: false, private: false, access: { has: (obj) => "content" in obj, get: (obj) => obj.content }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$i(_a3, null, _addScriptTag_decorators, { kind: "method", name: "addScriptTag", static: false, private: false, access: { has: (obj) => "addScriptTag" in obj, get: (obj) => obj.addScriptTag }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$i(_a3, null, _addStyleTag_decorators, { kind: "method", name: "addStyleTag", static: false, private: false, access: { has: (obj) => "addStyleTag" in obj, get: (obj) => obj.addStyleTag }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$i(_a3, null, _click_decorators, { kind: "method", name: "click", static: false, private: false, access: { has: (obj) => "click" in obj, get: (obj) => obj.click }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$i(_a3, null, _focus_decorators, { kind: "method", name: "focus", static: false, private: false, access: { has: (obj) => "focus" in obj, get: (obj) => obj.focus }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$i(_a3, null, _hover_decorators, { kind: "method", name: "hover", static: false, private: false, access: { has: (obj) => "hover" in obj, get: (obj) => obj.hover }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$i(_a3, null, _select_decorators, { kind: "method", name: "select", static: false, private: false, access: { has: (obj) => "select" in obj, get: (obj) => obj.select }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$i(_a3, null, _tap_decorators, { kind: "method", name: "tap", static: false, private: false, access: { has: (obj) => "tap" in obj, get: (obj) => obj.tap }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$i(_a3, null, _type_decorators, { kind: "method", name: "type", static: false, private: false, access: { has: (obj) => "type" in obj, get: (obj) => obj.type }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$i(_a3, null, _title_decorators, { kind: "method", name: "title", static: false, private: false, access: { has: (obj) => "title" in obj, get: (obj) => obj.title }, metadata: _metadata }, null, _instanceExtraInitializers);
      if (_metadata) Object.defineProperty(_a3, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    })(), _a3;
  })();
  class HTTPRequest {
    /**
     * @internal
     */
    constructor() {
      __privateAdd(this, _HTTPRequest_instances);
      /**
       * @internal
       */
      __publicField(this, "_interceptionId");
      /**
       * @internal
       */
      __publicField(this, "_failureText", null);
      /**
       * @internal
       */
      __publicField(this, "_response", null);
      /**
       * @internal
       */
      __publicField(this, "_fromMemoryCache", false);
      /**
       * @internal
       */
      __publicField(this, "_redirectChain", []);
      /**
       * @internal
       */
      __publicField(this, "interception", {
        enabled: false,
        handled: false,
        handlers: [],
        resolutionState: {
          action: InterceptResolutionAction.None
        },
        requestOverrides: {},
        response: null,
        abortReason: null
      });
    }
    /**
     * The `ContinueRequestOverrides` that will be used
     * if the interception is allowed to continue (ie, `abort()` and
     * `respond()` aren't called).
     */
    continueRequestOverrides() {
      assert$1(this.interception.enabled, "Request Interception is not enabled!");
      return this.interception.requestOverrides;
    }
    /**
     * The `ResponseForRequest` that gets used if the
     * interception is allowed to respond (ie, `abort()` is not called).
     */
    responseForRequest() {
      assert$1(this.interception.enabled, "Request Interception is not enabled!");
      return this.interception.response;
    }
    /**
     * The most recent reason for aborting the request
     */
    abortErrorReason() {
      assert$1(this.interception.enabled, "Request Interception is not enabled!");
      return this.interception.abortReason;
    }
    /**
     * An InterceptResolutionState object describing the current resolution
     * action and priority.
     *
     * InterceptResolutionState contains:
     * action: InterceptResolutionAction
     * priority?: number
     *
     * InterceptResolutionAction is one of: `abort`, `respond`, `continue`,
     * `disabled`, `none`, or `already-handled`.
     */
    interceptResolutionState() {
      if (!this.interception.enabled) {
        return { action: InterceptResolutionAction.Disabled };
      }
      if (this.interception.handled) {
        return { action: InterceptResolutionAction.AlreadyHandled };
      }
      return { ...this.interception.resolutionState };
    }
    /**
     * Is `true` if the intercept resolution has already been handled,
     * `false` otherwise.
     */
    isInterceptResolutionHandled() {
      return this.interception.handled;
    }
    /**
     * Adds an async request handler to the processing queue.
     * Deferred handlers are not guaranteed to execute in any particular order,
     * but they are guaranteed to resolve before the request interception
     * is finalized.
     */
    enqueueInterceptAction(pendingHandler) {
      this.interception.handlers.push(pendingHandler);
    }
    /**
     * Awaits pending interception handlers and then decides how to fulfill
     * the request interception.
     */
    async finalizeInterceptions() {
      await this.interception.handlers.reduce((promiseChain, interceptAction) => {
        return promiseChain.then(interceptAction);
      }, Promise.resolve());
      this.interception.handlers = [];
      const { action } = this.interceptResolutionState();
      switch (action) {
        case "abort":
          return await this._abort(this.interception.abortReason);
        case "respond":
          if (this.interception.response === null) {
            throw new Error("Response is missing for the interception");
          }
          return await this._respond(this.interception.response);
        case "continue":
          return await this._continue(this.interception.requestOverrides);
      }
    }
    /**
     * Continues request with optional request overrides.
     *
     * @example
     *
     * ```ts
     * await page.setRequestInterception(true);
     * page.on('request', request => {
     *   // Override headers
     *   const headers = Object.assign({}, request.headers(), {
     *     foo: 'bar', // set "foo" header
     *     origin: undefined, // remove "origin" header
     *   });
     *   request.continue({headers});
     * });
     * ```
     *
     * @param overrides - optional overrides to apply to the request.
     * @param priority - If provided, intercept is resolved using cooperative
     * handling rules. Otherwise, intercept is resolved immediately.
     *
     * @remarks
     *
     * To use this, request interception should be enabled with
     * {@link Page.setRequestInterception}.
     *
     * Exception is immediately thrown if the request interception is not enabled.
     */
    async continue(overrides = {}, priority) {
      if (!__privateMethod(this, _HTTPRequest_instances, canBeIntercepted_fn).call(this)) {
        return;
      }
      assert$1(this.interception.enabled, "Request Interception is not enabled!");
      assert$1(!this.interception.handled, "Request is already handled!");
      if (priority === void 0) {
        return await this._continue(overrides);
      }
      this.interception.requestOverrides = overrides;
      if (this.interception.resolutionState.priority === void 0 || priority > this.interception.resolutionState.priority) {
        this.interception.resolutionState = {
          action: InterceptResolutionAction.Continue,
          priority
        };
        return;
      }
      if (priority === this.interception.resolutionState.priority) {
        if (this.interception.resolutionState.action === "abort" || this.interception.resolutionState.action === "respond") {
          return;
        }
        this.interception.resolutionState.action = InterceptResolutionAction.Continue;
      }
      return;
    }
    /**
     * Fulfills a request with the given response.
     *
     * @example
     * An example of fulfilling all requests with 404 responses:
     *
     * ```ts
     * await page.setRequestInterception(true);
     * page.on('request', request => {
     *   request.respond({
     *     status: 404,
     *     contentType: 'text/plain',
     *     body: 'Not Found!',
     *   });
     * });
     * ```
     *
     * NOTE: Mocking responses for dataURL requests is not supported.
     * Calling `request.respond` for a dataURL request is a noop.
     *
     * @param response - the response to fulfill the request with.
     * @param priority - If provided, intercept is resolved using
     * cooperative handling rules. Otherwise, intercept is resolved
     * immediately.
     *
     * @remarks
     *
     * To use this, request
     * interception should be enabled with {@link Page.setRequestInterception}.
     *
     * Exception is immediately thrown if the request interception is not enabled.
     */
    async respond(response, priority) {
      if (!__privateMethod(this, _HTTPRequest_instances, canBeIntercepted_fn).call(this)) {
        return;
      }
      assert$1(this.interception.enabled, "Request Interception is not enabled!");
      assert$1(!this.interception.handled, "Request is already handled!");
      if (priority === void 0) {
        return await this._respond(response);
      }
      this.interception.response = response;
      if (this.interception.resolutionState.priority === void 0 || priority > this.interception.resolutionState.priority) {
        this.interception.resolutionState = {
          action: InterceptResolutionAction.Respond,
          priority
        };
        return;
      }
      if (priority === this.interception.resolutionState.priority) {
        if (this.interception.resolutionState.action === "abort") {
          return;
        }
        this.interception.resolutionState.action = InterceptResolutionAction.Respond;
      }
    }
    /**
     * Aborts a request.
     *
     * @param errorCode - optional error code to provide.
     * @param priority - If provided, intercept is resolved using
     * cooperative handling rules. Otherwise, intercept is resolved
     * immediately.
     *
     * @remarks
     *
     * To use this, request interception should be enabled with
     * {@link Page.setRequestInterception}. If it is not enabled, this method will
     * throw an exception immediately.
     */
    async abort(errorCode = "failed", priority) {
      if (!__privateMethod(this, _HTTPRequest_instances, canBeIntercepted_fn).call(this)) {
        return;
      }
      const errorReason = errorReasons[errorCode];
      assert$1(errorReason, "Unknown error code: " + errorCode);
      assert$1(this.interception.enabled, "Request Interception is not enabled!");
      assert$1(!this.interception.handled, "Request is already handled!");
      if (priority === void 0) {
        return await this._abort(errorReason);
      }
      this.interception.abortReason = errorReason;
      if (this.interception.resolutionState.priority === void 0 || priority >= this.interception.resolutionState.priority) {
        this.interception.resolutionState = {
          action: InterceptResolutionAction.Abort,
          priority
        };
        return;
      }
    }
    /**
     * @internal
     */
    static getResponse(body) {
      const byteBody = isString(body) ? new TextEncoder().encode(body) : body;
      return {
        contentLength: byteBody.byteLength,
        base64: typedArrayToBase64(byteBody)
      };
    }
  }
  _HTTPRequest_instances = new WeakSet();
  canBeIntercepted_fn = function() {
    return !this.url().startsWith("data:") && !this._fromMemoryCache;
  };
  var InterceptResolutionAction;
  (function(InterceptResolutionAction2) {
    InterceptResolutionAction2["Abort"] = "abort";
    InterceptResolutionAction2["Respond"] = "respond";
    InterceptResolutionAction2["Continue"] = "continue";
    InterceptResolutionAction2["Disabled"] = "disabled";
    InterceptResolutionAction2["None"] = "none";
    InterceptResolutionAction2["AlreadyHandled"] = "already-handled";
  })(InterceptResolutionAction || (InterceptResolutionAction = {}));
  function headersArray(headers) {
    const result = [];
    for (const name in headers) {
      const value = headers[name];
      if (!Object.is(value, void 0)) {
        const values = Array.isArray(value) ? value : [value];
        result.push(...values.map((value2) => {
          return { name, value: value2 + "" };
        }));
      }
    }
    return result;
  }
  const STATUS_TEXTS = {
    "100": "Continue",
    "101": "Switching Protocols",
    "102": "Processing",
    "103": "Early Hints",
    "200": "OK",
    "201": "Created",
    "202": "Accepted",
    "203": "Non-Authoritative Information",
    "204": "No Content",
    "205": "Reset Content",
    "206": "Partial Content",
    "207": "Multi-Status",
    "208": "Already Reported",
    "226": "IM Used",
    "300": "Multiple Choices",
    "301": "Moved Permanently",
    "302": "Found",
    "303": "See Other",
    "304": "Not Modified",
    "305": "Use Proxy",
    "306": "Switch Proxy",
    "307": "Temporary Redirect",
    "308": "Permanent Redirect",
    "400": "Bad Request",
    "401": "Unauthorized",
    "402": "Payment Required",
    "403": "Forbidden",
    "404": "Not Found",
    "405": "Method Not Allowed",
    "406": "Not Acceptable",
    "407": "Proxy Authentication Required",
    "408": "Request Timeout",
    "409": "Conflict",
    "410": "Gone",
    "411": "Length Required",
    "412": "Precondition Failed",
    "413": "Payload Too Large",
    "414": "URI Too Long",
    "415": "Unsupported Media Type",
    "416": "Range Not Satisfiable",
    "417": "Expectation Failed",
    "418": "I'm a teapot",
    "421": "Misdirected Request",
    "422": "Unprocessable Entity",
    "423": "Locked",
    "424": "Failed Dependency",
    "425": "Too Early",
    "426": "Upgrade Required",
    "428": "Precondition Required",
    "429": "Too Many Requests",
    "431": "Request Header Fields Too Large",
    "451": "Unavailable For Legal Reasons",
    "500": "Internal Server Error",
    "501": "Not Implemented",
    "502": "Bad Gateway",
    "503": "Service Unavailable",
    "504": "Gateway Timeout",
    "505": "HTTP Version Not Supported",
    "506": "Variant Also Negotiates",
    "507": "Insufficient Storage",
    "508": "Loop Detected",
    "510": "Not Extended",
    "511": "Network Authentication Required"
  };
  const errorReasons = {
    aborted: "Aborted",
    accessdenied: "AccessDenied",
    addressunreachable: "AddressUnreachable",
    blockedbyclient: "BlockedByClient",
    blockedbyresponse: "BlockedByResponse",
    connectionaborted: "ConnectionAborted",
    connectionclosed: "ConnectionClosed",
    connectionfailed: "ConnectionFailed",
    connectionrefused: "ConnectionRefused",
    connectionreset: "ConnectionReset",
    internetdisconnected: "InternetDisconnected",
    namenotresolved: "NameNotResolved",
    timedout: "TimedOut",
    failed: "Failed"
  };
  function handleError(error) {
    if (error.originalMessage.includes("Invalid header") || error.originalMessage.includes('Expected "header"') || // WebDriver BiDi error for invalid values, for example, headers.
    error.originalMessage.includes("invalid argument")) {
      throw error;
    }
    debugError(error);
  }
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class HTTPResponse {
    /**
     * @internal
     */
    constructor() {
    }
    /**
     * True if the response was successful (status in the range 200-299).
     */
    ok() {
      const status = this.status();
      return status === 0 || status >= 200 && status <= 299;
    }
    /**
     * {@inheritDoc HTTPResponse.content}
     */
    async buffer() {
      const content = await this.content();
      return Buffer.from(content);
    }
    /**
     * Promise which resolves to a text (utf8) representation of response body.
     */
    async text() {
      const content = await this.content();
      return new TextDecoder().decode(content);
    }
    /**
     * Promise which resolves to a JSON representation of response body.
     *
     * @remarks
     *
     * This method will throw if the response body is not parsable via
     * `JSON.parse`.
     */
    async json() {
      const content = await this.text();
      return JSON.parse(content);
    }
  }
  /**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  function createIncrementalIdGenerator() {
    let id = 0;
    return () => {
      return ++id;
    };
  }
  /**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class Keyboard {
    /**
     * @internal
     */
    constructor() {
    }
  }
  const MouseButton = Object.freeze({
    Left: "left",
    Right: "right",
    Middle: "middle",
    Back: "back",
    Forward: "forward"
  });
  class Mouse {
    /**
     * @internal
     */
    constructor() {
    }
  }
  class Touchscreen {
    /**
     * @internal
     */
    constructor() {
      /**
       * @internal
       */
      __publicField(this, "idGenerator", createIncrementalIdGenerator());
      /**
       * @internal
       */
      __publicField(this, "touches", []);
    }
    /**
     * @internal
     */
    removeHandle(handle) {
      const index = this.touches.indexOf(handle);
      if (index === -1) {
        return;
      }
      this.touches.splice(index, 1);
    }
    /**
     * Dispatches a `touchstart` and `touchend` event.
     * @param x - Horizontal position of the tap.
     * @param y - Vertical position of the tap.
     */
    async tap(x, y) {
      const touch = await this.touchStart(x, y);
      await touch.end();
    }
    /**
     * Dispatches a `touchMove` event on the first touch that is active.
     * @param x - Horizontal position of the move.
     * @param y - Vertical position of the move.
     *
     * @remarks
     *
     * Not every `touchMove` call results in a `touchmove` event being emitted,
     * depending on the browser's optimizations. For example, Chrome
     * {@link https://developer.chrome.com/blog/a-more-compatible-smoother-touch/#chromes-new-model-the-throttled-async-touchmove-model | throttles}
     * touch move events.
     */
    async touchMove(x, y) {
      const touch = this.touches[0];
      if (!touch) {
        throw new TouchError("Must start a new Touch first");
      }
      return await touch.move(x, y);
    }
    /**
     * Dispatches a `touchend` event on the first touch that is active.
     */
    async touchEnd() {
      const touch = this.touches.shift();
      if (!touch) {
        throw new TouchError("Must start a new Touch first");
      }
      await touch.end();
    }
  }
  /**
   * @license
   * Copyright 2019 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  const DEFAULT_TIMEOUT = 3e4;
  class TimeoutSettings {
    constructor() {
      __privateAdd(this, _defaultTimeout);
      __privateAdd(this, _defaultNavigationTimeout);
      __privateSet(this, _defaultTimeout, null);
      __privateSet(this, _defaultNavigationTimeout, null);
    }
    setDefaultTimeout(timeout2) {
      __privateSet(this, _defaultTimeout, timeout2);
    }
    setDefaultNavigationTimeout(timeout2) {
      __privateSet(this, _defaultNavigationTimeout, timeout2);
    }
    navigationTimeout() {
      if (__privateGet(this, _defaultNavigationTimeout) !== null) {
        return __privateGet(this, _defaultNavigationTimeout);
      }
      if (__privateGet(this, _defaultTimeout) !== null) {
        return __privateGet(this, _defaultTimeout);
      }
      return DEFAULT_TIMEOUT;
    }
    timeout() {
      if (__privateGet(this, _defaultTimeout) !== null) {
        return __privateGet(this, _defaultTimeout);
      }
      return DEFAULT_TIMEOUT;
    }
  }
  _defaultTimeout = new WeakMap();
  _defaultNavigationTimeout = new WeakMap();
  /**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var __runInitializers$h = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i2 = 0; i2 < initializers.length; i2++) {
      value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate$h = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind2 = contextIn.kind, key = kind2 === "getter" ? "get" : kind2 === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function(f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i2])(kind2 === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind2 === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_ = accept(result.get)) descriptor.get = _;
        if (_ = accept(result.set)) descriptor.set = _;
        if (_ = accept(result.init)) initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind2 === "field") initializers.unshift(_);
        else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  var __addDisposableResource$b = function(env, value, async2) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async2) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async2) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({ value, dispose, async: async2 });
    } else if (async2) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources$b = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  function setDefaultScreenshotOptions(options) {
    options.optimizeForSpeed ?? (options.optimizeForSpeed = false);
    options.type ?? (options.type = "png");
    options.fromSurface ?? (options.fromSurface = true);
    options.fullPage ?? (options.fullPage = false);
    options.omitBackground ?? (options.omitBackground = false);
    options.encoding ?? (options.encoding = "binary");
    options.captureBeyondViewport ?? (options.captureBeyondViewport = true);
  }
  let Page$4 = (() => {
    var _requestHandlers, _inflight$, _screencastSessionCount, _startScreencastPromise, _Page_instances, getNativePixelDimensions_fn, _a3;
    let _classSuper = EventEmitter$1;
    let _instanceExtraInitializers = [];
    let _screenshot_decorators;
    return _a3 = class extends _classSuper {
      /**
       * @internal
       */
      constructor() {
        super();
        __privateAdd(this, _Page_instances);
        /**
         * @internal
         */
        __publicField(this, "_isDragging", (__runInitializers$h(this, _instanceExtraInitializers), false));
        /**
         * @internal
         */
        __publicField(this, "_timeoutSettings", new TimeoutSettings());
        __privateAdd(this, _requestHandlers, /* @__PURE__ */ new WeakMap());
        __privateAdd(this, _inflight$, new ReplaySubject(1));
        __privateAdd(this, _screencastSessionCount, 0);
        __privateAdd(this, _startScreencastPromise);
        fromEmitterEvent(
          this,
          "request"
          /* PageEvent.Request */
        ).pipe(mergeMap((originalRequest) => {
          return concat$1(of(1), merge(fromEmitterEvent(
            this,
            "requestfailed"
            /* PageEvent.RequestFailed */
          ), fromEmitterEvent(
            this,
            "requestfinished"
            /* PageEvent.RequestFinished */
          ), fromEmitterEvent(
            this,
            "response"
            /* PageEvent.Response */
          ).pipe(map((response) => {
            return response.request();
          }))).pipe(filter((request) => {
            return request.id === originalRequest.id;
          }), take(1), map(() => {
            return -1;
          })));
        }), mergeScan((acc, addend) => {
          return of(acc + addend);
        }, 0), takeUntil(fromEmitterEvent(
          this,
          "close"
          /* PageEvent.Close */
        )), startWith(0)).subscribe(__privateGet(this, _inflight$));
      }
      /**
       * Listen to page events.
       *
       * @remarks
       * This method exists to define event typings and handle proper wireup of
       * cooperative request interception. Actual event listening and dispatching is
       * delegated to {@link EventEmitter}.
       *
       * @internal
       */
      on(type, handler) {
        if (type !== "request") {
          return super.on(type, handler);
        }
        let wrapper = __privateGet(this, _requestHandlers).get(handler);
        if (wrapper === void 0) {
          wrapper = (event) => {
            event.enqueueInterceptAction(() => {
              return handler(event);
            });
          };
          __privateGet(this, _requestHandlers).set(handler, wrapper);
        }
        return super.on(type, wrapper);
      }
      /**
       * @internal
       */
      off(type, handler) {
        if (type === "request") {
          handler = __privateGet(this, _requestHandlers).get(handler) || handler;
        }
        return super.off(type, handler);
      }
      /**
       * {@inheritDoc Accessibility}
       */
      get accessibility() {
        return this.mainFrame().accessibility;
      }
      locator(selectorOrFunc) {
        if (typeof selectorOrFunc === "string") {
          return NodeLocator.create(this, selectorOrFunc);
        } else {
          return FunctionLocator.create(this, selectorOrFunc);
        }
      }
      /**
       * A shortcut for {@link Locator.race} that does not require static imports.
       *
       * @internal
       */
      locatorRace(locators) {
        return Locator.race(locators);
      }
      /**
       * Finds the first element that matches the selector. If no element matches
       * the selector, the return value resolves to `null`.
       *
       * @param selector -
       * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
       * to query the page for.
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
       * can be passed as-is and a
       * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
       * allows quering by
       * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
       * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
       * and
       * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
       * and
       * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
       * Alternatively, you can specify the selector type using a
       * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
       *
       * @remarks
       *
       * Shortcut for {@link Frame.$ | Page.mainFrame().$(selector) }.
       */
      async $(selector) {
        return await this.mainFrame().$(selector);
      }
      /**
       * Finds elements on the page that match the selector. If no elements
       * match the selector, the return value resolves to `[]`.
       *
       * @param selector -
       * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
       * to query the page for.
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
       * can be passed as-is and a
       * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
       * allows quering by
       * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
       * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
       * and
       * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
       * and
       * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
       * Alternatively, you can specify the selector type using a
       * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
       *
       * @remarks
       *
       * Shortcut for {@link Frame.$$ | Page.mainFrame().$$(selector) }.
       */
      async $$(selector, options) {
        return await this.mainFrame().$$(selector, options);
      }
      /**
       * @remarks
       *
       * The only difference between {@link Page.evaluate | page.evaluate} and
       * `page.evaluateHandle` is that `evaluateHandle` will return the value
       * wrapped in an in-page object.
       *
       * If the function passed to `page.evaluateHandle` returns a Promise, the
       * function will wait for the promise to resolve and return its value.
       *
       * You can pass a string instead of a function (although functions are
       * recommended as they are easier to debug and use with TypeScript):
       *
       * @example
       *
       * ```ts
       * const aHandle = await page.evaluateHandle('document');
       * ```
       *
       * @example
       * {@link JSHandle} instances can be passed as arguments to the `pageFunction`:
       *
       * ```ts
       * const aHandle = await page.evaluateHandle(() => document.body);
       * const resultHandle = await page.evaluateHandle(
       *   body => body.innerHTML,
       *   aHandle,
       * );
       * console.log(await resultHandle.jsonValue());
       * await resultHandle.dispose();
       * ```
       *
       * Most of the time this function returns a {@link JSHandle},
       * but if `pageFunction` returns a reference to an element,
       * you instead get an {@link ElementHandle} back:
       *
       * @example
       *
       * ```ts
       * const button = await page.evaluateHandle(() =>
       *   document.querySelector('button'),
       * );
       * // can call `click` because `button` is an `ElementHandle`
       * await button.click();
       * ```
       *
       * The TypeScript definitions assume that `evaluateHandle` returns
       * a `JSHandle`, but if you know it's going to return an
       * `ElementHandle`, pass it as the generic argument:
       *
       * ```ts
       * const button = await page.evaluateHandle<ElementHandle>(...);
       * ```
       *
       * @param pageFunction - a function that is run within the page
       * @param args - arguments to be passed to the pageFunction
       */
      async evaluateHandle(pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
        return await this.mainFrame().evaluateHandle(pageFunction, ...args);
      }
      /**
       * This method finds the first element within the page that matches the selector
       * and passes the result as the first argument to the `pageFunction`.
       *
       * @remarks
       *
       * If no element is found matching `selector`, the method will throw an error.
       *
       * If `pageFunction` returns a promise `$eval` will wait for the promise to
       * resolve and then return its value.
       *
       * @example
       *
       * ```ts
       * const searchValue = await page.$eval('#search', el => el.value);
       * const preloadHref = await page.$eval('link[rel=preload]', el => el.href);
       * const html = await page.$eval('.main-container', el => el.outerHTML);
       * ```
       *
       * If you are using TypeScript, you may have to provide an explicit type to the
       * first argument of the `pageFunction`.
       * By default it is typed as `Element`, but you may need to provide a more
       * specific sub-type:
       *
       * @example
       *
       * ```ts
       * // if you don't provide HTMLInputElement here, TS will error
       * // as `value` is not on `Element`
       * const searchValue = await page.$eval(
       *   '#search',
       *   (el: HTMLInputElement) => el.value,
       * );
       * ```
       *
       * The compiler should be able to infer the return type
       * from the `pageFunction` you provide. If it is unable to, you can use the generic
       * type to tell the compiler what return type you expect from `$eval`:
       *
       * @example
       *
       * ```ts
       * // The compiler can infer the return type in this case, but if it can't
       * // or if you want to be more explicit, provide it as the generic type.
       * const searchValue = await page.$eval<string>(
       *   '#search',
       *   (el: HTMLInputElement) => el.value,
       * );
       * ```
       *
       * @param selector -
       * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
       * to query the page for.
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
       * can be passed as-is and a
       * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
       * allows quering by
       * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
       * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
       * and
       * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
       * and
       * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
       * Alternatively, you can specify the selector type using a
       * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
       * @param pageFunction - the function to be evaluated in the page context.
       * Will be passed the result of the element matching the selector as its
       * first argument.
       * @param args - any additional arguments to pass through to `pageFunction`.
       *
       * @returns The result of calling `pageFunction`. If it returns an element it
       * is wrapped in an {@link ElementHandle}, else the raw value itself is
       * returned.
       */
      async $eval(selector, pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
        return await this.mainFrame().$eval(selector, pageFunction, ...args);
      }
      /**
       * This method returns all elements matching the selector and passes the
       * resulting array as the first argument to the `pageFunction`.
       *
       * @remarks
       * If `pageFunction` returns a promise `$$eval` will wait for the promise to
       * resolve and then return its value.
       *
       * @example
       *
       * ```ts
       * // get the amount of divs on the page
       * const divCount = await page.$$eval('div', divs => divs.length);
       *
       * // get the text content of all the `.options` elements:
       * const options = await page.$$eval('div > span.options', options => {
       *   return options.map(option => option.textContent);
       * });
       * ```
       *
       * If you are using TypeScript, you may have to provide an explicit type to the
       * first argument of the `pageFunction`.
       * By default it is typed as `Element[]`, but you may need to provide a more
       * specific sub-type:
       *
       * @example
       *
       * ```ts
       * await page.$$eval('input', elements => {
       *   return elements.map(e => e.value);
       * });
       * ```
       *
       * The compiler should be able to infer the return type
       * from the `pageFunction` you provide. If it is unable to, you can use the generic
       * type to tell the compiler what return type you expect from `$$eval`:
       *
       * @example
       *
       * ```ts
       * const allInputValues = await page.$$eval('input', elements =>
       *   elements.map(e => e.textContent),
       * );
       * ```
       *
       * @param selector -
       * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
       * to query the page for.
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
       * can be passed as-is and a
       * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
       * allows quering by
       * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
       * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
       * and
       * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
       * and
       * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
       * Alternatively, you can specify the selector type using a
       * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
       * @param pageFunction - the function to be evaluated in the page context.
       * Will be passed an array of matching elements as its first argument.
       * @param args - any additional arguments to pass through to `pageFunction`.
       *
       * @returns The result of calling `pageFunction`. If it returns an element it
       * is wrapped in an {@link ElementHandle}, else the raw value itself is
       * returned.
       */
      async $$eval(selector, pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
        return await this.mainFrame().$$eval(selector, pageFunction, ...args);
      }
      /**
       * Adds a `<script>` tag into the page with the desired URL or content.
       *
       * @remarks
       * Shortcut for
       * {@link Frame.addScriptTag | page.mainFrame().addScriptTag(options)}.
       *
       * @param options - Options for the script.
       * @returns An {@link ElementHandle | element handle} to the injected
       * `<script>` element.
       */
      async addScriptTag(options) {
        return await this.mainFrame().addScriptTag(options);
      }
      async addStyleTag(options) {
        return await this.mainFrame().addStyleTag(options);
      }
      /**
       * The page's URL.
       *
       * @remarks
       *
       * Shortcut for {@link Frame.url | page.mainFrame().url()}.
       */
      url() {
        return this.mainFrame().url();
      }
      /**
       * The full HTML contents of the page, including the DOCTYPE.
       */
      async content() {
        return await this.mainFrame().content();
      }
      /**
       * Set the content of the page.
       *
       * @param html - HTML markup to assign to the page.
       * @param options - Parameters that has some properties.
       */
      async setContent(html, options) {
        await this.mainFrame().setContent(html, options);
      }
      /**
       * {@inheritDoc Frame.goto}
       */
      async goto(url, options) {
        return await this.mainFrame().goto(url, options);
      }
      /**
       * Waits for the page to navigate to a new URL or to reload. It is useful when
       * you run code that will indirectly cause the page to navigate.
       *
       * @example
       *
       * ```ts
       * const [response] = await Promise.all([
       *   page.waitForNavigation(), // The promise resolves after navigation has finished
       *   page.click('a.my-link'), // Clicking the link will indirectly cause a navigation
       * ]);
       * ```
       *
       * @remarks
       *
       * Usage of the
       * {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API}
       * to change the URL is considered a navigation.
       *
       * @param options - Navigation parameters which might have the following
       * properties:
       * @returns A `Promise` which resolves to the main resource response.
       *
       * - In case of multiple redirects, the navigation will resolve with the
       *   response of the last redirect.
       * - In case of navigation to a different anchor or navigation due to History
       *   API usage, the navigation will resolve with `null`.
       */
      async waitForNavigation(options = {}) {
        return await this.mainFrame().waitForNavigation(options);
      }
      /**
       * @param urlOrPredicate - A URL or predicate to wait for
       * @param options - Optional waiting parameters
       * @returns Promise which resolves to the matched request
       * @example
       *
       * ```ts
       * const firstRequest = await page.waitForRequest(
       *   'https://example.com/resource',
       * );
       * const finalRequest = await page.waitForRequest(
       *   request => request.url() === 'https://example.com',
       * );
       * return finalRequest.response()?.ok();
       * ```
       *
       * @remarks
       * Optional Waiting Parameters have:
       *
       * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds, pass
       *   `0` to disable the timeout. The default value can be changed by using the
       *   {@link Page.setDefaultTimeout} method.
       */
      waitForRequest(urlOrPredicate, options = {}) {
        const { timeout: ms2 = this._timeoutSettings.timeout(), signal } = options;
        if (typeof urlOrPredicate === "string") {
          const url = urlOrPredicate;
          urlOrPredicate = (request) => {
            return request.url() === url;
          };
        }
        const observable$ = fromEmitterEvent(
          this,
          "request"
          /* PageEvent.Request */
        ).pipe(filterAsync(urlOrPredicate), raceWith(timeout(ms2), fromAbortSignal(signal), fromEmitterEvent(
          this,
          "close"
          /* PageEvent.Close */
        ).pipe(map(() => {
          throw new TargetCloseError("Page closed!");
        }))));
        return firstValueFrom(observable$);
      }
      /**
       * @param urlOrPredicate - A URL or predicate to wait for.
       * @param options - Optional waiting parameters
       * @returns Promise which resolves to the matched response.
       * @example
       *
       * ```ts
       * const firstResponse = await page.waitForResponse(
       *   'https://example.com/resource',
       * );
       * const finalResponse = await page.waitForResponse(
       *   response =>
       *     response.url() === 'https://example.com' && response.status() === 200,
       * );
       * const finalResponse = await page.waitForResponse(async response => {
       *   return (await response.text()).includes('<html>');
       * });
       * return finalResponse.ok();
       * ```
       *
       * @remarks
       * Optional Parameter have:
       *
       * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds,
       *   pass `0` to disable the timeout. The default value can be changed by using
       *   the {@link Page.setDefaultTimeout} method.
       */
      waitForResponse(urlOrPredicate, options = {}) {
        const { timeout: ms2 = this._timeoutSettings.timeout(), signal } = options;
        if (typeof urlOrPredicate === "string") {
          const url = urlOrPredicate;
          urlOrPredicate = (response) => {
            return response.url() === url;
          };
        }
        const observable$ = fromEmitterEvent(
          this,
          "response"
          /* PageEvent.Response */
        ).pipe(filterAsync(urlOrPredicate), raceWith(timeout(ms2), fromAbortSignal(signal), fromEmitterEvent(
          this,
          "close"
          /* PageEvent.Close */
        ).pipe(map(() => {
          throw new TargetCloseError("Page closed!");
        }))));
        return firstValueFrom(observable$);
      }
      /**
       * Waits for the network to be idle.
       *
       * @param options - Options to configure waiting behavior.
       * @returns A promise which resolves once the network is idle.
       */
      waitForNetworkIdle(options = {}) {
        return firstValueFrom(this.waitForNetworkIdle$(options));
      }
      /**
       * @internal
       */
      waitForNetworkIdle$(options = {}) {
        const { timeout: ms2 = this._timeoutSettings.timeout(), idleTime = NETWORK_IDLE_TIME, concurrency = 0, signal } = options;
        return __privateGet(this, _inflight$).pipe(switchMap((inflight) => {
          if (inflight > concurrency) {
            return EMPTY;
          }
          return timer(idleTime);
        }), map(() => {
        }), raceWith(timeout(ms2), fromAbortSignal(signal), fromEmitterEvent(
          this,
          "close"
          /* PageEvent.Close */
        ).pipe(map(() => {
          throw new TargetCloseError("Page closed!");
        }))));
      }
      /**
       * Waits for a frame matching the given conditions to appear.
       *
       * @example
       *
       * ```ts
       * const frame = await page.waitForFrame(async frame => {
       *   return frame.name() === 'Test';
       * });
       * ```
       */
      async waitForFrame(urlOrPredicate, options = {}) {
        const { timeout: ms2 = this.getDefaultTimeout(), signal } = options;
        const predicate = isString(urlOrPredicate) ? (frame) => {
          return urlOrPredicate === frame.url();
        } : urlOrPredicate;
        return await firstValueFrom(merge(fromEmitterEvent(
          this,
          "frameattached"
          /* PageEvent.FrameAttached */
        ), fromEmitterEvent(
          this,
          "framenavigated"
          /* PageEvent.FrameNavigated */
        ), from(this.frames())).pipe(filterAsync(predicate), first(), raceWith(timeout(ms2), fromAbortSignal(signal), fromEmitterEvent(
          this,
          "close"
          /* PageEvent.Close */
        ).pipe(map(() => {
          throw new TargetCloseError("Page closed.");
        })))));
      }
      /**
       * Emulates a given device's metrics and user agent.
       *
       * To aid emulation, Puppeteer provides a list of known devices that can be
       * via {@link KnownDevices}.
       *
       * @remarks
       * This method is a shortcut for calling two methods:
       * {@link Page.setUserAgent} and {@link Page.setViewport}.
       *
       * This method will resize the page. A lot of websites don't expect phones to
       * change size, so you should emulate before navigating to the page.
       *
       * @example
       *
       * ```ts
       * import {KnownDevices} from 'puppeteer';
       * const iPhone = KnownDevices['iPhone 15 Pro'];
       *
       * (async () => {
       *   const browser = await puppeteer.launch();
       *   const page = await browser.newPage();
       *   await page.emulate(iPhone);
       *   await page.goto('https://www.google.com');
       *   // other actions...
       *   await browser.close();
       * })();
       * ```
       */
      async emulate(device) {
        await Promise.all([
          this.setUserAgent(device.userAgent),
          this.setViewport(device.viewport)
        ]);
      }
      /**
       * Evaluates a function in the page's context and returns the result.
       *
       * If the function passed to `page.evaluate` returns a Promise, the
       * function will wait for the promise to resolve and return its value.
       *
       * @example
       *
       * ```ts
       * const result = await frame.evaluate(() => {
       *   return Promise.resolve(8 * 7);
       * });
       * console.log(result); // prints "56"
       * ```
       *
       * You can pass a string instead of a function (although functions are
       * recommended as they are easier to debug and use with TypeScript):
       *
       * @example
       *
       * ```ts
       * const aHandle = await page.evaluate('1 + 2');
       * ```
       *
       * To get the best TypeScript experience, you should pass in as the
       * generic the type of `pageFunction`:
       *
       * ```ts
       * const aHandle = await page.evaluate(() => 2);
       * ```
       *
       * @example
       *
       * {@link ElementHandle} instances (including {@link JSHandle}s) can be passed
       * as arguments to the `pageFunction`:
       *
       * ```ts
       * const bodyHandle = await page.$('body');
       * const html = await page.evaluate(body => body.innerHTML, bodyHandle);
       * await bodyHandle.dispose();
       * ```
       *
       * @param pageFunction - a function that is run within the page
       * @param args - arguments to be passed to the pageFunction
       *
       * @returns the return value of `pageFunction`.
       */
      async evaluate(pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
        return await this.mainFrame().evaluate(pageFunction, ...args);
      }
      /**
       * @internal
       */
      async _maybeWriteTypedArrayToFile(path, typedArray) {
        if (!path) {
          return;
        }
        await environment.value.fs.promises.writeFile(path, typedArray);
      }
      /**
       * Captures a screencast of this {@link Page | page}.
       *
       * @example
       * Recording a {@link Page | page}:
       *
       * ```
       * import puppeteer from 'puppeteer';
       *
       * // Launch a browser
       * const browser = await puppeteer.launch();
       *
       * // Create a new page
       * const page = await browser.newPage();
       *
       * // Go to your site.
       * await page.goto("https://www.example.com");
       *
       * // Start recording.
       * const recorder = await page.screencast({path: 'recording.webm'});
       *
       * // Do something.
       *
       * // Stop recording.
       * await recorder.stop();
       *
       * browser.close();
       * ```
       *
       * @param options - Configures screencast behavior.
       *
       * @experimental
       *
       * @remarks
       *
       * All recordings will be {@link https://www.webmproject.org/ | WebM} format using
       * the {@link https://www.webmproject.org/vp9/ | VP9} video codec. The FPS is 30.
       *
       * You must have {@link https://ffmpeg.org/ | ffmpeg} installed on your system.
       */
      async screencast(options = {}) {
        const ScreenRecorder = environment.value.ScreenRecorder;
        const [width, height, devicePixelRatio] = await __privateMethod(this, _Page_instances, getNativePixelDimensions_fn).call(this);
        let crop;
        if (options.crop) {
          const { x, y, width: cropWidth, height: cropHeight } = roundRectangle(normalizeRectangle(options.crop));
          if (x < 0 || y < 0) {
            throw new Error(`\`crop.x\` and \`crop.y\` must be greater than or equal to 0.`);
          }
          if (cropWidth <= 0 || cropHeight <= 0) {
            throw new Error(`\`crop.height\` and \`crop.width\` must be greater than or equal to 0.`);
          }
          const viewportWidth = width / devicePixelRatio;
          const viewportHeight = height / devicePixelRatio;
          if (x + cropWidth > viewportWidth) {
            throw new Error(`\`crop.width\` cannot be larger than the viewport width (${viewportWidth}).`);
          }
          if (y + cropHeight > viewportHeight) {
            throw new Error(`\`crop.height\` cannot be larger than the viewport height (${viewportHeight}).`);
          }
          crop = {
            x: x * devicePixelRatio,
            y: y * devicePixelRatio,
            width: cropWidth * devicePixelRatio,
            height: cropHeight * devicePixelRatio
          };
        }
        if (options.speed !== void 0 && options.speed <= 0) {
          throw new Error(`\`speed\` must be greater than 0.`);
        }
        if (options.scale !== void 0 && options.scale <= 0) {
          throw new Error(`\`scale\` must be greater than 0.`);
        }
        const recorder = new ScreenRecorder(this, width, height, {
          ...options,
          path: options.ffmpegPath,
          crop
        });
        try {
          await this._startScreencast();
        } catch (error) {
          void recorder.stop();
          throw error;
        }
        if (options.path) {
          const { createWriteStream } = environment.value.fs;
          const stream = createWriteStream(options.path, "binary");
          recorder.pipe(stream);
        }
        return recorder;
      }
      /**
       * @internal
       */
      async _startScreencast() {
        ++__privateWrapper(this, _screencastSessionCount)._;
        if (!__privateGet(this, _startScreencastPromise)) {
          __privateSet(this, _startScreencastPromise, this.mainFrame().client.send("Page.startScreencast", { format: "png" }).then(() => {
            return new Promise((resolve) => {
              return this.mainFrame().client.once("Page.screencastFrame", () => {
                return resolve();
              });
            });
          }));
        }
        await __privateGet(this, _startScreencastPromise);
      }
      /**
       * @internal
       */
      async _stopScreencast() {
        --__privateWrapper(this, _screencastSessionCount)._;
        if (!__privateGet(this, _startScreencastPromise)) {
          return;
        }
        __privateSet(this, _startScreencastPromise, void 0);
        if (__privateGet(this, _screencastSessionCount) === 0) {
          await this.mainFrame().client.send("Page.stopScreencast");
        }
      }
      async screenshot(userOptions = {}) {
        const env_2 = { stack: [], error: void 0, hasError: false };
        try {
          const _guard = __addDisposableResource$b(env_2, await this.browserContext().startScreenshot(), false);
          const options = {
            ...userOptions,
            clip: userOptions.clip ? {
              ...userOptions.clip
            } : void 0
          };
          if (options.type === void 0 && options.path !== void 0) {
            const filePath = options.path;
            const extension = filePath.slice(filePath.lastIndexOf(".") + 1).toLowerCase();
            switch (extension) {
              case "png":
                options.type = "png";
                break;
              case "jpeg":
              case "jpg":
                options.type = "jpeg";
                break;
              case "webp":
                options.type = "webp";
                break;
            }
          }
          if (options.quality !== void 0) {
            if (options.quality < 0 || options.quality > 100) {
              throw new Error(`Expected 'quality' (${options.quality}) to be between 0 and 100, inclusive.`);
            }
            if (options.type === void 0 || !["jpeg", "webp"].includes(options.type)) {
              throw new Error(`${options.type ?? "png"} screenshots do not support 'quality'.`);
            }
          }
          if (options.clip) {
            if (options.clip.width <= 0) {
              throw new Error("'width' in 'clip' must be positive.");
            }
            if (options.clip.height <= 0) {
              throw new Error("'height' in 'clip' must be positive.");
            }
          }
          setDefaultScreenshotOptions(options);
          const stack = __addDisposableResource$b(env_2, new AsyncDisposableStack(), true);
          if (options.clip) {
            if (options.fullPage) {
              throw new Error("'clip' and 'fullPage' are mutually exclusive");
            }
            options.clip = roundRectangle(normalizeRectangle(options.clip));
          } else {
            if (options.fullPage) {
              if (!options.captureBeyondViewport) {
                const scrollDimensions = await this.mainFrame().isolatedRealm().evaluate(() => {
                  const element = document.documentElement;
                  return {
                    width: element.scrollWidth,
                    height: element.scrollHeight
                  };
                });
                const viewport = this.viewport();
                await this.setViewport({
                  ...viewport,
                  ...scrollDimensions
                });
                stack.defer(async () => {
                  await this.setViewport(viewport).catch(debugError);
                });
              }
            } else {
              options.captureBeyondViewport = false;
            }
          }
          const data = await this._screenshot(options);
          if (options.encoding === "base64") {
            return data;
          }
          const typedArray = stringToTypedArray(data, true);
          await this._maybeWriteTypedArrayToFile(options.path, typedArray);
          return typedArray;
        } catch (e_2) {
          env_2.error = e_2;
          env_2.hasError = true;
        } finally {
          const result_1 = __disposeResources$b(env_2);
          if (result_1)
            await result_1;
        }
      }
      /**
       * The page's title
       *
       * @remarks
       *
       * Shortcut for {@link Frame.title | page.mainFrame().title()}.
       */
      async title() {
        return await this.mainFrame().title();
      }
      /**
       * This method fetches an element with `selector`, scrolls it into view if
       * needed, and then uses {@link Page.mouse} to click in the center of the
       * element. If there's no element matching `selector`, the method throws an
       * error.
       *
       * @remarks
       *
       * Bear in mind that if `click()` triggers a navigation event and
       * there's a separate `page.waitForNavigation()` promise to be resolved, you
       * may end up with a race condition that yields unexpected results. The
       * correct pattern for click and wait for navigation is the following:
       *
       * ```ts
       * const [response] = await Promise.all([
       *   page.waitForNavigation(waitOptions),
       *   page.click(selector, clickOptions),
       * ]);
       * ```
       *
       * Shortcut for {@link Frame.click | page.mainFrame().click(selector[, options]) }.
       * @param selector -
       * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
       * to query the page for.
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
       * can be passed as-is and a
       * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
       * allows quering by
       * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
       * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
       * and
       * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
       * and
       * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
       * Alternatively, you can specify the selector type using a
       * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}. If there are
       * multiple elements satisfying the `selector`, the first will be clicked
       * @param options - `Object`
       * @returns Promise which resolves when the element matching `selector` is
       * successfully clicked. The Promise will be rejected if there is no element
       * matching `selector`.
       */
      click(selector, options) {
        return this.mainFrame().click(selector, options);
      }
      /**
       * This method fetches an element with `selector` and focuses it. If
       * there's no element matching `selector`, the method throws an error.
       * @param selector -
       * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
       * to query the page for.
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
       * can be passed as-is and a
       * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
       * allows quering by
       * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
       * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
       * and
       * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
       * and
       * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
       * Alternatively, you can specify the selector type using a
       * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
       * If there are multiple elements satisfying the selector, the first
       * will be focused.
       * @returns Promise which resolves when the element matching selector
       * is successfully focused. The promise will be rejected if there is
       * no element matching selector.
       *
       * @remarks
       *
       * Shortcut for
       * {@link Frame.focus | page.mainFrame().focus(selector)}.
       */
      focus(selector) {
        return this.mainFrame().focus(selector);
      }
      /**
       * This method fetches an element with `selector`, scrolls it into view if
       * needed, and then uses {@link Page.mouse}
       * to hover over the center of the element.
       * If there's no element matching `selector`, the method throws an error.
       * @param selector -
       * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
       * to query the page for.
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
       * can be passed as-is and a
       * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
       * allows quering by
       * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
       * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
       * and
       * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
       * and
       * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
       * Alternatively, you can specify the selector type using a
       * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}. If there are
       * multiple elements satisfying the `selector`, the first will be hovered.
       * @returns Promise which resolves when the element matching `selector` is
       * successfully hovered. Promise gets rejected if there's no element matching
       * `selector`.
       *
       * @remarks
       *
       * Shortcut for {@link Page.hover | page.mainFrame().hover(selector)}.
       */
      hover(selector) {
        return this.mainFrame().hover(selector);
      }
      /**
       * Triggers a `change` and `input` event once all the provided options have been
       * selected. If there's no `<select>` element matching `selector`, the method
       * throws an error.
       *
       * @example
       *
       * ```ts
       * page.select('select#colors', 'blue'); // single selection
       * page.select('select#colors', 'red', 'green', 'blue'); // multiple selections
       * ```
       *
       * @param selector -
       * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
       * to query the page for.
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
       * can be passed as-is and a
       * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
       * allows quering by
       * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
       * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
       * and
       * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
       * and
       * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
       * Alternatively, you can specify the selector type using a
       * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
       * @param values - Values of options to select. If the `<select>` has the
       * `multiple` attribute, all values are considered, otherwise only the first one
       * is taken into account.
       * @returns
       *
       * @remarks
       *
       * Shortcut for {@link Frame.select | page.mainFrame().select()}
       */
      select(selector, ...values) {
        return this.mainFrame().select(selector, ...values);
      }
      /**
       * This method fetches an element with `selector`, scrolls it into view if
       * needed, and then uses {@link Page.touchscreen}
       * to tap in the center of the element.
       * If there's no element matching `selector`, the method throws an error.
       * @param selector -
       * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
       * to query the page for.
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
       * can be passed as-is and a
       * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
       * allows quering by
       * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
       * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
       * and
       * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
       * and
       * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
       * Alternatively, you can specify the selector type using a
       * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}. If there are multiple elements satisfying the
       * selector, the first will be tapped.
       *
       * @remarks
       *
       * Shortcut for {@link Frame.tap | page.mainFrame().tap(selector)}.
       */
      tap(selector) {
        return this.mainFrame().tap(selector);
      }
      /**
       * Sends a `keydown`, `keypress/input`, and `keyup` event for each character
       * in the text.
       *
       * To press a special key, like `Control` or `ArrowDown`, use {@link Keyboard.press}.
       * @example
       *
       * ```ts
       * await page.type('#mytextarea', 'Hello');
       * // Types instantly
       * await page.type('#mytextarea', 'World', {delay: 100});
       * // Types slower, like a user
       * ```
       *
       * @param selector -
       * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
       * to query the page for.
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
       * can be passed as-is and a
       * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
       * allows quering by
       * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
       * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
       * and
       * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
       * and
       * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
       * Alternatively, you can specify the selector type using a
       * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
       * @param text - A text to type into a focused element.
       * @param options - have property `delay` which is the Time to wait between
       * key presses in milliseconds. Defaults to `0`.
       * @returns
       */
      type(selector, text, options) {
        return this.mainFrame().type(selector, text, options);
      }
      /**
       * Wait for the `selector` to appear in page. If at the moment of calling the
       * method the `selector` already exists, the method will return immediately. If
       * the `selector` doesn't appear after the `timeout` milliseconds of waiting, the
       * function will throw.
       *
       * @example
       * This method works across navigations:
       *
       * ```ts
       * import puppeteer from 'puppeteer';
       * (async () => {
       *   const browser = await puppeteer.launch();
       *   const page = await browser.newPage();
       *   let currentURL;
       *   page
       *     .waitForSelector('img')
       *     .then(() => console.log('First URL with image: ' + currentURL));
       *   for (currentURL of [
       *     'https://example.com',
       *     'https://google.com',
       *     'https://bbc.com',
       *   ]) {
       *     await page.goto(currentURL);
       *   }
       *   await browser.close();
       * })();
       * ```
       *
       * @param selector -
       * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
       * to query the page for.
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
       * can be passed as-is and a
       * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
       * allows quering by
       * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
       * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
       * and
       * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
       * and
       * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
       * Alternatively, you can specify the selector type using a
       * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
       * @param options - Optional waiting parameters
       * @returns Promise which resolves when element specified by selector string
       * is added to DOM. Resolves to `null` if waiting for hidden: `true` and
       * selector is not found in DOM.
       *
       * @remarks
       * The optional Parameter in Arguments `options` are:
       *
       * - `visible`: A boolean wait for element to be present in DOM and to be
       *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS
       *   properties. Defaults to `false`.
       *
       * - `hidden`: Wait for element to not be found in the DOM or to be hidden,
       *   i.e. have `display: none` or `visibility: hidden` CSS properties. Defaults to
       *   `false`.
       *
       * - `timeout`: maximum time to wait for in milliseconds. Defaults to `30000`
       *   (30 seconds). Pass `0` to disable timeout. The default value can be changed
       *   by using the {@link Page.setDefaultTimeout} method.
       */
      async waitForSelector(selector, options = {}) {
        return await this.mainFrame().waitForSelector(selector, options);
      }
      /**
       * Waits for the provided function, `pageFunction`, to return a truthy value when
       * evaluated in the page's context.
       *
       * @example
       * {@link Page.waitForFunction} can be used to observe a viewport size change:
       *
       * ```ts
       * import puppeteer from 'puppeteer';
       * (async () => {
       *   const browser = await puppeteer.launch();
       *   const page = await browser.newPage();
       *   const watchDog = page.waitForFunction('window.innerWidth < 100');
       *   await page.setViewport({width: 50, height: 50});
       *   await watchDog;
       *   await browser.close();
       * })();
       * ```
       *
       * @example
       * Arguments can be passed from Node.js to `pageFunction`:
       *
       * ```ts
       * const selector = '.foo';
       * await page.waitForFunction(
       *   selector => !!document.querySelector(selector),
       *   {},
       *   selector,
       * );
       * ```
       *
       * @example
       * The provided `pageFunction` can be asynchronous:
       *
       * ```ts
       * const username = 'github-username';
       * await page.waitForFunction(
       *   async username => {
       *     const githubResponse = await fetch(
       *       `https://api.github.com/users/${username}`,
       *     );
       *     const githubUser = await githubResponse.json();
       *     // show the avatar
       *     const img = document.createElement('img');
       *     img.src = githubUser.avatar_url;
       *     // wait 3 seconds
       *     await new Promise((resolve, reject) => setTimeout(resolve, 3000));
       *     img.remove();
       *   },
       *   {},
       *   username,
       * );
       * ```
       *
       * @param pageFunction - Function to be evaluated in browser context until it returns a
       * truthy value.
       * @param options - Options for configuring waiting behavior.
       */
      waitForFunction(pageFunction, options, ...args) {
        return this.mainFrame().waitForFunction(pageFunction, options, ...args);
      }
      /** @internal */
      [(_screenshot_decorators = [guarded(function() {
        return this.browser();
      })], disposeSymbol)]() {
        return void this.close().catch(debugError);
      }
      /** @internal */
      [asyncDisposeSymbol]() {
        return this.close();
      }
    }, _requestHandlers = new WeakMap(), _inflight$ = new WeakMap(), _screencastSessionCount = new WeakMap(), _startScreencastPromise = new WeakMap(), _Page_instances = new WeakSet(), getNativePixelDimensions_fn = async function() {
      const env_1 = { stack: [], error: void 0, hasError: false };
      try {
        const viewport = this.viewport();
        const stack = __addDisposableResource$b(env_1, new DisposableStack(), false);
        if (viewport && viewport.deviceScaleFactor !== 0) {
          await this.setViewport({ ...viewport, deviceScaleFactor: 0 });
          stack.defer(() => {
            void this.setViewport(viewport).catch(debugError);
          });
        }
        return await this.mainFrame().isolatedRealm().evaluate(() => {
          return [
            window.visualViewport.width * window.devicePixelRatio,
            window.visualViewport.height * window.devicePixelRatio,
            window.devicePixelRatio
          ];
        });
      } catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
      } finally {
        __disposeResources$b(env_1);
      }
    }, (() => {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      __esDecorate$h(_a3, null, _screenshot_decorators, { kind: "method", name: "screenshot", static: false, private: false, access: { has: (obj) => "screenshot" in obj, get: (obj) => obj.screenshot }, metadata: _metadata }, null, _instanceExtraInitializers);
      if (_metadata) Object.defineProperty(_a3, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    })(), _a3;
  })();
  function normalizeRectangle(clip) {
    return {
      ...clip,
      ...clip.width < 0 ? {
        x: clip.x + clip.width,
        width: -clip.width
      } : {
        x: clip.x,
        width: clip.width
      },
      ...clip.height < 0 ? {
        y: clip.y + clip.height,
        height: -clip.height
      } : {
        y: clip.y,
        height: clip.height
      }
    };
  }
  function roundRectangle(clip) {
    const x = Math.round(clip.x);
    const y = Math.round(clip.y);
    const width = Math.round(clip.width + clip.x - x);
    const height = Math.round(clip.height + clip.y - y);
    return { ...clip, x, y, width, height };
  }
  /**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class WaitTask {
    constructor(world, options, fn, ...args) {
      __privateAdd(this, _world);
      __privateAdd(this, _polling);
      __privateAdd(this, _root);
      __privateAdd(this, _fn);
      __privateAdd(this, _args);
      __privateAdd(this, _timeout);
      __privateAdd(this, _timeoutError2);
      __privateAdd(this, _result, Deferred$1.create());
      __privateAdd(this, _poller);
      __privateAdd(this, _signal);
      __privateAdd(this, _reruns, []);
      __privateAdd(this, _onAbortSignal, () => {
        var _a3;
        void this.terminate((_a3 = __privateGet(this, _signal)) == null ? void 0 : _a3.reason);
      });
      var _a3;
      __privateSet(this, _world, world);
      __privateSet(this, _polling, options.polling);
      __privateSet(this, _root, options.root);
      __privateSet(this, _signal, options.signal);
      (_a3 = __privateGet(this, _signal)) == null ? void 0 : _a3.addEventListener("abort", __privateGet(this, _onAbortSignal), {
        once: true
      });
      switch (typeof fn) {
        case "string":
          __privateSet(this, _fn, `() => {return (${fn});}`);
          break;
        default:
          __privateSet(this, _fn, stringifyFunction(fn));
          break;
      }
      __privateSet(this, _args, args);
      __privateGet(this, _world).taskManager.add(this);
      if (options.timeout) {
        __privateSet(this, _timeoutError2, new TimeoutError(`Waiting failed: ${options.timeout}ms exceeded`));
        __privateSet(this, _timeout, setTimeout(() => {
          void this.terminate(__privateGet(this, _timeoutError2));
        }, options.timeout));
      }
      void this.rerun();
    }
    get result() {
      return __privateGet(this, _result).valueOrThrow();
    }
    async rerun() {
      for (const prev of __privateGet(this, _reruns)) {
        prev.abort();
      }
      __privateGet(this, _reruns).length = 0;
      const controller = new AbortController();
      __privateGet(this, _reruns).push(controller);
      try {
        switch (__privateGet(this, _polling)) {
          case "raf":
            __privateSet(this, _poller, await __privateGet(this, _world).evaluateHandle(({ RAFPoller, createFunction: createFunction2 }, fn, ...args) => {
              const fun = createFunction2(fn);
              return new RAFPoller(() => {
                return fun(...args);
              });
            }, LazyArg.create((context) => {
              return context.puppeteerUtil;
            }), __privateGet(this, _fn), ...__privateGet(this, _args)));
            break;
          case "mutation":
            __privateSet(this, _poller, await __privateGet(this, _world).evaluateHandle(({ MutationPoller, createFunction: createFunction2 }, root2, fn, ...args) => {
              const fun = createFunction2(fn);
              return new MutationPoller(() => {
                return fun(...args);
              }, root2 || document);
            }, LazyArg.create((context) => {
              return context.puppeteerUtil;
            }), __privateGet(this, _root), __privateGet(this, _fn), ...__privateGet(this, _args)));
            break;
          default:
            __privateSet(this, _poller, await __privateGet(this, _world).evaluateHandle(({ IntervalPoller, createFunction: createFunction2 }, ms2, fn, ...args) => {
              const fun = createFunction2(fn);
              return new IntervalPoller(() => {
                return fun(...args);
              }, ms2);
            }, LazyArg.create((context) => {
              return context.puppeteerUtil;
            }), __privateGet(this, _polling), __privateGet(this, _fn), ...__privateGet(this, _args)));
            break;
        }
        await __privateGet(this, _poller).evaluate((poller) => {
          void poller.start();
        });
        const result = await __privateGet(this, _poller).evaluateHandle((poller) => {
          return poller.result();
        });
        __privateGet(this, _result).resolve(result);
        await this.terminate();
      } catch (error) {
        if (controller.signal.aborted) {
          return;
        }
        const badError = this.getBadError(error);
        if (badError) {
          await this.terminate(badError);
        }
      }
    }
    async terminate(error) {
      var _a3;
      __privateGet(this, _world).taskManager.delete(this);
      (_a3 = __privateGet(this, _signal)) == null ? void 0 : _a3.removeEventListener("abort", __privateGet(this, _onAbortSignal));
      clearTimeout(__privateGet(this, _timeout));
      if (error && !__privateGet(this, _result).finished()) {
        __privateGet(this, _result).reject(error);
      }
      if (__privateGet(this, _poller)) {
        try {
          await __privateGet(this, _poller).evaluate(async (poller) => {
            await poller.stop();
          });
          if (__privateGet(this, _poller)) {
            await __privateGet(this, _poller).dispose();
            __privateSet(this, _poller, void 0);
          }
        } catch {
        }
      }
    }
    /**
     * Not all errors lead to termination. They usually imply we need to rerun the task.
     */
    getBadError(error) {
      if (isErrorLike(error)) {
        if (error.message.includes("Execution context is not available in detached frame")) {
          return new Error("Waiting failed: Frame detached");
        }
        if (error.message.includes("Execution context was destroyed")) {
          return;
        }
        if (error.message.includes("Cannot find context with specified id")) {
          return;
        }
        if (error.message.includes("DiscardedBrowsingContextError")) {
          return;
        }
        return error;
      }
      return new Error("WaitTask failed with an error", {
        cause: error
      });
    }
  }
  _world = new WeakMap();
  _polling = new WeakMap();
  _root = new WeakMap();
  _fn = new WeakMap();
  _args = new WeakMap();
  _timeout = new WeakMap();
  _timeoutError2 = new WeakMap();
  _result = new WeakMap();
  _poller = new WeakMap();
  _signal = new WeakMap();
  _reruns = new WeakMap();
  _onAbortSignal = new WeakMap();
  class TaskManager {
    constructor() {
      __privateAdd(this, _tasks, /* @__PURE__ */ new Set());
    }
    add(task) {
      __privateGet(this, _tasks).add(task);
    }
    delete(task) {
      __privateGet(this, _tasks).delete(task);
    }
    terminateAll(error) {
      for (const task of __privateGet(this, _tasks)) {
        void task.terminate(error);
      }
      __privateGet(this, _tasks).clear();
    }
    async rerunAll() {
      await Promise.all([...__privateGet(this, _tasks)].map((task) => {
        return task.rerun();
      }));
    }
  }
  _tasks = new WeakMap();
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  let Realm$2 = (_j = class {
    constructor(timeoutSettings) {
      __publicField(this, "timeoutSettings");
      __publicField(this, "taskManager", new TaskManager());
      __privateAdd(this, _disposed3, false);
      this.timeoutSettings = timeoutSettings;
    }
    async waitForFunction(pageFunction, options = {}, ...args) {
      const { polling = "raf", timeout: timeout2 = this.timeoutSettings.timeout(), root: root2, signal } = options;
      if (typeof polling === "number" && polling < 0) {
        throw new Error("Cannot poll with non-positive interval");
      }
      const waitTask = new WaitTask(this, {
        polling,
        root: root2,
        timeout: timeout2,
        signal
      }, pageFunction, ...args);
      return await waitTask.result;
    }
    get disposed() {
      return __privateGet(this, _disposed3);
    }
    /** @internal */
    dispose() {
      __privateSet(this, _disposed3, true);
      this.taskManager.terminateAll(new Error("waitForFunction failed: frame got detached."));
    }
    /** @internal */
    [disposeSymbol]() {
      this.dispose();
    }
  }, _disposed3 = new WeakMap(), _j);
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var TargetType;
  (function(TargetType2) {
    TargetType2["PAGE"] = "page";
    TargetType2["BACKGROUND_PAGE"] = "background_page";
    TargetType2["SERVICE_WORKER"] = "service_worker";
    TargetType2["SHARED_WORKER"] = "shared_worker";
    TargetType2["BROWSER"] = "browser";
    TargetType2["WEBVIEW"] = "webview";
    TargetType2["OTHER"] = "other";
    TargetType2["TAB"] = "tab";
  })(TargetType || (TargetType = {}));
  class Target {
    /**
     * @internal
     */
    constructor() {
    }
    /**
     * If the target is not of type `"service_worker"` or `"shared_worker"`, returns `null`.
     */
    async worker() {
      return null;
    }
    /**
     * If the target is not of type `"page"`, `"webview"` or `"background_page"`,
     * returns `null`.
     */
    async page() {
      return null;
    }
  }
  /**
   * @license
   * Copyright 2018 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class WebWorker extends EventEmitter$1 {
    /**
     * @internal
     */
    constructor(url) {
      super();
      /**
       * @internal
       */
      __publicField(this, "timeoutSettings", new TimeoutSettings());
      __privateAdd(this, _url);
      __privateSet(this, _url, url);
    }
    /**
     * The URL of this web worker.
     */
    url() {
      return __privateGet(this, _url);
    }
    /**
     * Evaluates a given function in the {@link WebWorker | worker}.
     *
     * @remarks If the given function returns a promise,
     * {@link WebWorker.evaluate | evaluate} will wait for the promise to resolve.
     *
     * As a rule of thumb, if the return value of the given function is more
     * complicated than a JSON object (e.g. most classes), then
     * {@link WebWorker.evaluate | evaluate} will _likely_ return some truncated
     * value (or `{}`). This is because we are not returning the actual return
     * value, but a deserialized version as a result of transferring the return
     * value through a protocol to Puppeteer.
     *
     * In general, you should use
     * {@link WebWorker.evaluateHandle | evaluateHandle} if
     * {@link WebWorker.evaluate | evaluate} cannot serialize the return value
     * properly or you need a mutable {@link JSHandle | handle} to the return
     * object.
     *
     * @param func - Function to be evaluated.
     * @param args - Arguments to pass into `func`.
     * @returns The result of `func`.
     */
    async evaluate(func, ...args) {
      func = withSourcePuppeteerURLIfNone(this.evaluate.name, func);
      return await this.mainRealm().evaluate(func, ...args);
    }
    /**
     * Evaluates a given function in the {@link WebWorker | worker}.
     *
     * @remarks If the given function returns a promise,
     * {@link WebWorker.evaluate | evaluate} will wait for the promise to resolve.
     *
     * In general, you should use
     * {@link WebWorker.evaluateHandle | evaluateHandle} if
     * {@link WebWorker.evaluate | evaluate} cannot serialize the return value
     * properly or you need a mutable {@link JSHandle | handle} to the return
     * object.
     *
     * @param func - Function to be evaluated.
     * @param args - Arguments to pass into `func`.
     * @returns A {@link JSHandle | handle} to the return value of `func`.
     */
    async evaluateHandle(func, ...args) {
      func = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, func);
      return await this.mainRealm().evaluateHandle(func, ...args);
    }
    async close() {
      throw new UnsupportedOperation("WebWorker.close() is not supported");
    }
  }
  _url = new WeakMap();
  /**
   * @license
   * Copyright 2018 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var __addDisposableResource$a = function(env, value, async2) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async2) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async2) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({ value, dispose, async: async2 });
    } else if (async2) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources$a = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  class Accessibility {
    /**
     * @internal
     */
    constructor(realm, frameId = "") {
      __privateAdd(this, _realm);
      __privateAdd(this, _frameId);
      __privateSet(this, _realm, realm);
      __privateSet(this, _frameId, frameId);
    }
    /**
     * Captures the current state of the accessibility tree.
     * The returned object represents the root accessible node of the page.
     *
     * @remarks
     *
     * **NOTE** The Chrome accessibility tree contains nodes that go unused on
     * most platforms and by most screen readers. Puppeteer will discard them as
     * well for an easier to process tree, unless `interestingOnly` is set to
     * `false`.
     *
     * @example
     * An example of dumping the entire accessibility tree:
     *
     * ```ts
     * const snapshot = await page.accessibility.snapshot();
     * console.log(snapshot);
     * ```
     *
     * @example
     * An example of logging the focused node's name:
     *
     * ```ts
     * const snapshot = await page.accessibility.snapshot();
     * const node = findFocusedNode(snapshot);
     * console.log(node && node.name);
     *
     * function findFocusedNode(node) {
     *   if (node.focused) return node;
     *   for (const child of node.children || []) {
     *     const foundNode = findFocusedNode(child);
     *     return foundNode;
     *   }
     *   return null;
     * }
     * ```
     *
     * @returns An AXNode object representing the snapshot.
     */
    async snapshot(options = {}) {
      const { interestingOnly = true, root: root2 = null, includeIframes = false } = options;
      const { nodes } = await __privateGet(this, _realm).environment.client.send("Accessibility.getFullAXTree", {
        frameId: __privateGet(this, _frameId)
      });
      let backendNodeId;
      if (root2) {
        const { node } = await __privateGet(this, _realm).environment.client.send("DOM.describeNode", {
          objectId: root2.id
        });
        backendNodeId = node.backendNodeId;
      }
      const defaultRoot = AXNode.createTree(__privateGet(this, _realm), nodes);
      const populateIframes = async (root3) => {
        var _a3;
        if (((_a3 = root3.payload.role) == null ? void 0 : _a3.value) === "Iframe") {
          const env_1 = { stack: [], error: void 0, hasError: false };
          try {
            if (!root3.payload.backendDOMNodeId) {
              return;
            }
            const handle = __addDisposableResource$a(env_1, await __privateGet(this, _realm).adoptBackendNode(root3.payload.backendDOMNodeId), false);
            if (!handle || !("contentFrame" in handle)) {
              return;
            }
            const frame = await handle.contentFrame();
            if (!frame) {
              return;
            }
            const iframeSnapshot = await frame.accessibility.snapshot(options);
            root3.iframeSnapshot = iframeSnapshot ?? void 0;
          } catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
          } finally {
            __disposeResources$a(env_1);
          }
        }
        for (const child of root3.children) {
          await populateIframes(child);
        }
      };
      let needle = defaultRoot;
      if (!defaultRoot) {
        return null;
      }
      if (includeIframes) {
        await populateIframes(defaultRoot);
      }
      if (backendNodeId) {
        needle = defaultRoot.find((node) => {
          return node.payload.backendDOMNodeId === backendNodeId;
        });
      }
      if (!needle) {
        return null;
      }
      if (!interestingOnly) {
        return this.serializeTree(needle)[0] ?? null;
      }
      const interestingNodes = /* @__PURE__ */ new Set();
      this.collectInterestingNodes(interestingNodes, defaultRoot, false);
      if (!interestingNodes.has(needle)) {
        return null;
      }
      return this.serializeTree(needle, interestingNodes)[0] ?? null;
    }
    serializeTree(node, interestingNodes) {
      const children = [];
      for (const child of node.children) {
        children.push(...this.serializeTree(child, interestingNodes));
      }
      if (interestingNodes && !interestingNodes.has(node)) {
        return children;
      }
      const serializedNode = node.serialize();
      if (children.length) {
        serializedNode.children = children;
      }
      if (node.iframeSnapshot) {
        if (!serializedNode.children) {
          serializedNode.children = [];
        }
        serializedNode.children.push(node.iframeSnapshot);
      }
      return [serializedNode];
    }
    collectInterestingNodes(collection, node, insideControl) {
      if (node.isInteresting(insideControl) || node.iframeSnapshot) {
        collection.add(node);
      }
      if (node.isLeafNode()) {
        return;
      }
      insideControl = insideControl || node.isControl();
      for (const child of node.children) {
        this.collectInterestingNodes(collection, child, insideControl);
      }
    }
  }
  _realm = new WeakMap();
  _frameId = new WeakMap();
  const _AXNode = class _AXNode {
    constructor(realm, payload) {
      __privateAdd(this, _AXNode_instances);
      __publicField(this, "payload");
      __publicField(this, "children", []);
      __publicField(this, "iframeSnapshot");
      __privateAdd(this, _richlyEditable, false);
      __privateAdd(this, _editable, false);
      __privateAdd(this, _focusable, false);
      __privateAdd(this, _hidden, false);
      __privateAdd(this, _name);
      __privateAdd(this, _role);
      __privateAdd(this, _ignored);
      __privateAdd(this, _cachedHasFocusableChild);
      __privateAdd(this, _realm2);
      this.payload = payload;
      __privateSet(this, _name, this.payload.name ? this.payload.name.value : "");
      __privateSet(this, _role, this.payload.role ? this.payload.role.value : "Unknown");
      __privateSet(this, _ignored, this.payload.ignored);
      __privateSet(this, _realm2, realm);
      for (const property of this.payload.properties || []) {
        if (property.name === "editable") {
          __privateSet(this, _richlyEditable, property.value.value === "richtext");
          __privateSet(this, _editable, true);
        }
        if (property.name === "focusable") {
          __privateSet(this, _focusable, property.value.value);
        }
        if (property.name === "hidden") {
          __privateSet(this, _hidden, property.value.value);
        }
      }
    }
    find(predicate) {
      if (predicate(this)) {
        return this;
      }
      for (const child of this.children) {
        const result = child.find(predicate);
        if (result) {
          return result;
        }
      }
      return null;
    }
    isLeafNode() {
      if (!this.children.length) {
        return true;
      }
      if (__privateMethod(this, _AXNode_instances, isPlainTextField_fn).call(this) || __privateMethod(this, _AXNode_instances, isTextOnlyObject_fn).call(this)) {
        return true;
      }
      switch (__privateGet(this, _role)) {
        case "doc-cover":
        case "graphics-symbol":
        case "img":
        case "image":
        case "Meter":
        case "scrollbar":
        case "slider":
        case "separator":
        case "progressbar":
          return true;
      }
      if (__privateMethod(this, _AXNode_instances, hasFocusableChild_fn).call(this)) {
        return false;
      }
      if (__privateGet(this, _focusable) && __privateGet(this, _name)) {
        return true;
      }
      if (__privateGet(this, _role) === "heading" && __privateGet(this, _name)) {
        return true;
      }
      return false;
    }
    isControl() {
      switch (__privateGet(this, _role)) {
        case "button":
        case "checkbox":
        case "ColorWell":
        case "combobox":
        case "DisclosureTriangle":
        case "listbox":
        case "menu":
        case "menubar":
        case "menuitem":
        case "menuitemcheckbox":
        case "menuitemradio":
        case "radio":
        case "scrollbar":
        case "searchbox":
        case "slider":
        case "spinbutton":
        case "switch":
        case "tab":
        case "textbox":
        case "tree":
        case "treeitem":
          return true;
        default:
          return false;
      }
    }
    isInteresting(insideControl) {
      const role = __privateGet(this, _role);
      if (role === "Ignored" || __privateGet(this, _hidden) || __privateGet(this, _ignored)) {
        return false;
      }
      if (__privateGet(this, _focusable) || __privateGet(this, _richlyEditable)) {
        return true;
      }
      if (this.isControl()) {
        return true;
      }
      if (insideControl) {
        return false;
      }
      return this.isLeafNode() && !!__privateGet(this, _name);
    }
    serialize() {
      const properties = /* @__PURE__ */ new Map();
      for (const property of this.payload.properties || []) {
        properties.set(property.name.toLowerCase(), property.value.value);
      }
      if (this.payload.name) {
        properties.set("name", this.payload.name.value);
      }
      if (this.payload.value) {
        properties.set("value", this.payload.value.value);
      }
      if (this.payload.description) {
        properties.set("description", this.payload.description.value);
      }
      const node = {
        role: __privateGet(this, _role),
        elementHandle: async () => {
          if (!this.payload.backendDOMNodeId) {
            return null;
          }
          return await __privateGet(this, _realm2).adoptBackendNode(this.payload.backendDOMNodeId);
        }
      };
      const userStringProperties = [
        "name",
        "value",
        "description",
        "keyshortcuts",
        "roledescription",
        "valuetext"
      ];
      const getUserStringPropertyValue = (key) => {
        return properties.get(key);
      };
      for (const userStringProperty of userStringProperties) {
        if (!properties.has(userStringProperty)) {
          continue;
        }
        node[userStringProperty] = getUserStringPropertyValue(userStringProperty);
      }
      const booleanProperties = [
        "disabled",
        "expanded",
        "focused",
        "modal",
        "multiline",
        "multiselectable",
        "readonly",
        "required",
        "selected"
      ];
      const getBooleanPropertyValue = (key) => {
        return properties.get(key);
      };
      for (const booleanProperty of booleanProperties) {
        if (booleanProperty === "focused" && __privateGet(this, _role) === "RootWebArea") {
          continue;
        }
        const value = getBooleanPropertyValue(booleanProperty);
        if (!value) {
          continue;
        }
        node[booleanProperty] = getBooleanPropertyValue(booleanProperty);
      }
      const tristateProperties = ["checked", "pressed"];
      for (const tristateProperty of tristateProperties) {
        if (!properties.has(tristateProperty)) {
          continue;
        }
        const value = properties.get(tristateProperty);
        node[tristateProperty] = value === "mixed" ? "mixed" : value === "true" ? true : false;
      }
      const numericalProperties = [
        "level",
        "valuemax",
        "valuemin"
      ];
      const getNumericalPropertyValue = (key) => {
        return properties.get(key);
      };
      for (const numericalProperty of numericalProperties) {
        if (!properties.has(numericalProperty)) {
          continue;
        }
        node[numericalProperty] = getNumericalPropertyValue(numericalProperty);
      }
      const tokenProperties = [
        "autocomplete",
        "haspopup",
        "invalid",
        "orientation"
      ];
      const getTokenPropertyValue = (key) => {
        return properties.get(key);
      };
      for (const tokenProperty of tokenProperties) {
        const value = getTokenPropertyValue(tokenProperty);
        if (!value || value === "false") {
          continue;
        }
        node[tokenProperty] = getTokenPropertyValue(tokenProperty);
      }
      return node;
    }
    static createTree(realm, payloads) {
      const nodeById = /* @__PURE__ */ new Map();
      for (const payload of payloads) {
        nodeById.set(payload.nodeId, new _AXNode(realm, payload));
      }
      for (const node of nodeById.values()) {
        for (const childId of node.payload.childIds || []) {
          const child = nodeById.get(childId);
          if (child) {
            node.children.push(child);
          }
        }
      }
      return nodeById.values().next().value ?? null;
    }
  };
  _richlyEditable = new WeakMap();
  _editable = new WeakMap();
  _focusable = new WeakMap();
  _hidden = new WeakMap();
  _name = new WeakMap();
  _role = new WeakMap();
  _ignored = new WeakMap();
  _cachedHasFocusableChild = new WeakMap();
  _realm2 = new WeakMap();
  _AXNode_instances = new WeakSet();
  isPlainTextField_fn = function() {
    if (__privateGet(this, _richlyEditable)) {
      return false;
    }
    if (__privateGet(this, _editable)) {
      return true;
    }
    return __privateGet(this, _role) === "textbox" || __privateGet(this, _role) === "searchbox";
  };
  isTextOnlyObject_fn = function() {
    const role = __privateGet(this, _role);
    return role === "LineBreak" || role === "text" || role === "InlineTextBox" || role === "StaticText";
  };
  hasFocusableChild_fn = function() {
    var _a3;
    if (__privateGet(this, _cachedHasFocusableChild) === void 0) {
      __privateSet(this, _cachedHasFocusableChild, false);
      for (const child of this.children) {
        if (__privateGet(child, _focusable) || __privateMethod(_a3 = child, _AXNode_instances, hasFocusableChild_fn).call(_a3)) {
          __privateSet(this, _cachedHasFocusableChild, true);
          break;
        }
      }
    }
    return __privateGet(this, _cachedHasFocusableChild);
  };
  let AXNode = _AXNode;
  var __addDisposableResource$9 = function(env, value, async2) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async2) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async2) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({ value, dispose, async: async2 });
    } else if (async2) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources$9 = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  class Binding {
    constructor(name, fn, initSource) {
      __privateAdd(this, _name2);
      __privateAdd(this, _fn2);
      __privateAdd(this, _initSource);
      __privateSet(this, _name2, name);
      __privateSet(this, _fn2, fn);
      __privateSet(this, _initSource, initSource);
    }
    get name() {
      return __privateGet(this, _name2);
    }
    get initSource() {
      return __privateGet(this, _initSource);
    }
    /**
     * @param context - Context to run the binding in; the context should have
     * the binding added to it beforehand.
     * @param id - ID of the call. This should come from the CDP
     * `onBindingCalled` response.
     * @param args - Plain arguments from CDP.
     */
    async run(context, id, args, isTrivial) {
      const stack = new DisposableStack();
      try {
        if (!isTrivial) {
          const env_1 = { stack: [], error: void 0, hasError: false };
          try {
            const handles = __addDisposableResource$9(env_1, await context.evaluateHandle((name, seq) => {
              return globalThis[name].args.get(seq);
            }, __privateGet(this, _name2), id), false);
            const properties = await handles.getProperties();
            for (const [index, handle] of properties) {
              if (index in args) {
                switch (handle.remoteObject().subtype) {
                  case "node":
                    args[+index] = handle;
                    break;
                  default:
                    stack.use(handle);
                }
              } else {
                stack.use(handle);
              }
            }
          } catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
          } finally {
            __disposeResources$9(env_1);
          }
        }
        await context.evaluate((name, seq, result) => {
          const callbacks = globalThis[name].callbacks;
          callbacks.get(seq).resolve(result);
          callbacks.delete(seq);
        }, __privateGet(this, _name2), id, await __privateGet(this, _fn2).call(this, ...args));
        for (const arg of args) {
          if (arg instanceof JSHandle) {
            stack.use(arg);
          }
        }
      } catch (error) {
        if (isErrorLike(error)) {
          await context.evaluate((name, seq, message, stack2) => {
            const error2 = new Error(message);
            error2.stack = stack2;
            const callbacks = globalThis[name].callbacks;
            callbacks.get(seq).reject(error2);
            callbacks.delete(seq);
          }, __privateGet(this, _name2), id, error.message, error.stack).catch(debugError);
        } else {
          await context.evaluate((name, seq, error2) => {
            const callbacks = globalThis[name].callbacks;
            callbacks.get(seq).reject(error2);
            callbacks.delete(seq);
          }, __privateGet(this, _name2), id, error).catch(debugError);
        }
      }
    }
  }
  _name2 = new WeakMap();
  _fn2 = new WeakMap();
  _initSource = new WeakMap();
  /**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class ConsoleMessage {
    /**
     * @internal
     */
    constructor(type, text, args, stackTraceLocations, frame) {
      __privateAdd(this, _type2);
      __privateAdd(this, _text);
      __privateAdd(this, _args2);
      __privateAdd(this, _stackTraceLocations);
      __privateAdd(this, _frame);
      __privateSet(this, _type2, type);
      __privateSet(this, _text, text);
      __privateSet(this, _args2, args);
      __privateSet(this, _stackTraceLocations, stackTraceLocations);
      __privateSet(this, _frame, frame);
    }
    /**
     * The type of the console message.
     */
    type() {
      return __privateGet(this, _type2);
    }
    /**
     * The text of the console message.
     */
    text() {
      return __privateGet(this, _text);
    }
    /**
     * An array of arguments passed to the console.
     */
    args() {
      return __privateGet(this, _args2);
    }
    /**
     * The location of the console message.
     */
    location() {
      return __privateGet(this, _stackTraceLocations)[0] ?? (__privateGet(this, _frame) ? { url: __privateGet(this, _frame).url() } : {});
    }
    /**
     * The array of locations on the stack of the console message.
     */
    stackTrace() {
      return __privateGet(this, _stackTraceLocations);
    }
  }
  _type2 = new WeakMap();
  _text = new WeakMap();
  _args2 = new WeakMap();
  _stackTraceLocations = new WeakMap();
  _frame = new WeakMap();
  /**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class FileChooser {
    /**
     * @internal
     */
    constructor(element, event) {
      __privateAdd(this, _element);
      __privateAdd(this, _multiple);
      __privateAdd(this, _handled, false);
      __privateSet(this, _element, element);
      __privateSet(this, _multiple, event.mode !== "selectSingle");
    }
    /**
     * Whether file chooser allow for
     * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#attr-multiple | multiple}
     * file selection.
     */
    isMultiple() {
      return __privateGet(this, _multiple);
    }
    /**
     * Accept the file chooser request with the given file paths.
     *
     * @remarks This will not validate whether the file paths exists. Also, if a
     * path is relative, then it is resolved against the
     * {@link https://nodejs.org/api/process.html#process_process_cwd | current working directory}.
     * For locals script connecting to remote chrome environments, paths must be
     * absolute.
     */
    async accept(paths) {
      assert$1(!__privateGet(this, _handled), "Cannot accept FileChooser which is already handled!");
      __privateSet(this, _handled, true);
      await __privateGet(this, _element).uploadFile(...paths);
    }
    /**
     * Closes the file chooser without selecting any files.
     */
    async cancel() {
      assert$1(!__privateGet(this, _handled), "Cannot cancel FileChooser which is already handled!");
      __privateSet(this, _handled, true);
      await __privateGet(this, _element).evaluate((element) => {
        element.dispatchEvent(new Event("cancel", { bubbles: true }));
      });
    }
  }
  _element = new WeakMap();
  _multiple = new WeakMap();
  _handled = new WeakMap();
  /**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var NetworkManagerEvent;
  (function(NetworkManagerEvent2) {
    NetworkManagerEvent2.Request = Symbol("NetworkManager.Request");
    NetworkManagerEvent2.RequestServedFromCache = Symbol("NetworkManager.RequestServedFromCache");
    NetworkManagerEvent2.Response = Symbol("NetworkManager.Response");
    NetworkManagerEvent2.RequestFailed = Symbol("NetworkManager.RequestFailed");
    NetworkManagerEvent2.RequestFinished = Symbol("NetworkManager.RequestFinished");
  })(NetworkManagerEvent || (NetworkManagerEvent = {}));
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class CallbackRegistry {
    constructor() {
      __privateAdd(this, _callbacks, /* @__PURE__ */ new Map());
      __privateAdd(this, _idGenerator, createIncrementalIdGenerator());
    }
    create(label, timeout2, request) {
      const callback = new Callback(__privateGet(this, _idGenerator).call(this), label, timeout2);
      __privateGet(this, _callbacks).set(callback.id, callback);
      try {
        request(callback.id);
      } catch (error) {
        callback.promise.catch(debugError).finally(() => {
          __privateGet(this, _callbacks).delete(callback.id);
        });
        callback.reject(error);
        throw error;
      }
      return callback.promise.finally(() => {
        __privateGet(this, _callbacks).delete(callback.id);
      });
    }
    reject(id, message, originalMessage) {
      const callback = __privateGet(this, _callbacks).get(id);
      if (!callback) {
        return;
      }
      this._reject(callback, message, originalMessage);
    }
    rejectRaw(id, error) {
      const callback = __privateGet(this, _callbacks).get(id);
      if (!callback) {
        return;
      }
      callback.reject(error);
    }
    _reject(callback, errorMessage, originalMessage) {
      let error;
      let message;
      if (errorMessage instanceof ProtocolError) {
        error = errorMessage;
        error.cause = callback.error;
        message = errorMessage.message;
      } else {
        error = callback.error;
        message = errorMessage;
      }
      callback.reject(rewriteError$1(error, `Protocol error (${callback.label}): ${message}`, originalMessage));
    }
    resolve(id, value) {
      const callback = __privateGet(this, _callbacks).get(id);
      if (!callback) {
        return;
      }
      callback.resolve(value);
    }
    clear() {
      for (const callback of __privateGet(this, _callbacks).values()) {
        this._reject(callback, new TargetCloseError("Target closed"));
      }
      __privateGet(this, _callbacks).clear();
    }
    /**
     * @internal
     */
    getPendingProtocolErrors() {
      const result = [];
      for (const callback of __privateGet(this, _callbacks).values()) {
        result.push(new Error(`${callback.label} timed out. Trace: ${callback.error.stack}`));
      }
      return result;
    }
  }
  _callbacks = new WeakMap();
  _idGenerator = new WeakMap();
  class Callback {
    constructor(id, label, timeout2) {
      __privateAdd(this, _id);
      __privateAdd(this, _error, new ProtocolError());
      __privateAdd(this, _deferred, Deferred$1.create());
      __privateAdd(this, _timer);
      __privateAdd(this, _label);
      __privateSet(this, _id, id);
      __privateSet(this, _label, label);
      if (timeout2) {
        __privateSet(this, _timer, setTimeout(() => {
          __privateGet(this, _deferred).reject(rewriteError$1(__privateGet(this, _error), `${label} timed out. Increase the 'protocolTimeout' setting in launch/connect calls for a higher timeout if needed.`));
        }, timeout2));
      }
    }
    resolve(value) {
      clearTimeout(__privateGet(this, _timer));
      __privateGet(this, _deferred).resolve(value);
    }
    reject(error) {
      clearTimeout(__privateGet(this, _timer));
      __privateGet(this, _deferred).reject(error);
    }
    get id() {
      return __privateGet(this, _id);
    }
    get promise() {
      return __privateGet(this, _deferred).valueOrThrow();
    }
    get error() {
      return __privateGet(this, _error);
    }
    get label() {
      return __privateGet(this, _label);
    }
  }
  _id = new WeakMap();
  _error = new WeakMap();
  _deferred = new WeakMap();
  _timer = new WeakMap();
  _label = new WeakMap();
  /**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class CdpCDPSession extends CDPSession {
    /**
     * @internal
     */
    constructor(connection, targetType, sessionId, parentSessionId, rawErrors) {
      super();
      __privateAdd(this, _sessionId);
      __privateAdd(this, _targetType);
      __privateAdd(this, _callbacks2, new CallbackRegistry());
      __privateAdd(this, _connection);
      __privateAdd(this, _parentSessionId);
      __privateAdd(this, _target);
      __privateAdd(this, _rawErrors, false);
      __privateSet(this, _connection, connection);
      __privateSet(this, _targetType, targetType);
      __privateSet(this, _sessionId, sessionId);
      __privateSet(this, _parentSessionId, parentSessionId);
      __privateSet(this, _rawErrors, rawErrors);
    }
    /**
     * Sets the {@link CdpTarget} associated with the session instance.
     *
     * @internal
     */
    _setTarget(target) {
      __privateSet(this, _target, target);
    }
    /**
     * Gets the {@link CdpTarget} associated with the session instance.
     *
     * @internal
     */
    _target() {
      assert$1(__privateGet(this, _target), "Target must exist");
      return __privateGet(this, _target);
    }
    connection() {
      return __privateGet(this, _connection);
    }
    parentSession() {
      var _a3;
      if (!__privateGet(this, _parentSessionId)) {
        return this;
      }
      const parent = (_a3 = __privateGet(this, _connection)) == null ? void 0 : _a3.session(__privateGet(this, _parentSessionId));
      return parent ?? void 0;
    }
    send(method, params, options) {
      if (!__privateGet(this, _connection)) {
        return Promise.reject(new TargetCloseError(`Protocol error (${method}): Session closed. Most likely the ${__privateGet(this, _targetType)} has been closed.`));
      }
      return __privateGet(this, _connection)._rawSend(__privateGet(this, _callbacks2), method, params, __privateGet(this, _sessionId), options);
    }
    /**
     * @internal
     */
    _onMessage(object) {
      if (object.id) {
        if (object.error) {
          if (__privateGet(this, _rawErrors)) {
            __privateGet(this, _callbacks2).rejectRaw(object.id, object.error);
          } else {
            __privateGet(this, _callbacks2).reject(object.id, createProtocolErrorMessage(object), object.error.message);
          }
        } else {
          __privateGet(this, _callbacks2).resolve(object.id, object.result);
        }
      } else {
        assert$1(!object.id);
        this.emit(object.method, object.params);
      }
    }
    /**
     * Detaches the cdpSession from the target. Once detached, the cdpSession object
     * won't emit any events and can't be used to send messages.
     */
    async detach() {
      if (!__privateGet(this, _connection)) {
        throw new Error(`Session already detached. Most likely the ${__privateGet(this, _targetType)} has been closed.`);
      }
      await __privateGet(this, _connection).send("Target.detachFromTarget", {
        sessionId: __privateGet(this, _sessionId)
      });
    }
    /**
     * @internal
     */
    _onClosed() {
      __privateGet(this, _callbacks2).clear();
      __privateSet(this, _connection, void 0);
      this.emit(CDPSessionEvent.Disconnected, void 0);
    }
    /**
     * Returns the session's id.
     */
    id() {
      return __privateGet(this, _sessionId);
    }
    /**
     * @internal
     */
    getPendingProtocolErrors() {
      return __privateGet(this, _callbacks2).getPendingProtocolErrors();
    }
  }
  _sessionId = new WeakMap();
  _targetType = new WeakMap();
  _callbacks2 = new WeakMap();
  _connection = new WeakMap();
  _parentSessionId = new WeakMap();
  _target = new WeakMap();
  _rawErrors = new WeakMap();
  /**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  const debugProtocolSend$1 = debug$3("puppeteer:protocol:SEND ►");
  const debugProtocolReceive$1 = debug$3("puppeteer:protocol:RECV ◀");
  class Connection extends EventEmitter$1 {
    constructor(url, transport, delay = 0, timeout2, rawErrors = false) {
      super();
      __privateAdd(this, _Connection_instances);
      __privateAdd(this, _url2);
      __privateAdd(this, _transport);
      __privateAdd(this, _delay);
      __privateAdd(this, _timeout2);
      __privateAdd(this, _sessions, /* @__PURE__ */ new Map());
      __privateAdd(this, _closed, false);
      __privateAdd(this, _manuallyAttached, /* @__PURE__ */ new Set());
      __privateAdd(this, _callbacks3);
      __privateAdd(this, _rawErrors2, false);
      __privateSet(this, _rawErrors2, rawErrors);
      __privateSet(this, _callbacks3, new CallbackRegistry());
      __privateSet(this, _url2, url);
      __privateSet(this, _delay, delay);
      __privateSet(this, _timeout2, timeout2 ?? 18e4);
      __privateSet(this, _transport, transport);
      __privateGet(this, _transport).onmessage = this.onMessage.bind(this);
      __privateGet(this, _transport).onclose = __privateMethod(this, _Connection_instances, onClose_fn).bind(this);
    }
    static fromSession(session) {
      return session.connection();
    }
    /**
     * @internal
     */
    get delay() {
      return __privateGet(this, _delay);
    }
    get timeout() {
      return __privateGet(this, _timeout2);
    }
    /**
     * @internal
     */
    get _closed() {
      return __privateGet(this, _closed);
    }
    /**
     * @internal
     */
    get _sessions() {
      return __privateGet(this, _sessions);
    }
    /**
     * @param sessionId - The session id
     * @returns The current CDP session if it exists
     */
    session(sessionId) {
      return __privateGet(this, _sessions).get(sessionId) || null;
    }
    url() {
      return __privateGet(this, _url2);
    }
    send(method, params, options) {
      return this._rawSend(__privateGet(this, _callbacks3), method, params, void 0, options);
    }
    /**
     * @internal
     */
    _rawSend(callbacks, method, params, sessionId, options) {
      if (__privateGet(this, _closed)) {
        return Promise.reject(new Error("Protocol error: Connection closed."));
      }
      return callbacks.create(method, (options == null ? void 0 : options.timeout) ?? __privateGet(this, _timeout2), (id) => {
        const stringifiedMessage = JSON.stringify({
          method,
          params,
          id,
          sessionId
        });
        debugProtocolSend$1(stringifiedMessage);
        __privateGet(this, _transport).send(stringifiedMessage);
      });
    }
    /**
     * @internal
     */
    async closeBrowser() {
      await this.send("Browser.close");
    }
    /**
     * @internal
     */
    async onMessage(message) {
      if (__privateGet(this, _delay)) {
        await new Promise((r) => {
          return setTimeout(r, __privateGet(this, _delay));
        });
      }
      debugProtocolReceive$1(message);
      const object = JSON.parse(message);
      if (object.method === "Target.attachedToTarget") {
        const sessionId = object.params.sessionId;
        const session = new CdpCDPSession(this, object.params.targetInfo.type, sessionId, object.sessionId, __privateGet(this, _rawErrors2));
        __privateGet(this, _sessions).set(sessionId, session);
        this.emit(CDPSessionEvent.SessionAttached, session);
        const parentSession = __privateGet(this, _sessions).get(object.sessionId);
        if (parentSession) {
          parentSession.emit(CDPSessionEvent.SessionAttached, session);
        }
      } else if (object.method === "Target.detachedFromTarget") {
        const session = __privateGet(this, _sessions).get(object.params.sessionId);
        if (session) {
          session._onClosed();
          __privateGet(this, _sessions).delete(object.params.sessionId);
          this.emit(CDPSessionEvent.SessionDetached, session);
          const parentSession = __privateGet(this, _sessions).get(object.sessionId);
          if (parentSession) {
            parentSession.emit(CDPSessionEvent.SessionDetached, session);
          }
        }
      }
      if (object.sessionId) {
        const session = __privateGet(this, _sessions).get(object.sessionId);
        if (session) {
          session._onMessage(object);
        }
      } else if (object.id) {
        if (object.error) {
          if (__privateGet(this, _rawErrors2)) {
            __privateGet(this, _callbacks3).rejectRaw(object.id, object.error);
          } else {
            __privateGet(this, _callbacks3).reject(object.id, createProtocolErrorMessage(object), object.error.message);
          }
        } else {
          __privateGet(this, _callbacks3).resolve(object.id, object.result);
        }
      } else {
        this.emit(object.method, object.params);
      }
    }
    dispose() {
      __privateMethod(this, _Connection_instances, onClose_fn).call(this);
      __privateGet(this, _transport).close();
    }
    /**
     * @internal
     */
    isAutoAttached(targetId) {
      return !__privateGet(this, _manuallyAttached).has(targetId);
    }
    /**
     * @internal
     */
    async _createSession(targetInfo, isAutoAttachEmulated = true) {
      if (!isAutoAttachEmulated) {
        __privateGet(this, _manuallyAttached).add(targetInfo.targetId);
      }
      const { sessionId } = await this.send("Target.attachToTarget", {
        targetId: targetInfo.targetId,
        flatten: true
      });
      __privateGet(this, _manuallyAttached).delete(targetInfo.targetId);
      const session = __privateGet(this, _sessions).get(sessionId);
      if (!session) {
        throw new Error("CDPSession creation failed.");
      }
      return session;
    }
    /**
     * @param targetInfo - The target info
     * @returns The CDP session that is created
     */
    async createSession(targetInfo) {
      return await this._createSession(targetInfo, false);
    }
    /**
     * @internal
     */
    getPendingProtocolErrors() {
      const result = [];
      result.push(...__privateGet(this, _callbacks3).getPendingProtocolErrors());
      for (const session of __privateGet(this, _sessions).values()) {
        result.push(...session.getPendingProtocolErrors());
      }
      return result;
    }
  }
  _url2 = new WeakMap();
  _transport = new WeakMap();
  _delay = new WeakMap();
  _timeout2 = new WeakMap();
  _sessions = new WeakMap();
  _closed = new WeakMap();
  _manuallyAttached = new WeakMap();
  _callbacks3 = new WeakMap();
  _rawErrors2 = new WeakMap();
  _Connection_instances = new WeakSet();
  onClose_fn = function() {
    if (__privateGet(this, _closed)) {
      return;
    }
    __privateSet(this, _closed, true);
    __privateGet(this, _transport).onmessage = void 0;
    __privateGet(this, _transport).onclose = void 0;
    __privateGet(this, _callbacks3).clear();
    for (const session of __privateGet(this, _sessions).values()) {
      session._onClosed();
    }
    __privateGet(this, _sessions).clear();
    this.emit(CDPSessionEvent.Disconnected, void 0);
  };
  function isTargetClosedError(error) {
    return error instanceof TargetCloseError;
  }
  /**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class Coverage {
    /**
     * @internal
     */
    constructor(client2) {
      __privateAdd(this, _jsCoverage);
      __privateAdd(this, _cssCoverage);
      __privateSet(this, _jsCoverage, new JSCoverage(client2));
      __privateSet(this, _cssCoverage, new CSSCoverage(client2));
    }
    /**
     * @internal
     */
    updateClient(client2) {
      __privateGet(this, _jsCoverage).updateClient(client2);
      __privateGet(this, _cssCoverage).updateClient(client2);
    }
    /**
     * @param options - Set of configurable options for coverage defaults to
     * `resetOnNavigation : true, reportAnonymousScripts : false,`
     * `includeRawScriptCoverage : false, useBlockCoverage : true`
     * @returns Promise that resolves when coverage is started.
     *
     * @remarks
     * Anonymous scripts are ones that don't have an associated url. These are
     * scripts that are dynamically created on the page using `eval` or
     * `new Function`. If `reportAnonymousScripts` is set to `true`, anonymous
     * scripts URL will start with `debugger://VM` (unless a magic //# sourceURL
     * comment is present, in which case that will the be URL).
     */
    async startJSCoverage(options = {}) {
      return await __privateGet(this, _jsCoverage).start(options);
    }
    /**
     * Promise that resolves to the array of coverage reports for
     * all scripts.
     *
     * @remarks
     * JavaScript Coverage doesn't include anonymous scripts by default.
     * However, scripts with sourceURLs are reported.
     */
    async stopJSCoverage() {
      return await __privateGet(this, _jsCoverage).stop();
    }
    /**
     * @param options - Set of configurable options for coverage, defaults to
     * `resetOnNavigation : true`
     * @returns Promise that resolves when coverage is started.
     */
    async startCSSCoverage(options = {}) {
      return await __privateGet(this, _cssCoverage).start(options);
    }
    /**
     * Promise that resolves to the array of coverage reports
     * for all stylesheets.
     *
     * @remarks
     * CSS Coverage doesn't include dynamically injected style tags
     * without sourceURLs.
     */
    async stopCSSCoverage() {
      return await __privateGet(this, _cssCoverage).stop();
    }
  }
  _jsCoverage = new WeakMap();
  _cssCoverage = new WeakMap();
  class JSCoverage {
    /**
     * @internal
     */
    constructor(client2) {
      __privateAdd(this, _JSCoverage_instances);
      __privateAdd(this, _client);
      __privateAdd(this, _enabled, false);
      __privateAdd(this, _scriptURLs, /* @__PURE__ */ new Map());
      __privateAdd(this, _scriptSources, /* @__PURE__ */ new Map());
      __privateAdd(this, _subscriptions);
      __privateAdd(this, _resetOnNavigation, false);
      __privateAdd(this, _reportAnonymousScripts, false);
      __privateAdd(this, _includeRawScriptCoverage, false);
      __privateSet(this, _client, client2);
    }
    /**
     * @internal
     */
    updateClient(client2) {
      __privateSet(this, _client, client2);
    }
    async start(options = {}) {
      assert$1(!__privateGet(this, _enabled), "JSCoverage is already enabled");
      const { resetOnNavigation = true, reportAnonymousScripts = false, includeRawScriptCoverage = false, useBlockCoverage = true } = options;
      __privateSet(this, _resetOnNavigation, resetOnNavigation);
      __privateSet(this, _reportAnonymousScripts, reportAnonymousScripts);
      __privateSet(this, _includeRawScriptCoverage, includeRawScriptCoverage);
      __privateSet(this, _enabled, true);
      __privateGet(this, _scriptURLs).clear();
      __privateGet(this, _scriptSources).clear();
      __privateSet(this, _subscriptions, new DisposableStack());
      const clientEmitter = __privateGet(this, _subscriptions).use(new EventEmitter$1(__privateGet(this, _client)));
      clientEmitter.on("Debugger.scriptParsed", __privateMethod(this, _JSCoverage_instances, onScriptParsed_fn).bind(this));
      clientEmitter.on("Runtime.executionContextsCleared", __privateMethod(this, _JSCoverage_instances, onExecutionContextsCleared_fn).bind(this));
      await Promise.all([
        __privateGet(this, _client).send("Profiler.enable"),
        __privateGet(this, _client).send("Profiler.startPreciseCoverage", {
          callCount: __privateGet(this, _includeRawScriptCoverage),
          detailed: useBlockCoverage
        }),
        __privateGet(this, _client).send("Debugger.enable"),
        __privateGet(this, _client).send("Debugger.setSkipAllPauses", { skip: true })
      ]);
    }
    async stop() {
      var _a3;
      assert$1(__privateGet(this, _enabled), "JSCoverage is not enabled");
      __privateSet(this, _enabled, false);
      const result = await Promise.all([
        __privateGet(this, _client).send("Profiler.takePreciseCoverage"),
        __privateGet(this, _client).send("Profiler.stopPreciseCoverage"),
        __privateGet(this, _client).send("Profiler.disable"),
        __privateGet(this, _client).send("Debugger.disable")
      ]);
      (_a3 = __privateGet(this, _subscriptions)) == null ? void 0 : _a3.dispose();
      const coverage = [];
      const profileResponse = result[0];
      for (const entry of profileResponse.result) {
        let url = __privateGet(this, _scriptURLs).get(entry.scriptId);
        if (!url && __privateGet(this, _reportAnonymousScripts)) {
          url = "debugger://VM" + entry.scriptId;
        }
        const text = __privateGet(this, _scriptSources).get(entry.scriptId);
        if (text === void 0 || url === void 0) {
          continue;
        }
        const flattenRanges = [];
        for (const func of entry.functions) {
          flattenRanges.push(...func.ranges);
        }
        const ranges = convertToDisjointRanges(flattenRanges);
        if (!__privateGet(this, _includeRawScriptCoverage)) {
          coverage.push({ url, ranges, text });
        } else {
          coverage.push({ url, ranges, text, rawScriptCoverage: entry });
        }
      }
      return coverage;
    }
  }
  _client = new WeakMap();
  _enabled = new WeakMap();
  _scriptURLs = new WeakMap();
  _scriptSources = new WeakMap();
  _subscriptions = new WeakMap();
  _resetOnNavigation = new WeakMap();
  _reportAnonymousScripts = new WeakMap();
  _includeRawScriptCoverage = new WeakMap();
  _JSCoverage_instances = new WeakSet();
  onExecutionContextsCleared_fn = function() {
    if (!__privateGet(this, _resetOnNavigation)) {
      return;
    }
    __privateGet(this, _scriptURLs).clear();
    __privateGet(this, _scriptSources).clear();
  };
  onScriptParsed_fn = async function(event) {
    if (PuppeteerURL.isPuppeteerURL(event.url)) {
      return;
    }
    if (!event.url && !__privateGet(this, _reportAnonymousScripts)) {
      return;
    }
    try {
      const response = await __privateGet(this, _client).send("Debugger.getScriptSource", {
        scriptId: event.scriptId
      });
      __privateGet(this, _scriptURLs).set(event.scriptId, event.url);
      __privateGet(this, _scriptSources).set(event.scriptId, response.scriptSource);
    } catch (error) {
      debugError(error);
    }
  };
  class CSSCoverage {
    constructor(client2) {
      __privateAdd(this, _CSSCoverage_instances);
      __privateAdd(this, _client2);
      __privateAdd(this, _enabled2, false);
      __privateAdd(this, _stylesheetURLs, /* @__PURE__ */ new Map());
      __privateAdd(this, _stylesheetSources, /* @__PURE__ */ new Map());
      __privateAdd(this, _eventListeners);
      __privateAdd(this, _resetOnNavigation2, false);
      __privateSet(this, _client2, client2);
    }
    /**
     * @internal
     */
    updateClient(client2) {
      __privateSet(this, _client2, client2);
    }
    async start(options = {}) {
      assert$1(!__privateGet(this, _enabled2), "CSSCoverage is already enabled");
      const { resetOnNavigation = true } = options;
      __privateSet(this, _resetOnNavigation2, resetOnNavigation);
      __privateSet(this, _enabled2, true);
      __privateGet(this, _stylesheetURLs).clear();
      __privateGet(this, _stylesheetSources).clear();
      __privateSet(this, _eventListeners, new DisposableStack());
      const clientEmitter = __privateGet(this, _eventListeners).use(new EventEmitter$1(__privateGet(this, _client2)));
      clientEmitter.on("CSS.styleSheetAdded", __privateMethod(this, _CSSCoverage_instances, onStyleSheet_fn).bind(this));
      clientEmitter.on("Runtime.executionContextsCleared", __privateMethod(this, _CSSCoverage_instances, onExecutionContextsCleared_fn2).bind(this));
      await Promise.all([
        __privateGet(this, _client2).send("DOM.enable"),
        __privateGet(this, _client2).send("CSS.enable"),
        __privateGet(this, _client2).send("CSS.startRuleUsageTracking")
      ]);
    }
    async stop() {
      var _a3;
      assert$1(__privateGet(this, _enabled2), "CSSCoverage is not enabled");
      __privateSet(this, _enabled2, false);
      const ruleTrackingResponse = await __privateGet(this, _client2).send("CSS.stopRuleUsageTracking");
      await Promise.all([
        __privateGet(this, _client2).send("CSS.disable"),
        __privateGet(this, _client2).send("DOM.disable")
      ]);
      (_a3 = __privateGet(this, _eventListeners)) == null ? void 0 : _a3.dispose();
      const styleSheetIdToCoverage = /* @__PURE__ */ new Map();
      for (const entry of ruleTrackingResponse.ruleUsage) {
        let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);
        if (!ranges) {
          ranges = [];
          styleSheetIdToCoverage.set(entry.styleSheetId, ranges);
        }
        ranges.push({
          startOffset: entry.startOffset,
          endOffset: entry.endOffset,
          count: entry.used ? 1 : 0
        });
      }
      const coverage = [];
      for (const styleSheetId of __privateGet(this, _stylesheetURLs).keys()) {
        const url = __privateGet(this, _stylesheetURLs).get(styleSheetId);
        assert$1(typeof url !== "undefined", `Stylesheet URL is undefined (styleSheetId=${styleSheetId})`);
        const text = __privateGet(this, _stylesheetSources).get(styleSheetId);
        assert$1(typeof text !== "undefined", `Stylesheet text is undefined (styleSheetId=${styleSheetId})`);
        const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);
        coverage.push({ url, ranges, text });
      }
      return coverage;
    }
  }
  _client2 = new WeakMap();
  _enabled2 = new WeakMap();
  _stylesheetURLs = new WeakMap();
  _stylesheetSources = new WeakMap();
  _eventListeners = new WeakMap();
  _resetOnNavigation2 = new WeakMap();
  _CSSCoverage_instances = new WeakSet();
  onExecutionContextsCleared_fn2 = function() {
    if (!__privateGet(this, _resetOnNavigation2)) {
      return;
    }
    __privateGet(this, _stylesheetURLs).clear();
    __privateGet(this, _stylesheetSources).clear();
  };
  onStyleSheet_fn = async function(event) {
    const header = event.header;
    if (!header.sourceURL) {
      return;
    }
    try {
      const response = await __privateGet(this, _client2).send("CSS.getStyleSheetText", {
        styleSheetId: header.styleSheetId
      });
      __privateGet(this, _stylesheetURLs).set(header.styleSheetId, header.sourceURL);
      __privateGet(this, _stylesheetSources).set(header.styleSheetId, response.text);
    } catch (error) {
      debugError(error);
    }
  };
  function convertToDisjointRanges(nestedRanges) {
    const points = [];
    for (const range2 of nestedRanges) {
      points.push({ offset: range2.startOffset, type: 0, range: range2 });
      points.push({ offset: range2.endOffset, type: 1, range: range2 });
    }
    points.sort((a, b) => {
      if (a.offset !== b.offset) {
        return a.offset - b.offset;
      }
      if (a.type !== b.type) {
        return b.type - a.type;
      }
      const aLength = a.range.endOffset - a.range.startOffset;
      const bLength = b.range.endOffset - b.range.startOffset;
      if (a.type === 0) {
        return bLength - aLength;
      }
      return aLength - bLength;
    });
    const hitCountStack = [];
    const results = [];
    let lastOffset = 0;
    for (const point of points) {
      if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {
        const lastResult = results[results.length - 1];
        if (lastResult && lastResult.end === lastOffset) {
          lastResult.end = point.offset;
        } else {
          results.push({ start: lastOffset, end: point.offset });
        }
      }
      lastOffset = point.offset;
      if (point.type === 0) {
        hitCountStack.push(point.range.count);
      } else {
        hitCountStack.pop();
      }
    }
    return results.filter((range2) => {
      return range2.end - range2.start > 0;
    });
  }
  /**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class CdpDialog extends Dialog {
    constructor(client2, type, message, defaultValue = "") {
      super(type, message, defaultValue);
      __privateAdd(this, _client3);
      __privateSet(this, _client3, client2);
    }
    async handle(options) {
      await __privateGet(this, _client3).send("Page.handleJavaScriptDialog", {
        accept: options.accept,
        promptText: options.text
      });
    }
  }
  _client3 = new WeakMap();
  var __runInitializers$g = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i2 = 0; i2 < initializers.length; i2++) {
      value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate$g = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind2 = contextIn.kind, key = kind2 === "getter" ? "get" : kind2 === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function(f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i2])(kind2 === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind2 === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_ = accept(result.get)) descriptor.get = _;
        if (_ = accept(result.set)) descriptor.set = _;
        if (_ = accept(result.init)) initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind2 === "field") initializers.unshift(_);
        else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  var __setFunctionName$2 = function(f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
  };
  class EmulatedState {
    constructor(initialState, clientProvider, updater) {
      __privateAdd(this, _state);
      __privateAdd(this, _clientProvider);
      __privateAdd(this, _updater);
      __privateSet(this, _state, initialState);
      __privateSet(this, _clientProvider, clientProvider);
      __privateSet(this, _updater, updater);
      __privateGet(this, _clientProvider).registerState(this);
    }
    async setState(state) {
      __privateSet(this, _state, state);
      await this.sync();
    }
    get state() {
      return __privateGet(this, _state);
    }
    async sync() {
      await Promise.all(__privateGet(this, _clientProvider).clients().map((client2) => {
        return __privateGet(this, _updater).call(this, client2, __privateGet(this, _state));
      }));
    }
  }
  _state = new WeakMap();
  _clientProvider = new WeakMap();
  _updater = new WeakMap();
  let EmulationManager = (() => {
    var _client16, _emulatingMobile, _hasTouch, _states, _viewportState, _idleOverridesState, _timezoneState, _visionDeficiencyState, _cpuThrottlingState, _mediaFeaturesState, _mediaTypeState, _geoLocationState, _defaultBackgroundColorState, _javascriptEnabledState, _secondaryClients, _EmulationManager_instances, applyViewport_get, emulateIdleState_get, emulateTimezone_get, emulateVisionDeficiency_get, emulateCpuThrottling_get, emulateMediaFeatures_get, emulateMediaType_get, setGeolocation_get, setDefaultBackgroundColor_get, setJavaScriptEnabled_get, _a3;
    let _instanceExtraInitializers = [];
    let _private_applyViewport_decorators;
    let _private_applyViewport_descriptor;
    let _private_emulateIdleState_decorators;
    let _private_emulateIdleState_descriptor;
    let _private_emulateTimezone_decorators;
    let _private_emulateTimezone_descriptor;
    let _private_emulateVisionDeficiency_decorators;
    let _private_emulateVisionDeficiency_descriptor;
    let _private_emulateCpuThrottling_decorators;
    let _private_emulateCpuThrottling_descriptor;
    let _private_emulateMediaFeatures_decorators;
    let _private_emulateMediaFeatures_descriptor;
    let _private_emulateMediaType_decorators;
    let _private_emulateMediaType_descriptor;
    let _private_setGeolocation_decorators;
    let _private_setGeolocation_descriptor;
    let _private_setDefaultBackgroundColor_decorators;
    let _private_setDefaultBackgroundColor_descriptor;
    let _private_setJavaScriptEnabled_decorators;
    let _private_setJavaScriptEnabled_descriptor;
    return _a3 = class {
      constructor(client2) {
        __privateAdd(this, _EmulationManager_instances);
        __privateAdd(this, _client16, __runInitializers$g(this, _instanceExtraInitializers));
        __privateAdd(this, _emulatingMobile, false);
        __privateAdd(this, _hasTouch, false);
        __privateAdd(this, _states, []);
        __privateAdd(this, _viewportState, new EmulatedState({
          active: false
        }, this, __privateGet(this, _EmulationManager_instances, applyViewport_get)));
        __privateAdd(this, _idleOverridesState, new EmulatedState({
          active: false
        }, this, __privateGet(this, _EmulationManager_instances, emulateIdleState_get)));
        __privateAdd(this, _timezoneState, new EmulatedState({
          active: false
        }, this, __privateGet(this, _EmulationManager_instances, emulateTimezone_get)));
        __privateAdd(this, _visionDeficiencyState, new EmulatedState({
          active: false
        }, this, __privateGet(this, _EmulationManager_instances, emulateVisionDeficiency_get)));
        __privateAdd(this, _cpuThrottlingState, new EmulatedState({
          active: false
        }, this, __privateGet(this, _EmulationManager_instances, emulateCpuThrottling_get)));
        __privateAdd(this, _mediaFeaturesState, new EmulatedState({
          active: false
        }, this, __privateGet(this, _EmulationManager_instances, emulateMediaFeatures_get)));
        __privateAdd(this, _mediaTypeState, new EmulatedState({
          active: false
        }, this, __privateGet(this, _EmulationManager_instances, emulateMediaType_get)));
        __privateAdd(this, _geoLocationState, new EmulatedState({
          active: false
        }, this, __privateGet(this, _EmulationManager_instances, setGeolocation_get)));
        __privateAdd(this, _defaultBackgroundColorState, new EmulatedState({
          active: false
        }, this, __privateGet(this, _EmulationManager_instances, setDefaultBackgroundColor_get)));
        __privateAdd(this, _javascriptEnabledState, new EmulatedState({
          javaScriptEnabled: true,
          active: false
        }, this, __privateGet(this, _EmulationManager_instances, setJavaScriptEnabled_get)));
        __privateAdd(this, _secondaryClients, /* @__PURE__ */ new Set());
        __privateSet(this, _client16, client2);
      }
      updateClient(client2) {
        __privateSet(this, _client16, client2);
        __privateGet(this, _secondaryClients).delete(client2);
      }
      registerState(state) {
        __privateGet(this, _states).push(state);
      }
      clients() {
        return [__privateGet(this, _client16), ...Array.from(__privateGet(this, _secondaryClients))];
      }
      async registerSpeculativeSession(client2) {
        __privateGet(this, _secondaryClients).add(client2);
        client2.once(CDPSessionEvent.Disconnected, () => {
          __privateGet(this, _secondaryClients).delete(client2);
        });
        void Promise.all(__privateGet(this, _states).map((s) => {
          return s.sync().catch(debugError);
        }));
      }
      get javascriptEnabled() {
        return __privateGet(this, _javascriptEnabledState).state.javaScriptEnabled;
      }
      async emulateViewport(viewport) {
        const currentState = __privateGet(this, _viewportState).state;
        if (!viewport && !currentState.active) {
          return false;
        }
        await __privateGet(this, _viewportState).setState(viewport ? {
          viewport,
          active: true
        } : {
          active: false
        });
        const mobile = (viewport == null ? void 0 : viewport.isMobile) || false;
        const hasTouch = (viewport == null ? void 0 : viewport.hasTouch) || false;
        const reloadNeeded = __privateGet(this, _emulatingMobile) !== mobile || __privateGet(this, _hasTouch) !== hasTouch;
        __privateSet(this, _emulatingMobile, mobile);
        __privateSet(this, _hasTouch, hasTouch);
        return reloadNeeded;
      }
      async emulateIdleState(overrides) {
        await __privateGet(this, _idleOverridesState).setState({
          active: true,
          overrides
        });
      }
      async emulateTimezone(timezoneId) {
        await __privateGet(this, _timezoneState).setState({
          timezoneId,
          active: true
        });
      }
      async emulateVisionDeficiency(type) {
        const visionDeficiencies = /* @__PURE__ */ new Set([
          "none",
          "achromatopsia",
          "blurredVision",
          "deuteranopia",
          "protanopia",
          "reducedContrast",
          "tritanopia"
        ]);
        assert$1(!type || visionDeficiencies.has(type), `Unsupported vision deficiency: ${type}`);
        await __privateGet(this, _visionDeficiencyState).setState({
          active: true,
          visionDeficiency: type
        });
      }
      async emulateCPUThrottling(factor) {
        assert$1(factor === null || factor >= 1, "Throttling rate should be greater or equal to 1");
        await __privateGet(this, _cpuThrottlingState).setState({
          active: true,
          factor: factor ?? void 0
        });
      }
      async emulateMediaFeatures(features) {
        if (Array.isArray(features)) {
          for (const mediaFeature of features) {
            const name = mediaFeature.name;
            assert$1(/^(?:prefers-(?:color-scheme|reduced-motion)|color-gamut)$/.test(name), "Unsupported media feature: " + name);
          }
        }
        await __privateGet(this, _mediaFeaturesState).setState({
          active: true,
          mediaFeatures: features
        });
      }
      async emulateMediaType(type) {
        assert$1(type === "screen" || type === "print" || (type ?? void 0) === void 0, "Unsupported media type: " + type);
        await __privateGet(this, _mediaTypeState).setState({
          type,
          active: true
        });
      }
      async setGeolocation(options) {
        const { longitude, latitude, accuracy = 0 } = options;
        if (longitude < -180 || longitude > 180) {
          throw new Error(`Invalid longitude "${longitude}": precondition -180 <= LONGITUDE <= 180 failed.`);
        }
        if (latitude < -90 || latitude > 90) {
          throw new Error(`Invalid latitude "${latitude}": precondition -90 <= LATITUDE <= 90 failed.`);
        }
        if (accuracy < 0) {
          throw new Error(`Invalid accuracy "${accuracy}": precondition 0 <= ACCURACY failed.`);
        }
        await __privateGet(this, _geoLocationState).setState({
          active: true,
          geoLocation: {
            longitude,
            latitude,
            accuracy
          }
        });
      }
      /**
       * Resets default white background
       */
      async resetDefaultBackgroundColor() {
        await __privateGet(this, _defaultBackgroundColorState).setState({
          active: true,
          color: void 0
        });
      }
      /**
       * Hides default white background
       */
      async setTransparentBackgroundColor() {
        await __privateGet(this, _defaultBackgroundColorState).setState({
          active: true,
          color: { r: 0, g: 0, b: 0, a: 0 }
        });
      }
      async setJavaScriptEnabled(enabled) {
        await __privateGet(this, _javascriptEnabledState).setState({
          active: true,
          javaScriptEnabled: enabled
        });
      }
    }, _client16 = new WeakMap(), _emulatingMobile = new WeakMap(), _hasTouch = new WeakMap(), _states = new WeakMap(), _viewportState = new WeakMap(), _idleOverridesState = new WeakMap(), _timezoneState = new WeakMap(), _visionDeficiencyState = new WeakMap(), _cpuThrottlingState = new WeakMap(), _mediaFeaturesState = new WeakMap(), _mediaTypeState = new WeakMap(), _geoLocationState = new WeakMap(), _defaultBackgroundColorState = new WeakMap(), _javascriptEnabledState = new WeakMap(), _secondaryClients = new WeakMap(), _EmulationManager_instances = new WeakSet(), applyViewport_get = function() {
      return _private_applyViewport_descriptor.value;
    }, emulateIdleState_get = function() {
      return _private_emulateIdleState_descriptor.value;
    }, emulateTimezone_get = function() {
      return _private_emulateTimezone_descriptor.value;
    }, emulateVisionDeficiency_get = function() {
      return _private_emulateVisionDeficiency_descriptor.value;
    }, emulateCpuThrottling_get = function() {
      return _private_emulateCpuThrottling_descriptor.value;
    }, emulateMediaFeatures_get = function() {
      return _private_emulateMediaFeatures_descriptor.value;
    }, emulateMediaType_get = function() {
      return _private_emulateMediaType_descriptor.value;
    }, setGeolocation_get = function() {
      return _private_setGeolocation_descriptor.value;
    }, setDefaultBackgroundColor_get = function() {
      return _private_setDefaultBackgroundColor_descriptor.value;
    }, setJavaScriptEnabled_get = function() {
      return _private_setJavaScriptEnabled_descriptor.value;
    }, (() => {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      _private_applyViewport_decorators = [invokeAtMostOnceForArguments];
      _private_emulateIdleState_decorators = [invokeAtMostOnceForArguments];
      _private_emulateTimezone_decorators = [invokeAtMostOnceForArguments];
      _private_emulateVisionDeficiency_decorators = [invokeAtMostOnceForArguments];
      _private_emulateCpuThrottling_decorators = [invokeAtMostOnceForArguments];
      _private_emulateMediaFeatures_decorators = [invokeAtMostOnceForArguments];
      _private_emulateMediaType_decorators = [invokeAtMostOnceForArguments];
      _private_setGeolocation_decorators = [invokeAtMostOnceForArguments];
      _private_setDefaultBackgroundColor_decorators = [invokeAtMostOnceForArguments];
      _private_setJavaScriptEnabled_decorators = [invokeAtMostOnceForArguments];
      __esDecorate$g(_a3, _private_applyViewport_descriptor = { value: __setFunctionName$2(async function(client2, viewportState) {
        if (!viewportState.viewport) {
          await Promise.all([
            client2.send("Emulation.clearDeviceMetricsOverride"),
            client2.send("Emulation.setTouchEmulationEnabled", {
              enabled: false
            })
          ]).catch(debugError);
          return;
        }
        const { viewport } = viewportState;
        const mobile = viewport.isMobile || false;
        const width = viewport.width;
        const height = viewport.height;
        const deviceScaleFactor = viewport.deviceScaleFactor ?? 1;
        const screenOrientation = viewport.isLandscape ? { angle: 90, type: "landscapePrimary" } : { angle: 0, type: "portraitPrimary" };
        const hasTouch = viewport.hasTouch || false;
        await Promise.all([
          client2.send("Emulation.setDeviceMetricsOverride", {
            mobile,
            width,
            height,
            deviceScaleFactor,
            screenOrientation
          }).catch((err) => {
            if (err.message.includes("Target does not support metrics override")) {
              debugError(err);
              return;
            }
            throw err;
          }),
          client2.send("Emulation.setTouchEmulationEnabled", {
            enabled: hasTouch
          })
        ]);
      }, "#applyViewport") }, _private_applyViewport_decorators, { kind: "method", name: "#applyViewport", static: false, private: true, access: { has: (obj) => __privateIn(_EmulationManager_instances, obj), get: (obj) => __privateGet(obj, _EmulationManager_instances, applyViewport_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$g(_a3, _private_emulateIdleState_descriptor = { value: __setFunctionName$2(async function(client2, idleStateState) {
        if (!idleStateState.active) {
          return;
        }
        if (idleStateState.overrides) {
          await client2.send("Emulation.setIdleOverride", {
            isUserActive: idleStateState.overrides.isUserActive,
            isScreenUnlocked: idleStateState.overrides.isScreenUnlocked
          });
        } else {
          await client2.send("Emulation.clearIdleOverride");
        }
      }, "#emulateIdleState") }, _private_emulateIdleState_decorators, { kind: "method", name: "#emulateIdleState", static: false, private: true, access: { has: (obj) => __privateIn(_EmulationManager_instances, obj), get: (obj) => __privateGet(obj, _EmulationManager_instances, emulateIdleState_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$g(_a3, _private_emulateTimezone_descriptor = { value: __setFunctionName$2(async function(client2, timezoneState) {
        if (!timezoneState.active) {
          return;
        }
        try {
          await client2.send("Emulation.setTimezoneOverride", {
            timezoneId: timezoneState.timezoneId || ""
          });
        } catch (error) {
          if (isErrorLike(error) && error.message.includes("Invalid timezone")) {
            throw new Error(`Invalid timezone ID: ${timezoneState.timezoneId}`);
          }
          throw error;
        }
      }, "#emulateTimezone") }, _private_emulateTimezone_decorators, { kind: "method", name: "#emulateTimezone", static: false, private: true, access: { has: (obj) => __privateIn(_EmulationManager_instances, obj), get: (obj) => __privateGet(obj, _EmulationManager_instances, emulateTimezone_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$g(_a3, _private_emulateVisionDeficiency_descriptor = { value: __setFunctionName$2(async function(client2, visionDeficiency) {
        if (!visionDeficiency.active) {
          return;
        }
        await client2.send("Emulation.setEmulatedVisionDeficiency", {
          type: visionDeficiency.visionDeficiency || "none"
        });
      }, "#emulateVisionDeficiency") }, _private_emulateVisionDeficiency_decorators, { kind: "method", name: "#emulateVisionDeficiency", static: false, private: true, access: { has: (obj) => __privateIn(_EmulationManager_instances, obj), get: (obj) => __privateGet(obj, _EmulationManager_instances, emulateVisionDeficiency_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$g(_a3, _private_emulateCpuThrottling_descriptor = { value: __setFunctionName$2(async function(client2, state) {
        if (!state.active) {
          return;
        }
        await client2.send("Emulation.setCPUThrottlingRate", {
          rate: state.factor ?? 1
        });
      }, "#emulateCpuThrottling") }, _private_emulateCpuThrottling_decorators, { kind: "method", name: "#emulateCpuThrottling", static: false, private: true, access: { has: (obj) => __privateIn(_EmulationManager_instances, obj), get: (obj) => __privateGet(obj, _EmulationManager_instances, emulateCpuThrottling_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$g(_a3, _private_emulateMediaFeatures_descriptor = { value: __setFunctionName$2(async function(client2, state) {
        if (!state.active) {
          return;
        }
        await client2.send("Emulation.setEmulatedMedia", {
          features: state.mediaFeatures
        });
      }, "#emulateMediaFeatures") }, _private_emulateMediaFeatures_decorators, { kind: "method", name: "#emulateMediaFeatures", static: false, private: true, access: { has: (obj) => __privateIn(_EmulationManager_instances, obj), get: (obj) => __privateGet(obj, _EmulationManager_instances, emulateMediaFeatures_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$g(_a3, _private_emulateMediaType_descriptor = { value: __setFunctionName$2(async function(client2, state) {
        if (!state.active) {
          return;
        }
        await client2.send("Emulation.setEmulatedMedia", {
          media: state.type || ""
        });
      }, "#emulateMediaType") }, _private_emulateMediaType_decorators, { kind: "method", name: "#emulateMediaType", static: false, private: true, access: { has: (obj) => __privateIn(_EmulationManager_instances, obj), get: (obj) => __privateGet(obj, _EmulationManager_instances, emulateMediaType_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$g(_a3, _private_setGeolocation_descriptor = { value: __setFunctionName$2(async function(client2, state) {
        if (!state.active) {
          return;
        }
        await client2.send("Emulation.setGeolocationOverride", state.geoLocation ? {
          longitude: state.geoLocation.longitude,
          latitude: state.geoLocation.latitude,
          accuracy: state.geoLocation.accuracy
        } : void 0);
      }, "#setGeolocation") }, _private_setGeolocation_decorators, { kind: "method", name: "#setGeolocation", static: false, private: true, access: { has: (obj) => __privateIn(_EmulationManager_instances, obj), get: (obj) => __privateGet(obj, _EmulationManager_instances, setGeolocation_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$g(_a3, _private_setDefaultBackgroundColor_descriptor = { value: __setFunctionName$2(async function(client2, state) {
        if (!state.active) {
          return;
        }
        await client2.send("Emulation.setDefaultBackgroundColorOverride", {
          color: state.color
        });
      }, "#setDefaultBackgroundColor") }, _private_setDefaultBackgroundColor_decorators, { kind: "method", name: "#setDefaultBackgroundColor", static: false, private: true, access: { has: (obj) => __privateIn(_EmulationManager_instances, obj), get: (obj) => __privateGet(obj, _EmulationManager_instances, setDefaultBackgroundColor_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$g(_a3, _private_setJavaScriptEnabled_descriptor = { value: __setFunctionName$2(async function(client2, state) {
        if (!state.active) {
          return;
        }
        await client2.send("Emulation.setScriptExecutionDisabled", {
          value: !state.javaScriptEnabled
        });
      }, "#setJavaScriptEnabled") }, _private_setJavaScriptEnabled_decorators, { kind: "method", name: "#setJavaScriptEnabled", static: false, private: true, access: { has: (obj) => __privateIn(_EmulationManager_instances, obj), get: (obj) => __privateGet(obj, _EmulationManager_instances, setJavaScriptEnabled_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
      if (_metadata) Object.defineProperty(_a3, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    })(), _a3;
  })();
  /**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class CdpPreloadScript {
    constructor(mainFrame, id, source2) {
      /**
       * This is the ID of the preload script returned by
       * Page.addScriptToEvaluateOnNewDocument in the main frame.
       *
       * Sub-frames would get a different CDP ID because
       * addScriptToEvaluateOnNewDocument is called for each subframe. But
       * users only see this ID and subframe IDs are internal to Puppeteer.
       */
      __privateAdd(this, _id2);
      __privateAdd(this, _source);
      __privateAdd(this, _frameToId, /* @__PURE__ */ new WeakMap());
      __privateSet(this, _id2, id);
      __privateSet(this, _source, source2);
      __privateGet(this, _frameToId).set(mainFrame, id);
    }
    get id() {
      return __privateGet(this, _id2);
    }
    get source() {
      return __privateGet(this, _source);
    }
    getIdForFrame(frame) {
      return __privateGet(this, _frameToId).get(frame);
    }
    setIdForFrame(frame, identifier) {
      __privateGet(this, _frameToId).set(frame, identifier);
    }
  }
  _id2 = new WeakMap();
  _source = new WeakMap();
  _frameToId = new WeakMap();
  /**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class DeviceRequestPromptDevice {
    /**
     * @internal
     */
    constructor(id, name) {
      /**
       * Device id during a prompt.
       */
      __publicField(this, "id");
      /**
       * Device name as it appears in a prompt.
       */
      __publicField(this, "name");
      this.id = id;
      this.name = name;
    }
  }
  class DeviceRequestPrompt {
    /**
     * @internal
     */
    constructor(client2, timeoutSettings, firstEvent) {
      __privateAdd(this, _DeviceRequestPrompt_instances);
      __privateAdd(this, _client4);
      __privateAdd(this, _timeoutSettings);
      __privateAdd(this, _id3);
      __privateAdd(this, _handled2, false);
      __privateAdd(this, _updateDevicesHandle, __privateMethod(this, _DeviceRequestPrompt_instances, updateDevices_fn).bind(this));
      __privateAdd(this, _waitForDevicePromises, /* @__PURE__ */ new Set());
      /**
       * Current list of selectable devices.
       */
      __publicField(this, "devices", []);
      __privateSet(this, _client4, client2);
      __privateSet(this, _timeoutSettings, timeoutSettings);
      __privateSet(this, _id3, firstEvent.id);
      __privateGet(this, _client4).on("DeviceAccess.deviceRequestPrompted", __privateGet(this, _updateDevicesHandle));
      __privateGet(this, _client4).on("Target.detachedFromTarget", () => {
        __privateSet(this, _client4, null);
      });
      __privateMethod(this, _DeviceRequestPrompt_instances, updateDevices_fn).call(this, firstEvent);
    }
    /**
     * Resolve to the first device in the prompt matching a filter.
     */
    async waitForDevice(filter2, options = {}) {
      for (const device of this.devices) {
        if (filter2(device)) {
          return device;
        }
      }
      const { timeout: timeout2 = __privateGet(this, _timeoutSettings).timeout() } = options;
      const deferred = Deferred$1.create({
        message: `Waiting for \`DeviceRequestPromptDevice\` failed: ${timeout2}ms exceeded`,
        timeout: timeout2
      });
      if (options.signal) {
        options.signal.addEventListener("abort", () => {
          var _a3;
          deferred.reject((_a3 = options.signal) == null ? void 0 : _a3.reason);
        }, { once: true });
      }
      const handle = { filter: filter2, promise: deferred };
      __privateGet(this, _waitForDevicePromises).add(handle);
      try {
        return await deferred.valueOrThrow();
      } finally {
        __privateGet(this, _waitForDevicePromises).delete(handle);
      }
    }
    /**
     * Select a device in the prompt's list.
     */
    async select(device) {
      assert$1(__privateGet(this, _client4) !== null, "Cannot select device through detached session!");
      assert$1(this.devices.includes(device), "Cannot select unknown device!");
      assert$1(!__privateGet(this, _handled2), "Cannot select DeviceRequestPrompt which is already handled!");
      __privateGet(this, _client4).off("DeviceAccess.deviceRequestPrompted", __privateGet(this, _updateDevicesHandle));
      __privateSet(this, _handled2, true);
      return await __privateGet(this, _client4).send("DeviceAccess.selectPrompt", {
        id: __privateGet(this, _id3),
        deviceId: device.id
      });
    }
    /**
     * Cancel the prompt.
     */
    async cancel() {
      assert$1(__privateGet(this, _client4) !== null, "Cannot cancel prompt through detached session!");
      assert$1(!__privateGet(this, _handled2), "Cannot cancel DeviceRequestPrompt which is already handled!");
      __privateGet(this, _client4).off("DeviceAccess.deviceRequestPrompted", __privateGet(this, _updateDevicesHandle));
      __privateSet(this, _handled2, true);
      return await __privateGet(this, _client4).send("DeviceAccess.cancelPrompt", { id: __privateGet(this, _id3) });
    }
  }
  _client4 = new WeakMap();
  _timeoutSettings = new WeakMap();
  _id3 = new WeakMap();
  _handled2 = new WeakMap();
  _updateDevicesHandle = new WeakMap();
  _waitForDevicePromises = new WeakMap();
  _DeviceRequestPrompt_instances = new WeakSet();
  updateDevices_fn = function(event) {
    if (event.id !== __privateGet(this, _id3)) {
      return;
    }
    for (const rawDevice of event.devices) {
      if (this.devices.some((device) => {
        return device.id === rawDevice.id;
      })) {
        continue;
      }
      const newDevice = new DeviceRequestPromptDevice(rawDevice.id, rawDevice.name);
      this.devices.push(newDevice);
      for (const waitForDevicePromise of __privateGet(this, _waitForDevicePromises)) {
        if (waitForDevicePromise.filter(newDevice)) {
          waitForDevicePromise.promise.resolve(newDevice);
        }
      }
    }
  };
  class DeviceRequestPromptManager {
    /**
     * @internal
     */
    constructor(client2, timeoutSettings) {
      __privateAdd(this, _DeviceRequestPromptManager_instances);
      __privateAdd(this, _client5);
      __privateAdd(this, _timeoutSettings2);
      __privateAdd(this, _deviceRequestPrompDeferreds, /* @__PURE__ */ new Set());
      __privateSet(this, _client5, client2);
      __privateSet(this, _timeoutSettings2, timeoutSettings);
      __privateGet(this, _client5).on("DeviceAccess.deviceRequestPrompted", (event) => {
        __privateMethod(this, _DeviceRequestPromptManager_instances, onDeviceRequestPrompted_fn).call(this, event);
      });
      __privateGet(this, _client5).on("Target.detachedFromTarget", () => {
        __privateSet(this, _client5, null);
      });
    }
    /**
     * Wait for device prompt created by an action like calling WebBluetooth's
     * requestDevice.
     */
    async waitForDevicePrompt(options = {}) {
      assert$1(__privateGet(this, _client5) !== null, "Cannot wait for device prompt through detached session!");
      const needsEnable = __privateGet(this, _deviceRequestPrompDeferreds).size === 0;
      let enablePromise;
      if (needsEnable) {
        enablePromise = __privateGet(this, _client5).send("DeviceAccess.enable");
      }
      const { timeout: timeout2 = __privateGet(this, _timeoutSettings2).timeout() } = options;
      const deferred = Deferred$1.create({
        message: `Waiting for \`DeviceRequestPrompt\` failed: ${timeout2}ms exceeded`,
        timeout: timeout2
      });
      if (options.signal) {
        options.signal.addEventListener("abort", () => {
          var _a3;
          deferred.reject((_a3 = options.signal) == null ? void 0 : _a3.reason);
        }, { once: true });
      }
      __privateGet(this, _deviceRequestPrompDeferreds).add(deferred);
      try {
        const [result] = await Promise.all([
          deferred.valueOrThrow(),
          enablePromise
        ]);
        return result;
      } finally {
        __privateGet(this, _deviceRequestPrompDeferreds).delete(deferred);
      }
    }
  }
  _client5 = new WeakMap();
  _timeoutSettings2 = new WeakMap();
  _deviceRequestPrompDeferreds = new WeakMap();
  _DeviceRequestPromptManager_instances = new WeakSet();
  /**
   * @internal
   */
  onDeviceRequestPrompted_fn = function(event) {
    if (!__privateGet(this, _deviceRequestPrompDeferreds).size) {
      return;
    }
    assert$1(__privateGet(this, _client5) !== null);
    const devicePrompt = new DeviceRequestPrompt(__privateGet(this, _client5), __privateGet(this, _timeoutSettings2), event);
    for (const promise of __privateGet(this, _deviceRequestPrompDeferreds)) {
      promise.resolve(devicePrompt);
    }
    __privateGet(this, _deviceRequestPrompDeferreds).clear();
  };
  /**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  function createEvaluationError$1(details) {
    let name;
    let message;
    if (!details.exception) {
      name = "Error";
      message = details.text;
    } else if ((details.exception.type !== "object" || details.exception.subtype !== "error") && !details.exception.objectId) {
      return valueFromRemoteObject(details.exception);
    } else {
      const detail = getErrorDetails(details);
      name = detail.name;
      message = detail.message;
    }
    const messageHeight = message.split("\n").length;
    const error = new Error(message);
    error.name = name;
    const stackLines = error.stack.split("\n");
    const messageLines = stackLines.splice(0, messageHeight);
    stackLines.shift();
    if (details.stackTrace && stackLines.length < Error.stackTraceLimit) {
      for (const frame of details.stackTrace.callFrames.reverse()) {
        if (PuppeteerURL.isPuppeteerURL(frame.url) && frame.url !== PuppeteerURL.INTERNAL_URL) {
          const url = PuppeteerURL.parse(frame.url);
          stackLines.unshift(`    at ${frame.functionName || url.functionName} (${url.functionName} at ${url.siteString}, <anonymous>:${frame.lineNumber}:${frame.columnNumber})`);
        } else {
          stackLines.push(`    at ${frame.functionName || "<anonymous>"} (${frame.url}:${frame.lineNumber}:${frame.columnNumber})`);
        }
        if (stackLines.length >= Error.stackTraceLimit) {
          break;
        }
      }
    }
    error.stack = [...messageLines, ...stackLines].join("\n");
    return error;
  }
  const getErrorDetails = (details) => {
    var _a3, _b2, _c2, _d2;
    let name = "";
    let message;
    const lines = ((_b2 = (_a3 = details.exception) == null ? void 0 : _a3.description) == null ? void 0 : _b2.split("\n    at ")) ?? [];
    const size = Math.min(((_c2 = details.stackTrace) == null ? void 0 : _c2.callFrames.length) ?? 0, lines.length - 1);
    lines.splice(-size, size);
    if ((_d2 = details.exception) == null ? void 0 : _d2.className) {
      name = details.exception.className;
    }
    message = lines.join("\n");
    if (name && message.startsWith(`${name}: `)) {
      message = message.slice(name.length + 2);
    }
    return { message, name };
  };
  function createClientError(details) {
    let name;
    let message;
    if (!details.exception) {
      name = "Error";
      message = details.text;
    } else if ((details.exception.type !== "object" || details.exception.subtype !== "error") && !details.exception.objectId) {
      return valueFromRemoteObject(details.exception);
    } else {
      const detail = getErrorDetails(details);
      name = detail.name;
      message = detail.message;
    }
    const error = new Error(message);
    error.name = name;
    const messageHeight = error.message.split("\n").length;
    const messageLines = error.stack.split("\n").splice(0, messageHeight);
    const stackLines = [];
    if (details.stackTrace) {
      for (const frame of details.stackTrace.callFrames) {
        stackLines.push(`    at ${frame.functionName || "<anonymous>"} (${frame.url}:${frame.lineNumber + 1}:${frame.columnNumber + 1})`);
        if (stackLines.length >= Error.stackTraceLimit) {
          break;
        }
      }
    }
    error.stack = [...messageLines, ...stackLines].join("\n");
    return error;
  }
  function valueFromRemoteObject(remoteObject) {
    assert$1(!remoteObject.objectId, "Cannot extract value when objectId is given");
    if (remoteObject.unserializableValue) {
      if (remoteObject.type === "bigint") {
        return BigInt(remoteObject.unserializableValue.replace("n", ""));
      }
      switch (remoteObject.unserializableValue) {
        case "-0":
          return -0;
        case "NaN":
          return NaN;
        case "Infinity":
          return Infinity;
        case "-Infinity":
          return -Infinity;
        default:
          throw new Error("Unsupported unserializable value: " + remoteObject.unserializableValue);
      }
    }
    return remoteObject.value;
  }
  function addPageBinding(type, name, prefix) {
    if (globalThis[name]) {
      return;
    }
    Object.assign(globalThis, {
      [name](...args) {
        const callPuppeteer = globalThis[name];
        callPuppeteer.args ?? (callPuppeteer.args = /* @__PURE__ */ new Map());
        callPuppeteer.callbacks ?? (callPuppeteer.callbacks = /* @__PURE__ */ new Map());
        const seq = (callPuppeteer.lastSeq ?? 0) + 1;
        callPuppeteer.lastSeq = seq;
        callPuppeteer.args.set(seq, args);
        globalThis[prefix + name](JSON.stringify({
          type,
          name,
          seq,
          args,
          isTrivial: !args.some((value) => {
            return value instanceof Node;
          })
        }));
        return new Promise((resolve, reject) => {
          callPuppeteer.callbacks.set(seq, {
            resolve(value) {
              callPuppeteer.args.delete(seq);
              resolve(value);
            },
            reject(value) {
              callPuppeteer.args.delete(seq);
              reject(value);
            }
          });
        });
      }
    });
  }
  const CDP_BINDING_PREFIX = "puppeteer_";
  function pageBindingInitString(type, name) {
    return evaluationString(addPageBinding, type, name, CDP_BINDING_PREFIX);
  }
  /**
   * @license
   * Copyright 2019 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class CdpJSHandle extends JSHandle {
    constructor(world, remoteObject) {
      super();
      __privateAdd(this, _disposed4, false);
      __privateAdd(this, _remoteObject);
      __privateAdd(this, _world2);
      __privateSet(this, _world2, world);
      __privateSet(this, _remoteObject, remoteObject);
    }
    get disposed() {
      return __privateGet(this, _disposed4);
    }
    get realm() {
      return __privateGet(this, _world2);
    }
    get client() {
      return this.realm.environment.client;
    }
    async jsonValue() {
      if (!__privateGet(this, _remoteObject).objectId) {
        return valueFromRemoteObject(__privateGet(this, _remoteObject));
      }
      const value = await this.evaluate((object) => {
        return object;
      });
      if (value === void 0) {
        throw new Error("Could not serialize referenced object");
      }
      return value;
    }
    /**
     * Either `null` or the handle itself if the handle is an
     * instance of {@link ElementHandle}.
     */
    asElement() {
      return null;
    }
    async dispose() {
      if (__privateGet(this, _disposed4)) {
        return;
      }
      __privateSet(this, _disposed4, true);
      await releaseObject(this.client, __privateGet(this, _remoteObject));
    }
    toString() {
      if (!__privateGet(this, _remoteObject).objectId) {
        return "JSHandle:" + valueFromRemoteObject(__privateGet(this, _remoteObject));
      }
      const type = __privateGet(this, _remoteObject).subtype || __privateGet(this, _remoteObject).type;
      return "JSHandle@" + type;
    }
    get id() {
      return __privateGet(this, _remoteObject).objectId;
    }
    remoteObject() {
      return __privateGet(this, _remoteObject);
    }
    async getProperties() {
      const response = await this.client.send("Runtime.getProperties", {
        objectId: __privateGet(this, _remoteObject).objectId,
        ownProperties: true
      });
      const result = /* @__PURE__ */ new Map();
      for (const property of response.result) {
        if (!property.enumerable || !property.value) {
          continue;
        }
        result.set(property.name, __privateGet(this, _world2).createCdpHandle(property.value));
      }
      return result;
    }
  }
  _disposed4 = new WeakMap();
  _remoteObject = new WeakMap();
  _world2 = new WeakMap();
  async function releaseObject(client2, remoteObject) {
    if (!remoteObject.objectId) {
      return;
    }
    await client2.send("Runtime.releaseObject", { objectId: remoteObject.objectId }).catch((error) => {
      debugError(error);
    });
  }
  /**
   * @license
   * Copyright 2019 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var __runInitializers$f = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i2 = 0; i2 < initializers.length; i2++) {
      value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate$f = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind2 = contextIn.kind, key = kind2 === "getter" ? "get" : kind2 === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function(f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i2])(kind2 === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind2 === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_ = accept(result.get)) descriptor.get = _;
        if (_ = accept(result.set)) descriptor.set = _;
        if (_ = accept(result.init)) initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind2 === "field") initializers.unshift(_);
        else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  const NON_ELEMENT_NODE_ROLES = /* @__PURE__ */ new Set(["StaticText", "InlineTextBox"]);
  let CdpElementHandle = (() => {
    var _backendNodeId, _CdpElementHandle_instances, frameManager_get, _a3;
    let _classSuper = ElementHandle;
    let _instanceExtraInitializers = [];
    let _contentFrame_decorators;
    let _scrollIntoView_decorators;
    let _uploadFile_decorators;
    let _autofill_decorators;
    return _a3 = class extends _classSuper {
      constructor(world, remoteObject) {
        super(new CdpJSHandle(world, remoteObject));
        __privateAdd(this, _CdpElementHandle_instances);
        __privateAdd(this, _backendNodeId, __runInitializers$f(this, _instanceExtraInitializers));
      }
      get realm() {
        return this.handle.realm;
      }
      get client() {
        return this.handle.client;
      }
      remoteObject() {
        return this.handle.remoteObject();
      }
      get frame() {
        return this.realm.environment;
      }
      async contentFrame() {
        const nodeInfo = await this.client.send("DOM.describeNode", {
          objectId: this.id
        });
        if (typeof nodeInfo.node.frameId !== "string") {
          return null;
        }
        return __privateGet(this, _CdpElementHandle_instances, frameManager_get).frame(nodeInfo.node.frameId);
      }
      async scrollIntoView() {
        await this.assertConnectedElement();
        try {
          await this.client.send("DOM.scrollIntoViewIfNeeded", {
            objectId: this.id
          });
        } catch (error) {
          debugError(error);
          await super.scrollIntoView();
        }
      }
      async uploadFile(...files) {
        const isMultiple = await this.evaluate((element) => {
          return element.multiple;
        });
        assert$1(files.length <= 1 || isMultiple, "Multiple file uploads only work with <input type=file multiple>");
        const path = environment.value.path;
        if (path) {
          files = files.map((filePath) => {
            if (path.win32.isAbsolute(filePath) || path.posix.isAbsolute(filePath)) {
              return filePath;
            } else {
              return path.resolve(filePath);
            }
          });
        }
        if (files.length === 0) {
          await this.evaluate((element) => {
            element.files = new DataTransfer().files;
            element.dispatchEvent(new Event("input", { bubbles: true, composed: true }));
            element.dispatchEvent(new Event("change", { bubbles: true }));
          });
          return;
        }
        const { node: { backendNodeId } } = await this.client.send("DOM.describeNode", {
          objectId: this.id
        });
        await this.client.send("DOM.setFileInputFiles", {
          objectId: this.id,
          files,
          backendNodeId
        });
      }
      async autofill(data) {
        const nodeInfo = await this.client.send("DOM.describeNode", {
          objectId: this.handle.id
        });
        const fieldId = nodeInfo.node.backendNodeId;
        const frameId = this.frame._id;
        await this.client.send("Autofill.trigger", {
          fieldId,
          frameId,
          card: data.creditCard
        });
      }
      async *queryAXTree(name, role) {
        const { nodes } = await this.client.send("Accessibility.queryAXTree", {
          objectId: this.id,
          accessibleName: name,
          role
        });
        const results = nodes.filter((node) => {
          if (node.ignored) {
            return false;
          }
          if (!node.role) {
            return false;
          }
          if (NON_ELEMENT_NODE_ROLES.has(node.role.value)) {
            return false;
          }
          return true;
        });
        return yield* AsyncIterableUtil.map(results, (node) => {
          return this.realm.adoptBackendNode(node.backendDOMNodeId);
        });
      }
      async backendNodeId() {
        if (__privateGet(this, _backendNodeId)) {
          return __privateGet(this, _backendNodeId);
        }
        const { node } = await this.client.send("DOM.describeNode", {
          objectId: this.handle.id
        });
        __privateSet(this, _backendNodeId, node.backendNodeId);
        return __privateGet(this, _backendNodeId);
      }
    }, _backendNodeId = new WeakMap(), _CdpElementHandle_instances = new WeakSet(), frameManager_get = function() {
      return this.frame._frameManager;
    }, (() => {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      _contentFrame_decorators = [throwIfDisposed()];
      _scrollIntoView_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _uploadFile_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _autofill_decorators = [throwIfDisposed()];
      __esDecorate$f(_a3, null, _contentFrame_decorators, { kind: "method", name: "contentFrame", static: false, private: false, access: { has: (obj) => "contentFrame" in obj, get: (obj) => obj.contentFrame }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$f(_a3, null, _scrollIntoView_decorators, { kind: "method", name: "scrollIntoView", static: false, private: false, access: { has: (obj) => "scrollIntoView" in obj, get: (obj) => obj.scrollIntoView }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$f(_a3, null, _uploadFile_decorators, { kind: "method", name: "uploadFile", static: false, private: false, access: { has: (obj) => "uploadFile" in obj, get: (obj) => obj.uploadFile }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$f(_a3, null, _autofill_decorators, { kind: "method", name: "autofill", static: false, private: false, access: { has: (obj) => "autofill" in obj, get: (obj) => obj.autofill }, metadata: _metadata }, null, _instanceExtraInitializers);
      if (_metadata) Object.defineProperty(_a3, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    })(), _a3;
  })();
  /**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var __addDisposableResource$8 = function(env, value, async2) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async2) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async2) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({ value, dispose, async: async2 });
    } else if (async2) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources$8 = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  const ariaQuerySelectorBinding = new Binding("__ariaQuerySelector", ARIAQueryHandler.queryOne, "");
  const ariaQuerySelectorAllBinding = new Binding("__ariaQuerySelectorAll", async (element, selector) => {
    const results = ARIAQueryHandler.queryAll(element, selector);
    return await element.realm.evaluateHandle((...elements) => {
      return elements;
    }, ...await AsyncIterableUtil.collect(results));
  }, "");
  class ExecutionContext extends EventEmitter$1 {
    constructor(client2, contextPayload, world) {
      super();
      __privateAdd(this, _ExecutionContext_instances);
      __privateAdd(this, _client6);
      __privateAdd(this, _world3);
      __privateAdd(this, _id4);
      __privateAdd(this, _name3);
      __privateAdd(this, _disposables, new DisposableStack());
      // Contains mapping from functions that should be bound to Puppeteer functions.
      __privateAdd(this, _bindings, /* @__PURE__ */ new Map());
      // If multiple waitFor are set up asynchronously, we need to wait for the
      // first one to set up the binding in the page before running the others.
      __privateAdd(this, _mutex2, new Mutex$1());
      __privateAdd(this, _bindingsInstalled, false);
      __privateAdd(this, _puppeteerUtil);
      __privateSet(this, _client6, client2);
      __privateSet(this, _world3, world);
      __privateSet(this, _id4, contextPayload.id);
      if (contextPayload.name) {
        __privateSet(this, _name3, contextPayload.name);
      }
      const clientEmitter = __privateGet(this, _disposables).use(new EventEmitter$1(__privateGet(this, _client6)));
      clientEmitter.on("Runtime.bindingCalled", __privateMethod(this, _ExecutionContext_instances, onBindingCalled_fn).bind(this));
      clientEmitter.on("Runtime.executionContextDestroyed", async (event) => {
        if (event.executionContextId === __privateGet(this, _id4)) {
          this[disposeSymbol]();
        }
      });
      clientEmitter.on("Runtime.executionContextsCleared", async () => {
        this[disposeSymbol]();
      });
      clientEmitter.on("Runtime.consoleAPICalled", __privateMethod(this, _ExecutionContext_instances, onConsoleAPI_fn).bind(this));
      clientEmitter.on(CDPSessionEvent.Disconnected, () => {
        this[disposeSymbol]();
      });
    }
    get id() {
      return __privateGet(this, _id4);
    }
    get puppeteerUtil() {
      let promise = Promise.resolve();
      if (!__privateGet(this, _bindingsInstalled)) {
        promise = Promise.all([
          __privateMethod(this, _ExecutionContext_instances, addBindingWithoutThrowing_fn).call(this, ariaQuerySelectorBinding),
          __privateMethod(this, _ExecutionContext_instances, addBindingWithoutThrowing_fn).call(this, ariaQuerySelectorAllBinding)
        ]);
        __privateSet(this, _bindingsInstalled, true);
      }
      scriptInjector.inject((script) => {
        if (__privateGet(this, _puppeteerUtil)) {
          void __privateGet(this, _puppeteerUtil).then((handle) => {
            void handle.dispose();
          });
        }
        __privateSet(this, _puppeteerUtil, promise.then(() => {
          return this.evaluateHandle(script);
        }));
      }, !__privateGet(this, _puppeteerUtil));
      return __privateGet(this, _puppeteerUtil);
    }
    /**
     * Evaluates the given function.
     *
     * @example
     *
     * ```ts
     * const executionContext = await page.mainFrame().executionContext();
     * const result = await executionContext.evaluate(() => Promise.resolve(8 * 7))* ;
     * console.log(result); // prints "56"
     * ```
     *
     * @example
     * A string can also be passed in instead of a function:
     *
     * ```ts
     * console.log(await executionContext.evaluate('1 + 2')); // prints "3"
     * ```
     *
     * @example
     * Handles can also be passed as `args`. They resolve to their referenced object:
     *
     * ```ts
     * const oneHandle = await executionContext.evaluateHandle(() => 1);
     * const twoHandle = await executionContext.evaluateHandle(() => 2);
     * const result = await executionContext.evaluate(
     *   (a, b) => a + b,
     *   oneHandle,
     *   twoHandle,
     * );
     * await oneHandle.dispose();
     * await twoHandle.dispose();
     * console.log(result); // prints '3'.
     * ```
     *
     * @param pageFunction - The function to evaluate.
     * @param args - Additional arguments to pass into the function.
     * @returns The result of evaluating the function. If the result is an object,
     * a vanilla object containing the serializable properties of the result is
     * returned.
     */
    async evaluate(pageFunction, ...args) {
      return await __privateMethod(this, _ExecutionContext_instances, evaluate_fn).call(this, true, pageFunction, ...args);
    }
    /**
     * Evaluates the given function.
     *
     * Unlike {@link ExecutionContext.evaluate | evaluate}, this method returns a
     * handle to the result of the function.
     *
     * This method may be better suited if the object cannot be serialized (e.g.
     * `Map`) and requires further manipulation.
     *
     * @example
     *
     * ```ts
     * const context = await page.mainFrame().executionContext();
     * const handle: JSHandle<typeof globalThis> = await context.evaluateHandle(
     *   () => Promise.resolve(self),
     * );
     * ```
     *
     * @example
     * A string can also be passed in instead of a function.
     *
     * ```ts
     * const handle: JSHandle<number> = await context.evaluateHandle('1 + 2');
     * ```
     *
     * @example
     * Handles can also be passed as `args`. They resolve to their referenced object:
     *
     * ```ts
     * const bodyHandle: ElementHandle<HTMLBodyElement> =
     *   await context.evaluateHandle(() => {
     *     return document.body;
     *   });
     * const stringHandle: JSHandle<string> = await context.evaluateHandle(
     *   body => body.innerHTML,
     *   body,
     * );
     * console.log(await stringHandle.jsonValue()); // prints body's innerHTML
     * // Always dispose your garbage! :)
     * await bodyHandle.dispose();
     * await stringHandle.dispose();
     * ```
     *
     * @param pageFunction - The function to evaluate.
     * @param args - Additional arguments to pass into the function.
     * @returns A {@link JSHandle | handle} to the result of evaluating the
     * function. If the result is a `Node`, then this will return an
     * {@link ElementHandle | element handle}.
     */
    async evaluateHandle(pageFunction, ...args) {
      return await __privateMethod(this, _ExecutionContext_instances, evaluate_fn).call(this, false, pageFunction, ...args);
    }
    [disposeSymbol]() {
      __privateGet(this, _disposables).dispose();
      this.emit("disposed", void 0);
    }
  }
  _client6 = new WeakMap();
  _world3 = new WeakMap();
  _id4 = new WeakMap();
  _name3 = new WeakMap();
  _disposables = new WeakMap();
  _bindings = new WeakMap();
  _mutex2 = new WeakMap();
  _ExecutionContext_instances = new WeakSet();
  addBinding_fn = async function(binding) {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
      if (__privateGet(this, _bindings).has(binding.name)) {
        return;
      }
      const _ = __addDisposableResource$8(env_1, await __privateGet(this, _mutex2).acquire(), false);
      try {
        await __privateGet(this, _client6).send("Runtime.addBinding", __privateGet(this, _name3) ? {
          name: CDP_BINDING_PREFIX + binding.name,
          executionContextName: __privateGet(this, _name3)
        } : {
          name: CDP_BINDING_PREFIX + binding.name,
          executionContextId: __privateGet(this, _id4)
        });
        await this.evaluate(addPageBinding, "internal", binding.name, CDP_BINDING_PREFIX);
        __privateGet(this, _bindings).set(binding.name, binding);
      } catch (error) {
        if (error instanceof Error) {
          if (error.message.includes("Execution context was destroyed")) {
            return;
          }
          if (error.message.includes("Cannot find context with specified id")) {
            return;
          }
        }
        debugError(error);
      }
    } catch (e_1) {
      env_1.error = e_1;
      env_1.hasError = true;
    } finally {
      __disposeResources$8(env_1);
    }
  };
  onBindingCalled_fn = async function(event) {
    if (event.executionContextId !== __privateGet(this, _id4)) {
      return;
    }
    let payload;
    try {
      payload = JSON.parse(event.payload);
    } catch {
      return;
    }
    const { type, name, seq, args, isTrivial } = payload;
    if (type !== "internal") {
      this.emit("bindingcalled", event);
      return;
    }
    if (!__privateGet(this, _bindings).has(name)) {
      this.emit("bindingcalled", event);
      return;
    }
    try {
      const binding = __privateGet(this, _bindings).get(name);
      await (binding == null ? void 0 : binding.run(this, seq, args, isTrivial));
    } catch (err) {
      debugError(err);
    }
  };
  onConsoleAPI_fn = function(event) {
    if (event.executionContextId !== __privateGet(this, _id4)) {
      return;
    }
    this.emit("consoleapicalled", event);
  };
  _bindingsInstalled = new WeakMap();
  _puppeteerUtil = new WeakMap();
  addBindingWithoutThrowing_fn = async function(binding) {
    try {
      await __privateMethod(this, _ExecutionContext_instances, addBinding_fn).call(this, binding);
    } catch (err) {
      debugError(err);
    }
  };
  evaluate_fn = async function(returnByValue, pageFunction, ...args) {
    var _a3;
    const sourceUrlComment = getSourceUrlComment(((_a3 = getSourcePuppeteerURLIfAvailable(pageFunction)) == null ? void 0 : _a3.toString()) ?? PuppeteerURL.INTERNAL_URL);
    if (isString(pageFunction)) {
      const contextId = __privateGet(this, _id4);
      const expression = pageFunction;
      const expressionWithSourceUrl = SOURCE_URL_REGEX.test(expression) ? expression : `${expression}
${sourceUrlComment}
`;
      const { exceptionDetails: exceptionDetails2, result: remoteObject2 } = await __privateGet(this, _client6).send("Runtime.evaluate", {
        expression: expressionWithSourceUrl,
        contextId,
        returnByValue,
        awaitPromise: true,
        userGesture: true
      }).catch(rewriteError);
      if (exceptionDetails2) {
        throw createEvaluationError$1(exceptionDetails2);
      }
      return returnByValue ? valueFromRemoteObject(remoteObject2) : __privateGet(this, _world3).createCdpHandle(remoteObject2);
    }
    const functionDeclaration = stringifyFunction(pageFunction);
    const functionDeclarationWithSourceUrl = SOURCE_URL_REGEX.test(functionDeclaration) ? functionDeclaration : `${functionDeclaration}
${sourceUrlComment}
`;
    let callFunctionOnPromise;
    try {
      callFunctionOnPromise = __privateGet(this, _client6).send("Runtime.callFunctionOn", {
        functionDeclaration: functionDeclarationWithSourceUrl,
        executionContextId: __privateGet(this, _id4),
        // LazyArgs are used only internally and should not affect the order
        // evaluate calls for the public APIs.
        arguments: args.some((arg) => {
          return arg instanceof LazyArg;
        }) ? await Promise.all(args.map((arg) => {
          return convertArgumentAsync(this, arg);
        })) : args.map((arg) => {
          return convertArgument(this, arg);
        }),
        returnByValue,
        awaitPromise: true,
        userGesture: true
      });
    } catch (error) {
      if (error instanceof TypeError && error.message.startsWith("Converting circular structure to JSON")) {
        error.message += " Recursive objects are not allowed.";
      }
      throw error;
    }
    const { exceptionDetails, result: remoteObject } = await callFunctionOnPromise.catch(rewriteError);
    if (exceptionDetails) {
      throw createEvaluationError$1(exceptionDetails);
    }
    return returnByValue ? valueFromRemoteObject(remoteObject) : __privateGet(this, _world3).createCdpHandle(remoteObject);
    async function convertArgumentAsync(context, arg) {
      if (arg instanceof LazyArg) {
        arg = await arg.get(context);
      }
      return convertArgument(context, arg);
    }
    function convertArgument(context, arg) {
      if (typeof arg === "bigint") {
        return { unserializableValue: `${arg.toString()}n` };
      }
      if (Object.is(arg, -0)) {
        return { unserializableValue: "-0" };
      }
      if (Object.is(arg, Infinity)) {
        return { unserializableValue: "Infinity" };
      }
      if (Object.is(arg, -Infinity)) {
        return { unserializableValue: "-Infinity" };
      }
      if (Object.is(arg, NaN)) {
        return { unserializableValue: "NaN" };
      }
      const objectHandle = arg && (arg instanceof CdpJSHandle || arg instanceof CdpElementHandle) ? arg : null;
      if (objectHandle) {
        if (objectHandle.realm !== __privateGet(context, _world3)) {
          throw new Error("JSHandles can be evaluated only in the context they were created!");
        }
        if (objectHandle.disposed) {
          throw new Error("JSHandle is disposed!");
        }
        if (objectHandle.remoteObject().unserializableValue) {
          return {
            unserializableValue: objectHandle.remoteObject().unserializableValue
          };
        }
        if (!objectHandle.remoteObject().objectId) {
          return { value: objectHandle.remoteObject().value };
        }
        return { objectId: objectHandle.remoteObject().objectId };
      }
      return { value: arg };
    }
  };
  const rewriteError = (error) => {
    if (error.message.includes("Object reference chain is too long")) {
      return { result: { type: "undefined" } };
    }
    if (error.message.includes("Object couldn't be returned by value")) {
      return { result: { type: "undefined" } };
    }
    if (error.message.endsWith("Cannot find context with specified id") || error.message.endsWith("Inspected target navigated or closed")) {
      throw new Error("Execution context was destroyed, most likely because of a navigation.");
    }
    throw error;
  };
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var FrameManagerEvent;
  (function(FrameManagerEvent2) {
    FrameManagerEvent2.FrameAttached = Symbol("FrameManager.FrameAttached");
    FrameManagerEvent2.FrameNavigated = Symbol("FrameManager.FrameNavigated");
    FrameManagerEvent2.FrameDetached = Symbol("FrameManager.FrameDetached");
    FrameManagerEvent2.FrameSwapped = Symbol("FrameManager.FrameSwapped");
    FrameManagerEvent2.LifecycleEvent = Symbol("FrameManager.LifecycleEvent");
    FrameManagerEvent2.FrameNavigatedWithinDocument = Symbol("FrameManager.FrameNavigatedWithinDocument");
    FrameManagerEvent2.ConsoleApiCalled = Symbol("FrameManager.ConsoleApiCalled");
    FrameManagerEvent2.BindingCalled = Symbol("FrameManager.BindingCalled");
  })(FrameManagerEvent || (FrameManagerEvent = {}));
  /**
   * @license
   * Copyright 2019 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class IsolatedWorld extends Realm$2 {
    constructor(frameOrWorker, timeoutSettings) {
      super(timeoutSettings);
      __privateAdd(this, _IsolatedWorld_instances);
      __privateAdd(this, _context);
      __privateAdd(this, _emitter2, new EventEmitter$1());
      __privateAdd(this, _frameOrWorker);
      __privateSet(this, _frameOrWorker, frameOrWorker);
    }
    get environment() {
      return __privateGet(this, _frameOrWorker);
    }
    get client() {
      return __privateGet(this, _frameOrWorker).client;
    }
    get emitter() {
      return __privateGet(this, _emitter2);
    }
    setContext(context) {
      var _a3;
      (_a3 = __privateGet(this, _context)) == null ? void 0 : _a3[disposeSymbol]();
      context.once("disposed", __privateMethod(this, _IsolatedWorld_instances, onContextDisposed_fn).bind(this));
      context.on("consoleapicalled", __privateMethod(this, _IsolatedWorld_instances, onContextConsoleApiCalled_fn).bind(this));
      context.on("bindingcalled", __privateMethod(this, _IsolatedWorld_instances, onContextBindingCalled_fn).bind(this));
      __privateSet(this, _context, context);
      __privateGet(this, _emitter2).emit("context", context);
      void this.taskManager.rerunAll();
    }
    hasContext() {
      return !!__privateGet(this, _context);
    }
    get context() {
      return __privateGet(this, _context);
    }
    async evaluateHandle(pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
      let context = __privateMethod(this, _IsolatedWorld_instances, executionContext_fn).call(this);
      if (!context) {
        context = await __privateMethod(this, _IsolatedWorld_instances, waitForExecutionContext_fn).call(this);
      }
      return await context.evaluateHandle(pageFunction, ...args);
    }
    async evaluate(pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
      let context = __privateMethod(this, _IsolatedWorld_instances, executionContext_fn).call(this);
      if (!context) {
        context = await __privateMethod(this, _IsolatedWorld_instances, waitForExecutionContext_fn).call(this);
      }
      return await context.evaluate(pageFunction, ...args);
    }
    async adoptBackendNode(backendNodeId) {
      let context = __privateMethod(this, _IsolatedWorld_instances, executionContext_fn).call(this);
      if (!context) {
        context = await __privateMethod(this, _IsolatedWorld_instances, waitForExecutionContext_fn).call(this);
      }
      const { object } = await this.client.send("DOM.resolveNode", {
        backendNodeId,
        executionContextId: context.id
      });
      return this.createCdpHandle(object);
    }
    async adoptHandle(handle) {
      if (handle.realm === this) {
        return await handle.evaluateHandle((value) => {
          return value;
        });
      }
      const nodeInfo = await this.client.send("DOM.describeNode", {
        objectId: handle.id
      });
      return await this.adoptBackendNode(nodeInfo.node.backendNodeId);
    }
    async transferHandle(handle) {
      if (handle.realm === this) {
        return handle;
      }
      if (handle.remoteObject().objectId === void 0) {
        return handle;
      }
      const info = await this.client.send("DOM.describeNode", {
        objectId: handle.remoteObject().objectId
      });
      const newHandle = await this.adoptBackendNode(info.node.backendNodeId);
      await handle.dispose();
      return newHandle;
    }
    /**
     * @internal
     */
    createCdpHandle(remoteObject) {
      if (remoteObject.subtype === "node") {
        return new CdpElementHandle(this, remoteObject);
      }
      return new CdpJSHandle(this, remoteObject);
    }
    [disposeSymbol]() {
      var _a3;
      (_a3 = __privateGet(this, _context)) == null ? void 0 : _a3[disposeSymbol]();
      __privateGet(this, _emitter2).emit("disposed", void 0);
      super[disposeSymbol]();
      __privateGet(this, _emitter2).removeAllListeners();
    }
  }
  _context = new WeakMap();
  _emitter2 = new WeakMap();
  _frameOrWorker = new WeakMap();
  _IsolatedWorld_instances = new WeakSet();
  onContextDisposed_fn = function() {
    __privateSet(this, _context, void 0);
    if ("clearDocumentHandle" in __privateGet(this, _frameOrWorker)) {
      __privateGet(this, _frameOrWorker).clearDocumentHandle();
    }
  };
  onContextConsoleApiCalled_fn = function(event) {
    __privateGet(this, _emitter2).emit("consoleapicalled", event);
  };
  onContextBindingCalled_fn = function(event) {
    __privateGet(this, _emitter2).emit("bindingcalled", event);
  };
  executionContext_fn = function() {
    if (this.disposed) {
      throw new Error(`Execution context is not available in detached frame or worker "${this.environment.url()}" (are you trying to evaluate?)`);
    }
    return __privateGet(this, _context);
  };
  waitForExecutionContext_fn = async function() {
    const error = new Error("Execution context was destroyed");
    const result = await firstValueFrom(fromEmitterEvent(__privateGet(this, _emitter2), "context").pipe(raceWith(fromEmitterEvent(__privateGet(this, _emitter2), "disposed").pipe(map(() => {
      throw error;
    })), timeout(this.timeoutSettings.timeout()))));
    return result;
  };
  /**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  const MAIN_WORLD = Symbol("mainWorld");
  const PUPPETEER_WORLD = Symbol("puppeteerWorld");
  /**
   * @license
   * Copyright 2019 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  const puppeteerToProtocolLifecycle = /* @__PURE__ */ new Map([
    ["load", "load"],
    ["domcontentloaded", "DOMContentLoaded"],
    ["networkidle0", "networkIdle"],
    ["networkidle2", "networkAlmostIdle"]
  ]);
  class LifecycleWatcher {
    constructor(networkManager, frame, waitUntil, timeout2, signal) {
      __privateAdd(this, _LifecycleWatcher_instances);
      __privateAdd(this, _expectedLifecycle);
      __privateAdd(this, _frame2);
      __privateAdd(this, _timeout3);
      __privateAdd(this, _navigationRequest, null);
      __privateAdd(this, _subscriptions2, new DisposableStack());
      __privateAdd(this, _initialLoaderId);
      __privateAdd(this, _terminationDeferred);
      __privateAdd(this, _sameDocumentNavigationDeferred, Deferred$1.create());
      __privateAdd(this, _lifecycleDeferred, Deferred$1.create());
      __privateAdd(this, _newDocumentNavigationDeferred, Deferred$1.create());
      __privateAdd(this, _hasSameDocumentNavigation);
      __privateAdd(this, _swapped);
      __privateAdd(this, _navigationResponseReceived);
      if (Array.isArray(waitUntil)) {
        waitUntil = waitUntil.slice();
      } else if (typeof waitUntil === "string") {
        waitUntil = [waitUntil];
      }
      __privateSet(this, _initialLoaderId, frame._loaderId);
      __privateSet(this, _expectedLifecycle, waitUntil.map((value) => {
        const protocolEvent = puppeteerToProtocolLifecycle.get(value);
        assert$1(protocolEvent, "Unknown value for options.waitUntil: " + value);
        return protocolEvent;
      }));
      signal == null ? void 0 : signal.addEventListener("abort", () => {
        __privateGet(this, _terminationDeferred).reject(signal.reason);
      });
      __privateSet(this, _frame2, frame);
      __privateSet(this, _timeout3, timeout2);
      const frameManagerEmitter = __privateGet(this, _subscriptions2).use(new EventEmitter$1(frame._frameManager));
      frameManagerEmitter.on(FrameManagerEvent.LifecycleEvent, __privateMethod(this, _LifecycleWatcher_instances, checkLifecycleComplete_fn).bind(this));
      const frameEmitter = __privateGet(this, _subscriptions2).use(new EventEmitter$1(frame));
      frameEmitter.on(FrameEvent.FrameNavigatedWithinDocument, __privateMethod(this, _LifecycleWatcher_instances, navigatedWithinDocument_fn).bind(this));
      frameEmitter.on(FrameEvent.FrameNavigated, __privateMethod(this, _LifecycleWatcher_instances, navigated_fn).bind(this));
      frameEmitter.on(FrameEvent.FrameSwapped, __privateMethod(this, _LifecycleWatcher_instances, frameSwapped_fn).bind(this));
      frameEmitter.on(FrameEvent.FrameSwappedByActivation, __privateMethod(this, _LifecycleWatcher_instances, frameSwapped_fn).bind(this));
      frameEmitter.on(FrameEvent.FrameDetached, __privateMethod(this, _LifecycleWatcher_instances, onFrameDetached_fn).bind(this));
      const networkManagerEmitter = __privateGet(this, _subscriptions2).use(new EventEmitter$1(networkManager));
      networkManagerEmitter.on(NetworkManagerEvent.Request, __privateMethod(this, _LifecycleWatcher_instances, onRequest_fn).bind(this));
      networkManagerEmitter.on(NetworkManagerEvent.Response, __privateMethod(this, _LifecycleWatcher_instances, onResponse_fn).bind(this));
      networkManagerEmitter.on(NetworkManagerEvent.RequestFailed, __privateMethod(this, _LifecycleWatcher_instances, onRequestFailed_fn).bind(this));
      __privateSet(this, _terminationDeferred, Deferred$1.create({
        timeout: __privateGet(this, _timeout3),
        message: `Navigation timeout of ${__privateGet(this, _timeout3)} ms exceeded`
      }));
      __privateMethod(this, _LifecycleWatcher_instances, checkLifecycleComplete_fn).call(this);
    }
    async navigationResponse() {
      var _a3;
      await ((_a3 = __privateGet(this, _navigationResponseReceived)) == null ? void 0 : _a3.valueOrThrow());
      return __privateGet(this, _navigationRequest) ? __privateGet(this, _navigationRequest).response() : null;
    }
    sameDocumentNavigationPromise() {
      return __privateGet(this, _sameDocumentNavigationDeferred).valueOrThrow();
    }
    newDocumentNavigationPromise() {
      return __privateGet(this, _newDocumentNavigationDeferred).valueOrThrow();
    }
    lifecyclePromise() {
      return __privateGet(this, _lifecycleDeferred).valueOrThrow();
    }
    terminationPromise() {
      return __privateGet(this, _terminationDeferred).valueOrThrow();
    }
    dispose() {
      __privateGet(this, _subscriptions2).dispose();
      __privateGet(this, _terminationDeferred).resolve(new Error("LifecycleWatcher disposed"));
    }
  }
  _expectedLifecycle = new WeakMap();
  _frame2 = new WeakMap();
  _timeout3 = new WeakMap();
  _navigationRequest = new WeakMap();
  _subscriptions2 = new WeakMap();
  _initialLoaderId = new WeakMap();
  _terminationDeferred = new WeakMap();
  _sameDocumentNavigationDeferred = new WeakMap();
  _lifecycleDeferred = new WeakMap();
  _newDocumentNavigationDeferred = new WeakMap();
  _hasSameDocumentNavigation = new WeakMap();
  _swapped = new WeakMap();
  _navigationResponseReceived = new WeakMap();
  _LifecycleWatcher_instances = new WeakSet();
  onRequest_fn = function(request) {
    var _a3, _b2;
    if (request.frame() !== __privateGet(this, _frame2) || !request.isNavigationRequest()) {
      return;
    }
    __privateSet(this, _navigationRequest, request);
    (_a3 = __privateGet(this, _navigationResponseReceived)) == null ? void 0 : _a3.resolve();
    __privateSet(this, _navigationResponseReceived, Deferred$1.create());
    if (request.response() !== null) {
      (_b2 = __privateGet(this, _navigationResponseReceived)) == null ? void 0 : _b2.resolve();
    }
  };
  onRequestFailed_fn = function(request) {
    var _a3, _b2;
    if (((_a3 = __privateGet(this, _navigationRequest)) == null ? void 0 : _a3.id) !== request.id) {
      return;
    }
    (_b2 = __privateGet(this, _navigationResponseReceived)) == null ? void 0 : _b2.resolve();
  };
  onResponse_fn = function(response) {
    var _a3, _b2;
    if (((_a3 = __privateGet(this, _navigationRequest)) == null ? void 0 : _a3.id) !== response.request().id) {
      return;
    }
    (_b2 = __privateGet(this, _navigationResponseReceived)) == null ? void 0 : _b2.resolve();
  };
  onFrameDetached_fn = function(frame) {
    if (__privateGet(this, _frame2) === frame) {
      __privateGet(this, _terminationDeferred).resolve(new Error("Navigating frame was detached"));
      return;
    }
    __privateMethod(this, _LifecycleWatcher_instances, checkLifecycleComplete_fn).call(this);
  };
  navigatedWithinDocument_fn = function() {
    __privateSet(this, _hasSameDocumentNavigation, true);
    __privateMethod(this, _LifecycleWatcher_instances, checkLifecycleComplete_fn).call(this);
  };
  navigated_fn = function(navigationType) {
    if (navigationType === "BackForwardCacheRestore") {
      return __privateMethod(this, _LifecycleWatcher_instances, frameSwapped_fn).call(this);
    }
    __privateMethod(this, _LifecycleWatcher_instances, checkLifecycleComplete_fn).call(this);
  };
  frameSwapped_fn = function() {
    __privateSet(this, _swapped, true);
    __privateMethod(this, _LifecycleWatcher_instances, checkLifecycleComplete_fn).call(this);
  };
  checkLifecycleComplete_fn = function() {
    if (!checkLifecycle(__privateGet(this, _frame2), __privateGet(this, _expectedLifecycle))) {
      return;
    }
    __privateGet(this, _lifecycleDeferred).resolve();
    if (__privateGet(this, _hasSameDocumentNavigation)) {
      __privateGet(this, _sameDocumentNavigationDeferred).resolve(void 0);
    }
    if (__privateGet(this, _swapped) || __privateGet(this, _frame2)._loaderId !== __privateGet(this, _initialLoaderId)) {
      __privateGet(this, _newDocumentNavigationDeferred).resolve(void 0);
    }
    function checkLifecycle(frame, expectedLifecycle) {
      for (const event of expectedLifecycle) {
        if (!frame._lifecycleEvents.has(event)) {
          return false;
        }
      }
      for (const child of frame.childFrames()) {
        if (child._hasStartedLoading && !checkLifecycle(child, expectedLifecycle)) {
          return false;
        }
      }
      return true;
    }
  };
  /**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var __runInitializers$e = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i2 = 0; i2 < initializers.length; i2++) {
      value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate$e = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind2 = contextIn.kind, key = kind2 === "getter" ? "get" : kind2 === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function(f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i2])(kind2 === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind2 === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_ = accept(result.get)) descriptor.get = _;
        if (_ = accept(result.set)) descriptor.set = _;
        if (_ = accept(result.init)) initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind2 === "field") initializers.unshift(_);
        else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  let CdpFrame = (() => {
    var _url5, _detached2, _client16, _CdpFrame_instances, onMainWorldConsoleApiCalled_fn, onMainWorldBindingCalled_fn, deviceRequestPromptManager_fn, _a3;
    let _classSuper = Frame;
    let _instanceExtraInitializers = [];
    let _goto_decorators;
    let _waitForNavigation_decorators;
    let _setContent_decorators;
    let _addPreloadScript_decorators;
    let _addExposedFunctionBinding_decorators;
    let _removeExposedFunctionBinding_decorators;
    let _waitForDevicePrompt_decorators;
    return _a3 = class extends _classSuper {
      constructor(frameManager, frameId, parentFrameId, client2) {
        super();
        __privateAdd(this, _CdpFrame_instances);
        __privateAdd(this, _url5, (__runInitializers$e(this, _instanceExtraInitializers), ""));
        __privateAdd(this, _detached2, false);
        __privateAdd(this, _client16);
        __publicField(this, "_frameManager");
        __publicField(this, "_loaderId", "");
        __publicField(this, "_lifecycleEvents", /* @__PURE__ */ new Set());
        __publicField(this, "_id");
        __publicField(this, "_parentId");
        __publicField(this, "accessibility");
        __publicField(this, "worlds");
        this._frameManager = frameManager;
        __privateSet(this, _url5, "");
        this._id = frameId;
        this._parentId = parentFrameId;
        __privateSet(this, _detached2, false);
        __privateSet(this, _client16, client2);
        this._loaderId = "";
        this.worlds = {
          [MAIN_WORLD]: new IsolatedWorld(this, this._frameManager.timeoutSettings),
          [PUPPETEER_WORLD]: new IsolatedWorld(this, this._frameManager.timeoutSettings)
        };
        this.accessibility = new Accessibility(this.worlds[MAIN_WORLD], frameId);
        this.on(FrameEvent.FrameSwappedByActivation, () => {
          this._onLoadingStarted();
          this._onLoadingStopped();
        });
        this.worlds[MAIN_WORLD].emitter.on("consoleapicalled", __privateMethod(this, _CdpFrame_instances, onMainWorldConsoleApiCalled_fn).bind(this));
        this.worlds[MAIN_WORLD].emitter.on("bindingcalled", __privateMethod(this, _CdpFrame_instances, onMainWorldBindingCalled_fn).bind(this));
      }
      /**
       * This is used internally in DevTools.
       *
       * @internal
       */
      _client() {
        return __privateGet(this, _client16);
      }
      /**
       * Updates the frame ID with the new ID. This happens when the main frame is
       * replaced by a different frame.
       */
      updateId(id) {
        this._id = id;
      }
      updateClient(client2) {
        __privateSet(this, _client16, client2);
      }
      page() {
        return this._frameManager.page();
      }
      async goto(url, options = {}) {
        const { referer = this._frameManager.networkManager.extraHTTPHeaders()["referer"], referrerPolicy = this._frameManager.networkManager.extraHTTPHeaders()["referer-policy"], waitUntil = ["load"], timeout: timeout2 = this._frameManager.timeoutSettings.navigationTimeout() } = options;
        let ensureNewDocumentNavigation = false;
        const watcher = new LifecycleWatcher(this._frameManager.networkManager, this, waitUntil, timeout2);
        let error = await Deferred$1.race([
          navigate(__privateGet(this, _client16), url, referer, referrerPolicy, this._id),
          watcher.terminationPromise()
        ]);
        if (!error) {
          error = await Deferred$1.race([
            watcher.terminationPromise(),
            ensureNewDocumentNavigation ? watcher.newDocumentNavigationPromise() : watcher.sameDocumentNavigationPromise()
          ]);
        }
        try {
          if (error) {
            throw error;
          }
          return await watcher.navigationResponse();
        } finally {
          watcher.dispose();
        }
        async function navigate(client2, url2, referrer, referrerPolicy2, frameId) {
          try {
            const response = await client2.send("Page.navigate", {
              url: url2,
              referrer,
              frameId,
              referrerPolicy: referrerPolicy2
            });
            ensureNewDocumentNavigation = !!response.loaderId;
            if (response.errorText === "net::ERR_HTTP_RESPONSE_CODE_FAILURE") {
              return null;
            }
            return response.errorText ? new Error(`${response.errorText} at ${url2}`) : null;
          } catch (error2) {
            if (isErrorLike(error2)) {
              return error2;
            }
            throw error2;
          }
        }
      }
      async waitForNavigation(options = {}) {
        const { waitUntil = ["load"], timeout: timeout2 = this._frameManager.timeoutSettings.navigationTimeout(), signal } = options;
        const watcher = new LifecycleWatcher(this._frameManager.networkManager, this, waitUntil, timeout2, signal);
        const error = await Deferred$1.race([
          watcher.terminationPromise(),
          ...options.ignoreSameDocumentNavigation ? [] : [watcher.sameDocumentNavigationPromise()],
          watcher.newDocumentNavigationPromise()
        ]);
        try {
          if (error) {
            throw error;
          }
          const result = await Deferred$1.race([watcher.terminationPromise(), watcher.navigationResponse()]);
          if (result instanceof Error) {
            throw error;
          }
          return result || null;
        } finally {
          watcher.dispose();
        }
      }
      get client() {
        return __privateGet(this, _client16);
      }
      mainRealm() {
        return this.worlds[MAIN_WORLD];
      }
      isolatedRealm() {
        return this.worlds[PUPPETEER_WORLD];
      }
      async setContent(html, options = {}) {
        const { waitUntil = ["load"], timeout: timeout2 = this._frameManager.timeoutSettings.navigationTimeout() } = options;
        await this.setFrameContent(html);
        const watcher = new LifecycleWatcher(this._frameManager.networkManager, this, waitUntil, timeout2);
        const error = await Deferred$1.race([
          watcher.terminationPromise(),
          watcher.lifecyclePromise()
        ]);
        watcher.dispose();
        if (error) {
          throw error;
        }
      }
      url() {
        return __privateGet(this, _url5);
      }
      parentFrame() {
        return this._frameManager._frameTree.parentFrame(this._id) || null;
      }
      childFrames() {
        return this._frameManager._frameTree.childFrames(this._id);
      }
      async addPreloadScript(preloadScript) {
        const parentFrame = this.parentFrame();
        if (parentFrame && __privateGet(this, _client16) === parentFrame.client) {
          return;
        }
        if (preloadScript.getIdForFrame(this)) {
          return;
        }
        const { identifier } = await __privateGet(this, _client16).send("Page.addScriptToEvaluateOnNewDocument", {
          source: preloadScript.source
        });
        preloadScript.setIdForFrame(this, identifier);
      }
      async addExposedFunctionBinding(binding) {
        if (this !== this._frameManager.mainFrame() && !this._hasStartedLoading) {
          return;
        }
        await Promise.all([
          __privateGet(this, _client16).send("Runtime.addBinding", {
            name: CDP_BINDING_PREFIX + binding.name
          }),
          this.evaluate(binding.initSource).catch(debugError)
        ]);
      }
      async removeExposedFunctionBinding(binding) {
        if (this !== this._frameManager.mainFrame() && !this._hasStartedLoading) {
          return;
        }
        await Promise.all([
          __privateGet(this, _client16).send("Runtime.removeBinding", {
            name: CDP_BINDING_PREFIX + binding.name
          }),
          this.evaluate((name) => {
            globalThis[name] = void 0;
          }, binding.name).catch(debugError)
        ]);
      }
      async waitForDevicePrompt(options = {}) {
        return await __privateMethod(this, _CdpFrame_instances, deviceRequestPromptManager_fn).call(this).waitForDevicePrompt(options);
      }
      _navigated(framePayload) {
        this._name = framePayload.name;
        __privateSet(this, _url5, `${framePayload.url}${framePayload.urlFragment || ""}`);
      }
      _navigatedWithinDocument(url) {
        __privateSet(this, _url5, url);
      }
      _onLifecycleEvent(loaderId, name) {
        if (name === "init") {
          this._loaderId = loaderId;
          this._lifecycleEvents.clear();
        }
        this._lifecycleEvents.add(name);
      }
      _onLoadingStopped() {
        this._lifecycleEvents.add("DOMContentLoaded");
        this._lifecycleEvents.add("load");
      }
      _onLoadingStarted() {
        this._hasStartedLoading = true;
      }
      get detached() {
        return __privateGet(this, _detached2);
      }
      [(_goto_decorators = [throwIfDetached], _waitForNavigation_decorators = [throwIfDetached], _setContent_decorators = [throwIfDetached], _addPreloadScript_decorators = [throwIfDetached], _addExposedFunctionBinding_decorators = [throwIfDetached], _removeExposedFunctionBinding_decorators = [throwIfDetached], _waitForDevicePrompt_decorators = [throwIfDetached], disposeSymbol)]() {
        if (__privateGet(this, _detached2)) {
          return;
        }
        __privateSet(this, _detached2, true);
        this.worlds[MAIN_WORLD][disposeSymbol]();
        this.worlds[PUPPETEER_WORLD][disposeSymbol]();
      }
      exposeFunction() {
        throw new UnsupportedOperation();
      }
      async frameElement() {
        const parent = this.parentFrame();
        if (!parent) {
          return null;
        }
        const { backendNodeId } = await parent.client.send("DOM.getFrameOwner", {
          frameId: this._id
        });
        return await parent.mainRealm().adoptBackendNode(backendNodeId);
      }
    }, _url5 = new WeakMap(), _detached2 = new WeakMap(), _client16 = new WeakMap(), _CdpFrame_instances = new WeakSet(), onMainWorldConsoleApiCalled_fn = function(event) {
      this._frameManager.emit(FrameManagerEvent.ConsoleApiCalled, [
        this.worlds[MAIN_WORLD],
        event
      ]);
    }, onMainWorldBindingCalled_fn = function(event) {
      this._frameManager.emit(FrameManagerEvent.BindingCalled, [
        this.worlds[MAIN_WORLD],
        event
      ]);
    }, deviceRequestPromptManager_fn = function() {
      return this._frameManager._deviceRequestPromptManager(__privateGet(this, _client16));
    }, (() => {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      __esDecorate$e(_a3, null, _goto_decorators, { kind: "method", name: "goto", static: false, private: false, access: { has: (obj) => "goto" in obj, get: (obj) => obj.goto }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$e(_a3, null, _waitForNavigation_decorators, { kind: "method", name: "waitForNavigation", static: false, private: false, access: { has: (obj) => "waitForNavigation" in obj, get: (obj) => obj.waitForNavigation }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$e(_a3, null, _setContent_decorators, { kind: "method", name: "setContent", static: false, private: false, access: { has: (obj) => "setContent" in obj, get: (obj) => obj.setContent }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$e(_a3, null, _addPreloadScript_decorators, { kind: "method", name: "addPreloadScript", static: false, private: false, access: { has: (obj) => "addPreloadScript" in obj, get: (obj) => obj.addPreloadScript }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$e(_a3, null, _addExposedFunctionBinding_decorators, { kind: "method", name: "addExposedFunctionBinding", static: false, private: false, access: { has: (obj) => "addExposedFunctionBinding" in obj, get: (obj) => obj.addExposedFunctionBinding }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$e(_a3, null, _removeExposedFunctionBinding_decorators, { kind: "method", name: "removeExposedFunctionBinding", static: false, private: false, access: { has: (obj) => "removeExposedFunctionBinding" in obj, get: (obj) => obj.removeExposedFunctionBinding }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$e(_a3, null, _waitForDevicePrompt_decorators, { kind: "method", name: "waitForDevicePrompt", static: false, private: false, access: { has: (obj) => "waitForDevicePrompt" in obj, get: (obj) => obj.waitForDevicePrompt }, metadata: _metadata }, null, _instanceExtraInitializers);
      if (_metadata) Object.defineProperty(_a3, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    })(), _a3;
  })();
  /**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class FrameTree {
    constructor() {
      __privateAdd(this, _frames, /* @__PURE__ */ new Map());
      // frameID -> parentFrameID
      __privateAdd(this, _parentIds, /* @__PURE__ */ new Map());
      // frameID -> childFrameIDs
      __privateAdd(this, _childIds, /* @__PURE__ */ new Map());
      __privateAdd(this, _mainFrame);
      __privateAdd(this, _isMainFrameStale, false);
      __privateAdd(this, _waitRequests, /* @__PURE__ */ new Map());
    }
    getMainFrame() {
      return __privateGet(this, _mainFrame);
    }
    getById(frameId) {
      return __privateGet(this, _frames).get(frameId);
    }
    /**
     * Returns a promise that is resolved once the frame with
     * the given ID is added to the tree.
     */
    waitForFrame(frameId) {
      const frame = this.getById(frameId);
      if (frame) {
        return Promise.resolve(frame);
      }
      const deferred = Deferred$1.create();
      const callbacks = __privateGet(this, _waitRequests).get(frameId) || /* @__PURE__ */ new Set();
      callbacks.add(deferred);
      return deferred.valueOrThrow();
    }
    frames() {
      return Array.from(__privateGet(this, _frames).values());
    }
    addFrame(frame) {
      var _a3;
      __privateGet(this, _frames).set(frame._id, frame);
      if (frame._parentId) {
        __privateGet(this, _parentIds).set(frame._id, frame._parentId);
        if (!__privateGet(this, _childIds).has(frame._parentId)) {
          __privateGet(this, _childIds).set(frame._parentId, /* @__PURE__ */ new Set());
        }
        __privateGet(this, _childIds).get(frame._parentId).add(frame._id);
      } else if (!__privateGet(this, _mainFrame) || __privateGet(this, _isMainFrameStale)) {
        __privateSet(this, _mainFrame, frame);
        __privateSet(this, _isMainFrameStale, false);
      }
      (_a3 = __privateGet(this, _waitRequests).get(frame._id)) == null ? void 0 : _a3.forEach((request) => {
        return request.resolve(frame);
      });
    }
    removeFrame(frame) {
      var _a3;
      __privateGet(this, _frames).delete(frame._id);
      __privateGet(this, _parentIds).delete(frame._id);
      if (frame._parentId) {
        (_a3 = __privateGet(this, _childIds).get(frame._parentId)) == null ? void 0 : _a3.delete(frame._id);
      } else {
        __privateSet(this, _isMainFrameStale, true);
      }
    }
    childFrames(frameId) {
      const childIds = __privateGet(this, _childIds).get(frameId);
      if (!childIds) {
        return [];
      }
      return Array.from(childIds).map((id) => {
        return this.getById(id);
      }).filter((frame) => {
        return frame !== void 0;
      });
    }
    parentFrame(frameId) {
      const parentId = __privateGet(this, _parentIds).get(frameId);
      return parentId ? this.getById(parentId) : void 0;
    }
  }
  _frames = new WeakMap();
  _parentIds = new WeakMap();
  _childIds = new WeakMap();
  _mainFrame = new WeakMap();
  _isMainFrameStale = new WeakMap();
  _waitRequests = new WeakMap();
  class CdpHTTPRequest extends HTTPRequest {
    constructor(client2, frame, interceptionId, allowInterception, data, redirectChain) {
      super();
      __publicField(this, "id");
      __privateAdd(this, _client7);
      __privateAdd(this, _isNavigationRequest);
      __privateAdd(this, _url3);
      __privateAdd(this, _resourceType);
      __privateAdd(this, _method);
      __privateAdd(this, _hasPostData, false);
      __privateAdd(this, _postData);
      __privateAdd(this, _headers, {});
      __privateAdd(this, _frame3);
      __privateAdd(this, _initiator);
      __privateSet(this, _client7, client2);
      this.id = data.requestId;
      __privateSet(this, _isNavigationRequest, data.requestId === data.loaderId && data.type === "Document");
      this._interceptionId = interceptionId;
      __privateSet(this, _url3, data.request.url + (data.request.urlFragment ?? ""));
      __privateSet(this, _resourceType, (data.type || "other").toLowerCase());
      __privateSet(this, _method, data.request.method);
      __privateSet(this, _postData, data.request.postData);
      __privateSet(this, _hasPostData, data.request.hasPostData ?? false);
      __privateSet(this, _frame3, frame);
      this._redirectChain = redirectChain;
      __privateSet(this, _initiator, data.initiator);
      this.interception.enabled = allowInterception;
      for (const [key, value] of Object.entries(data.request.headers)) {
        __privateGet(this, _headers)[key.toLowerCase()] = value;
      }
    }
    get client() {
      return __privateGet(this, _client7);
    }
    set client(newClient) {
      __privateSet(this, _client7, newClient);
    }
    url() {
      return __privateGet(this, _url3);
    }
    resourceType() {
      return __privateGet(this, _resourceType);
    }
    method() {
      return __privateGet(this, _method);
    }
    postData() {
      return __privateGet(this, _postData);
    }
    hasPostData() {
      return __privateGet(this, _hasPostData);
    }
    async fetchPostData() {
      try {
        const result = await __privateGet(this, _client7).send("Network.getRequestPostData", {
          requestId: this.id
        });
        return result.postData;
      } catch (err) {
        debugError(err);
        return;
      }
    }
    headers() {
      return __privateGet(this, _headers);
    }
    response() {
      return this._response;
    }
    frame() {
      return __privateGet(this, _frame3);
    }
    isNavigationRequest() {
      return __privateGet(this, _isNavigationRequest);
    }
    initiator() {
      return __privateGet(this, _initiator);
    }
    redirectChain() {
      return this._redirectChain.slice();
    }
    failure() {
      if (!this._failureText) {
        return null;
      }
      return {
        errorText: this._failureText
      };
    }
    /**
     * @internal
     */
    async _continue(overrides = {}) {
      const { url, method, postData, headers } = overrides;
      this.interception.handled = true;
      const postDataBinaryBase64 = postData ? stringToBase64(postData) : void 0;
      if (this._interceptionId === void 0) {
        throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.continueRequest");
      }
      await __privateGet(this, _client7).send("Fetch.continueRequest", {
        requestId: this._interceptionId,
        url,
        method,
        postData: postDataBinaryBase64,
        headers: headers ? headersArray(headers) : void 0
      }).catch((error) => {
        this.interception.handled = false;
        return handleError(error);
      });
    }
    async _respond(response) {
      this.interception.handled = true;
      let parsedBody;
      if (response.body) {
        parsedBody = HTTPRequest.getResponse(response.body);
      }
      const responseHeaders = {};
      if (response.headers) {
        for (const header of Object.keys(response.headers)) {
          const value = response.headers[header];
          responseHeaders[header.toLowerCase()] = Array.isArray(value) ? value.map((item) => {
            return String(item);
          }) : String(value);
        }
      }
      if (response.contentType) {
        responseHeaders["content-type"] = response.contentType;
      }
      if ((parsedBody == null ? void 0 : parsedBody.contentLength) && !("content-length" in responseHeaders)) {
        responseHeaders["content-length"] = String(parsedBody.contentLength);
      }
      const status = response.status || 200;
      if (this._interceptionId === void 0) {
        throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.fulfillRequest");
      }
      await __privateGet(this, _client7).send("Fetch.fulfillRequest", {
        requestId: this._interceptionId,
        responseCode: status,
        responsePhrase: STATUS_TEXTS[status],
        responseHeaders: headersArray(responseHeaders),
        body: parsedBody == null ? void 0 : parsedBody.base64
      }).catch((error) => {
        this.interception.handled = false;
        return handleError(error);
      });
    }
    async _abort(errorReason) {
      this.interception.handled = true;
      if (this._interceptionId === void 0) {
        throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.failRequest");
      }
      await __privateGet(this, _client7).send("Fetch.failRequest", {
        requestId: this._interceptionId,
        errorReason: errorReason || "Failed"
      }).catch(handleError);
    }
  }
  _client7 = new WeakMap();
  _isNavigationRequest = new WeakMap();
  _url3 = new WeakMap();
  _resourceType = new WeakMap();
  _method = new WeakMap();
  _hasPostData = new WeakMap();
  _postData = new WeakMap();
  _headers = new WeakMap();
  _frame3 = new WeakMap();
  _initiator = new WeakMap();
  /**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class SecurityDetails {
    /**
     * @internal
     */
    constructor(securityPayload) {
      __privateAdd(this, _subjectName);
      __privateAdd(this, _issuer);
      __privateAdd(this, _validFrom);
      __privateAdd(this, _validTo);
      __privateAdd(this, _protocol);
      __privateAdd(this, _sanList);
      __privateSet(this, _subjectName, securityPayload.subjectName);
      __privateSet(this, _issuer, securityPayload.issuer);
      __privateSet(this, _validFrom, securityPayload.validFrom);
      __privateSet(this, _validTo, securityPayload.validTo);
      __privateSet(this, _protocol, securityPayload.protocol);
      __privateSet(this, _sanList, securityPayload.sanList);
    }
    /**
     * The name of the issuer of the certificate.
     */
    issuer() {
      return __privateGet(this, _issuer);
    }
    /**
     * {@link https://en.wikipedia.org/wiki/Unix_time | Unix timestamp}
     * marking the start of the certificate's validity.
     */
    validFrom() {
      return __privateGet(this, _validFrom);
    }
    /**
     * {@link https://en.wikipedia.org/wiki/Unix_time | Unix timestamp}
     * marking the end of the certificate's validity.
     */
    validTo() {
      return __privateGet(this, _validTo);
    }
    /**
     * The security protocol being used, e.g. "TLS 1.2".
     */
    protocol() {
      return __privateGet(this, _protocol);
    }
    /**
     * The name of the subject to which the certificate was issued.
     */
    subjectName() {
      return __privateGet(this, _subjectName);
    }
    /**
     * The list of {@link https://en.wikipedia.org/wiki/Subject_Alternative_Name | subject alternative names (SANs)} of the certificate.
     */
    subjectAlternativeNames() {
      return __privateGet(this, _sanList);
    }
  }
  _subjectName = new WeakMap();
  _issuer = new WeakMap();
  _validFrom = new WeakMap();
  _validTo = new WeakMap();
  _protocol = new WeakMap();
  _sanList = new WeakMap();
  class CdpHTTPResponse extends HTTPResponse {
    constructor(request, responsePayload, extraInfo) {
      super();
      __privateAdd(this, _CdpHTTPResponse_instances);
      __privateAdd(this, _request);
      __privateAdd(this, _contentPromise, null);
      __privateAdd(this, _bodyLoadedDeferred, Deferred$1.create());
      __privateAdd(this, _remoteAddress);
      __privateAdd(this, _status);
      __privateAdd(this, _statusText);
      __privateAdd(this, _fromDiskCache);
      __privateAdd(this, _fromServiceWorker);
      __privateAdd(this, _headers2, {});
      __privateAdd(this, _securityDetails);
      __privateAdd(this, _timing);
      __privateSet(this, _request, request);
      __privateSet(this, _remoteAddress, {
        ip: responsePayload.remoteIPAddress,
        port: responsePayload.remotePort
      });
      __privateSet(this, _statusText, __privateMethod(this, _CdpHTTPResponse_instances, parseStatusTextFromExtraInfo_fn).call(this, extraInfo) || responsePayload.statusText);
      __privateSet(this, _fromDiskCache, !!responsePayload.fromDiskCache);
      __privateSet(this, _fromServiceWorker, !!responsePayload.fromServiceWorker);
      __privateSet(this, _status, extraInfo ? extraInfo.statusCode : responsePayload.status);
      const headers = extraInfo ? extraInfo.headers : responsePayload.headers;
      for (const [key, value] of Object.entries(headers)) {
        __privateGet(this, _headers2)[key.toLowerCase()] = value;
      }
      __privateSet(this, _securityDetails, responsePayload.securityDetails ? new SecurityDetails(responsePayload.securityDetails) : null);
      __privateSet(this, _timing, responsePayload.timing || null);
    }
    _resolveBody(err) {
      if (err) {
        return __privateGet(this, _bodyLoadedDeferred).reject(err);
      }
      return __privateGet(this, _bodyLoadedDeferred).resolve();
    }
    remoteAddress() {
      return __privateGet(this, _remoteAddress);
    }
    url() {
      return __privateGet(this, _request).url();
    }
    status() {
      return __privateGet(this, _status);
    }
    statusText() {
      return __privateGet(this, _statusText);
    }
    headers() {
      return __privateGet(this, _headers2);
    }
    securityDetails() {
      return __privateGet(this, _securityDetails);
    }
    timing() {
      return __privateGet(this, _timing);
    }
    content() {
      if (!__privateGet(this, _contentPromise)) {
        __privateSet(this, _contentPromise, __privateGet(this, _bodyLoadedDeferred).valueOrThrow().then(async () => {
          try {
            const response = await __privateGet(this, _request).client.send("Network.getResponseBody", {
              requestId: __privateGet(this, _request).id
            });
            return stringToTypedArray(response.body, response.base64Encoded);
          } catch (error) {
            if (error instanceof ProtocolError && error.originalMessage === "No resource with given identifier found") {
              throw new ProtocolError("Could not load body for this request. This might happen if the request is a preflight request.");
            }
            throw error;
          }
        }));
      }
      return __privateGet(this, _contentPromise);
    }
    request() {
      return __privateGet(this, _request);
    }
    fromCache() {
      return __privateGet(this, _fromDiskCache) || __privateGet(this, _request)._fromMemoryCache;
    }
    fromServiceWorker() {
      return __privateGet(this, _fromServiceWorker);
    }
    frame() {
      return __privateGet(this, _request).frame();
    }
  }
  _request = new WeakMap();
  _contentPromise = new WeakMap();
  _bodyLoadedDeferred = new WeakMap();
  _remoteAddress = new WeakMap();
  _status = new WeakMap();
  _statusText = new WeakMap();
  _fromDiskCache = new WeakMap();
  _fromServiceWorker = new WeakMap();
  _headers2 = new WeakMap();
  _securityDetails = new WeakMap();
  _timing = new WeakMap();
  _CdpHTTPResponse_instances = new WeakSet();
  parseStatusTextFromExtraInfo_fn = function(extraInfo) {
    if (!extraInfo || !extraInfo.headersText) {
      return;
    }
    const firstLine = extraInfo.headersText.split("\r", 1)[0];
    if (!firstLine || firstLine.length > 1e3) {
      return;
    }
    const match = firstLine.match(/[^ ]* [^ ]* (.*)/);
    if (!match) {
      return;
    }
    const statusText = match[1];
    if (!statusText) {
      return;
    }
    return statusText;
  };
  /**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class NetworkEventManager {
    constructor() {
      /**
       * There are four possible orders of events:
       * A. `_onRequestWillBeSent`
       * B. `_onRequestWillBeSent`, `_onRequestPaused`
       * C. `_onRequestPaused`, `_onRequestWillBeSent`
       * D. `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,
       * `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`
       * (see crbug.com/1196004)
       *
       * For `_onRequest` we need the event from `_onRequestWillBeSent` and
       * optionally the `interceptionId` from `_onRequestPaused`.
       *
       * If request interception is disabled, call `_onRequest` once per call to
       * `_onRequestWillBeSent`.
       * If request interception is enabled, call `_onRequest` once per call to
       * `_onRequestPaused` (once per `interceptionId`).
       *
       * Events are stored to allow for subsequent events to call `_onRequest`.
       *
       * Note that (chains of) redirect requests have the same `requestId` (!) as
       * the original request. We have to anticipate series of events like these:
       * A. `_onRequestWillBeSent`,
       * `_onRequestWillBeSent`, ...
       * B. `_onRequestWillBeSent`, `_onRequestPaused`,
       * `_onRequestWillBeSent`, `_onRequestPaused`, ...
       * C. `_onRequestWillBeSent`, `_onRequestPaused`,
       * `_onRequestPaused`, `_onRequestWillBeSent`, ...
       * D. `_onRequestPaused`, `_onRequestWillBeSent`,
       * `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,
       * `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`, ...
       * (see crbug.com/1196004)
       */
      __privateAdd(this, _requestWillBeSentMap, /* @__PURE__ */ new Map());
      __privateAdd(this, _requestPausedMap, /* @__PURE__ */ new Map());
      __privateAdd(this, _httpRequestsMap, /* @__PURE__ */ new Map());
      /*
       * The below maps are used to reconcile Network.responseReceivedExtraInfo
       * events with their corresponding request. Each response and redirect
       * response gets an ExtraInfo event, and we don't know which will come first.
       * This means that we have to store a Response or an ExtraInfo for each
       * response, and emit the event when we get both of them. In addition, to
       * handle redirects, we have to make them Arrays to represent the chain of
       * events.
       */
      __privateAdd(this, _responseReceivedExtraInfoMap, /* @__PURE__ */ new Map());
      __privateAdd(this, _queuedRedirectInfoMap, /* @__PURE__ */ new Map());
      __privateAdd(this, _queuedEventGroupMap, /* @__PURE__ */ new Map());
    }
    forget(networkRequestId) {
      __privateGet(this, _requestWillBeSentMap).delete(networkRequestId);
      __privateGet(this, _requestPausedMap).delete(networkRequestId);
      __privateGet(this, _queuedEventGroupMap).delete(networkRequestId);
      __privateGet(this, _queuedRedirectInfoMap).delete(networkRequestId);
      __privateGet(this, _responseReceivedExtraInfoMap).delete(networkRequestId);
    }
    responseExtraInfo(networkRequestId) {
      if (!__privateGet(this, _responseReceivedExtraInfoMap).has(networkRequestId)) {
        __privateGet(this, _responseReceivedExtraInfoMap).set(networkRequestId, []);
      }
      return __privateGet(this, _responseReceivedExtraInfoMap).get(networkRequestId);
    }
    queuedRedirectInfo(fetchRequestId) {
      if (!__privateGet(this, _queuedRedirectInfoMap).has(fetchRequestId)) {
        __privateGet(this, _queuedRedirectInfoMap).set(fetchRequestId, []);
      }
      return __privateGet(this, _queuedRedirectInfoMap).get(fetchRequestId);
    }
    queueRedirectInfo(fetchRequestId, redirectInfo) {
      this.queuedRedirectInfo(fetchRequestId).push(redirectInfo);
    }
    takeQueuedRedirectInfo(fetchRequestId) {
      return this.queuedRedirectInfo(fetchRequestId).shift();
    }
    inFlightRequestsCount() {
      let inFlightRequestCounter = 0;
      for (const request of __privateGet(this, _httpRequestsMap).values()) {
        if (!request.response()) {
          inFlightRequestCounter++;
        }
      }
      return inFlightRequestCounter;
    }
    storeRequestWillBeSent(networkRequestId, event) {
      __privateGet(this, _requestWillBeSentMap).set(networkRequestId, event);
    }
    getRequestWillBeSent(networkRequestId) {
      return __privateGet(this, _requestWillBeSentMap).get(networkRequestId);
    }
    forgetRequestWillBeSent(networkRequestId) {
      __privateGet(this, _requestWillBeSentMap).delete(networkRequestId);
    }
    getRequestPaused(networkRequestId) {
      return __privateGet(this, _requestPausedMap).get(networkRequestId);
    }
    forgetRequestPaused(networkRequestId) {
      __privateGet(this, _requestPausedMap).delete(networkRequestId);
    }
    storeRequestPaused(networkRequestId, event) {
      __privateGet(this, _requestPausedMap).set(networkRequestId, event);
    }
    getRequest(networkRequestId) {
      return __privateGet(this, _httpRequestsMap).get(networkRequestId);
    }
    storeRequest(networkRequestId, request) {
      __privateGet(this, _httpRequestsMap).set(networkRequestId, request);
    }
    forgetRequest(networkRequestId) {
      __privateGet(this, _httpRequestsMap).delete(networkRequestId);
    }
    getQueuedEventGroup(networkRequestId) {
      return __privateGet(this, _queuedEventGroupMap).get(networkRequestId);
    }
    queueEventGroup(networkRequestId, event) {
      __privateGet(this, _queuedEventGroupMap).set(networkRequestId, event);
    }
    forgetQueuedEventGroup(networkRequestId) {
      __privateGet(this, _queuedEventGroupMap).delete(networkRequestId);
    }
    printState() {
      function replacer(_key, value) {
        if (value instanceof Map) {
          return {
            dataType: "Map",
            value: Array.from(value.entries())
            // or with spread: value: [...value]
          };
        } else if (value instanceof CdpHTTPRequest) {
          return {
            dataType: "CdpHTTPRequest",
            value: `${value.id}: ${value.url()}`
          };
        }
        {
          return value;
        }
      }
      console.log("httpRequestsMap", JSON.stringify(__privateGet(this, _httpRequestsMap), replacer, 2));
      console.log("requestWillBeSentMap", JSON.stringify(__privateGet(this, _requestWillBeSentMap), replacer, 2));
      console.log("requestWillBeSentMap", JSON.stringify(__privateGet(this, _responseReceivedExtraInfoMap), replacer, 2));
      console.log("requestWillBeSentMap", JSON.stringify(__privateGet(this, _requestPausedMap), replacer, 2));
    }
  }
  _requestWillBeSentMap = new WeakMap();
  _requestPausedMap = new WeakMap();
  _httpRequestsMap = new WeakMap();
  _responseReceivedExtraInfoMap = new WeakMap();
  _queuedRedirectInfoMap = new WeakMap();
  _queuedEventGroupMap = new WeakMap();
  /**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class NetworkManager extends EventEmitter$1 {
    constructor(frameManager) {
      super();
      __privateAdd(this, _NetworkManager_instances);
      __privateAdd(this, _frameManager);
      __privateAdd(this, _networkEventManager, new NetworkEventManager());
      __privateAdd(this, _extraHTTPHeaders);
      __privateAdd(this, _credentials, null);
      __privateAdd(this, _attemptedAuthentications, /* @__PURE__ */ new Set());
      __privateAdd(this, _userRequestInterceptionEnabled, false);
      __privateAdd(this, _protocolRequestInterceptionEnabled, false);
      __privateAdd(this, _userCacheDisabled);
      __privateAdd(this, _emulatedNetworkConditions);
      __privateAdd(this, _userAgent);
      __privateAdd(this, _userAgentMetadata);
      __privateAdd(this, _handlers3, [
        ["Fetch.requestPaused", __privateMethod(this, _NetworkManager_instances, onRequestPaused_fn)],
        ["Fetch.authRequired", __privateMethod(this, _NetworkManager_instances, onAuthRequired_fn)],
        ["Network.requestWillBeSent", __privateMethod(this, _NetworkManager_instances, onRequestWillBeSent_fn)],
        ["Network.requestServedFromCache", __privateMethod(this, _NetworkManager_instances, onRequestServedFromCache_fn)],
        ["Network.responseReceived", __privateMethod(this, _NetworkManager_instances, onResponseReceived_fn)],
        ["Network.loadingFinished", __privateMethod(this, _NetworkManager_instances, onLoadingFinished_fn)],
        ["Network.loadingFailed", __privateMethod(this, _NetworkManager_instances, onLoadingFailed_fn)],
        ["Network.responseReceivedExtraInfo", __privateMethod(this, _NetworkManager_instances, onResponseReceivedExtraInfo_fn)],
        [CDPSessionEvent.Disconnected, __privateMethod(this, _NetworkManager_instances, removeClient_fn)]
      ]);
      __privateAdd(this, _clients, /* @__PURE__ */ new Map());
      __privateSet(this, _frameManager, frameManager);
    }
    async addClient(client2) {
      if (__privateGet(this, _clients).has(client2)) {
        return;
      }
      const subscriptions = new DisposableStack();
      __privateGet(this, _clients).set(client2, subscriptions);
      const clientEmitter = subscriptions.use(new EventEmitter$1(client2));
      for (const [event, handler] of __privateGet(this, _handlers3)) {
        clientEmitter.on(event, (arg) => {
          return handler.bind(this)(client2, arg);
        });
      }
      await Promise.all([
        client2.send("Network.enable"),
        __privateMethod(this, _NetworkManager_instances, applyExtraHTTPHeaders_fn).call(this, client2),
        __privateMethod(this, _NetworkManager_instances, applyNetworkConditions_fn).call(this, client2),
        __privateMethod(this, _NetworkManager_instances, applyProtocolCacheDisabled_fn).call(this, client2),
        __privateMethod(this, _NetworkManager_instances, applyProtocolRequestInterception_fn).call(this, client2),
        __privateMethod(this, _NetworkManager_instances, applyUserAgent_fn).call(this, client2)
      ]);
    }
    async authenticate(credentials) {
      __privateSet(this, _credentials, credentials);
      const enabled = __privateGet(this, _userRequestInterceptionEnabled) || !!__privateGet(this, _credentials);
      if (enabled === __privateGet(this, _protocolRequestInterceptionEnabled)) {
        return;
      }
      __privateSet(this, _protocolRequestInterceptionEnabled, enabled);
      await __privateMethod(this, _NetworkManager_instances, applyToAllClients_fn).call(this, __privateMethod(this, _NetworkManager_instances, applyProtocolRequestInterception_fn).bind(this));
    }
    async setExtraHTTPHeaders(headers) {
      const extraHTTPHeaders = {};
      for (const [key, value] of Object.entries(headers)) {
        assert$1(isString(value), `Expected value of header "${key}" to be String, but "${typeof value}" is found.`);
        extraHTTPHeaders[key.toLowerCase()] = value;
      }
      __privateSet(this, _extraHTTPHeaders, extraHTTPHeaders);
      await __privateMethod(this, _NetworkManager_instances, applyToAllClients_fn).call(this, __privateMethod(this, _NetworkManager_instances, applyExtraHTTPHeaders_fn).bind(this));
    }
    extraHTTPHeaders() {
      return Object.assign({}, __privateGet(this, _extraHTTPHeaders));
    }
    inFlightRequestsCount() {
      return __privateGet(this, _networkEventManager).inFlightRequestsCount();
    }
    async setOfflineMode(value) {
      if (!__privateGet(this, _emulatedNetworkConditions)) {
        __privateSet(this, _emulatedNetworkConditions, {
          offline: false,
          upload: -1,
          download: -1,
          latency: 0
        });
      }
      __privateGet(this, _emulatedNetworkConditions).offline = value;
      await __privateMethod(this, _NetworkManager_instances, applyToAllClients_fn).call(this, __privateMethod(this, _NetworkManager_instances, applyNetworkConditions_fn).bind(this));
    }
    async emulateNetworkConditions(networkConditions) {
      if (!__privateGet(this, _emulatedNetworkConditions)) {
        __privateSet(this, _emulatedNetworkConditions, {
          offline: false,
          upload: -1,
          download: -1,
          latency: 0
        });
      }
      __privateGet(this, _emulatedNetworkConditions).upload = networkConditions ? networkConditions.upload : -1;
      __privateGet(this, _emulatedNetworkConditions).download = networkConditions ? networkConditions.download : -1;
      __privateGet(this, _emulatedNetworkConditions).latency = networkConditions ? networkConditions.latency : 0;
      await __privateMethod(this, _NetworkManager_instances, applyToAllClients_fn).call(this, __privateMethod(this, _NetworkManager_instances, applyNetworkConditions_fn).bind(this));
    }
    async setUserAgent(userAgent, userAgentMetadata) {
      __privateSet(this, _userAgent, userAgent);
      __privateSet(this, _userAgentMetadata, userAgentMetadata);
      await __privateMethod(this, _NetworkManager_instances, applyToAllClients_fn).call(this, __privateMethod(this, _NetworkManager_instances, applyUserAgent_fn).bind(this));
    }
    async setCacheEnabled(enabled) {
      __privateSet(this, _userCacheDisabled, !enabled);
      await __privateMethod(this, _NetworkManager_instances, applyToAllClients_fn).call(this, __privateMethod(this, _NetworkManager_instances, applyProtocolCacheDisabled_fn).bind(this));
    }
    async setRequestInterception(value) {
      __privateSet(this, _userRequestInterceptionEnabled, value);
      const enabled = __privateGet(this, _userRequestInterceptionEnabled) || !!__privateGet(this, _credentials);
      if (enabled === __privateGet(this, _protocolRequestInterceptionEnabled)) {
        return;
      }
      __privateSet(this, _protocolRequestInterceptionEnabled, enabled);
      await __privateMethod(this, _NetworkManager_instances, applyToAllClients_fn).call(this, __privateMethod(this, _NetworkManager_instances, applyProtocolRequestInterception_fn).bind(this));
    }
  }
  _frameManager = new WeakMap();
  _networkEventManager = new WeakMap();
  _extraHTTPHeaders = new WeakMap();
  _credentials = new WeakMap();
  _attemptedAuthentications = new WeakMap();
  _userRequestInterceptionEnabled = new WeakMap();
  _protocolRequestInterceptionEnabled = new WeakMap();
  _userCacheDisabled = new WeakMap();
  _emulatedNetworkConditions = new WeakMap();
  _userAgent = new WeakMap();
  _userAgentMetadata = new WeakMap();
  _handlers3 = new WeakMap();
  _clients = new WeakMap();
  _NetworkManager_instances = new WeakSet();
  removeClient_fn = async function(client2) {
    var _a3;
    (_a3 = __privateGet(this, _clients).get(client2)) == null ? void 0 : _a3.dispose();
    __privateGet(this, _clients).delete(client2);
  };
  applyExtraHTTPHeaders_fn = async function(client2) {
    if (__privateGet(this, _extraHTTPHeaders) === void 0) {
      return;
    }
    await client2.send("Network.setExtraHTTPHeaders", {
      headers: __privateGet(this, _extraHTTPHeaders)
    });
  };
  applyToAllClients_fn = async function(fn) {
    await Promise.all(Array.from(__privateGet(this, _clients).keys()).map((client2) => {
      return fn(client2);
    }));
  };
  applyNetworkConditions_fn = async function(client2) {
    if (__privateGet(this, _emulatedNetworkConditions) === void 0) {
      return;
    }
    await client2.send("Network.emulateNetworkConditions", {
      offline: __privateGet(this, _emulatedNetworkConditions).offline,
      latency: __privateGet(this, _emulatedNetworkConditions).latency,
      uploadThroughput: __privateGet(this, _emulatedNetworkConditions).upload,
      downloadThroughput: __privateGet(this, _emulatedNetworkConditions).download
    });
  };
  applyUserAgent_fn = async function(client2) {
    if (__privateGet(this, _userAgent) === void 0) {
      return;
    }
    await client2.send("Network.setUserAgentOverride", {
      userAgent: __privateGet(this, _userAgent),
      userAgentMetadata: __privateGet(this, _userAgentMetadata)
    });
  };
  applyProtocolRequestInterception_fn = async function(client2) {
    if (__privateGet(this, _userCacheDisabled) === void 0) {
      __privateSet(this, _userCacheDisabled, false);
    }
    if (__privateGet(this, _protocolRequestInterceptionEnabled)) {
      await Promise.all([
        __privateMethod(this, _NetworkManager_instances, applyProtocolCacheDisabled_fn).call(this, client2),
        client2.send("Fetch.enable", {
          handleAuthRequests: true,
          patterns: [{ urlPattern: "*" }]
        })
      ]);
    } else {
      await Promise.all([
        __privateMethod(this, _NetworkManager_instances, applyProtocolCacheDisabled_fn).call(this, client2),
        client2.send("Fetch.disable")
      ]);
    }
  };
  applyProtocolCacheDisabled_fn = async function(client2) {
    if (__privateGet(this, _userCacheDisabled) === void 0) {
      return;
    }
    await client2.send("Network.setCacheDisabled", {
      cacheDisabled: __privateGet(this, _userCacheDisabled)
    });
  };
  onRequestWillBeSent_fn = function(client2, event) {
    if (__privateGet(this, _userRequestInterceptionEnabled) && !event.request.url.startsWith("data:")) {
      const { requestId: networkRequestId } = event;
      __privateGet(this, _networkEventManager).storeRequestWillBeSent(networkRequestId, event);
      const requestPausedEvent = __privateGet(this, _networkEventManager).getRequestPaused(networkRequestId);
      if (requestPausedEvent) {
        const { requestId: fetchRequestId } = requestPausedEvent;
        __privateMethod(this, _NetworkManager_instances, patchRequestEventHeaders_fn).call(this, event, requestPausedEvent);
        __privateMethod(this, _NetworkManager_instances, onRequest_fn2).call(this, client2, event, fetchRequestId);
        __privateGet(this, _networkEventManager).forgetRequestPaused(networkRequestId);
      }
      return;
    }
    __privateMethod(this, _NetworkManager_instances, onRequest_fn2).call(this, client2, event, void 0);
  };
  onAuthRequired_fn = function(client2, event) {
    let response = "Default";
    if (__privateGet(this, _attemptedAuthentications).has(event.requestId)) {
      response = "CancelAuth";
    } else if (__privateGet(this, _credentials)) {
      response = "ProvideCredentials";
      __privateGet(this, _attemptedAuthentications).add(event.requestId);
    }
    const { username, password } = __privateGet(this, _credentials) || {
      username: void 0,
      password: void 0
    };
    client2.send("Fetch.continueWithAuth", {
      requestId: event.requestId,
      authChallengeResponse: { response, username, password }
    }).catch(debugError);
  };
  /**
   * CDP may send a Fetch.requestPaused without or before a
   * Network.requestWillBeSent
   *
   * CDP may send multiple Fetch.requestPaused
   * for the same Network.requestWillBeSent.
   */
  onRequestPaused_fn = function(client2, event) {
    if (!__privateGet(this, _userRequestInterceptionEnabled) && __privateGet(this, _protocolRequestInterceptionEnabled)) {
      client2.send("Fetch.continueRequest", {
        requestId: event.requestId
      }).catch(debugError);
    }
    const { networkId: networkRequestId, requestId: fetchRequestId } = event;
    if (!networkRequestId) {
      __privateMethod(this, _NetworkManager_instances, onRequestWithoutNetworkInstrumentation_fn).call(this, client2, event);
      return;
    }
    const requestWillBeSentEvent = (() => {
      const requestWillBeSentEvent2 = __privateGet(this, _networkEventManager).getRequestWillBeSent(networkRequestId);
      if (requestWillBeSentEvent2 && (requestWillBeSentEvent2.request.url !== event.request.url || requestWillBeSentEvent2.request.method !== event.request.method)) {
        __privateGet(this, _networkEventManager).forgetRequestWillBeSent(networkRequestId);
        return;
      }
      return requestWillBeSentEvent2;
    })();
    if (requestWillBeSentEvent) {
      __privateMethod(this, _NetworkManager_instances, patchRequestEventHeaders_fn).call(this, requestWillBeSentEvent, event);
      __privateMethod(this, _NetworkManager_instances, onRequest_fn2).call(this, client2, requestWillBeSentEvent, fetchRequestId);
    } else {
      __privateGet(this, _networkEventManager).storeRequestPaused(networkRequestId, event);
    }
  };
  patchRequestEventHeaders_fn = function(requestWillBeSentEvent, requestPausedEvent) {
    requestWillBeSentEvent.request.headers = {
      ...requestWillBeSentEvent.request.headers,
      // includes extra headers, like: Accept, Origin
      ...requestPausedEvent.request.headers
    };
  };
  onRequestWithoutNetworkInstrumentation_fn = function(client2, event) {
    const frame = event.frameId ? __privateGet(this, _frameManager).frame(event.frameId) : null;
    const request = new CdpHTTPRequest(client2, frame, event.requestId, __privateGet(this, _userRequestInterceptionEnabled), event, []);
    this.emit(NetworkManagerEvent.Request, request);
    void request.finalizeInterceptions();
  };
  onRequest_fn2 = function(client2, event, fetchRequestId, fromMemoryCache = false) {
    let redirectChain = [];
    if (event.redirectResponse) {
      let redirectResponseExtraInfo = null;
      if (event.redirectHasExtraInfo) {
        redirectResponseExtraInfo = __privateGet(this, _networkEventManager).responseExtraInfo(event.requestId).shift();
        if (!redirectResponseExtraInfo) {
          __privateGet(this, _networkEventManager).queueRedirectInfo(event.requestId, {
            event,
            fetchRequestId
          });
          return;
        }
      }
      const request2 = __privateGet(this, _networkEventManager).getRequest(event.requestId);
      if (request2) {
        __privateMethod(this, _NetworkManager_instances, handleRequestRedirect_fn).call(this, client2, request2, event.redirectResponse, redirectResponseExtraInfo);
        redirectChain = request2._redirectChain;
      }
    }
    const frame = event.frameId ? __privateGet(this, _frameManager).frame(event.frameId) : null;
    const request = new CdpHTTPRequest(client2, frame, fetchRequestId, __privateGet(this, _userRequestInterceptionEnabled), event, redirectChain);
    request._fromMemoryCache = fromMemoryCache;
    __privateGet(this, _networkEventManager).storeRequest(event.requestId, request);
    this.emit(NetworkManagerEvent.Request, request);
    void request.finalizeInterceptions();
  };
  onRequestServedFromCache_fn = function(client2, event) {
    const requestWillBeSentEvent = __privateGet(this, _networkEventManager).getRequestWillBeSent(event.requestId);
    let request = __privateGet(this, _networkEventManager).getRequest(event.requestId);
    if (request) {
      request._fromMemoryCache = true;
    }
    if (!request && requestWillBeSentEvent) {
      __privateMethod(this, _NetworkManager_instances, onRequest_fn2).call(this, client2, requestWillBeSentEvent, void 0, true);
      request = __privateGet(this, _networkEventManager).getRequest(event.requestId);
    }
    if (!request) {
      debugError(new Error(`Request ${event.requestId} was served from cache but we could not find the corresponding request object`));
      return;
    }
    this.emit(NetworkManagerEvent.RequestServedFromCache, request);
  };
  handleRequestRedirect_fn = function(_client16, request, responsePayload, extraInfo) {
    const response = new CdpHTTPResponse(request, responsePayload, extraInfo);
    request._response = response;
    request._redirectChain.push(request);
    response._resolveBody(new Error("Response body is unavailable for redirect responses"));
    __privateMethod(this, _NetworkManager_instances, forgetRequest_fn).call(this, request, false);
    this.emit(NetworkManagerEvent.Response, response);
    this.emit(NetworkManagerEvent.RequestFinished, request);
  };
  emitResponseEvent_fn = function(_client16, responseReceived, extraInfo) {
    const request = __privateGet(this, _networkEventManager).getRequest(responseReceived.requestId);
    if (!request) {
      return;
    }
    const extraInfos = __privateGet(this, _networkEventManager).responseExtraInfo(responseReceived.requestId);
    if (extraInfos.length) {
      debugError(new Error("Unexpected extraInfo events for request " + responseReceived.requestId));
    }
    if (responseReceived.response.fromDiskCache) {
      extraInfo = null;
    }
    const response = new CdpHTTPResponse(request, responseReceived.response, extraInfo);
    request._response = response;
    this.emit(NetworkManagerEvent.Response, response);
  };
  onResponseReceived_fn = function(client2, event) {
    const request = __privateGet(this, _networkEventManager).getRequest(event.requestId);
    let extraInfo = null;
    if (request && !request._fromMemoryCache && event.hasExtraInfo) {
      extraInfo = __privateGet(this, _networkEventManager).responseExtraInfo(event.requestId).shift();
      if (!extraInfo) {
        __privateGet(this, _networkEventManager).queueEventGroup(event.requestId, {
          responseReceivedEvent: event
        });
        return;
      }
    }
    __privateMethod(this, _NetworkManager_instances, emitResponseEvent_fn).call(this, client2, event, extraInfo);
  };
  onResponseReceivedExtraInfo_fn = function(client2, event) {
    const redirectInfo = __privateGet(this, _networkEventManager).takeQueuedRedirectInfo(event.requestId);
    if (redirectInfo) {
      __privateGet(this, _networkEventManager).responseExtraInfo(event.requestId).push(event);
      __privateMethod(this, _NetworkManager_instances, onRequest_fn2).call(this, client2, redirectInfo.event, redirectInfo.fetchRequestId);
      return;
    }
    const queuedEvents = __privateGet(this, _networkEventManager).getQueuedEventGroup(event.requestId);
    if (queuedEvents) {
      __privateGet(this, _networkEventManager).forgetQueuedEventGroup(event.requestId);
      __privateMethod(this, _NetworkManager_instances, emitResponseEvent_fn).call(this, client2, queuedEvents.responseReceivedEvent, event);
      if (queuedEvents.loadingFinishedEvent) {
        __privateMethod(this, _NetworkManager_instances, emitLoadingFinished_fn).call(this, client2, queuedEvents.loadingFinishedEvent);
      }
      if (queuedEvents.loadingFailedEvent) {
        __privateMethod(this, _NetworkManager_instances, emitLoadingFailed_fn).call(this, client2, queuedEvents.loadingFailedEvent);
      }
      return;
    }
    __privateGet(this, _networkEventManager).responseExtraInfo(event.requestId).push(event);
  };
  forgetRequest_fn = function(request, events2) {
    const requestId = request.id;
    const interceptionId = request._interceptionId;
    __privateGet(this, _networkEventManager).forgetRequest(requestId);
    if (interceptionId !== void 0) {
      __privateGet(this, _attemptedAuthentications).delete(interceptionId);
    }
    if (events2) {
      __privateGet(this, _networkEventManager).forget(requestId);
    }
  };
  onLoadingFinished_fn = function(client2, event) {
    const queuedEvents = __privateGet(this, _networkEventManager).getQueuedEventGroup(event.requestId);
    if (queuedEvents) {
      queuedEvents.loadingFinishedEvent = event;
    } else {
      __privateMethod(this, _NetworkManager_instances, emitLoadingFinished_fn).call(this, client2, event);
    }
  };
  emitLoadingFinished_fn = function(client2, event) {
    var _a3;
    const request = __privateGet(this, _networkEventManager).getRequest(event.requestId);
    if (!request) {
      return;
    }
    __privateMethod(this, _NetworkManager_instances, maybeReassignOOPIFRequestClient_fn).call(this, client2, request);
    if (request.response()) {
      (_a3 = request.response()) == null ? void 0 : _a3._resolveBody();
    }
    __privateMethod(this, _NetworkManager_instances, forgetRequest_fn).call(this, request, true);
    this.emit(NetworkManagerEvent.RequestFinished, request);
  };
  onLoadingFailed_fn = function(client2, event) {
    const queuedEvents = __privateGet(this, _networkEventManager).getQueuedEventGroup(event.requestId);
    if (queuedEvents) {
      queuedEvents.loadingFailedEvent = event;
    } else {
      __privateMethod(this, _NetworkManager_instances, emitLoadingFailed_fn).call(this, client2, event);
    }
  };
  emitLoadingFailed_fn = function(client2, event) {
    const request = __privateGet(this, _networkEventManager).getRequest(event.requestId);
    if (!request) {
      return;
    }
    __privateMethod(this, _NetworkManager_instances, maybeReassignOOPIFRequestClient_fn).call(this, client2, request);
    request._failureText = event.errorText;
    const response = request.response();
    if (response) {
      response._resolveBody();
    }
    __privateMethod(this, _NetworkManager_instances, forgetRequest_fn).call(this, request, true);
    this.emit(NetworkManagerEvent.RequestFailed, request);
  };
  maybeReassignOOPIFRequestClient_fn = function(client2, request) {
    if (client2 !== request.client && request.isNavigationRequest()) {
      request.client = client2;
    }
  };
  /**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  const TIME_FOR_WAITING_FOR_SWAP = 100;
  class FrameManager extends EventEmitter$1 {
    constructor(client2, page, timeoutSettings) {
      super();
      __privateAdd(this, _FrameManager_instances);
      __privateAdd(this, _page);
      __privateAdd(this, _networkManager);
      __privateAdd(this, _timeoutSettings3);
      __privateAdd(this, _isolatedWorlds, /* @__PURE__ */ new Set());
      __privateAdd(this, _client8);
      __privateAdd(this, _scriptsToEvaluateOnNewDocument, /* @__PURE__ */ new Map());
      __privateAdd(this, _bindings2, /* @__PURE__ */ new Set());
      __publicField(this, "_frameTree", new FrameTree());
      /**
       * Set of frame IDs stored to indicate if a frame has received a
       * frameNavigated event so that frame tree responses could be ignored as the
       * frameNavigated event usually contains the latest information.
       */
      __privateAdd(this, _frameNavigatedReceived, /* @__PURE__ */ new Set());
      __privateAdd(this, _deviceRequestPromptManagerMap, /* @__PURE__ */ new WeakMap());
      __privateAdd(this, _frameTreeHandled);
      __privateSet(this, _client8, client2);
      __privateSet(this, _page, page);
      __privateSet(this, _networkManager, new NetworkManager(this));
      __privateSet(this, _timeoutSettings3, timeoutSettings);
      this.setupEventListeners(__privateGet(this, _client8));
      client2.once(CDPSessionEvent.Disconnected, () => {
        __privateMethod(this, _FrameManager_instances, onClientDisconnect_fn).call(this).catch(debugError);
      });
    }
    get timeoutSettings() {
      return __privateGet(this, _timeoutSettings3);
    }
    get networkManager() {
      return __privateGet(this, _networkManager);
    }
    get client() {
      return __privateGet(this, _client8);
    }
    /**
     * When the main frame is replaced by another main frame,
     * we maintain the main frame object identity while updating
     * its frame tree and ID.
     */
    async swapFrameTree(client2) {
      __privateSet(this, _client8, client2);
      assert$1(__privateGet(this, _client8) instanceof CdpCDPSession, "CDPSession is not an instance of CDPSessionImpl.");
      const frame = this._frameTree.getMainFrame();
      if (frame) {
        __privateGet(this, _frameNavigatedReceived).add(__privateGet(this, _client8)._target()._targetId);
        this._frameTree.removeFrame(frame);
        frame.updateId(__privateGet(this, _client8)._target()._targetId);
        this._frameTree.addFrame(frame);
        frame.updateClient(client2);
      }
      this.setupEventListeners(client2);
      client2.once(CDPSessionEvent.Disconnected, () => {
        __privateMethod(this, _FrameManager_instances, onClientDisconnect_fn).call(this).catch(debugError);
      });
      await this.initialize(client2, frame);
      await __privateGet(this, _networkManager).addClient(client2);
      if (frame) {
        frame.emit(FrameEvent.FrameSwappedByActivation, void 0);
      }
    }
    async registerSpeculativeSession(client2) {
      await __privateGet(this, _networkManager).addClient(client2);
    }
    setupEventListeners(session) {
      session.on("Page.frameAttached", async (event) => {
        var _a3;
        await ((_a3 = __privateGet(this, _frameTreeHandled)) == null ? void 0 : _a3.valueOrThrow());
        __privateMethod(this, _FrameManager_instances, onFrameAttached_fn).call(this, session, event.frameId, event.parentFrameId);
      });
      session.on("Page.frameNavigated", async (event) => {
        var _a3;
        __privateGet(this, _frameNavigatedReceived).add(event.frame.id);
        await ((_a3 = __privateGet(this, _frameTreeHandled)) == null ? void 0 : _a3.valueOrThrow());
        void __privateMethod(this, _FrameManager_instances, onFrameNavigated_fn).call(this, event.frame, event.type);
      });
      session.on("Page.navigatedWithinDocument", async (event) => {
        var _a3;
        await ((_a3 = __privateGet(this, _frameTreeHandled)) == null ? void 0 : _a3.valueOrThrow());
        __privateMethod(this, _FrameManager_instances, onFrameNavigatedWithinDocument_fn).call(this, event.frameId, event.url);
      });
      session.on("Page.frameDetached", async (event) => {
        var _a3;
        await ((_a3 = __privateGet(this, _frameTreeHandled)) == null ? void 0 : _a3.valueOrThrow());
        __privateMethod(this, _FrameManager_instances, onFrameDetached_fn2).call(this, event.frameId, event.reason);
      });
      session.on("Page.frameStartedLoading", async (event) => {
        var _a3;
        await ((_a3 = __privateGet(this, _frameTreeHandled)) == null ? void 0 : _a3.valueOrThrow());
        __privateMethod(this, _FrameManager_instances, onFrameStartedLoading_fn).call(this, event.frameId);
      });
      session.on("Page.frameStoppedLoading", async (event) => {
        var _a3;
        await ((_a3 = __privateGet(this, _frameTreeHandled)) == null ? void 0 : _a3.valueOrThrow());
        __privateMethod(this, _FrameManager_instances, onFrameStoppedLoading_fn).call(this, event.frameId);
      });
      session.on("Runtime.executionContextCreated", async (event) => {
        var _a3;
        await ((_a3 = __privateGet(this, _frameTreeHandled)) == null ? void 0 : _a3.valueOrThrow());
        __privateMethod(this, _FrameManager_instances, onExecutionContextCreated_fn).call(this, event.context, session);
      });
      session.on("Page.lifecycleEvent", async (event) => {
        var _a3;
        await ((_a3 = __privateGet(this, _frameTreeHandled)) == null ? void 0 : _a3.valueOrThrow());
        __privateMethod(this, _FrameManager_instances, onLifecycleEvent_fn).call(this, event);
      });
    }
    async initialize(client2, frame) {
      var _a3, _b2;
      try {
        (_a3 = __privateGet(this, _frameTreeHandled)) == null ? void 0 : _a3.resolve();
        __privateSet(this, _frameTreeHandled, Deferred$1.create());
        await Promise.all([
          __privateGet(this, _networkManager).addClient(client2),
          client2.send("Page.enable"),
          client2.send("Page.getFrameTree").then(({ frameTree }) => {
            var _a4;
            __privateMethod(this, _FrameManager_instances, handleFrameTree_fn).call(this, client2, frameTree);
            (_a4 = __privateGet(this, _frameTreeHandled)) == null ? void 0 : _a4.resolve();
          }),
          client2.send("Page.setLifecycleEventsEnabled", { enabled: true }),
          client2.send("Runtime.enable").then(() => {
            return __privateMethod(this, _FrameManager_instances, createIsolatedWorld_fn).call(this, client2, UTILITY_WORLD_NAME);
          }),
          ...(frame ? Array.from(__privateGet(this, _scriptsToEvaluateOnNewDocument).values()) : []).map((script) => {
            return frame == null ? void 0 : frame.addPreloadScript(script);
          }),
          ...(frame ? Array.from(__privateGet(this, _bindings2).values()) : []).map((binding) => {
            return frame == null ? void 0 : frame.addExposedFunctionBinding(binding);
          })
        ]);
      } catch (error) {
        (_b2 = __privateGet(this, _frameTreeHandled)) == null ? void 0 : _b2.resolve();
        if (isErrorLike(error) && isTargetClosedError(error)) {
          return;
        }
        throw error;
      }
    }
    page() {
      return __privateGet(this, _page);
    }
    mainFrame() {
      const mainFrame = this._frameTree.getMainFrame();
      assert$1(mainFrame, "Requesting main frame too early!");
      return mainFrame;
    }
    frames() {
      return Array.from(this._frameTree.frames());
    }
    frame(frameId) {
      return this._frameTree.getById(frameId) || null;
    }
    async addExposedFunctionBinding(binding) {
      __privateGet(this, _bindings2).add(binding);
      await Promise.all(this.frames().map(async (frame) => {
        return await frame.addExposedFunctionBinding(binding);
      }));
    }
    async removeExposedFunctionBinding(binding) {
      __privateGet(this, _bindings2).delete(binding);
      await Promise.all(this.frames().map(async (frame) => {
        return await frame.removeExposedFunctionBinding(binding);
      }));
    }
    async evaluateOnNewDocument(source2) {
      const { identifier } = await this.mainFrame()._client().send("Page.addScriptToEvaluateOnNewDocument", {
        source: source2
      });
      const preloadScript = new CdpPreloadScript(this.mainFrame(), identifier, source2);
      __privateGet(this, _scriptsToEvaluateOnNewDocument).set(identifier, preloadScript);
      await Promise.all(this.frames().map(async (frame) => {
        return await frame.addPreloadScript(preloadScript);
      }));
      return { identifier };
    }
    async removeScriptToEvaluateOnNewDocument(identifier) {
      const preloadScript = __privateGet(this, _scriptsToEvaluateOnNewDocument).get(identifier);
      if (!preloadScript) {
        throw new Error(`Script to evaluate on new document with id ${identifier} not found`);
      }
      __privateGet(this, _scriptsToEvaluateOnNewDocument).delete(identifier);
      await Promise.all(this.frames().map((frame) => {
        const identifier2 = preloadScript.getIdForFrame(frame);
        if (!identifier2) {
          return;
        }
        return frame._client().send("Page.removeScriptToEvaluateOnNewDocument", {
          identifier: identifier2
        }).catch(debugError);
      }));
    }
    onAttachedToTarget(target) {
      if (target._getTargetInfo().type !== "iframe") {
        return;
      }
      const frame = this.frame(target._getTargetInfo().targetId);
      if (frame) {
        frame.updateClient(target._session());
      }
      this.setupEventListeners(target._session());
      void this.initialize(target._session(), frame);
    }
    _deviceRequestPromptManager(client2) {
      let manager = __privateGet(this, _deviceRequestPromptManagerMap).get(client2);
      if (manager === void 0) {
        manager = new DeviceRequestPromptManager(client2, __privateGet(this, _timeoutSettings3));
        __privateGet(this, _deviceRequestPromptManagerMap).set(client2, manager);
      }
      return manager;
    }
  }
  _page = new WeakMap();
  _networkManager = new WeakMap();
  _timeoutSettings3 = new WeakMap();
  _isolatedWorlds = new WeakMap();
  _client8 = new WeakMap();
  _scriptsToEvaluateOnNewDocument = new WeakMap();
  _bindings2 = new WeakMap();
  _frameNavigatedReceived = new WeakMap();
  _deviceRequestPromptManagerMap = new WeakMap();
  _frameTreeHandled = new WeakMap();
  _FrameManager_instances = new WeakSet();
  onClientDisconnect_fn = async function() {
    const mainFrame = this._frameTree.getMainFrame();
    if (!mainFrame) {
      return;
    }
    for (const child of mainFrame.childFrames()) {
      __privateMethod(this, _FrameManager_instances, removeFramesRecursively_fn).call(this, child);
    }
    const swapped = Deferred$1.create({
      timeout: TIME_FOR_WAITING_FOR_SWAP,
      message: "Frame was not swapped"
    });
    mainFrame.once(FrameEvent.FrameSwappedByActivation, () => {
      swapped.resolve();
    });
    try {
      await swapped.valueOrThrow();
    } catch {
      __privateMethod(this, _FrameManager_instances, removeFramesRecursively_fn).call(this, mainFrame);
    }
  };
  onLifecycleEvent_fn = function(event) {
    const frame = this.frame(event.frameId);
    if (!frame) {
      return;
    }
    frame._onLifecycleEvent(event.loaderId, event.name);
    this.emit(FrameManagerEvent.LifecycleEvent, frame);
    frame.emit(FrameEvent.LifecycleEvent, void 0);
  };
  onFrameStartedLoading_fn = function(frameId) {
    const frame = this.frame(frameId);
    if (!frame) {
      return;
    }
    frame._onLoadingStarted();
  };
  onFrameStoppedLoading_fn = function(frameId) {
    const frame = this.frame(frameId);
    if (!frame) {
      return;
    }
    frame._onLoadingStopped();
    this.emit(FrameManagerEvent.LifecycleEvent, frame);
    frame.emit(FrameEvent.LifecycleEvent, void 0);
  };
  handleFrameTree_fn = function(session, frameTree) {
    if (frameTree.frame.parentId) {
      __privateMethod(this, _FrameManager_instances, onFrameAttached_fn).call(this, session, frameTree.frame.id, frameTree.frame.parentId);
    }
    if (!__privateGet(this, _frameNavigatedReceived).has(frameTree.frame.id)) {
      void __privateMethod(this, _FrameManager_instances, onFrameNavigated_fn).call(this, frameTree.frame, "Navigation");
    } else {
      __privateGet(this, _frameNavigatedReceived).delete(frameTree.frame.id);
    }
    if (!frameTree.childFrames) {
      return;
    }
    for (const child of frameTree.childFrames) {
      __privateMethod(this, _FrameManager_instances, handleFrameTree_fn).call(this, session, child);
    }
  };
  onFrameAttached_fn = function(session, frameId, parentFrameId) {
    let frame = this.frame(frameId);
    if (frame) {
      const parentFrame = this.frame(parentFrameId);
      if (session && parentFrame && frame.client !== (parentFrame == null ? void 0 : parentFrame.client)) {
        frame.updateClient(session);
      }
      return;
    }
    frame = new CdpFrame(this, frameId, parentFrameId, session);
    this._frameTree.addFrame(frame);
    this.emit(FrameManagerEvent.FrameAttached, frame);
  };
  onFrameNavigated_fn = async function(framePayload, navigationType) {
    const frameId = framePayload.id;
    const isMainFrame = !framePayload.parentId;
    let frame = this._frameTree.getById(frameId);
    if (frame) {
      for (const child of frame.childFrames()) {
        __privateMethod(this, _FrameManager_instances, removeFramesRecursively_fn).call(this, child);
      }
    }
    if (isMainFrame) {
      if (frame) {
        this._frameTree.removeFrame(frame);
        frame._id = frameId;
      } else {
        frame = new CdpFrame(this, frameId, void 0, __privateGet(this, _client8));
      }
      this._frameTree.addFrame(frame);
    }
    frame = await this._frameTree.waitForFrame(frameId);
    frame._navigated(framePayload);
    this.emit(FrameManagerEvent.FrameNavigated, frame);
    frame.emit(FrameEvent.FrameNavigated, navigationType);
  };
  createIsolatedWorld_fn = async function(session, name) {
    const key = `${session.id()}:${name}`;
    if (__privateGet(this, _isolatedWorlds).has(key)) {
      return;
    }
    await session.send("Page.addScriptToEvaluateOnNewDocument", {
      source: `//# sourceURL=${PuppeteerURL.INTERNAL_URL}`,
      worldName: name
    });
    await Promise.all(this.frames().filter((frame) => {
      return frame.client === session;
    }).map((frame) => {
      return session.send("Page.createIsolatedWorld", {
        frameId: frame._id,
        worldName: name,
        grantUniveralAccess: true
      }).catch(debugError);
    }));
    __privateGet(this, _isolatedWorlds).add(key);
  };
  onFrameNavigatedWithinDocument_fn = function(frameId, url) {
    const frame = this.frame(frameId);
    if (!frame) {
      return;
    }
    frame._navigatedWithinDocument(url);
    this.emit(FrameManagerEvent.FrameNavigatedWithinDocument, frame);
    frame.emit(FrameEvent.FrameNavigatedWithinDocument, void 0);
    this.emit(FrameManagerEvent.FrameNavigated, frame);
    frame.emit(FrameEvent.FrameNavigated, "Navigation");
  };
  onFrameDetached_fn2 = function(frameId, reason) {
    const frame = this.frame(frameId);
    if (!frame) {
      return;
    }
    switch (reason) {
      case "remove":
        __privateMethod(this, _FrameManager_instances, removeFramesRecursively_fn).call(this, frame);
        break;
      case "swap":
        this.emit(FrameManagerEvent.FrameSwapped, frame);
        frame.emit(FrameEvent.FrameSwapped, void 0);
        break;
    }
  };
  onExecutionContextCreated_fn = function(contextPayload, session) {
    const auxData = contextPayload.auxData;
    const frameId = auxData && auxData.frameId;
    const frame = typeof frameId === "string" ? this.frame(frameId) : void 0;
    let world;
    if (frame) {
      if (frame.client !== session) {
        return;
      }
      if (contextPayload.auxData && contextPayload.auxData["isDefault"]) {
        world = frame.worlds[MAIN_WORLD];
      } else if (contextPayload.name === UTILITY_WORLD_NAME) {
        world = frame.worlds[PUPPETEER_WORLD];
      }
    }
    if (!world) {
      return;
    }
    const context = new ExecutionContext((frame == null ? void 0 : frame.client) || __privateGet(this, _client8), contextPayload, world);
    world.setContext(context);
  };
  removeFramesRecursively_fn = function(frame) {
    for (const child of frame.childFrames()) {
      __privateMethod(this, _FrameManager_instances, removeFramesRecursively_fn).call(this, child);
    }
    frame[disposeSymbol]();
    this._frameTree.removeFrame(frame);
    this.emit(FrameManagerEvent.FrameDetached, frame);
    frame.emit(FrameEvent.FrameDetached, frame);
  };
  /**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  const _keyDefinitions = {
    "0": { keyCode: 48, key: "0", code: "Digit0" },
    "1": { keyCode: 49, key: "1", code: "Digit1" },
    "2": { keyCode: 50, key: "2", code: "Digit2" },
    "3": { keyCode: 51, key: "3", code: "Digit3" },
    "4": { keyCode: 52, key: "4", code: "Digit4" },
    "5": { keyCode: 53, key: "5", code: "Digit5" },
    "6": { keyCode: 54, key: "6", code: "Digit6" },
    "7": { keyCode: 55, key: "7", code: "Digit7" },
    "8": { keyCode: 56, key: "8", code: "Digit8" },
    "9": { keyCode: 57, key: "9", code: "Digit9" },
    Power: { key: "Power", code: "Power" },
    Eject: { key: "Eject", code: "Eject" },
    Abort: { keyCode: 3, code: "Abort", key: "Cancel" },
    Help: { keyCode: 6, code: "Help", key: "Help" },
    Backspace: { keyCode: 8, code: "Backspace", key: "Backspace" },
    Tab: { keyCode: 9, code: "Tab", key: "Tab" },
    Numpad5: {
      keyCode: 12,
      shiftKeyCode: 101,
      key: "Clear",
      code: "Numpad5",
      shiftKey: "5",
      location: 3
    },
    NumpadEnter: {
      keyCode: 13,
      code: "NumpadEnter",
      key: "Enter",
      text: "\r",
      location: 3
    },
    Enter: { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
    "\r": { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
    "\n": { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
    ShiftLeft: { keyCode: 16, code: "ShiftLeft", key: "Shift", location: 1 },
    ShiftRight: { keyCode: 16, code: "ShiftRight", key: "Shift", location: 2 },
    ControlLeft: {
      keyCode: 17,
      code: "ControlLeft",
      key: "Control",
      location: 1
    },
    ControlRight: {
      keyCode: 17,
      code: "ControlRight",
      key: "Control",
      location: 2
    },
    AltLeft: { keyCode: 18, code: "AltLeft", key: "Alt", location: 1 },
    AltRight: { keyCode: 18, code: "AltRight", key: "Alt", location: 2 },
    Pause: { keyCode: 19, code: "Pause", key: "Pause" },
    CapsLock: { keyCode: 20, code: "CapsLock", key: "CapsLock" },
    Escape: { keyCode: 27, code: "Escape", key: "Escape" },
    Convert: { keyCode: 28, code: "Convert", key: "Convert" },
    NonConvert: { keyCode: 29, code: "NonConvert", key: "NonConvert" },
    Space: { keyCode: 32, code: "Space", key: " " },
    Numpad9: {
      keyCode: 33,
      shiftKeyCode: 105,
      key: "PageUp",
      code: "Numpad9",
      shiftKey: "9",
      location: 3
    },
    PageUp: { keyCode: 33, code: "PageUp", key: "PageUp" },
    Numpad3: {
      keyCode: 34,
      shiftKeyCode: 99,
      key: "PageDown",
      code: "Numpad3",
      shiftKey: "3",
      location: 3
    },
    PageDown: { keyCode: 34, code: "PageDown", key: "PageDown" },
    End: { keyCode: 35, code: "End", key: "End" },
    Numpad1: {
      keyCode: 35,
      shiftKeyCode: 97,
      key: "End",
      code: "Numpad1",
      shiftKey: "1",
      location: 3
    },
    Home: { keyCode: 36, code: "Home", key: "Home" },
    Numpad7: {
      keyCode: 36,
      shiftKeyCode: 103,
      key: "Home",
      code: "Numpad7",
      shiftKey: "7",
      location: 3
    },
    ArrowLeft: { keyCode: 37, code: "ArrowLeft", key: "ArrowLeft" },
    Numpad4: {
      keyCode: 37,
      shiftKeyCode: 100,
      key: "ArrowLeft",
      code: "Numpad4",
      shiftKey: "4",
      location: 3
    },
    Numpad8: {
      keyCode: 38,
      shiftKeyCode: 104,
      key: "ArrowUp",
      code: "Numpad8",
      shiftKey: "8",
      location: 3
    },
    ArrowUp: { keyCode: 38, code: "ArrowUp", key: "ArrowUp" },
    ArrowRight: { keyCode: 39, code: "ArrowRight", key: "ArrowRight" },
    Numpad6: {
      keyCode: 39,
      shiftKeyCode: 102,
      key: "ArrowRight",
      code: "Numpad6",
      shiftKey: "6",
      location: 3
    },
    Numpad2: {
      keyCode: 40,
      shiftKeyCode: 98,
      key: "ArrowDown",
      code: "Numpad2",
      shiftKey: "2",
      location: 3
    },
    ArrowDown: { keyCode: 40, code: "ArrowDown", key: "ArrowDown" },
    Select: { keyCode: 41, code: "Select", key: "Select" },
    Open: { keyCode: 43, code: "Open", key: "Execute" },
    PrintScreen: { keyCode: 44, code: "PrintScreen", key: "PrintScreen" },
    Insert: { keyCode: 45, code: "Insert", key: "Insert" },
    Numpad0: {
      keyCode: 45,
      shiftKeyCode: 96,
      key: "Insert",
      code: "Numpad0",
      shiftKey: "0",
      location: 3
    },
    Delete: { keyCode: 46, code: "Delete", key: "Delete" },
    NumpadDecimal: {
      keyCode: 46,
      shiftKeyCode: 110,
      code: "NumpadDecimal",
      key: "\0",
      shiftKey: ".",
      location: 3
    },
    Digit0: { keyCode: 48, code: "Digit0", shiftKey: ")", key: "0" },
    Digit1: { keyCode: 49, code: "Digit1", shiftKey: "!", key: "1" },
    Digit2: { keyCode: 50, code: "Digit2", shiftKey: "@", key: "2" },
    Digit3: { keyCode: 51, code: "Digit3", shiftKey: "#", key: "3" },
    Digit4: { keyCode: 52, code: "Digit4", shiftKey: "$", key: "4" },
    Digit5: { keyCode: 53, code: "Digit5", shiftKey: "%", key: "5" },
    Digit6: { keyCode: 54, code: "Digit6", shiftKey: "^", key: "6" },
    Digit7: { keyCode: 55, code: "Digit7", shiftKey: "&", key: "7" },
    Digit8: { keyCode: 56, code: "Digit8", shiftKey: "*", key: "8" },
    Digit9: { keyCode: 57, code: "Digit9", shiftKey: "(", key: "9" },
    KeyA: { keyCode: 65, code: "KeyA", shiftKey: "A", key: "a" },
    KeyB: { keyCode: 66, code: "KeyB", shiftKey: "B", key: "b" },
    KeyC: { keyCode: 67, code: "KeyC", shiftKey: "C", key: "c" },
    KeyD: { keyCode: 68, code: "KeyD", shiftKey: "D", key: "d" },
    KeyE: { keyCode: 69, code: "KeyE", shiftKey: "E", key: "e" },
    KeyF: { keyCode: 70, code: "KeyF", shiftKey: "F", key: "f" },
    KeyG: { keyCode: 71, code: "KeyG", shiftKey: "G", key: "g" },
    KeyH: { keyCode: 72, code: "KeyH", shiftKey: "H", key: "h" },
    KeyI: { keyCode: 73, code: "KeyI", shiftKey: "I", key: "i" },
    KeyJ: { keyCode: 74, code: "KeyJ", shiftKey: "J", key: "j" },
    KeyK: { keyCode: 75, code: "KeyK", shiftKey: "K", key: "k" },
    KeyL: { keyCode: 76, code: "KeyL", shiftKey: "L", key: "l" },
    KeyM: { keyCode: 77, code: "KeyM", shiftKey: "M", key: "m" },
    KeyN: { keyCode: 78, code: "KeyN", shiftKey: "N", key: "n" },
    KeyO: { keyCode: 79, code: "KeyO", shiftKey: "O", key: "o" },
    KeyP: { keyCode: 80, code: "KeyP", shiftKey: "P", key: "p" },
    KeyQ: { keyCode: 81, code: "KeyQ", shiftKey: "Q", key: "q" },
    KeyR: { keyCode: 82, code: "KeyR", shiftKey: "R", key: "r" },
    KeyS: { keyCode: 83, code: "KeyS", shiftKey: "S", key: "s" },
    KeyT: { keyCode: 84, code: "KeyT", shiftKey: "T", key: "t" },
    KeyU: { keyCode: 85, code: "KeyU", shiftKey: "U", key: "u" },
    KeyV: { keyCode: 86, code: "KeyV", shiftKey: "V", key: "v" },
    KeyW: { keyCode: 87, code: "KeyW", shiftKey: "W", key: "w" },
    KeyX: { keyCode: 88, code: "KeyX", shiftKey: "X", key: "x" },
    KeyY: { keyCode: 89, code: "KeyY", shiftKey: "Y", key: "y" },
    KeyZ: { keyCode: 90, code: "KeyZ", shiftKey: "Z", key: "z" },
    MetaLeft: { keyCode: 91, code: "MetaLeft", key: "Meta", location: 1 },
    MetaRight: { keyCode: 92, code: "MetaRight", key: "Meta", location: 2 },
    ContextMenu: { keyCode: 93, code: "ContextMenu", key: "ContextMenu" },
    NumpadMultiply: {
      keyCode: 106,
      code: "NumpadMultiply",
      key: "*",
      location: 3
    },
    NumpadAdd: { keyCode: 107, code: "NumpadAdd", key: "+", location: 3 },
    NumpadSubtract: {
      keyCode: 109,
      code: "NumpadSubtract",
      key: "-",
      location: 3
    },
    NumpadDivide: { keyCode: 111, code: "NumpadDivide", key: "/", location: 3 },
    F1: { keyCode: 112, code: "F1", key: "F1" },
    F2: { keyCode: 113, code: "F2", key: "F2" },
    F3: { keyCode: 114, code: "F3", key: "F3" },
    F4: { keyCode: 115, code: "F4", key: "F4" },
    F5: { keyCode: 116, code: "F5", key: "F5" },
    F6: { keyCode: 117, code: "F6", key: "F6" },
    F7: { keyCode: 118, code: "F7", key: "F7" },
    F8: { keyCode: 119, code: "F8", key: "F8" },
    F9: { keyCode: 120, code: "F9", key: "F9" },
    F10: { keyCode: 121, code: "F10", key: "F10" },
    F11: { keyCode: 122, code: "F11", key: "F11" },
    F12: { keyCode: 123, code: "F12", key: "F12" },
    F13: { keyCode: 124, code: "F13", key: "F13" },
    F14: { keyCode: 125, code: "F14", key: "F14" },
    F15: { keyCode: 126, code: "F15", key: "F15" },
    F16: { keyCode: 127, code: "F16", key: "F16" },
    F17: { keyCode: 128, code: "F17", key: "F17" },
    F18: { keyCode: 129, code: "F18", key: "F18" },
    F19: { keyCode: 130, code: "F19", key: "F19" },
    F20: { keyCode: 131, code: "F20", key: "F20" },
    F21: { keyCode: 132, code: "F21", key: "F21" },
    F22: { keyCode: 133, code: "F22", key: "F22" },
    F23: { keyCode: 134, code: "F23", key: "F23" },
    F24: { keyCode: 135, code: "F24", key: "F24" },
    NumLock: { keyCode: 144, code: "NumLock", key: "NumLock" },
    ScrollLock: { keyCode: 145, code: "ScrollLock", key: "ScrollLock" },
    AudioVolumeMute: {
      keyCode: 173,
      code: "AudioVolumeMute",
      key: "AudioVolumeMute"
    },
    AudioVolumeDown: {
      keyCode: 174,
      code: "AudioVolumeDown",
      key: "AudioVolumeDown"
    },
    AudioVolumeUp: { keyCode: 175, code: "AudioVolumeUp", key: "AudioVolumeUp" },
    MediaTrackNext: {
      keyCode: 176,
      code: "MediaTrackNext",
      key: "MediaTrackNext"
    },
    MediaTrackPrevious: {
      keyCode: 177,
      code: "MediaTrackPrevious",
      key: "MediaTrackPrevious"
    },
    MediaStop: { keyCode: 178, code: "MediaStop", key: "MediaStop" },
    MediaPlayPause: {
      keyCode: 179,
      code: "MediaPlayPause",
      key: "MediaPlayPause"
    },
    Semicolon: { keyCode: 186, code: "Semicolon", shiftKey: ":", key: ";" },
    Equal: { keyCode: 187, code: "Equal", shiftKey: "+", key: "=" },
    NumpadEqual: { keyCode: 187, code: "NumpadEqual", key: "=", location: 3 },
    Comma: { keyCode: 188, code: "Comma", shiftKey: "<", key: "," },
    Minus: { keyCode: 189, code: "Minus", shiftKey: "_", key: "-" },
    Period: { keyCode: 190, code: "Period", shiftKey: ">", key: "." },
    Slash: { keyCode: 191, code: "Slash", shiftKey: "?", key: "/" },
    Backquote: { keyCode: 192, code: "Backquote", shiftKey: "~", key: "`" },
    BracketLeft: { keyCode: 219, code: "BracketLeft", shiftKey: "{", key: "[" },
    Backslash: { keyCode: 220, code: "Backslash", shiftKey: "|", key: "\\" },
    BracketRight: { keyCode: 221, code: "BracketRight", shiftKey: "}", key: "]" },
    Quote: { keyCode: 222, code: "Quote", shiftKey: '"', key: "'" },
    AltGraph: { keyCode: 225, code: "AltGraph", key: "AltGraph" },
    Props: { keyCode: 247, code: "Props", key: "CrSel" },
    Cancel: { keyCode: 3, key: "Cancel", code: "Abort" },
    Clear: { keyCode: 12, key: "Clear", code: "Numpad5", location: 3 },
    Shift: { keyCode: 16, key: "Shift", code: "ShiftLeft", location: 1 },
    Control: { keyCode: 17, key: "Control", code: "ControlLeft", location: 1 },
    Alt: { keyCode: 18, key: "Alt", code: "AltLeft", location: 1 },
    Accept: { keyCode: 30, key: "Accept" },
    ModeChange: { keyCode: 31, key: "ModeChange" },
    " ": { keyCode: 32, key: " ", code: "Space" },
    Print: { keyCode: 42, key: "Print" },
    Execute: { keyCode: 43, key: "Execute", code: "Open" },
    "\0": { keyCode: 46, key: "\0", code: "NumpadDecimal", location: 3 },
    a: { keyCode: 65, key: "a", code: "KeyA" },
    b: { keyCode: 66, key: "b", code: "KeyB" },
    c: { keyCode: 67, key: "c", code: "KeyC" },
    d: { keyCode: 68, key: "d", code: "KeyD" },
    e: { keyCode: 69, key: "e", code: "KeyE" },
    f: { keyCode: 70, key: "f", code: "KeyF" },
    g: { keyCode: 71, key: "g", code: "KeyG" },
    h: { keyCode: 72, key: "h", code: "KeyH" },
    i: { keyCode: 73, key: "i", code: "KeyI" },
    j: { keyCode: 74, key: "j", code: "KeyJ" },
    k: { keyCode: 75, key: "k", code: "KeyK" },
    l: { keyCode: 76, key: "l", code: "KeyL" },
    m: { keyCode: 77, key: "m", code: "KeyM" },
    n: { keyCode: 78, key: "n", code: "KeyN" },
    o: { keyCode: 79, key: "o", code: "KeyO" },
    p: { keyCode: 80, key: "p", code: "KeyP" },
    q: { keyCode: 81, key: "q", code: "KeyQ" },
    r: { keyCode: 82, key: "r", code: "KeyR" },
    s: { keyCode: 83, key: "s", code: "KeyS" },
    t: { keyCode: 84, key: "t", code: "KeyT" },
    u: { keyCode: 85, key: "u", code: "KeyU" },
    v: { keyCode: 86, key: "v", code: "KeyV" },
    w: { keyCode: 87, key: "w", code: "KeyW" },
    x: { keyCode: 88, key: "x", code: "KeyX" },
    y: { keyCode: 89, key: "y", code: "KeyY" },
    z: { keyCode: 90, key: "z", code: "KeyZ" },
    Meta: { keyCode: 91, key: "Meta", code: "MetaLeft", location: 1 },
    "*": { keyCode: 106, key: "*", code: "NumpadMultiply", location: 3 },
    "+": { keyCode: 107, key: "+", code: "NumpadAdd", location: 3 },
    "-": { keyCode: 109, key: "-", code: "NumpadSubtract", location: 3 },
    "/": { keyCode: 111, key: "/", code: "NumpadDivide", location: 3 },
    ";": { keyCode: 186, key: ";", code: "Semicolon" },
    "=": { keyCode: 187, key: "=", code: "Equal" },
    ",": { keyCode: 188, key: ",", code: "Comma" },
    ".": { keyCode: 190, key: ".", code: "Period" },
    "`": { keyCode: 192, key: "`", code: "Backquote" },
    "[": { keyCode: 219, key: "[", code: "BracketLeft" },
    "\\": { keyCode: 220, key: "\\", code: "Backslash" },
    "]": { keyCode: 221, key: "]", code: "BracketRight" },
    "'": { keyCode: 222, key: "'", code: "Quote" },
    Attn: { keyCode: 246, key: "Attn" },
    CrSel: { keyCode: 247, key: "CrSel", code: "Props" },
    ExSel: { keyCode: 248, key: "ExSel" },
    EraseEof: { keyCode: 249, key: "EraseEof" },
    Play: { keyCode: 250, key: "Play" },
    ZoomOut: { keyCode: 251, key: "ZoomOut" },
    ")": { keyCode: 48, key: ")", code: "Digit0" },
    "!": { keyCode: 49, key: "!", code: "Digit1" },
    "@": { keyCode: 50, key: "@", code: "Digit2" },
    "#": { keyCode: 51, key: "#", code: "Digit3" },
    $: { keyCode: 52, key: "$", code: "Digit4" },
    "%": { keyCode: 53, key: "%", code: "Digit5" },
    "^": { keyCode: 54, key: "^", code: "Digit6" },
    "&": { keyCode: 55, key: "&", code: "Digit7" },
    "(": { keyCode: 57, key: "(", code: "Digit9" },
    A: { keyCode: 65, key: "A", code: "KeyA" },
    B: { keyCode: 66, key: "B", code: "KeyB" },
    C: { keyCode: 67, key: "C", code: "KeyC" },
    D: { keyCode: 68, key: "D", code: "KeyD" },
    E: { keyCode: 69, key: "E", code: "KeyE" },
    F: { keyCode: 70, key: "F", code: "KeyF" },
    G: { keyCode: 71, key: "G", code: "KeyG" },
    H: { keyCode: 72, key: "H", code: "KeyH" },
    I: { keyCode: 73, key: "I", code: "KeyI" },
    J: { keyCode: 74, key: "J", code: "KeyJ" },
    K: { keyCode: 75, key: "K", code: "KeyK" },
    L: { keyCode: 76, key: "L", code: "KeyL" },
    M: { keyCode: 77, key: "M", code: "KeyM" },
    N: { keyCode: 78, key: "N", code: "KeyN" },
    O: { keyCode: 79, key: "O", code: "KeyO" },
    P: { keyCode: 80, key: "P", code: "KeyP" },
    Q: { keyCode: 81, key: "Q", code: "KeyQ" },
    R: { keyCode: 82, key: "R", code: "KeyR" },
    S: { keyCode: 83, key: "S", code: "KeyS" },
    T: { keyCode: 84, key: "T", code: "KeyT" },
    U: { keyCode: 85, key: "U", code: "KeyU" },
    V: { keyCode: 86, key: "V", code: "KeyV" },
    W: { keyCode: 87, key: "W", code: "KeyW" },
    X: { keyCode: 88, key: "X", code: "KeyX" },
    Y: { keyCode: 89, key: "Y", code: "KeyY" },
    Z: { keyCode: 90, key: "Z", code: "KeyZ" },
    ":": { keyCode: 186, key: ":", code: "Semicolon" },
    "<": { keyCode: 188, key: "<", code: "Comma" },
    _: { keyCode: 189, key: "_", code: "Minus" },
    ">": { keyCode: 190, key: ">", code: "Period" },
    "?": { keyCode: 191, key: "?", code: "Slash" },
    "~": { keyCode: 192, key: "~", code: "Backquote" },
    "{": { keyCode: 219, key: "{", code: "BracketLeft" },
    "|": { keyCode: 220, key: "|", code: "Backslash" },
    "}": { keyCode: 221, key: "}", code: "BracketRight" },
    '"': { keyCode: 222, key: '"', code: "Quote" },
    SoftLeft: { key: "SoftLeft", code: "SoftLeft", location: 4 },
    SoftRight: { key: "SoftRight", code: "SoftRight", location: 4 },
    Camera: { keyCode: 44, key: "Camera", code: "Camera", location: 4 },
    Call: { key: "Call", code: "Call", location: 4 },
    EndCall: { keyCode: 95, key: "EndCall", code: "EndCall", location: 4 },
    VolumeDown: {
      keyCode: 182,
      key: "VolumeDown",
      code: "VolumeDown",
      location: 4
    },
    VolumeUp: { keyCode: 183, key: "VolumeUp", code: "VolumeUp", location: 4 }
  };
  /**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class CdpKeyboard extends Keyboard {
    constructor(client2) {
      super();
      __privateAdd(this, _CdpKeyboard_instances);
      __privateAdd(this, _client9);
      __privateAdd(this, _pressedKeys, /* @__PURE__ */ new Set());
      __publicField(this, "_modifiers", 0);
      __privateSet(this, _client9, client2);
    }
    updateClient(client2) {
      __privateSet(this, _client9, client2);
    }
    async down(key, options = {
      text: void 0,
      commands: []
    }) {
      const description = __privateMethod(this, _CdpKeyboard_instances, keyDescriptionForString_fn).call(this, key);
      const autoRepeat = __privateGet(this, _pressedKeys).has(description.code);
      __privateGet(this, _pressedKeys).add(description.code);
      this._modifiers |= __privateMethod(this, _CdpKeyboard_instances, modifierBit_fn).call(this, description.key);
      const text = options.text === void 0 ? description.text : options.text;
      await __privateGet(this, _client9).send("Input.dispatchKeyEvent", {
        type: text ? "keyDown" : "rawKeyDown",
        modifiers: this._modifiers,
        windowsVirtualKeyCode: description.keyCode,
        code: description.code,
        key: description.key,
        text,
        unmodifiedText: text,
        autoRepeat,
        location: description.location,
        isKeypad: description.location === 3,
        commands: options.commands
      });
    }
    async up(key) {
      const description = __privateMethod(this, _CdpKeyboard_instances, keyDescriptionForString_fn).call(this, key);
      this._modifiers &= ~__privateMethod(this, _CdpKeyboard_instances, modifierBit_fn).call(this, description.key);
      __privateGet(this, _pressedKeys).delete(description.code);
      await __privateGet(this, _client9).send("Input.dispatchKeyEvent", {
        type: "keyUp",
        modifiers: this._modifiers,
        key: description.key,
        windowsVirtualKeyCode: description.keyCode,
        code: description.code,
        location: description.location
      });
    }
    async sendCharacter(char) {
      await __privateGet(this, _client9).send("Input.insertText", { text: char });
    }
    charIsKey(char) {
      return !!_keyDefinitions[char];
    }
    async type(text, options = {}) {
      const delay = options.delay || void 0;
      for (const char of text) {
        if (this.charIsKey(char)) {
          await this.press(char, { delay });
        } else {
          if (delay) {
            await new Promise((f) => {
              return setTimeout(f, delay);
            });
          }
          await this.sendCharacter(char);
        }
      }
    }
    async press(key, options = {}) {
      const { delay = null } = options;
      await this.down(key, options);
      if (delay) {
        await new Promise((f) => {
          return setTimeout(f, options.delay);
        });
      }
      await this.up(key);
    }
  }
  _client9 = new WeakMap();
  _pressedKeys = new WeakMap();
  _CdpKeyboard_instances = new WeakSet();
  modifierBit_fn = function(key) {
    if (key === "Alt") {
      return 1;
    }
    if (key === "Control") {
      return 2;
    }
    if (key === "Meta") {
      return 4;
    }
    if (key === "Shift") {
      return 8;
    }
    return 0;
  };
  keyDescriptionForString_fn = function(keyString) {
    const shift = this._modifiers & 8;
    const description = {
      key: "",
      keyCode: 0,
      code: "",
      text: "",
      location: 0
    };
    const definition = _keyDefinitions[keyString];
    assert$1(definition, `Unknown key: "${keyString}"`);
    if (definition.key) {
      description.key = definition.key;
    }
    if (shift && definition.shiftKey) {
      description.key = definition.shiftKey;
    }
    if (definition.keyCode) {
      description.keyCode = definition.keyCode;
    }
    if (shift && definition.shiftKeyCode) {
      description.keyCode = definition.shiftKeyCode;
    }
    if (definition.code) {
      description.code = definition.code;
    }
    if (definition.location) {
      description.location = definition.location;
    }
    if (description.key.length === 1) {
      description.text = description.key;
    }
    if (definition.text) {
      description.text = definition.text;
    }
    if (shift && definition.shiftText) {
      description.text = definition.shiftText;
    }
    if (this._modifiers & ~8) {
      description.text = "";
    }
    return description;
  };
  const getFlag = (button) => {
    switch (button) {
      case MouseButton.Left:
        return 1;
      case MouseButton.Right:
        return 2;
      case MouseButton.Middle:
        return 4;
      case MouseButton.Back:
        return 8;
      case MouseButton.Forward:
        return 16;
    }
  };
  const getButtonFromPressedButtons = (buttons) => {
    if (buttons & 1) {
      return MouseButton.Left;
    } else if (buttons & 2) {
      return MouseButton.Right;
    } else if (buttons & 4) {
      return MouseButton.Middle;
    } else if (buttons & 8) {
      return MouseButton.Back;
    } else if (buttons & 16) {
      return MouseButton.Forward;
    }
    return "none";
  };
  class CdpMouse extends Mouse {
    constructor(client2, keyboard) {
      super();
      __privateAdd(this, _CdpMouse_instances);
      __privateAdd(this, _client10);
      __privateAdd(this, _keyboard);
      __privateAdd(this, __state, {
        position: { x: 0, y: 0 },
        buttons: 0
      });
      // Transactions can run in parallel, so we store each of thme in this array.
      __privateAdd(this, _transactions, []);
      __privateSet(this, _client10, client2);
      __privateSet(this, _keyboard, keyboard);
    }
    updateClient(client2) {
      __privateSet(this, _client10, client2);
    }
    async reset() {
      const actions = [];
      for (const [flag, button] of [
        [1, MouseButton.Left],
        [4, MouseButton.Middle],
        [2, MouseButton.Right],
        [16, MouseButton.Forward],
        [8, MouseButton.Back]
      ]) {
        if (__privateGet(this, _CdpMouse_instances, state_get).buttons & flag) {
          actions.push(this.up({ button }));
        }
      }
      if (__privateGet(this, _CdpMouse_instances, state_get).position.x !== 0 || __privateGet(this, _CdpMouse_instances, state_get).position.y !== 0) {
        actions.push(this.move(0, 0));
      }
      await Promise.all(actions);
    }
    async move(x, y, options = {}) {
      const { steps = 1 } = options;
      const from2 = __privateGet(this, _CdpMouse_instances, state_get).position;
      const to = { x, y };
      for (let i2 = 1; i2 <= steps; i2++) {
        await __privateMethod(this, _CdpMouse_instances, withTransaction_fn).call(this, (updateState) => {
          updateState({
            position: {
              x: from2.x + (to.x - from2.x) * (i2 / steps),
              y: from2.y + (to.y - from2.y) * (i2 / steps)
            }
          });
          const { buttons, position } = __privateGet(this, _CdpMouse_instances, state_get);
          return __privateGet(this, _client10).send("Input.dispatchMouseEvent", {
            type: "mouseMoved",
            modifiers: __privateGet(this, _keyboard)._modifiers,
            buttons,
            button: getButtonFromPressedButtons(buttons),
            ...position
          });
        });
      }
    }
    async down(options = {}) {
      const { button = MouseButton.Left, clickCount = 1 } = options;
      const flag = getFlag(button);
      if (!flag) {
        throw new Error(`Unsupported mouse button: ${button}`);
      }
      if (__privateGet(this, _CdpMouse_instances, state_get).buttons & flag) {
        throw new Error(`'${button}' is already pressed.`);
      }
      await __privateMethod(this, _CdpMouse_instances, withTransaction_fn).call(this, (updateState) => {
        updateState({
          buttons: __privateGet(this, _CdpMouse_instances, state_get).buttons | flag
        });
        const { buttons, position } = __privateGet(this, _CdpMouse_instances, state_get);
        return __privateGet(this, _client10).send("Input.dispatchMouseEvent", {
          type: "mousePressed",
          modifiers: __privateGet(this, _keyboard)._modifiers,
          clickCount,
          buttons,
          button,
          ...position
        });
      });
    }
    async up(options = {}) {
      const { button = MouseButton.Left, clickCount = 1 } = options;
      const flag = getFlag(button);
      if (!flag) {
        throw new Error(`Unsupported mouse button: ${button}`);
      }
      if (!(__privateGet(this, _CdpMouse_instances, state_get).buttons & flag)) {
        throw new Error(`'${button}' is not pressed.`);
      }
      await __privateMethod(this, _CdpMouse_instances, withTransaction_fn).call(this, (updateState) => {
        updateState({
          buttons: __privateGet(this, _CdpMouse_instances, state_get).buttons & ~flag
        });
        const { buttons, position } = __privateGet(this, _CdpMouse_instances, state_get);
        return __privateGet(this, _client10).send("Input.dispatchMouseEvent", {
          type: "mouseReleased",
          modifiers: __privateGet(this, _keyboard)._modifiers,
          clickCount,
          buttons,
          button,
          ...position
        });
      });
    }
    async click(x, y, options = {}) {
      const { delay, count = 1, clickCount = count } = options;
      if (count < 1) {
        throw new Error("Click must occur a positive number of times.");
      }
      const actions = [this.move(x, y)];
      if (clickCount === count) {
        for (let i2 = 1; i2 < count; ++i2) {
          actions.push(this.down({ ...options, clickCount: i2 }), this.up({ ...options, clickCount: i2 }));
        }
      }
      actions.push(this.down({ ...options, clickCount }));
      if (typeof delay === "number") {
        await Promise.all(actions);
        actions.length = 0;
        await new Promise((resolve) => {
          setTimeout(resolve, delay);
        });
      }
      actions.push(this.up({ ...options, clickCount }));
      await Promise.all(actions);
    }
    async wheel(options = {}) {
      const { deltaX = 0, deltaY = 0 } = options;
      const { position, buttons } = __privateGet(this, _CdpMouse_instances, state_get);
      await __privateGet(this, _client10).send("Input.dispatchMouseEvent", {
        type: "mouseWheel",
        pointerType: "mouse",
        modifiers: __privateGet(this, _keyboard)._modifiers,
        deltaY,
        deltaX,
        buttons,
        ...position
      });
    }
    async drag(start, target) {
      const promise = new Promise((resolve) => {
        __privateGet(this, _client10).once("Input.dragIntercepted", (event) => {
          return resolve(event.data);
        });
      });
      await this.move(start.x, start.y);
      await this.down();
      await this.move(target.x, target.y);
      return await promise;
    }
    async dragEnter(target, data) {
      await __privateGet(this, _client10).send("Input.dispatchDragEvent", {
        type: "dragEnter",
        x: target.x,
        y: target.y,
        modifiers: __privateGet(this, _keyboard)._modifiers,
        data
      });
    }
    async dragOver(target, data) {
      await __privateGet(this, _client10).send("Input.dispatchDragEvent", {
        type: "dragOver",
        x: target.x,
        y: target.y,
        modifiers: __privateGet(this, _keyboard)._modifiers,
        data
      });
    }
    async drop(target, data) {
      await __privateGet(this, _client10).send("Input.dispatchDragEvent", {
        type: "drop",
        x: target.x,
        y: target.y,
        modifiers: __privateGet(this, _keyboard)._modifiers,
        data
      });
    }
    async dragAndDrop(start, target, options = {}) {
      const { delay = null } = options;
      const data = await this.drag(start, target);
      await this.dragEnter(target, data);
      await this.dragOver(target, data);
      if (delay) {
        await new Promise((resolve) => {
          return setTimeout(resolve, delay);
        });
      }
      await this.drop(target, data);
      await this.up();
    }
  }
  _client10 = new WeakMap();
  _keyboard = new WeakMap();
  __state = new WeakMap();
  _CdpMouse_instances = new WeakSet();
  state_get = function() {
    return Object.assign({ ...__privateGet(this, __state) }, ...__privateGet(this, _transactions));
  };
  _transactions = new WeakMap();
  createTransaction_fn = function() {
    const transaction = {};
    __privateGet(this, _transactions).push(transaction);
    const popTransaction = () => {
      __privateGet(this, _transactions).splice(__privateGet(this, _transactions).indexOf(transaction), 1);
    };
    return {
      update: (updates) => {
        Object.assign(transaction, updates);
      },
      commit: () => {
        __privateSet(this, __state, { ...__privateGet(this, __state), ...transaction });
        popTransaction();
      },
      rollback: popTransaction
    };
  };
  withTransaction_fn = async function(action) {
    const { update, commit, rollback } = __privateMethod(this, _CdpMouse_instances, createTransaction_fn).call(this);
    try {
      await action(update);
      commit();
    } catch (error) {
      rollback();
      throw error;
    }
  };
  class CdpTouchHandle {
    constructor(client2, touchScreen, keyboard, touchPoint) {
      __privateAdd(this, _started, false);
      __privateAdd(this, _touchScreen);
      __privateAdd(this, _touchPoint);
      __privateAdd(this, _client11);
      __privateAdd(this, _keyboard2);
      __privateSet(this, _client11, client2);
      __privateSet(this, _touchScreen, touchScreen);
      __privateSet(this, _keyboard2, keyboard);
      __privateSet(this, _touchPoint, touchPoint);
    }
    updateClient(client2) {
      __privateSet(this, _client11, client2);
    }
    async start() {
      if (__privateGet(this, _started)) {
        throw new TouchError("Touch has already started");
      }
      await __privateGet(this, _client11).send("Input.dispatchTouchEvent", {
        type: "touchStart",
        touchPoints: [__privateGet(this, _touchPoint)],
        modifiers: __privateGet(this, _keyboard2)._modifiers
      });
      __privateSet(this, _started, true);
    }
    move(x, y) {
      __privateGet(this, _touchPoint).x = Math.round(x);
      __privateGet(this, _touchPoint).y = Math.round(y);
      return __privateGet(this, _client11).send("Input.dispatchTouchEvent", {
        type: "touchMove",
        touchPoints: [__privateGet(this, _touchPoint)],
        modifiers: __privateGet(this, _keyboard2)._modifiers
      });
    }
    async end() {
      await __privateGet(this, _client11).send("Input.dispatchTouchEvent", {
        type: "touchEnd",
        touchPoints: [__privateGet(this, _touchPoint)],
        modifiers: __privateGet(this, _keyboard2)._modifiers
      });
      __privateGet(this, _touchScreen).removeHandle(this);
    }
  }
  _started = new WeakMap();
  _touchScreen = new WeakMap();
  _touchPoint = new WeakMap();
  _client11 = new WeakMap();
  _keyboard2 = new WeakMap();
  class CdpTouchscreen extends Touchscreen {
    constructor(client2, keyboard) {
      super();
      __privateAdd(this, _client12);
      __privateAdd(this, _keyboard3);
      __privateSet(this, _client12, client2);
      __privateSet(this, _keyboard3, keyboard);
    }
    updateClient(client2) {
      __privateSet(this, _client12, client2);
      this.touches.forEach((t) => {
        t.updateClient(client2);
      });
    }
    async touchStart(x, y) {
      const id = this.idGenerator();
      const touchPoint = {
        x: Math.round(x),
        y: Math.round(y),
        radiusX: 0.5,
        radiusY: 0.5,
        force: 0.5,
        id
      };
      const touch = new CdpTouchHandle(__privateGet(this, _client12), this, __privateGet(this, _keyboard3), touchPoint);
      await touch.start();
      this.touches.push(touch);
      return touch;
    }
  }
  _client12 = new WeakMap();
  _keyboard3 = new WeakMap();
  class Tracing {
    /**
     * @internal
     */
    constructor(client2) {
      __privateAdd(this, _client13);
      __privateAdd(this, _recording, false);
      __privateAdd(this, _path);
      __privateSet(this, _client13, client2);
    }
    /**
     * @internal
     */
    updateClient(client2) {
      __privateSet(this, _client13, client2);
    }
    /**
     * Starts a trace for the current page.
     * @remarks
     * Only one trace can be active at a time per browser.
     *
     * @param options - Optional `TracingOptions`.
     */
    async start(options = {}) {
      assert$1(!__privateGet(this, _recording), "Cannot start recording trace while already recording trace.");
      const defaultCategories = [
        "-*",
        "devtools.timeline",
        "v8.execute",
        "disabled-by-default-devtools.timeline",
        "disabled-by-default-devtools.timeline.frame",
        "toplevel",
        "blink.console",
        "blink.user_timing",
        "latencyInfo",
        "disabled-by-default-devtools.timeline.stack",
        "disabled-by-default-v8.cpu_profiler"
      ];
      const { path, screenshots = false, categories = defaultCategories } = options;
      if (screenshots) {
        categories.push("disabled-by-default-devtools.screenshot");
      }
      const excludedCategories = categories.filter((cat) => {
        return cat.startsWith("-");
      }).map((cat) => {
        return cat.slice(1);
      });
      const includedCategories = categories.filter((cat) => {
        return !cat.startsWith("-");
      });
      __privateSet(this, _path, path);
      __privateSet(this, _recording, true);
      await __privateGet(this, _client13).send("Tracing.start", {
        transferMode: "ReturnAsStream",
        traceConfig: {
          excludedCategories,
          includedCategories
        }
      });
    }
    /**
     * Stops a trace started with the `start` method.
     * @returns Promise which resolves to buffer with trace data.
     */
    async stop() {
      const contentDeferred = Deferred$1.create();
      __privateGet(this, _client13).once("Tracing.tracingComplete", async (event) => {
        try {
          assert$1(event.stream, 'Missing "stream"');
          const readable = await getReadableFromProtocolStream(__privateGet(this, _client13), event.stream);
          const typedArray = await getReadableAsTypedArray(readable, __privateGet(this, _path));
          contentDeferred.resolve(typedArray ?? void 0);
        } catch (error) {
          if (isErrorLike(error)) {
            contentDeferred.reject(error);
          } else {
            contentDeferred.reject(new Error(`Unknown error: ${error}`));
          }
        }
      });
      await __privateGet(this, _client13).send("Tracing.end");
      __privateSet(this, _recording, false);
      return await contentDeferred.valueOrThrow();
    }
  }
  _client13 = new WeakMap();
  _recording = new WeakMap();
  _path = new WeakMap();
  class CdpWebWorker extends WebWorker {
    constructor(client2, url, targetId, targetType, consoleAPICalled, exceptionThrown) {
      super(url);
      __privateAdd(this, _world4);
      __privateAdd(this, _client14);
      __privateAdd(this, _id5);
      __privateAdd(this, _targetType2);
      __privateSet(this, _id5, targetId);
      __privateSet(this, _client14, client2);
      __privateSet(this, _targetType2, targetType);
      __privateSet(this, _world4, new IsolatedWorld(this, new TimeoutSettings()));
      __privateGet(this, _client14).once("Runtime.executionContextCreated", async (event) => {
        __privateGet(this, _world4).setContext(new ExecutionContext(client2, event.context, __privateGet(this, _world4)));
      });
      __privateGet(this, _world4).emitter.on("consoleapicalled", async (event) => {
        try {
          return consoleAPICalled(event.type, event.args.map((object) => {
            return new CdpJSHandle(__privateGet(this, _world4), object);
          }), event.stackTrace);
        } catch (err) {
          debugError(err);
        }
      });
      __privateGet(this, _client14).on("Runtime.exceptionThrown", exceptionThrown);
      __privateGet(this, _client14).once(CDPSessionEvent.Disconnected, () => {
        __privateGet(this, _world4).dispose();
      });
      __privateGet(this, _client14).send("Runtime.enable").catch(debugError);
    }
    mainRealm() {
      return __privateGet(this, _world4);
    }
    get client() {
      return __privateGet(this, _client14);
    }
    async close() {
      var _a3, _b2;
      switch (__privateGet(this, _targetType2)) {
        case TargetType.SERVICE_WORKER:
        case TargetType.SHARED_WORKER: {
          await ((_a3 = this.client.connection()) == null ? void 0 : _a3.send("Target.closeTarget", {
            targetId: __privateGet(this, _id5)
          }));
          await ((_b2 = this.client.connection()) == null ? void 0 : _b2.send("Target.detachFromTarget", {
            sessionId: this.client.id()
          }));
          break;
        }
        default:
          await this.evaluate(() => {
            self.close();
          });
      }
    }
  }
  _world4 = new WeakMap();
  _client14 = new WeakMap();
  _id5 = new WeakMap();
  _targetType2 = new WeakMap();
  /**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var __addDisposableResource$7 = function(env, value, async2) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async2) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async2) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({ value, dispose, async: async2 });
    } else if (async2) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources$7 = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  function convertConsoleMessageLevel$1(method) {
    switch (method) {
      case "warning":
        return "warn";
      default:
        return method;
    }
  }
  const _CdpPage = class _CdpPage extends Page$4 {
    constructor(client2, target) {
      super();
      __privateAdd(this, _CdpPage_instances);
      __privateAdd(this, _closed2, false);
      __privateAdd(this, _targetManager);
      __privateAdd(this, _primaryTargetClient);
      __privateAdd(this, _primaryTarget);
      __privateAdd(this, _tabTargetClient);
      __privateAdd(this, _tabTarget);
      __privateAdd(this, _keyboard4);
      __privateAdd(this, _mouse);
      __privateAdd(this, _touchscreen);
      __privateAdd(this, _frameManager2);
      __privateAdd(this, _emulationManager);
      __privateAdd(this, _tracing);
      __privateAdd(this, _bindings3, /* @__PURE__ */ new Map());
      __privateAdd(this, _exposedFunctions, /* @__PURE__ */ new Map());
      __privateAdd(this, _coverage);
      __privateAdd(this, _viewport);
      __privateAdd(this, _workers, /* @__PURE__ */ new Map());
      __privateAdd(this, _fileChooserDeferreds, /* @__PURE__ */ new Set());
      __privateAdd(this, _sessionCloseDeferred, Deferred$1.create());
      __privateAdd(this, _serviceWorkerBypassed, false);
      __privateAdd(this, _userDragInterceptionEnabled, false);
      __privateAdd(this, _onDetachedFromTarget, (target) => {
        var _a3;
        const sessionId = (_a3 = target._session()) == null ? void 0 : _a3.id();
        const worker = __privateGet(this, _workers).get(sessionId);
        if (!worker) {
          return;
        }
        __privateGet(this, _workers).delete(sessionId);
        this.emit("workerdestroyed", worker);
      });
      __privateAdd(this, _onAttachedToTarget, (session) => {
        assert$1(session instanceof CdpCDPSession);
        __privateGet(this, _frameManager2).onAttachedToTarget(session._target());
        if (session._target()._getTargetInfo().type === "worker") {
          const worker = new CdpWebWorker(session, session._target().url(), session._target()._targetId, session._target().type(), __privateMethod(this, _CdpPage_instances, addConsoleMessage_fn).bind(this), __privateMethod(this, _CdpPage_instances, handleException_fn).bind(this));
          __privateGet(this, _workers).set(session.id(), worker);
          this.emit("workercreated", worker);
        }
        session.on(CDPSessionEvent.Ready, __privateGet(this, _onAttachedToTarget));
      });
      __privateSet(this, _primaryTargetClient, client2);
      __privateSet(this, _tabTargetClient, client2.parentSession());
      assert$1(__privateGet(this, _tabTargetClient), "Tab target session is not defined.");
      __privateSet(this, _tabTarget, __privateGet(this, _tabTargetClient)._target());
      assert$1(__privateGet(this, _tabTarget), "Tab target is not defined.");
      __privateSet(this, _primaryTarget, target);
      __privateSet(this, _targetManager, target._targetManager());
      __privateSet(this, _keyboard4, new CdpKeyboard(client2));
      __privateSet(this, _mouse, new CdpMouse(client2, __privateGet(this, _keyboard4)));
      __privateSet(this, _touchscreen, new CdpTouchscreen(client2, __privateGet(this, _keyboard4)));
      __privateSet(this, _frameManager2, new FrameManager(client2, this, this._timeoutSettings));
      __privateSet(this, _emulationManager, new EmulationManager(client2));
      __privateSet(this, _tracing, new Tracing(client2));
      __privateSet(this, _coverage, new Coverage(client2));
      __privateSet(this, _viewport, null);
      const frameManagerEmitter = new EventEmitter$1(__privateGet(this, _frameManager2));
      frameManagerEmitter.on(FrameManagerEvent.FrameAttached, (frame) => {
        this.emit("frameattached", frame);
      });
      frameManagerEmitter.on(FrameManagerEvent.FrameDetached, (frame) => {
        this.emit("framedetached", frame);
      });
      frameManagerEmitter.on(FrameManagerEvent.FrameNavigated, (frame) => {
        this.emit("framenavigated", frame);
      });
      frameManagerEmitter.on(FrameManagerEvent.ConsoleApiCalled, ([world, event]) => {
        __privateMethod(this, _CdpPage_instances, onConsoleAPI_fn2).call(this, world, event);
      });
      frameManagerEmitter.on(FrameManagerEvent.BindingCalled, ([world, event]) => {
        void __privateMethod(this, _CdpPage_instances, onBindingCalled_fn2).call(this, world, event);
      });
      const networkManagerEmitter = new EventEmitter$1(__privateGet(this, _frameManager2).networkManager);
      networkManagerEmitter.on(NetworkManagerEvent.Request, (request) => {
        this.emit("request", request);
      });
      networkManagerEmitter.on(NetworkManagerEvent.RequestServedFromCache, (request) => {
        this.emit("requestservedfromcache", request);
      });
      networkManagerEmitter.on(NetworkManagerEvent.Response, (response) => {
        this.emit("response", response);
      });
      networkManagerEmitter.on(NetworkManagerEvent.RequestFailed, (request) => {
        this.emit("requestfailed", request);
      });
      networkManagerEmitter.on(NetworkManagerEvent.RequestFinished, (request) => {
        this.emit("requestfinished", request);
      });
      __privateGet(this, _tabTargetClient).on(CDPSessionEvent.Swapped, __privateMethod(this, _CdpPage_instances, onActivation_fn).bind(this));
      __privateGet(this, _tabTargetClient).on(CDPSessionEvent.Ready, __privateMethod(this, _CdpPage_instances, onSecondaryTarget_fn).bind(this));
      __privateGet(this, _targetManager).on("targetGone", __privateGet(this, _onDetachedFromTarget));
      __privateGet(this, _tabTarget)._isClosedDeferred.valueOrThrow().then(() => {
        __privateGet(this, _targetManager).off("targetGone", __privateGet(this, _onDetachedFromTarget));
        this.emit("close", void 0);
        __privateSet(this, _closed2, true);
      }).catch(debugError);
      __privateMethod(this, _CdpPage_instances, setupPrimaryTargetListeners_fn).call(this);
      __privateMethod(this, _CdpPage_instances, attachExistingTargets_fn).call(this);
    }
    static async _create(client2, target, defaultViewport) {
      var _a3;
      const page = new _CdpPage(client2, target);
      await __privateMethod(_a3 = page, _CdpPage_instances, initialize_fn).call(_a3);
      if (defaultViewport) {
        try {
          await page.setViewport(defaultViewport);
        } catch (err) {
          if (isErrorLike(err) && isTargetClosedError(err)) {
            debugError(err);
          } else {
            throw err;
          }
        }
      }
      return page;
    }
    _client() {
      return __privateGet(this, _primaryTargetClient);
    }
    isServiceWorkerBypassed() {
      return __privateGet(this, _serviceWorkerBypassed);
    }
    isDragInterceptionEnabled() {
      return __privateGet(this, _userDragInterceptionEnabled);
    }
    isJavaScriptEnabled() {
      return __privateGet(this, _emulationManager).javascriptEnabled;
    }
    async waitForFileChooser(options = {}) {
      const needsEnable = __privateGet(this, _fileChooserDeferreds).size === 0;
      const { timeout: timeout2 = this._timeoutSettings.timeout() } = options;
      const deferred = Deferred$1.create({
        message: `Waiting for \`FileChooser\` failed: ${timeout2}ms exceeded`,
        timeout: timeout2
      });
      if (options.signal) {
        options.signal.addEventListener("abort", () => {
          var _a3;
          deferred.reject((_a3 = options.signal) == null ? void 0 : _a3.reason);
        }, { once: true });
      }
      __privateGet(this, _fileChooserDeferreds).add(deferred);
      let enablePromise;
      if (needsEnable) {
        enablePromise = __privateGet(this, _primaryTargetClient).send("Page.setInterceptFileChooserDialog", {
          enabled: true
        });
      }
      try {
        const [result] = await Promise.all([
          deferred.valueOrThrow(),
          enablePromise
        ]);
        return result;
      } catch (error) {
        __privateGet(this, _fileChooserDeferreds).delete(deferred);
        throw error;
      }
    }
    async setGeolocation(options) {
      return await __privateGet(this, _emulationManager).setGeolocation(options);
    }
    target() {
      return __privateGet(this, _primaryTarget);
    }
    browser() {
      return __privateGet(this, _primaryTarget).browser();
    }
    browserContext() {
      return __privateGet(this, _primaryTarget).browserContext();
    }
    mainFrame() {
      return __privateGet(this, _frameManager2).mainFrame();
    }
    get keyboard() {
      return __privateGet(this, _keyboard4);
    }
    get touchscreen() {
      return __privateGet(this, _touchscreen);
    }
    get coverage() {
      return __privateGet(this, _coverage);
    }
    get tracing() {
      return __privateGet(this, _tracing);
    }
    frames() {
      return __privateGet(this, _frameManager2).frames();
    }
    workers() {
      return Array.from(__privateGet(this, _workers).values());
    }
    async setRequestInterception(value) {
      return await __privateGet(this, _frameManager2).networkManager.setRequestInterception(value);
    }
    async setBypassServiceWorker(bypass) {
      __privateSet(this, _serviceWorkerBypassed, bypass);
      return await __privateGet(this, _primaryTargetClient).send("Network.setBypassServiceWorker", { bypass });
    }
    async setDragInterception(enabled) {
      __privateSet(this, _userDragInterceptionEnabled, enabled);
      return await __privateGet(this, _primaryTargetClient).send("Input.setInterceptDrags", {
        enabled
      });
    }
    async setOfflineMode(enabled) {
      return await __privateGet(this, _frameManager2).networkManager.setOfflineMode(enabled);
    }
    async emulateNetworkConditions(networkConditions) {
      return await __privateGet(this, _frameManager2).networkManager.emulateNetworkConditions(networkConditions);
    }
    setDefaultNavigationTimeout(timeout2) {
      this._timeoutSettings.setDefaultNavigationTimeout(timeout2);
    }
    setDefaultTimeout(timeout2) {
      this._timeoutSettings.setDefaultTimeout(timeout2);
    }
    getDefaultTimeout() {
      return this._timeoutSettings.timeout();
    }
    getDefaultNavigationTimeout() {
      return this._timeoutSettings.navigationTimeout();
    }
    async queryObjects(prototypeHandle) {
      assert$1(!prototypeHandle.disposed, "Prototype JSHandle is disposed!");
      assert$1(prototypeHandle.id, "Prototype JSHandle must not be referencing primitive value");
      const response = await this.mainFrame().client.send("Runtime.queryObjects", {
        prototypeObjectId: prototypeHandle.id
      });
      return this.mainFrame().mainRealm().createCdpHandle(response.objects);
    }
    async cookies(...urls) {
      const originalCookies = (await __privateGet(this, _primaryTargetClient).send("Network.getCookies", {
        urls: urls.length ? urls : [this.url()]
      })).cookies;
      const unsupportedCookieAttributes = ["sourcePort"];
      const filterUnsupportedAttributes = (cookie) => {
        for (const attr of unsupportedCookieAttributes) {
          delete cookie[attr];
        }
        return cookie;
      };
      return originalCookies.map(filterUnsupportedAttributes).map((cookie) => {
        return {
          ...cookie,
          // TODO: a breaking change is needed in Puppeteer types to support other
          // partition keys.
          partitionKey: cookie.partitionKey ? cookie.partitionKey.topLevelSite : void 0
        };
      });
    }
    async deleteCookie(...cookies) {
      const pageURL = this.url();
      for (const cookie of cookies) {
        const item = {
          ...cookie,
          partitionKey: convertCookiesPartitionKeyFromPuppeteerToCdp(cookie.partitionKey)
        };
        if (!cookie.url && pageURL.startsWith("http")) {
          item.url = pageURL;
        }
        await __privateGet(this, _primaryTargetClient).send("Network.deleteCookies", item);
        if (pageURL.startsWith("http") && !item.partitionKey) {
          const url = new URL(pageURL);
          await __privateGet(this, _primaryTargetClient).send("Network.deleteCookies", {
            ...item,
            partitionKey: {
              topLevelSite: url.origin.replace(`:${url.port}`, ""),
              hasCrossSiteAncestor: false
            }
          });
        }
      }
    }
    async setCookie(...cookies) {
      const pageURL = this.url();
      const startsWithHTTP = pageURL.startsWith("http");
      const items = cookies.map((cookie) => {
        const item = Object.assign({}, cookie);
        if (!item.url && startsWithHTTP) {
          item.url = pageURL;
        }
        assert$1(item.url !== "about:blank", `Blank page can not have cookie "${item.name}"`);
        assert$1(!String.prototype.startsWith.call(item.url || "", "data:"), `Data URL page can not have cookie "${item.name}"`);
        return item;
      });
      await this.deleteCookie(...items);
      if (items.length) {
        await __privateGet(this, _primaryTargetClient).send("Network.setCookies", {
          cookies: items.map((cookieParam) => {
            return {
              ...cookieParam,
              partitionKey: convertCookiesPartitionKeyFromPuppeteerToCdp(cookieParam.partitionKey)
            };
          })
        });
      }
    }
    async exposeFunction(name, pptrFunction) {
      if (__privateGet(this, _bindings3).has(name)) {
        throw new Error(`Failed to add page binding with name ${name}: window['${name}'] already exists!`);
      }
      const source2 = pageBindingInitString("exposedFun", name);
      let binding;
      switch (typeof pptrFunction) {
        case "function":
          binding = new Binding(name, pptrFunction, source2);
          break;
        default:
          binding = new Binding(name, pptrFunction.default, source2);
          break;
      }
      __privateGet(this, _bindings3).set(name, binding);
      const [{ identifier }] = await Promise.all([
        __privateGet(this, _frameManager2).evaluateOnNewDocument(source2),
        __privateGet(this, _frameManager2).addExposedFunctionBinding(binding)
      ]);
      __privateGet(this, _exposedFunctions).set(name, identifier);
    }
    async removeExposedFunction(name) {
      const exposedFunctionId = __privateGet(this, _exposedFunctions).get(name);
      if (!exposedFunctionId) {
        throw new Error(`Function with name "${name}" does not exist`);
      }
      const binding = __privateGet(this, _bindings3).get(name);
      __privateGet(this, _exposedFunctions).delete(name);
      __privateGet(this, _bindings3).delete(name);
      await Promise.all([
        __privateGet(this, _frameManager2).removeScriptToEvaluateOnNewDocument(exposedFunctionId),
        __privateGet(this, _frameManager2).removeExposedFunctionBinding(binding)
      ]);
    }
    async authenticate(credentials) {
      return await __privateGet(this, _frameManager2).networkManager.authenticate(credentials);
    }
    async setExtraHTTPHeaders(headers) {
      return await __privateGet(this, _frameManager2).networkManager.setExtraHTTPHeaders(headers);
    }
    async setUserAgent(userAgent, userAgentMetadata) {
      return await __privateGet(this, _frameManager2).networkManager.setUserAgent(userAgent, userAgentMetadata);
    }
    async metrics() {
      const response = await __privateGet(this, _primaryTargetClient).send("Performance.getMetrics");
      return __privateMethod(this, _CdpPage_instances, buildMetricsObject_fn).call(this, response.metrics);
    }
    async reload(options) {
      const [result] = await Promise.all([
        this.waitForNavigation({
          ...options,
          ignoreSameDocumentNavigation: true
        }),
        __privateGet(this, _primaryTargetClient).send("Page.reload")
      ]);
      return result;
    }
    async createCDPSession() {
      return await this.target().createCDPSession();
    }
    async goBack(options = {}) {
      return await __privateMethod(this, _CdpPage_instances, go_fn).call(this, -1, options);
    }
    async goForward(options = {}) {
      return await __privateMethod(this, _CdpPage_instances, go_fn).call(this, 1, options);
    }
    async bringToFront() {
      await __privateGet(this, _primaryTargetClient).send("Page.bringToFront");
    }
    async setJavaScriptEnabled(enabled) {
      return await __privateGet(this, _emulationManager).setJavaScriptEnabled(enabled);
    }
    async setBypassCSP(enabled) {
      await __privateGet(this, _primaryTargetClient).send("Page.setBypassCSP", { enabled });
    }
    async emulateMediaType(type) {
      return await __privateGet(this, _emulationManager).emulateMediaType(type);
    }
    async emulateCPUThrottling(factor) {
      return await __privateGet(this, _emulationManager).emulateCPUThrottling(factor);
    }
    async emulateMediaFeatures(features) {
      return await __privateGet(this, _emulationManager).emulateMediaFeatures(features);
    }
    async emulateTimezone(timezoneId) {
      return await __privateGet(this, _emulationManager).emulateTimezone(timezoneId);
    }
    async emulateIdleState(overrides) {
      return await __privateGet(this, _emulationManager).emulateIdleState(overrides);
    }
    async emulateVisionDeficiency(type) {
      return await __privateGet(this, _emulationManager).emulateVisionDeficiency(type);
    }
    async setViewport(viewport) {
      const needsReload = await __privateGet(this, _emulationManager).emulateViewport(viewport);
      __privateSet(this, _viewport, viewport);
      if (needsReload) {
        await this.reload();
      }
    }
    viewport() {
      return __privateGet(this, _viewport);
    }
    async evaluateOnNewDocument(pageFunction, ...args) {
      const source2 = evaluationString(pageFunction, ...args);
      return await __privateGet(this, _frameManager2).evaluateOnNewDocument(source2);
    }
    async removeScriptToEvaluateOnNewDocument(identifier) {
      return await __privateGet(this, _frameManager2).removeScriptToEvaluateOnNewDocument(identifier);
    }
    async setCacheEnabled(enabled = true) {
      await __privateGet(this, _frameManager2).networkManager.setCacheEnabled(enabled);
    }
    async _screenshot(options) {
      const env_2 = { stack: [], error: void 0, hasError: false };
      try {
        const { fromSurface, omitBackground, optimizeForSpeed, quality, clip: userClip, type, captureBeyondViewport } = options;
        const stack = __addDisposableResource$7(env_2, new AsyncDisposableStack(), true);
        if (omitBackground && (type === "png" || type === "webp")) {
          await __privateGet(this, _emulationManager).setTransparentBackgroundColor();
          stack.defer(async () => {
            await __privateGet(this, _emulationManager).resetDefaultBackgroundColor().catch(debugError);
          });
        }
        let clip = userClip;
        if (clip && !captureBeyondViewport) {
          const viewport = await this.mainFrame().isolatedRealm().evaluate(() => {
            const { height, pageLeft: x, pageTop: y, width } = window.visualViewport;
            return { x, y, height, width };
          });
          clip = getIntersectionRect(clip, viewport);
        }
        const { data } = await __privateGet(this, _primaryTargetClient).send("Page.captureScreenshot", {
          format: type,
          optimizeForSpeed,
          fromSurface,
          ...quality !== void 0 ? { quality: Math.round(quality) } : {},
          ...clip ? { clip: { ...clip, scale: clip.scale ?? 1 } } : {},
          captureBeyondViewport
        });
        return data;
      } catch (e_2) {
        env_2.error = e_2;
        env_2.hasError = true;
      } finally {
        const result_1 = __disposeResources$7(env_2);
        if (result_1)
          await result_1;
      }
    }
    async createPDFStream(options = {}) {
      const { timeout: ms2 = this._timeoutSettings.timeout() } = options;
      const { landscape, displayHeaderFooter, headerTemplate, footerTemplate, printBackground, scale, width: paperWidth, height: paperHeight, margin, pageRanges, preferCSSPageSize, omitBackground, tagged: generateTaggedPDF, outline: generateDocumentOutline, waitForFonts } = parsePDFOptions(options);
      if (omitBackground) {
        await __privateGet(this, _emulationManager).setTransparentBackgroundColor();
      }
      if (waitForFonts) {
        await firstValueFrom(from(this.mainFrame().isolatedRealm().evaluate(() => {
          return document.fonts.ready;
        })).pipe(raceWith(timeout(ms2))));
      }
      const printCommandPromise = __privateGet(this, _primaryTargetClient).send("Page.printToPDF", {
        transferMode: "ReturnAsStream",
        landscape,
        displayHeaderFooter,
        headerTemplate,
        footerTemplate,
        printBackground,
        scale,
        paperWidth,
        paperHeight,
        marginTop: margin.top,
        marginBottom: margin.bottom,
        marginLeft: margin.left,
        marginRight: margin.right,
        pageRanges,
        preferCSSPageSize,
        generateTaggedPDF,
        generateDocumentOutline
      });
      const result = await firstValueFrom(from(printCommandPromise).pipe(raceWith(timeout(ms2))));
      if (omitBackground) {
        await __privateGet(this, _emulationManager).resetDefaultBackgroundColor();
      }
      assert$1(result.stream, "`stream` is missing from `Page.printToPDF");
      return await getReadableFromProtocolStream(__privateGet(this, _primaryTargetClient), result.stream);
    }
    async pdf(options = {}) {
      const { path = void 0 } = options;
      const readable = await this.createPDFStream(options);
      const typedArray = await getReadableAsTypedArray(readable, path);
      assert$1(typedArray, "Could not create typed array");
      return typedArray;
    }
    async close(options = { runBeforeUnload: void 0 }) {
      const env_3 = { stack: [], error: void 0, hasError: false };
      try {
        const _guard = __addDisposableResource$7(env_3, await this.browserContext().waitForScreenshotOperations(), false);
        const connection = __privateGet(this, _primaryTargetClient).connection();
        assert$1(connection, "Protocol error: Connection closed. Most likely the page has been closed.");
        const runBeforeUnload = !!options.runBeforeUnload;
        if (runBeforeUnload) {
          await __privateGet(this, _primaryTargetClient).send("Page.close");
        } else {
          await connection.send("Target.closeTarget", {
            targetId: __privateGet(this, _primaryTarget)._targetId
          });
          await __privateGet(this, _tabTarget)._isClosedDeferred.valueOrThrow();
        }
      } catch (e_3) {
        env_3.error = e_3;
        env_3.hasError = true;
      } finally {
        __disposeResources$7(env_3);
      }
    }
    isClosed() {
      return __privateGet(this, _closed2);
    }
    get mouse() {
      return __privateGet(this, _mouse);
    }
    /**
     * This method is typically coupled with an action that triggers a device
     * request from an api such as WebBluetooth.
     *
     * :::caution
     *
     * This must be called before the device request is made. It will not return a
     * currently active device prompt.
     *
     * :::
     *
     * @example
     *
     * ```ts
     * const [devicePrompt] = Promise.all([
     *   page.waitForDevicePrompt(),
     *   page.click('#connect-bluetooth'),
     * ]);
     * await devicePrompt.select(
     *   await devicePrompt.waitForDevice(({name}) => name.includes('My Device')),
     * );
     * ```
     */
    async waitForDevicePrompt(options = {}) {
      return await this.mainFrame().waitForDevicePrompt(options);
    }
  };
  _closed2 = new WeakMap();
  _targetManager = new WeakMap();
  _primaryTargetClient = new WeakMap();
  _primaryTarget = new WeakMap();
  _tabTargetClient = new WeakMap();
  _tabTarget = new WeakMap();
  _keyboard4 = new WeakMap();
  _mouse = new WeakMap();
  _touchscreen = new WeakMap();
  _frameManager2 = new WeakMap();
  _emulationManager = new WeakMap();
  _tracing = new WeakMap();
  _bindings3 = new WeakMap();
  _exposedFunctions = new WeakMap();
  _coverage = new WeakMap();
  _viewport = new WeakMap();
  _workers = new WeakMap();
  _fileChooserDeferreds = new WeakMap();
  _sessionCloseDeferred = new WeakMap();
  _serviceWorkerBypassed = new WeakMap();
  _userDragInterceptionEnabled = new WeakMap();
  _CdpPage_instances = new WeakSet();
  attachExistingTargets_fn = function() {
    const queue2 = [];
    for (const childTarget of __privateGet(this, _targetManager).getChildTargets(__privateGet(this, _primaryTarget))) {
      queue2.push(childTarget);
    }
    let idx = 0;
    while (idx < queue2.length) {
      const next = queue2[idx];
      idx++;
      const session = next._session();
      if (session) {
        __privateGet(this, _onAttachedToTarget).call(this, session);
      }
      for (const childTarget of __privateGet(this, _targetManager).getChildTargets(next)) {
        queue2.push(childTarget);
      }
    }
  };
  onActivation_fn = async function(newSession) {
    __privateSet(this, _primaryTargetClient, newSession);
    assert$1(__privateGet(this, _primaryTargetClient) instanceof CdpCDPSession, "CDPSession is not instance of CDPSessionImpl");
    __privateSet(this, _primaryTarget, __privateGet(this, _primaryTargetClient)._target());
    assert$1(__privateGet(this, _primaryTarget), "Missing target on swap");
    __privateGet(this, _keyboard4).updateClient(newSession);
    __privateGet(this, _mouse).updateClient(newSession);
    __privateGet(this, _touchscreen).updateClient(newSession);
    __privateGet(this, _emulationManager).updateClient(newSession);
    __privateGet(this, _tracing).updateClient(newSession);
    __privateGet(this, _coverage).updateClient(newSession);
    await __privateGet(this, _frameManager2).swapFrameTree(newSession);
    __privateMethod(this, _CdpPage_instances, setupPrimaryTargetListeners_fn).call(this);
  };
  onSecondaryTarget_fn = async function(session) {
    assert$1(session instanceof CdpCDPSession);
    if (session._target()._subtype() !== "prerender") {
      return;
    }
    __privateGet(this, _frameManager2).registerSpeculativeSession(session).catch(debugError);
    __privateGet(this, _emulationManager).registerSpeculativeSession(session).catch(debugError);
  };
  /**
   * Sets up listeners for the primary target. The primary target can change
   * during a navigation to a prerended page.
   */
  setupPrimaryTargetListeners_fn = function() {
    const clientEmitter = new EventEmitter$1(__privateGet(this, _primaryTargetClient));
    clientEmitter.on(CDPSessionEvent.Ready, __privateGet(this, _onAttachedToTarget));
    clientEmitter.on(CDPSessionEvent.Disconnected, () => {
      __privateGet(this, _sessionCloseDeferred).reject(new TargetCloseError("Target closed"));
    });
    clientEmitter.on("Page.domContentEventFired", () => {
      this.emit("domcontentloaded", void 0);
    });
    clientEmitter.on("Page.loadEventFired", () => {
      this.emit("load", void 0);
    });
    clientEmitter.on("Page.javascriptDialogOpening", __privateMethod(this, _CdpPage_instances, onDialog_fn).bind(this));
    clientEmitter.on("Runtime.exceptionThrown", __privateMethod(this, _CdpPage_instances, handleException_fn).bind(this));
    clientEmitter.on("Inspector.targetCrashed", __privateMethod(this, _CdpPage_instances, onTargetCrashed_fn).bind(this));
    clientEmitter.on("Performance.metrics", __privateMethod(this, _CdpPage_instances, emitMetrics_fn).bind(this));
    clientEmitter.on("Log.entryAdded", __privateMethod(this, _CdpPage_instances, onLogEntryAdded_fn).bind(this));
    clientEmitter.on("Page.fileChooserOpened", __privateMethod(this, _CdpPage_instances, onFileChooser_fn).bind(this));
  };
  _onDetachedFromTarget = new WeakMap();
  _onAttachedToTarget = new WeakMap();
  initialize_fn = async function() {
    try {
      await Promise.all([
        __privateGet(this, _frameManager2).initialize(__privateGet(this, _primaryTargetClient)),
        __privateGet(this, _primaryTargetClient).send("Performance.enable"),
        __privateGet(this, _primaryTargetClient).send("Log.enable")
      ]);
    } catch (err) {
      if (isErrorLike(err) && isTargetClosedError(err)) {
        debugError(err);
      } else {
        throw err;
      }
    }
  };
  onFileChooser_fn = async function(event) {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
      if (!__privateGet(this, _fileChooserDeferreds).size) {
        return;
      }
      const frame = __privateGet(this, _frameManager2).frame(event.frameId);
      assert$1(frame, "This should never happen.");
      const handle = __addDisposableResource$7(env_1, await frame.worlds[MAIN_WORLD].adoptBackendNode(event.backendNodeId), false);
      const fileChooser = new FileChooser(handle.move(), event);
      for (const promise of __privateGet(this, _fileChooserDeferreds)) {
        promise.resolve(fileChooser);
      }
      __privateGet(this, _fileChooserDeferreds).clear();
    } catch (e_1) {
      env_1.error = e_1;
      env_1.hasError = true;
    } finally {
      __disposeResources$7(env_1);
    }
  };
  onTargetCrashed_fn = function() {
    this.emit("error", new Error("Page crashed!"));
  };
  onLogEntryAdded_fn = function(event) {
    const { level, text, args, source: source2, url, lineNumber } = event.entry;
    if (args) {
      args.map((arg) => {
        void releaseObject(__privateGet(this, _primaryTargetClient), arg);
      });
    }
    if (source2 !== "worker") {
      this.emit("console", new ConsoleMessage(convertConsoleMessageLevel$1(level), text, [], [{ url, lineNumber }]));
    }
  };
  emitMetrics_fn = function(event) {
    this.emit("metrics", {
      title: event.title,
      metrics: __privateMethod(this, _CdpPage_instances, buildMetricsObject_fn).call(this, event.metrics)
    });
  };
  buildMetricsObject_fn = function(metrics) {
    const result = {};
    for (const metric of metrics || []) {
      if (supportedMetrics.has(metric.name)) {
        result[metric.name] = metric.value;
      }
    }
    return result;
  };
  handleException_fn = function(exception) {
    this.emit("pageerror", createClientError(exception.exceptionDetails));
  };
  onConsoleAPI_fn2 = function(world, event) {
    const values = event.args.map((arg) => {
      return world.createCdpHandle(arg);
    });
    __privateMethod(this, _CdpPage_instances, addConsoleMessage_fn).call(this, convertConsoleMessageLevel$1(event.type), values, event.stackTrace);
  };
  onBindingCalled_fn2 = async function(world, event) {
    let payload;
    try {
      payload = JSON.parse(event.payload);
    } catch {
      return;
    }
    const { type, name, seq, args, isTrivial } = payload;
    if (type !== "exposedFun") {
      return;
    }
    const context = world.context;
    if (!context) {
      return;
    }
    const binding = __privateGet(this, _bindings3).get(name);
    await (binding == null ? void 0 : binding.run(context, seq, args, isTrivial));
  };
  addConsoleMessage_fn = function(eventType, args, stackTrace) {
    if (!this.listenerCount(
      "console"
      /* PageEvent.Console */
    )) {
      args.forEach((arg) => {
        return arg.dispose();
      });
      return;
    }
    const textTokens = [];
    for (const arg of args) {
      const remoteObject = arg.remoteObject();
      if (remoteObject.objectId) {
        textTokens.push(arg.toString());
      } else {
        textTokens.push(valueFromRemoteObject(remoteObject));
      }
    }
    const stackTraceLocations = [];
    if (stackTrace) {
      for (const callFrame of stackTrace.callFrames) {
        stackTraceLocations.push({
          url: callFrame.url,
          lineNumber: callFrame.lineNumber,
          columnNumber: callFrame.columnNumber
        });
      }
    }
    const message = new ConsoleMessage(convertConsoleMessageLevel$1(eventType), textTokens.join(" "), args, stackTraceLocations);
    this.emit("console", message);
  };
  onDialog_fn = function(event) {
    const type = validateDialogType(event.type);
    const dialog = new CdpDialog(__privateGet(this, _primaryTargetClient), type, event.message, event.defaultPrompt);
    this.emit("dialog", dialog);
  };
  go_fn = async function(delta, options) {
    const history = await __privateGet(this, _primaryTargetClient).send("Page.getNavigationHistory");
    const entry = history.entries[history.currentIndex + delta];
    if (!entry) {
      return null;
    }
    const result = await Promise.all([
      this.waitForNavigation(options),
      __privateGet(this, _primaryTargetClient).send("Page.navigateToHistoryEntry", {
        entryId: entry.id
      })
    ]);
    return result[0];
  };
  let CdpPage = _CdpPage;
  const supportedMetrics = /* @__PURE__ */ new Set([
    "Timestamp",
    "Documents",
    "Frames",
    "JSEventListeners",
    "Nodes",
    "LayoutCount",
    "RecalcStyleCount",
    "LayoutDuration",
    "RecalcStyleDuration",
    "ScriptDuration",
    "TaskDuration",
    "JSHeapUsedSize",
    "JSHeapTotalSize"
  ]);
  function getIntersectionRect(clip, viewport) {
    const x = Math.max(clip.x, viewport.x);
    const y = Math.max(clip.y, viewport.y);
    return {
      x,
      y,
      width: Math.max(Math.min(clip.x + clip.width, viewport.x + viewport.width) - x, 0),
      height: Math.max(Math.min(clip.y + clip.height, viewport.y + viewport.height) - y, 0)
    };
  }
  function convertCookiesPartitionKeyFromPuppeteerToCdp(partitionKey) {
    if (partitionKey === void 0) {
      return void 0;
    }
    if (typeof partitionKey === "string") {
      return {
        topLevelSite: partitionKey,
        hasCrossSiteAncestor: false
      };
    }
    return {
      topLevelSite: partitionKey.sourceOrigin,
      hasCrossSiteAncestor: partitionKey.hasCrossSiteAncestor ?? false
    };
  }
  /**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var __addDisposableResource$6 = function(env, value, async2) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async2) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async2) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({ value, dispose, async: async2 });
    } else if (async2) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources$6 = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  class CdpBrowserContext extends BrowserContext$1 {
    constructor(connection, browser2, contextId) {
      super();
      __privateAdd(this, _connection2);
      __privateAdd(this, _browser);
      __privateAdd(this, _id6);
      __privateSet(this, _connection2, connection);
      __privateSet(this, _browser, browser2);
      __privateSet(this, _id6, contextId);
    }
    get id() {
      return __privateGet(this, _id6);
    }
    targets() {
      return __privateGet(this, _browser).targets().filter((target) => {
        return target.browserContext() === this;
      });
    }
    async pages() {
      const pages = await Promise.all(this.targets().filter((target) => {
        var _a3;
        return target.type() === "page" || target.type() === "other" && ((_a3 = __privateGet(this, _browser)._getIsPageTargetCallback()) == null ? void 0 : _a3(target));
      }).map((target) => {
        return target.page();
      }));
      return pages.filter((page) => {
        return !!page;
      });
    }
    async overridePermissions(origin, permissions) {
      const protocolPermissions = permissions.map((permission) => {
        const protocolPermission = WEB_PERMISSION_TO_PROTOCOL_PERMISSION.get(permission);
        if (!protocolPermission) {
          throw new Error("Unknown permission: " + permission);
        }
        return protocolPermission;
      });
      await __privateGet(this, _connection2).send("Browser.grantPermissions", {
        origin,
        browserContextId: __privateGet(this, _id6) || void 0,
        permissions: protocolPermissions
      });
    }
    async clearPermissionOverrides() {
      await __privateGet(this, _connection2).send("Browser.resetPermissions", {
        browserContextId: __privateGet(this, _id6) || void 0
      });
    }
    async newPage() {
      const env_1 = { stack: [], error: void 0, hasError: false };
      try {
        const _guard = __addDisposableResource$6(env_1, await this.waitForScreenshotOperations(), false);
        return await __privateGet(this, _browser)._createPageInContext(__privateGet(this, _id6));
      } catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
      } finally {
        __disposeResources$6(env_1);
      }
    }
    browser() {
      return __privateGet(this, _browser);
    }
    async close() {
      assert$1(__privateGet(this, _id6), "Default BrowserContext cannot be closed!");
      await __privateGet(this, _browser)._disposeContext(__privateGet(this, _id6));
    }
    async cookies() {
      const { cookies } = await __privateGet(this, _connection2).send("Storage.getCookies", {
        browserContextId: __privateGet(this, _id6)
      });
      return cookies.map((cookie) => {
        return {
          ...cookie,
          partitionKey: cookie.partitionKey ? {
            sourceOrigin: cookie.partitionKey.topLevelSite,
            hasCrossSiteAncestor: cookie.partitionKey.hasCrossSiteAncestor
          } : void 0
        };
      });
    }
    async setCookie(...cookies) {
      return await __privateGet(this, _connection2).send("Storage.setCookies", {
        browserContextId: __privateGet(this, _id6),
        cookies: cookies.map((cookie) => {
          return {
            ...cookie,
            partitionKey: convertCookiesPartitionKeyFromPuppeteerToCdp(cookie.partitionKey)
          };
        })
      });
    }
    async setDownloadBehavior(downloadBehavior) {
      await __privateGet(this, _connection2).send("Browser.setDownloadBehavior", {
        behavior: downloadBehavior.policy,
        downloadPath: downloadBehavior.downloadPath,
        browserContextId: __privateGet(this, _id6)
      });
    }
  }
  _connection2 = new WeakMap();
  _browser = new WeakMap();
  _id6 = new WeakMap();
  /**
   * @license
   * Copyright 2019 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var InitializationStatus;
  (function(InitializationStatus2) {
    InitializationStatus2["SUCCESS"] = "success";
    InitializationStatus2["ABORTED"] = "aborted";
  })(InitializationStatus || (InitializationStatus = {}));
  let CdpTarget$1 = (_k = class extends Target {
    /**
     * To initialize the target for use, call initialize.
     *
     * @internal
     */
    constructor(targetInfo, session, browserContext2, targetManager, sessionFactory) {
      super();
      __privateAdd(this, _browserContext);
      __privateAdd(this, _session);
      __privateAdd(this, _targetInfo);
      __privateAdd(this, _targetManager2);
      __privateAdd(this, _sessionFactory);
      __privateAdd(this, _childTargets, /* @__PURE__ */ new Set());
      __publicField(this, "_initializedDeferred", Deferred$1.create());
      __publicField(this, "_isClosedDeferred", Deferred$1.create());
      __publicField(this, "_targetId");
      __privateSet(this, _session, session);
      __privateSet(this, _targetManager2, targetManager);
      __privateSet(this, _targetInfo, targetInfo);
      __privateSet(this, _browserContext, browserContext2);
      this._targetId = targetInfo.targetId;
      __privateSet(this, _sessionFactory, sessionFactory);
      if (__privateGet(this, _session) && __privateGet(this, _session) instanceof CdpCDPSession) {
        __privateGet(this, _session)._setTarget(this);
      }
    }
    async asPage() {
      const session = this._session();
      if (!session) {
        return await this.createCDPSession().then((client2) => {
          return CdpPage._create(client2, this, null);
        });
      }
      return await CdpPage._create(session, this, null);
    }
    _subtype() {
      return __privateGet(this, _targetInfo).subtype;
    }
    _session() {
      return __privateGet(this, _session);
    }
    _addChildTarget(target) {
      __privateGet(this, _childTargets).add(target);
    }
    _removeChildTarget(target) {
      __privateGet(this, _childTargets).delete(target);
    }
    _childTargets() {
      return __privateGet(this, _childTargets);
    }
    _sessionFactory() {
      if (!__privateGet(this, _sessionFactory)) {
        throw new Error("sessionFactory is not initialized");
      }
      return __privateGet(this, _sessionFactory);
    }
    createCDPSession() {
      if (!__privateGet(this, _sessionFactory)) {
        throw new Error("sessionFactory is not initialized");
      }
      return __privateGet(this, _sessionFactory).call(this, false).then((session) => {
        session._setTarget(this);
        return session;
      });
    }
    url() {
      return __privateGet(this, _targetInfo).url;
    }
    type() {
      const type = __privateGet(this, _targetInfo).type;
      switch (type) {
        case "page":
          return TargetType.PAGE;
        case "background_page":
          return TargetType.BACKGROUND_PAGE;
        case "service_worker":
          return TargetType.SERVICE_WORKER;
        case "shared_worker":
          return TargetType.SHARED_WORKER;
        case "browser":
          return TargetType.BROWSER;
        case "webview":
          return TargetType.WEBVIEW;
        case "tab":
          return TargetType.TAB;
        default:
          return TargetType.OTHER;
      }
    }
    _targetManager() {
      if (!__privateGet(this, _targetManager2)) {
        throw new Error("targetManager is not initialized");
      }
      return __privateGet(this, _targetManager2);
    }
    _getTargetInfo() {
      return __privateGet(this, _targetInfo);
    }
    browser() {
      if (!__privateGet(this, _browserContext)) {
        throw new Error("browserContext is not initialized");
      }
      return __privateGet(this, _browserContext).browser();
    }
    browserContext() {
      if (!__privateGet(this, _browserContext)) {
        throw new Error("browserContext is not initialized");
      }
      return __privateGet(this, _browserContext);
    }
    opener() {
      const { openerId } = __privateGet(this, _targetInfo);
      if (!openerId) {
        return;
      }
      return this.browser().targets().find((target) => {
        return target._targetId === openerId;
      });
    }
    _targetInfoChanged(targetInfo) {
      __privateSet(this, _targetInfo, targetInfo);
      this._checkIfInitialized();
    }
    _initialize() {
      this._initializedDeferred.resolve(InitializationStatus.SUCCESS);
    }
    _isTargetExposed() {
      return this.type() !== TargetType.TAB && !this._subtype();
    }
    _checkIfInitialized() {
      if (!this._initializedDeferred.resolved()) {
        this._initializedDeferred.resolve(InitializationStatus.SUCCESS);
      }
    }
  }, _browserContext = new WeakMap(), _session = new WeakMap(), _targetInfo = new WeakMap(), _targetManager2 = new WeakMap(), _sessionFactory = new WeakMap(), _childTargets = new WeakMap(), _k);
  const _PageTarget = class _PageTarget extends CdpTarget$1 {
    constructor(targetInfo, session, browserContext2, targetManager, sessionFactory, defaultViewport) {
      super(targetInfo, session, browserContext2, targetManager, sessionFactory);
      __privateAdd(this, _defaultViewport);
      __publicField(this, "pagePromise");
      __privateSet(this, _defaultViewport, defaultViewport ?? void 0);
    }
    _initialize() {
      this._initializedDeferred.valueOrThrow().then(async (result) => {
        if (result === InitializationStatus.ABORTED) {
          return;
        }
        const opener = this.opener();
        if (!(opener instanceof _PageTarget)) {
          return;
        }
        if (!opener || !opener.pagePromise || this.type() !== "page") {
          return true;
        }
        const openerPage = await opener.pagePromise;
        if (!openerPage.listenerCount(
          "popup"
          /* PageEvent.Popup */
        )) {
          return true;
        }
        const popupPage = await this.page();
        openerPage.emit("popup", popupPage);
        return true;
      }).catch(debugError);
      this._checkIfInitialized();
    }
    async page() {
      if (!this.pagePromise) {
        const session = this._session();
        this.pagePromise = (session ? Promise.resolve(session) : this._sessionFactory()(
          /* isAutoAttachEmulated=*/
          false
        )).then((client2) => {
          return CdpPage._create(client2, this, __privateGet(this, _defaultViewport) ?? null);
        });
      }
      return await this.pagePromise ?? null;
    }
    _checkIfInitialized() {
      if (this._initializedDeferred.resolved()) {
        return;
      }
      if (this._getTargetInfo().url !== "") {
        this._initializedDeferred.resolve(InitializationStatus.SUCCESS);
      }
    }
  };
  _defaultViewport = new WeakMap();
  let PageTarget = _PageTarget;
  class DevToolsTarget extends PageTarget {
  }
  class WorkerTarget extends CdpTarget$1 {
    constructor() {
      super(...arguments);
      __privateAdd(this, _workerPromise);
    }
    async worker() {
      if (!__privateGet(this, _workerPromise)) {
        const session = this._session();
        __privateSet(this, _workerPromise, (session ? Promise.resolve(session) : this._sessionFactory()(
          /* isAutoAttachEmulated=*/
          false
        )).then((client2) => {
          return new CdpWebWorker(
            client2,
            this._getTargetInfo().url,
            this._targetId,
            this.type(),
            () => {
            },
            () => {
            }
            /* exceptionThrown */
          );
        }));
      }
      return await __privateGet(this, _workerPromise);
    }
  }
  _workerPromise = new WeakMap();
  class OtherTarget extends CdpTarget$1 {
  }
  /**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  function isPageTargetBecomingPrimary(target, newTargetInfo) {
    return Boolean(target._subtype()) && !newTargetInfo.subtype;
  }
  class TargetManager extends EventEmitter$1 {
    constructor(connection, targetFactory, targetFilterCallback, waitForInitiallyDiscoveredTargets = true) {
      super();
      __privateAdd(this, _TargetManager_instances);
      __privateAdd(this, _connection3);
      /**
       * Keeps track of the following events: 'Target.targetCreated',
       * 'Target.targetDestroyed', 'Target.targetInfoChanged'.
       *
       * A target becomes discovered when 'Target.targetCreated' is received.
       * A target is removed from this map once 'Target.targetDestroyed' is
       * received.
       *
       * `targetFilterCallback` has no effect on this map.
       */
      __privateAdd(this, _discoveredTargetsByTargetId, /* @__PURE__ */ new Map());
      /**
       * A target is added to this map once TargetManager has created
       * a Target and attached at least once to it.
       */
      __privateAdd(this, _attachedTargetsByTargetId, /* @__PURE__ */ new Map());
      /**
       * Tracks which sessions attach to which target.
       */
      __privateAdd(this, _attachedTargetsBySessionId, /* @__PURE__ */ new Map());
      /**
       * If a target was filtered out by `targetFilterCallback`, we still receive
       * events about it from CDP, but we don't forward them to the rest of Puppeteer.
       */
      __privateAdd(this, _ignoredTargets, /* @__PURE__ */ new Set());
      __privateAdd(this, _targetFilterCallback);
      __privateAdd(this, _targetFactory);
      __privateAdd(this, _attachedToTargetListenersBySession, /* @__PURE__ */ new WeakMap());
      __privateAdd(this, _detachedFromTargetListenersBySession, /* @__PURE__ */ new WeakMap());
      __privateAdd(this, _initializeDeferred, Deferred$1.create());
      __privateAdd(this, _targetsIdsForInit, /* @__PURE__ */ new Set());
      __privateAdd(this, _waitForInitiallyDiscoveredTargets, true);
      __privateAdd(this, _discoveryFilter, [{}]);
      __privateAdd(this, _storeExistingTargetsForInit, () => {
        if (!__privateGet(this, _waitForInitiallyDiscoveredTargets)) {
          return;
        }
        for (const [targetId, targetInfo] of __privateGet(this, _discoveredTargetsByTargetId).entries()) {
          const targetForFilter = new CdpTarget$1(targetInfo, void 0, void 0, this, void 0);
          const isPageOrFrame = targetInfo.type === "page" || targetInfo.type === "iframe";
          const isExtension = targetInfo.url.startsWith("chrome-extension://");
          if ((!__privateGet(this, _targetFilterCallback) || __privateGet(this, _targetFilterCallback).call(this, targetForFilter)) && isPageOrFrame && !isExtension) {
            __privateGet(this, _targetsIdsForInit).add(targetId);
          }
        }
      });
      __privateAdd(this, _onSessionDetached, (session) => {
        __privateMethod(this, _TargetManager_instances, removeAttachmentListeners_fn).call(this, session);
      });
      __privateAdd(this, _onTargetCreated, async (event) => {
        __privateGet(this, _discoveredTargetsByTargetId).set(event.targetInfo.targetId, event.targetInfo);
        this.emit("targetDiscovered", event.targetInfo);
        if (event.targetInfo.type === "browser" && event.targetInfo.attached) {
          if (__privateGet(this, _attachedTargetsByTargetId).has(event.targetInfo.targetId)) {
            return;
          }
          const target = __privateGet(this, _targetFactory).call(this, event.targetInfo, void 0);
          target._initialize();
          __privateGet(this, _attachedTargetsByTargetId).set(event.targetInfo.targetId, target);
        }
      });
      __privateAdd(this, _onTargetDestroyed, (event) => {
        const targetInfo = __privateGet(this, _discoveredTargetsByTargetId).get(event.targetId);
        __privateGet(this, _discoveredTargetsByTargetId).delete(event.targetId);
        __privateMethod(this, _TargetManager_instances, finishInitializationIfReady_fn).call(this, event.targetId);
        if ((targetInfo == null ? void 0 : targetInfo.type) === "service_worker" && __privateGet(this, _attachedTargetsByTargetId).has(event.targetId)) {
          const target = __privateGet(this, _attachedTargetsByTargetId).get(event.targetId);
          if (target) {
            this.emit("targetGone", target);
            __privateGet(this, _attachedTargetsByTargetId).delete(event.targetId);
          }
        }
      });
      __privateAdd(this, _onTargetInfoChanged, (event) => {
        var _a3;
        __privateGet(this, _discoveredTargetsByTargetId).set(event.targetInfo.targetId, event.targetInfo);
        if (__privateGet(this, _ignoredTargets).has(event.targetInfo.targetId) || !__privateGet(this, _attachedTargetsByTargetId).has(event.targetInfo.targetId) || !event.targetInfo.attached) {
          return;
        }
        const target = __privateGet(this, _attachedTargetsByTargetId).get(event.targetInfo.targetId);
        if (!target) {
          return;
        }
        const previousURL = target.url();
        const wasInitialized = target._initializedDeferred.value() === InitializationStatus.SUCCESS;
        if (isPageTargetBecomingPrimary(target, event.targetInfo)) {
          const session = target == null ? void 0 : target._session();
          assert$1(session, "Target that is being activated is missing a CDPSession.");
          (_a3 = session.parentSession()) == null ? void 0 : _a3.emit(CDPSessionEvent.Swapped, session);
        }
        target._targetInfoChanged(event.targetInfo);
        if (wasInitialized && previousURL !== target.url()) {
          this.emit("targetChanged", {
            target,
            wasInitialized,
            previousURL
          });
        }
      });
      __privateAdd(this, _onAttachedToTarget2, async (parentSession, event) => {
        const targetInfo = event.targetInfo;
        const session = __privateGet(this, _connection3).session(event.sessionId);
        if (!session) {
          throw new Error(`Session ${event.sessionId} was not created.`);
        }
        const silentDetach = async () => {
          await session.send("Runtime.runIfWaitingForDebugger").catch(debugError);
          await parentSession.send("Target.detachFromTarget", {
            sessionId: session.id()
          }).catch(debugError);
        };
        if (!__privateGet(this, _connection3).isAutoAttached(targetInfo.targetId)) {
          return;
        }
        if (targetInfo.type === "service_worker") {
          __privateMethod(this, _TargetManager_instances, finishInitializationIfReady_fn).call(this, targetInfo.targetId);
          await silentDetach();
          if (__privateGet(this, _attachedTargetsByTargetId).has(targetInfo.targetId)) {
            return;
          }
          const target2 = __privateGet(this, _targetFactory).call(this, targetInfo);
          target2._initialize();
          __privateGet(this, _attachedTargetsByTargetId).set(targetInfo.targetId, target2);
          this.emit("targetAvailable", target2);
          return;
        }
        const isExistingTarget = __privateGet(this, _attachedTargetsByTargetId).has(targetInfo.targetId);
        const target = isExistingTarget ? __privateGet(this, _attachedTargetsByTargetId).get(targetInfo.targetId) : __privateGet(this, _targetFactory).call(this, targetInfo, session, parentSession instanceof CDPSession ? parentSession : void 0);
        if (__privateGet(this, _targetFilterCallback) && !__privateGet(this, _targetFilterCallback).call(this, target)) {
          __privateGet(this, _ignoredTargets).add(targetInfo.targetId);
          __privateMethod(this, _TargetManager_instances, finishInitializationIfReady_fn).call(this, targetInfo.targetId);
          await silentDetach();
          return;
        }
        __privateMethod(this, _TargetManager_instances, setupAttachmentListeners_fn).call(this, session);
        if (isExistingTarget) {
          session._setTarget(target);
          __privateGet(this, _attachedTargetsBySessionId).set(session.id(), __privateGet(this, _attachedTargetsByTargetId).get(targetInfo.targetId));
        } else {
          target._initialize();
          __privateGet(this, _attachedTargetsByTargetId).set(targetInfo.targetId, target);
          __privateGet(this, _attachedTargetsBySessionId).set(session.id(), target);
        }
        const parentTarget = parentSession instanceof CDPSession ? parentSession._target() : null;
        parentTarget == null ? void 0 : parentTarget._addChildTarget(target);
        parentSession.emit(CDPSessionEvent.Ready, session);
        __privateGet(this, _targetsIdsForInit).delete(target._targetId);
        if (!isExistingTarget) {
          this.emit("targetAvailable", target);
        }
        __privateMethod(this, _TargetManager_instances, finishInitializationIfReady_fn).call(this);
        await Promise.all([
          session.send("Target.setAutoAttach", {
            waitForDebuggerOnStart: true,
            flatten: true,
            autoAttach: true,
            filter: __privateGet(this, _discoveryFilter)
          }),
          session.send("Runtime.runIfWaitingForDebugger")
        ]).catch(debugError);
      });
      __privateAdd(this, _onDetachedFromTarget2, (parentSession, event) => {
        const target = __privateGet(this, _attachedTargetsBySessionId).get(event.sessionId);
        __privateGet(this, _attachedTargetsBySessionId).delete(event.sessionId);
        if (!target) {
          return;
        }
        if (parentSession instanceof CDPSession) {
          parentSession._target()._removeChildTarget(target);
        }
        __privateGet(this, _attachedTargetsByTargetId).delete(target._targetId);
        this.emit("targetGone", target);
      });
      __privateSet(this, _connection3, connection);
      __privateSet(this, _targetFilterCallback, targetFilterCallback);
      __privateSet(this, _targetFactory, targetFactory);
      __privateSet(this, _waitForInitiallyDiscoveredTargets, waitForInitiallyDiscoveredTargets);
      __privateGet(this, _connection3).on("Target.targetCreated", __privateGet(this, _onTargetCreated));
      __privateGet(this, _connection3).on("Target.targetDestroyed", __privateGet(this, _onTargetDestroyed));
      __privateGet(this, _connection3).on("Target.targetInfoChanged", __privateGet(this, _onTargetInfoChanged));
      __privateGet(this, _connection3).on(CDPSessionEvent.SessionDetached, __privateGet(this, _onSessionDetached));
      __privateMethod(this, _TargetManager_instances, setupAttachmentListeners_fn).call(this, __privateGet(this, _connection3));
    }
    async initialize() {
      await __privateGet(this, _connection3).send("Target.setDiscoverTargets", {
        discover: true,
        filter: __privateGet(this, _discoveryFilter)
      });
      __privateGet(this, _storeExistingTargetsForInit).call(this);
      await __privateGet(this, _connection3).send("Target.setAutoAttach", {
        waitForDebuggerOnStart: true,
        flatten: true,
        autoAttach: true,
        filter: [
          {
            type: "page",
            exclude: true
          },
          ...__privateGet(this, _discoveryFilter)
        ]
      });
      __privateMethod(this, _TargetManager_instances, finishInitializationIfReady_fn).call(this);
      await __privateGet(this, _initializeDeferred).valueOrThrow();
    }
    getChildTargets(target) {
      return target._childTargets();
    }
    dispose() {
      __privateGet(this, _connection3).off("Target.targetCreated", __privateGet(this, _onTargetCreated));
      __privateGet(this, _connection3).off("Target.targetDestroyed", __privateGet(this, _onTargetDestroyed));
      __privateGet(this, _connection3).off("Target.targetInfoChanged", __privateGet(this, _onTargetInfoChanged));
      __privateGet(this, _connection3).off(CDPSessionEvent.SessionDetached, __privateGet(this, _onSessionDetached));
      __privateMethod(this, _TargetManager_instances, removeAttachmentListeners_fn).call(this, __privateGet(this, _connection3));
    }
    getAvailableTargets() {
      return __privateGet(this, _attachedTargetsByTargetId);
    }
  }
  _connection3 = new WeakMap();
  _discoveredTargetsByTargetId = new WeakMap();
  _attachedTargetsByTargetId = new WeakMap();
  _attachedTargetsBySessionId = new WeakMap();
  _ignoredTargets = new WeakMap();
  _targetFilterCallback = new WeakMap();
  _targetFactory = new WeakMap();
  _attachedToTargetListenersBySession = new WeakMap();
  _detachedFromTargetListenersBySession = new WeakMap();
  _initializeDeferred = new WeakMap();
  _targetsIdsForInit = new WeakMap();
  _waitForInitiallyDiscoveredTargets = new WeakMap();
  _discoveryFilter = new WeakMap();
  _storeExistingTargetsForInit = new WeakMap();
  _TargetManager_instances = new WeakSet();
  setupAttachmentListeners_fn = function(session) {
    const listener = (event) => {
      void __privateGet(this, _onAttachedToTarget2).call(this, session, event);
    };
    assert$1(!__privateGet(this, _attachedToTargetListenersBySession).has(session));
    __privateGet(this, _attachedToTargetListenersBySession).set(session, listener);
    session.on("Target.attachedToTarget", listener);
    const detachedListener = (event) => {
      return __privateGet(this, _onDetachedFromTarget2).call(this, session, event);
    };
    assert$1(!__privateGet(this, _detachedFromTargetListenersBySession).has(session));
    __privateGet(this, _detachedFromTargetListenersBySession).set(session, detachedListener);
    session.on("Target.detachedFromTarget", detachedListener);
  };
  removeAttachmentListeners_fn = function(session) {
    const listener = __privateGet(this, _attachedToTargetListenersBySession).get(session);
    if (listener) {
      session.off("Target.attachedToTarget", listener);
      __privateGet(this, _attachedToTargetListenersBySession).delete(session);
    }
    if (__privateGet(this, _detachedFromTargetListenersBySession).has(session)) {
      session.off("Target.detachedFromTarget", __privateGet(this, _detachedFromTargetListenersBySession).get(session));
      __privateGet(this, _detachedFromTargetListenersBySession).delete(session);
    }
  };
  _onSessionDetached = new WeakMap();
  _onTargetCreated = new WeakMap();
  _onTargetDestroyed = new WeakMap();
  _onTargetInfoChanged = new WeakMap();
  _onAttachedToTarget2 = new WeakMap();
  finishInitializationIfReady_fn = function(targetId) {
    if (targetId !== void 0) {
      __privateGet(this, _targetsIdsForInit).delete(targetId);
    }
    if (__privateGet(this, _targetsIdsForInit).size === 0) {
      __privateGet(this, _initializeDeferred).resolve();
    }
  };
  _onDetachedFromTarget2 = new WeakMap();
  /**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  const _CdpBrowser = class _CdpBrowser extends Browser$1 {
    constructor(connection, contextIds, defaultViewport, process2, closeCallback, targetFilterCallback, isPageTargetCallback, waitForInitiallyDiscoveredTargets = true) {
      super();
      __privateAdd(this, _CdpBrowser_instances);
      __publicField(this, "protocol", "cdp");
      __privateAdd(this, _defaultViewport2);
      __privateAdd(this, _process);
      __privateAdd(this, _connection4);
      __privateAdd(this, _closeCallback);
      __privateAdd(this, _targetFilterCallback2);
      __privateAdd(this, _isPageTargetCallback);
      __privateAdd(this, _defaultContext);
      __privateAdd(this, _contexts, /* @__PURE__ */ new Map());
      __privateAdd(this, _targetManager3);
      __privateAdd(this, _emitDisconnected, () => {
        this.emit("disconnected", void 0);
      });
      __privateAdd(this, _createTarget, (targetInfo, session) => {
        var _a3;
        const { browserContextId } = targetInfo;
        const context = browserContextId && __privateGet(this, _contexts).has(browserContextId) ? __privateGet(this, _contexts).get(browserContextId) : __privateGet(this, _defaultContext);
        if (!context) {
          throw new Error("Missing browser context");
        }
        const createSession = (isAutoAttachEmulated) => {
          return __privateGet(this, _connection4)._createSession(targetInfo, isAutoAttachEmulated);
        };
        const otherTarget = new OtherTarget(targetInfo, session, context, __privateGet(this, _targetManager3), createSession);
        if ((_a3 = targetInfo.url) == null ? void 0 : _a3.startsWith("devtools://")) {
          return new DevToolsTarget(targetInfo, session, context, __privateGet(this, _targetManager3), createSession, __privateGet(this, _defaultViewport2) ?? null);
        }
        if (__privateGet(this, _isPageTargetCallback).call(this, otherTarget)) {
          return new PageTarget(targetInfo, session, context, __privateGet(this, _targetManager3), createSession, __privateGet(this, _defaultViewport2) ?? null);
        }
        if (targetInfo.type === "service_worker" || targetInfo.type === "shared_worker") {
          return new WorkerTarget(targetInfo, session, context, __privateGet(this, _targetManager3), createSession);
        }
        return otherTarget;
      });
      __privateAdd(this, _onAttachedToTarget3, async (target) => {
        if (target._isTargetExposed() && await target._initializedDeferred.valueOrThrow() === InitializationStatus.SUCCESS) {
          this.emit("targetcreated", target);
          target.browserContext().emit("targetcreated", target);
        }
      });
      __privateAdd(this, _onDetachedFromTarget3, async (target) => {
        target._initializedDeferred.resolve(InitializationStatus.ABORTED);
        target._isClosedDeferred.resolve();
        if (target._isTargetExposed() && await target._initializedDeferred.valueOrThrow() === InitializationStatus.SUCCESS) {
          this.emit("targetdestroyed", target);
          target.browserContext().emit("targetdestroyed", target);
        }
      });
      __privateAdd(this, _onTargetChanged, ({ target }) => {
        this.emit("targetchanged", target);
        target.browserContext().emit("targetchanged", target);
      });
      __privateAdd(this, _onTargetDiscovered, (targetInfo) => {
        this.emit("targetdiscovered", targetInfo);
      });
      __privateSet(this, _defaultViewport2, defaultViewport);
      __privateSet(this, _process, process2);
      __privateSet(this, _connection4, connection);
      __privateSet(this, _closeCallback, closeCallback || (() => {
      }));
      __privateSet(this, _targetFilterCallback2, targetFilterCallback || (() => {
        return true;
      }));
      __privateMethod(this, _CdpBrowser_instances, setIsPageTargetCallback_fn).call(this, isPageTargetCallback);
      __privateSet(this, _targetManager3, new TargetManager(connection, __privateGet(this, _createTarget), __privateGet(this, _targetFilterCallback2), waitForInitiallyDiscoveredTargets));
      __privateSet(this, _defaultContext, new CdpBrowserContext(__privateGet(this, _connection4), this));
      for (const contextId of contextIds) {
        __privateGet(this, _contexts).set(contextId, new CdpBrowserContext(__privateGet(this, _connection4), this, contextId));
      }
    }
    static async _create(connection, contextIds, acceptInsecureCerts, defaultViewport, downloadBehavior, process2, closeCallback, targetFilterCallback, isPageTargetCallback, waitForInitiallyDiscoveredTargets = true) {
      const browser2 = new _CdpBrowser(connection, contextIds, defaultViewport, process2, closeCallback, targetFilterCallback, isPageTargetCallback, waitForInitiallyDiscoveredTargets);
      if (acceptInsecureCerts) {
        await connection.send("Security.setIgnoreCertificateErrors", {
          ignore: true
        });
      }
      await browser2._attach(downloadBehavior);
      return browser2;
    }
    async _attach(downloadBehavior) {
      __privateGet(this, _connection4).on(CDPSessionEvent.Disconnected, __privateGet(this, _emitDisconnected));
      if (downloadBehavior) {
        await __privateGet(this, _defaultContext).setDownloadBehavior(downloadBehavior);
      }
      __privateGet(this, _targetManager3).on("targetAvailable", __privateGet(this, _onAttachedToTarget3));
      __privateGet(this, _targetManager3).on("targetGone", __privateGet(this, _onDetachedFromTarget3));
      __privateGet(this, _targetManager3).on("targetChanged", __privateGet(this, _onTargetChanged));
      __privateGet(this, _targetManager3).on("targetDiscovered", __privateGet(this, _onTargetDiscovered));
      await __privateGet(this, _targetManager3).initialize();
    }
    _detach() {
      __privateGet(this, _connection4).off(CDPSessionEvent.Disconnected, __privateGet(this, _emitDisconnected));
      __privateGet(this, _targetManager3).off("targetAvailable", __privateGet(this, _onAttachedToTarget3));
      __privateGet(this, _targetManager3).off("targetGone", __privateGet(this, _onDetachedFromTarget3));
      __privateGet(this, _targetManager3).off("targetChanged", __privateGet(this, _onTargetChanged));
      __privateGet(this, _targetManager3).off("targetDiscovered", __privateGet(this, _onTargetDiscovered));
    }
    process() {
      return __privateGet(this, _process) ?? null;
    }
    _targetManager() {
      return __privateGet(this, _targetManager3);
    }
    _getIsPageTargetCallback() {
      return __privateGet(this, _isPageTargetCallback);
    }
    async createBrowserContext(options = {}) {
      const { proxyServer, proxyBypassList, downloadBehavior } = options;
      const { browserContextId } = await __privateGet(this, _connection4).send("Target.createBrowserContext", {
        proxyServer,
        proxyBypassList: proxyBypassList && proxyBypassList.join(",")
      });
      const context = new CdpBrowserContext(__privateGet(this, _connection4), this, browserContextId);
      if (downloadBehavior) {
        await context.setDownloadBehavior(downloadBehavior);
      }
      __privateGet(this, _contexts).set(browserContextId, context);
      return context;
    }
    browserContexts() {
      return [__privateGet(this, _defaultContext), ...Array.from(__privateGet(this, _contexts).values())];
    }
    defaultBrowserContext() {
      return __privateGet(this, _defaultContext);
    }
    async _disposeContext(contextId) {
      if (!contextId) {
        return;
      }
      await __privateGet(this, _connection4).send("Target.disposeBrowserContext", {
        browserContextId: contextId
      });
      __privateGet(this, _contexts).delete(contextId);
    }
    wsEndpoint() {
      return __privateGet(this, _connection4).url();
    }
    async newPage() {
      return await __privateGet(this, _defaultContext).newPage();
    }
    async _createPageInContext(contextId) {
      const { targetId } = await __privateGet(this, _connection4).send("Target.createTarget", {
        url: "about:blank",
        browserContextId: contextId || void 0
      });
      const target = await this.waitForTarget((t) => {
        return t._targetId === targetId;
      });
      if (!target) {
        throw new Error(`Missing target for page (id = ${targetId})`);
      }
      const initialized = await target._initializedDeferred.valueOrThrow() === InitializationStatus.SUCCESS;
      if (!initialized) {
        throw new Error(`Failed to create target for page (id = ${targetId})`);
      }
      const page = await target.page();
      if (!page) {
        throw new Error(`Failed to create a page for context (id = ${contextId})`);
      }
      return page;
    }
    targets() {
      return Array.from(__privateGet(this, _targetManager3).getAvailableTargets().values()).filter((target) => {
        return target._isTargetExposed() && target._initializedDeferred.value() === InitializationStatus.SUCCESS;
      });
    }
    target() {
      const browserTarget = this.targets().find((target) => {
        return target.type() === "browser";
      });
      if (!browserTarget) {
        throw new Error("Browser target is not found");
      }
      return browserTarget;
    }
    async version() {
      const version2 = await __privateMethod(this, _CdpBrowser_instances, getVersion_fn).call(this);
      return version2.product;
    }
    async userAgent() {
      const version2 = await __privateMethod(this, _CdpBrowser_instances, getVersion_fn).call(this);
      return version2.userAgent;
    }
    async close() {
      await __privateGet(this, _closeCallback).call(null);
      await this.disconnect();
    }
    disconnect() {
      __privateGet(this, _targetManager3).dispose();
      __privateGet(this, _connection4).dispose();
      this._detach();
      return Promise.resolve();
    }
    get connected() {
      return !__privateGet(this, _connection4)._closed;
    }
    get debugInfo() {
      return {
        pendingProtocolErrors: __privateGet(this, _connection4).getPendingProtocolErrors()
      };
    }
  };
  _defaultViewport2 = new WeakMap();
  _process = new WeakMap();
  _connection4 = new WeakMap();
  _closeCallback = new WeakMap();
  _targetFilterCallback2 = new WeakMap();
  _isPageTargetCallback = new WeakMap();
  _defaultContext = new WeakMap();
  _contexts = new WeakMap();
  _targetManager3 = new WeakMap();
  _emitDisconnected = new WeakMap();
  _CdpBrowser_instances = new WeakSet();
  setIsPageTargetCallback_fn = function(isPageTargetCallback) {
    __privateSet(this, _isPageTargetCallback, isPageTargetCallback || ((target) => {
      return target.type() === "page" || target.type() === "background_page" || target.type() === "webview";
    }));
  };
  _createTarget = new WeakMap();
  _onAttachedToTarget3 = new WeakMap();
  _onDetachedFromTarget3 = new WeakMap();
  _onTargetChanged = new WeakMap();
  _onTargetDiscovered = new WeakMap();
  getVersion_fn = function() {
    return __privateGet(this, _connection4).send("Browser.getVersion");
  };
  let CdpBrowser = _CdpBrowser;
  /**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  async function _connectToCdpBrowser(connectionTransport, url, options) {
    const { acceptInsecureCerts = false, defaultViewport = DEFAULT_VIEWPORT, downloadBehavior, targetFilter, _isPageTarget: isPageTarget, slowMo = 0, protocolTimeout } = options;
    const connection = new Connection(url, connectionTransport, slowMo, protocolTimeout);
    const { browserContextIds } = await connection.send("Target.getBrowserContexts");
    const browser2 = await CdpBrowser._create(connection, browserContextIds, acceptInsecureCerts, defaultViewport, downloadBehavior, void 0, () => {
      return connection.send("Browser.close").catch(debugError);
    }, targetFilter, isPageTarget);
    return browser2;
  }
  const tabTargetInfo = {
    targetId: "tabTargetId",
    type: "tab",
    title: "tab",
    url: "about:blank",
    attached: false,
    canAccessOpener: false
  };
  const pageTargetInfo = {
    targetId: "pageTargetId",
    type: "page",
    title: "page",
    url: "about:blank",
    attached: false,
    canAccessOpener: false
  };
  const _ExtensionTransport = class _ExtensionTransport {
    /**
     * @internal
     */
    constructor(tabId) {
      __privateAdd(this, _ExtensionTransport_instances);
      __publicField(this, "onmessage");
      __publicField(this, "onclose");
      __privateAdd(this, _tabId);
      __privateAdd(this, _debuggerEventHandler, (source2, method, params) => {
        if (source2.tabId !== __privateGet(this, _tabId)) {
          return;
        }
        __privateMethod(this, _ExtensionTransport_instances, dispatchResponse_fn).call(this, {
          // @ts-expect-error sessionId is not in stable yet.
          sessionId: source2.sessionId ?? "pageTargetSessionId",
          method,
          params
        });
      });
      __privateSet(this, _tabId, tabId);
      chrome.debugger.onEvent.addListener(__privateGet(this, _debuggerEventHandler));
    }
    static async connectTab(tabId) {
      await chrome.debugger.attach({ tabId }, "1.3");
      return new _ExtensionTransport(tabId);
    }
    send(message) {
      const parsed = JSON.parse(message);
      switch (parsed.method) {
        case "Browser.getVersion": {
          __privateMethod(this, _ExtensionTransport_instances, dispatchResponse_fn).call(this, {
            id: parsed.id,
            sessionId: parsed.sessionId,
            method: parsed.method,
            result: {
              protocolVersion: "1.3",
              product: "chrome",
              revision: "unknown",
              userAgent: "chrome",
              jsVersion: "unknown"
            }
          });
          return;
        }
        case "Target.getBrowserContexts": {
          __privateMethod(this, _ExtensionTransport_instances, dispatchResponse_fn).call(this, {
            id: parsed.id,
            sessionId: parsed.sessionId,
            method: parsed.method,
            result: {
              browserContextIds: []
            }
          });
          return;
        }
        case "Target.setDiscoverTargets": {
          __privateMethod(this, _ExtensionTransport_instances, dispatchResponse_fn).call(this, {
            method: "Target.targetCreated",
            params: {
              targetInfo: tabTargetInfo
            }
          });
          __privateMethod(this, _ExtensionTransport_instances, dispatchResponse_fn).call(this, {
            method: "Target.targetCreated",
            params: {
              targetInfo: pageTargetInfo
            }
          });
          __privateMethod(this, _ExtensionTransport_instances, dispatchResponse_fn).call(this, {
            id: parsed.id,
            sessionId: parsed.sessionId,
            method: parsed.method,
            result: {}
          });
          return;
        }
        case "Target.setAutoAttach": {
          if (parsed.sessionId === "tabTargetSessionId") {
            __privateMethod(this, _ExtensionTransport_instances, dispatchResponse_fn).call(this, {
              method: "Target.attachedToTarget",
              params: {
                targetInfo: pageTargetInfo,
                sessionId: "pageTargetSessionId"
              }
            });
            __privateMethod(this, _ExtensionTransport_instances, dispatchResponse_fn).call(this, {
              id: parsed.id,
              sessionId: parsed.sessionId,
              method: parsed.method,
              result: {}
            });
            return;
          } else if (!parsed.sessionId) {
            __privateMethod(this, _ExtensionTransport_instances, dispatchResponse_fn).call(this, {
              method: "Target.attachedToTarget",
              params: {
                targetInfo: tabTargetInfo,
                sessionId: "tabTargetSessionId"
              }
            });
            __privateMethod(this, _ExtensionTransport_instances, dispatchResponse_fn).call(this, {
              id: parsed.id,
              sessionId: parsed.sessionId,
              method: parsed.method,
              result: {}
            });
            return;
          }
        }
      }
      if (parsed.sessionId === "pageTargetSessionId") {
        delete parsed.sessionId;
      }
      chrome.debugger.sendCommand(
        // @ts-expect-error sessionId is not in stable yet.
        { tabId: __privateGet(this, _tabId), sessionId: parsed.sessionId },
        parsed.method,
        parsed.params
      ).then((response) => {
        __privateMethod(this, _ExtensionTransport_instances, dispatchResponse_fn).call(this, {
          id: parsed.id,
          sessionId: parsed.sessionId ?? "pageTargetSessionId",
          method: parsed.method,
          result: response
        });
      }).catch((err) => {
        __privateMethod(this, _ExtensionTransport_instances, dispatchResponse_fn).call(this, {
          id: parsed.id,
          sessionId: parsed.sessionId ?? "pageTargetSessionId",
          method: parsed.method,
          error: {
            code: err == null ? void 0 : err.code,
            data: err == null ? void 0 : err.data,
            message: (err == null ? void 0 : err.message) ?? "CDP error had no message"
          }
        });
      });
    }
    close() {
      chrome.debugger.onEvent.removeListener(__privateGet(this, _debuggerEventHandler));
      void chrome.debugger.detach({ tabId: __privateGet(this, _tabId) });
    }
  };
  _tabId = new WeakMap();
  _debuggerEventHandler = new WeakMap();
  _ExtensionTransport_instances = new WeakSet();
  dispatchResponse_fn = function(message) {
    var _a3;
    (_a3 = this.onmessage) == null ? void 0 : _a3.call(this, JSON.stringify(message));
  };
  let ExtensionTransport = _ExtensionTransport;
  const _BrowserWebSocketTransport = class _BrowserWebSocketTransport {
    constructor(ws) {
      __privateAdd(this, _ws);
      __publicField(this, "onmessage");
      __publicField(this, "onclose");
      __privateSet(this, _ws, ws);
      __privateGet(this, _ws).addEventListener("message", (event) => {
        if (this.onmessage) {
          this.onmessage.call(null, event.data);
        }
      });
      __privateGet(this, _ws).addEventListener("close", () => {
        if (this.onclose) {
          this.onclose.call(null);
        }
      });
      __privateGet(this, _ws).addEventListener("error", () => {
      });
    }
    static create(url) {
      return new Promise((resolve, reject) => {
        const ws = new WebSocket(url);
        ws.addEventListener("open", () => {
          return resolve(new _BrowserWebSocketTransport(ws));
        });
        ws.addEventListener("error", reject);
      });
    }
    send(message) {
      __privateGet(this, _ws).send(message);
    }
    close() {
      __privateGet(this, _ws).close();
    }
  };
  _ws = new WeakMap();
  let BrowserWebSocketTransport = _BrowserWebSocketTransport;
  const BrowserWebSocketTransport$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    BrowserWebSocketTransport
  }, Symbol.toStringTag, { value: "Module" }));
  /**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  const knownDevices = [
    {
      name: "Blackberry PlayBook",
      userAgent: "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+",
      viewport: {
        width: 600,
        height: 1024,
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Blackberry PlayBook landscape",
      userAgent: "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+",
      viewport: {
        width: 1024,
        height: 600,
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "BlackBerry Z30",
      userAgent: "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+",
      viewport: {
        width: 360,
        height: 640,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "BlackBerry Z30 landscape",
      userAgent: "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+",
      viewport: {
        width: 640,
        height: 360,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Galaxy Note 3",
      userAgent: "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
      viewport: {
        width: 360,
        height: 640,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Galaxy Note 3 landscape",
      userAgent: "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
      viewport: {
        width: 640,
        height: 360,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Galaxy Note II",
      userAgent: "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
      viewport: {
        width: 360,
        height: 640,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Galaxy Note II landscape",
      userAgent: "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
      viewport: {
        width: 640,
        height: 360,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Galaxy S III",
      userAgent: "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
      viewport: {
        width: 360,
        height: 640,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Galaxy S III landscape",
      userAgent: "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
      viewport: {
        width: 640,
        height: 360,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Galaxy S5",
      userAgent: "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 360,
        height: 640,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Galaxy S5 landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 640,
        height: 360,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Galaxy S8",
      userAgent: "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
      viewport: {
        width: 360,
        height: 740,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Galaxy S8 landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
      viewport: {
        width: 740,
        height: 360,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Galaxy S9+",
      userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
      viewport: {
        width: 320,
        height: 658,
        deviceScaleFactor: 4.5,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Galaxy S9+ landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
      viewport: {
        width: 658,
        height: 320,
        deviceScaleFactor: 4.5,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Galaxy Tab S4",
      userAgent: "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Safari/537.36",
      viewport: {
        width: 712,
        height: 1138,
        deviceScaleFactor: 2.25,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Galaxy Tab S4 landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Safari/537.36",
      viewport: {
        width: 1138,
        height: 712,
        deviceScaleFactor: 2.25,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPad",
      userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
      viewport: {
        width: 768,
        height: 1024,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPad landscape",
      userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
      viewport: {
        width: 1024,
        height: 768,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPad (gen 6)",
      userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 768,
        height: 1024,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPad (gen 6) landscape",
      userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 1024,
        height: 768,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPad (gen 7)",
      userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 810,
        height: 1080,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPad (gen 7) landscape",
      userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 1080,
        height: 810,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPad Mini",
      userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
      viewport: {
        width: 768,
        height: 1024,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPad Mini landscape",
      userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
      viewport: {
        width: 1024,
        height: 768,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPad Pro",
      userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
      viewport: {
        width: 1024,
        height: 1366,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPad Pro landscape",
      userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
      viewport: {
        width: 1366,
        height: 1024,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPad Pro 11",
      userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 834,
        height: 1194,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPad Pro 11 landscape",
      userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 1194,
        height: 834,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 4",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53",
      viewport: {
        width: 320,
        height: 480,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 4 landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53",
      viewport: {
        width: 480,
        height: 320,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 5",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
      viewport: {
        width: 320,
        height: 568,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 5 landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
      viewport: {
        width: 568,
        height: 320,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 6",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
      viewport: {
        width: 375,
        height: 667,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 6 landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
      viewport: {
        width: 667,
        height: 375,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 6 Plus",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
      viewport: {
        width: 414,
        height: 736,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 6 Plus landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
      viewport: {
        width: 736,
        height: 414,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 7",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
      viewport: {
        width: 375,
        height: 667,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 7 landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
      viewport: {
        width: 667,
        height: 375,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 7 Plus",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
      viewport: {
        width: 414,
        height: 736,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 7 Plus landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
      viewport: {
        width: 736,
        height: 414,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 8",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
      viewport: {
        width: 375,
        height: 667,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 8 landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
      viewport: {
        width: 667,
        height: 375,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 8 Plus",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
      viewport: {
        width: 414,
        height: 736,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 8 Plus landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
      viewport: {
        width: 736,
        height: 414,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone SE",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
      viewport: {
        width: 320,
        height: 568,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone SE landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
      viewport: {
        width: 568,
        height: 320,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone X",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
      viewport: {
        width: 375,
        height: 812,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone X landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
      viewport: {
        width: 812,
        height: 375,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone XR",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 414,
        height: 896,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone XR landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 896,
        height: 414,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 11",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 414,
        height: 828,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 11 landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 828,
        height: 414,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 11 Pro",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 375,
        height: 812,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 11 Pro landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 812,
        height: 375,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 11 Pro Max",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 414,
        height: 896,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 11 Pro Max landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 896,
        height: 414,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 12",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 390,
        height: 844,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 12 landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 844,
        height: 390,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 12 Pro",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 390,
        height: 844,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 12 Pro landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 844,
        height: 390,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 12 Pro Max",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 428,
        height: 926,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 12 Pro Max landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 926,
        height: 428,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 12 Mini",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 375,
        height: 812,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 12 Mini landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 812,
        height: 375,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 13",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 390,
        height: 844,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 13 landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 844,
        height: 390,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 13 Pro",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 390,
        height: 844,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 13 Pro landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 844,
        height: 390,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 13 Pro Max",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 428,
        height: 926,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 13 Pro Max landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 926,
        height: 428,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 13 Mini",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 375,
        height: 812,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 13 Mini landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 812,
        height: 375,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 14",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 390,
        height: 663,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 14 landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 750,
        height: 340,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 14 Plus",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 428,
        height: 745,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 14 Plus landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 832,
        height: 378,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 14 Pro",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 393,
        height: 659,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 14 Pro landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 734,
        height: 343,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 14 Pro Max",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 430,
        height: 739,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 14 Pro Max landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 814,
        height: 380,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 15",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 393,
        height: 659,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 15 landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 734,
        height: 343,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 15 Plus",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 430,
        height: 739,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 15 Plus landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 814,
        height: 380,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 15 Pro",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 393,
        height: 659,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 15 Pro landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 734,
        height: 343,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 15 Pro Max",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 430,
        height: 739,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 15 Pro Max landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 814,
        height: 380,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "JioPhone 2",
      userAgent: "Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5",
      viewport: {
        width: 240,
        height: 320,
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "JioPhone 2 landscape",
      userAgent: "Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5",
      viewport: {
        width: 320,
        height: 240,
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Kindle Fire HDX",
      userAgent: "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
      viewport: {
        width: 800,
        height: 1280,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Kindle Fire HDX landscape",
      userAgent: "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
      viewport: {
        width: 1280,
        height: 800,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "LG Optimus L70",
      userAgent: "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 384,
        height: 640,
        deviceScaleFactor: 1.25,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "LG Optimus L70 landscape",
      userAgent: "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 640,
        height: 384,
        deviceScaleFactor: 1.25,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Microsoft Lumia 550",
      userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
      viewport: {
        width: 640,
        height: 360,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Microsoft Lumia 950",
      userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
      viewport: {
        width: 360,
        height: 640,
        deviceScaleFactor: 4,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Microsoft Lumia 950 landscape",
      userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
      viewport: {
        width: 640,
        height: 360,
        deviceScaleFactor: 4,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Nexus 10",
      userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
      viewport: {
        width: 800,
        height: 1280,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Nexus 10 landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
      viewport: {
        width: 1280,
        height: 800,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Nexus 4",
      userAgent: "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 384,
        height: 640,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Nexus 4 landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 640,
        height: 384,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Nexus 5",
      userAgent: "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 360,
        height: 640,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Nexus 5 landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 640,
        height: 360,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Nexus 5X",
      userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 412,
        height: 732,
        deviceScaleFactor: 2.625,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Nexus 5X landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 732,
        height: 412,
        deviceScaleFactor: 2.625,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Nexus 6",
      userAgent: "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 412,
        height: 732,
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Nexus 6 landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 732,
        height: 412,
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Nexus 6P",
      userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 412,
        height: 732,
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Nexus 6P landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 732,
        height: 412,
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Nexus 7",
      userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
      viewport: {
        width: 600,
        height: 960,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Nexus 7 landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
      viewport: {
        width: 960,
        height: 600,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Nokia Lumia 520",
      userAgent: "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
      viewport: {
        width: 320,
        height: 533,
        deviceScaleFactor: 1.5,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Nokia Lumia 520 landscape",
      userAgent: "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
      viewport: {
        width: 533,
        height: 320,
        deviceScaleFactor: 1.5,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Nokia N9",
      userAgent: "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
      viewport: {
        width: 480,
        height: 854,
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Nokia N9 landscape",
      userAgent: "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
      viewport: {
        width: 854,
        height: 480,
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Pixel 2",
      userAgent: "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 411,
        height: 731,
        deviceScaleFactor: 2.625,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Pixel 2 landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 731,
        height: 411,
        deviceScaleFactor: 2.625,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Pixel 2 XL",
      userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 411,
        height: 823,
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Pixel 2 XL landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 823,
        height: 411,
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Pixel 3",
      userAgent: "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.158 Mobile Safari/537.36",
      viewport: {
        width: 393,
        height: 786,
        deviceScaleFactor: 2.75,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Pixel 3 landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.158 Mobile Safari/537.36",
      viewport: {
        width: 786,
        height: 393,
        deviceScaleFactor: 2.75,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Pixel 4",
      userAgent: "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36",
      viewport: {
        width: 353,
        height: 745,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Pixel 4 landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36",
      viewport: {
        width: 745,
        height: 353,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Pixel 4a (5G)",
      userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
      viewport: {
        width: 353,
        height: 745,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Pixel 4a (5G) landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
      viewport: {
        width: 745,
        height: 353,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Pixel 5",
      userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
      viewport: {
        width: 393,
        height: 851,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Pixel 5 landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
      viewport: {
        width: 851,
        height: 393,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Moto G4",
      userAgent: "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
      viewport: {
        width: 360,
        height: 640,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Moto G4 landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
      viewport: {
        width: 640,
        height: 360,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    }
  ];
  const knownDevicesByName = {};
  for (const device of knownDevices) {
    knownDevicesByName[device.name] = device;
  }
  Object.freeze(knownDevicesByName);
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  async function _connectToBiDiBrowser(connectionTransport, url, options) {
    const { acceptInsecureCerts = false, defaultViewport = DEFAULT_VIEWPORT } = options;
    const { bidiConnection, cdpConnection, closeCallback } = await getBiDiConnection(connectionTransport, url, options);
    const BiDi = await Promise.resolve().then(() => bidi);
    const bidiBrowser = await BiDi.BidiBrowser.create({
      connection: bidiConnection,
      cdpConnection,
      closeCallback,
      process: void 0,
      defaultViewport,
      acceptInsecureCerts,
      capabilities: options.capabilities
    });
    return bidiBrowser;
  }
  async function getBiDiConnection(connectionTransport, url, options) {
    const BiDi = await Promise.resolve().then(() => bidi);
    const { slowMo = 0, protocolTimeout } = options;
    const pureBidiConnection = new BiDi.BidiConnection(url, connectionTransport, slowMo, protocolTimeout);
    try {
      const result = await pureBidiConnection.send("session.status", {});
      if ("type" in result && result.type === "success") {
        return {
          bidiConnection: pureBidiConnection,
          closeCallback: async () => {
            await pureBidiConnection.send("browser.close", {}).catch(debugError);
          }
        };
      }
    } catch (e) {
      if (!(e instanceof ProtocolError)) {
        throw e;
      }
    }
    pureBidiConnection.unbind();
    const cdpConnection = new Connection(
      url,
      connectionTransport,
      slowMo,
      protocolTimeout,
      /* rawErrors= */
      true
    );
    const version2 = await cdpConnection.send("Browser.getVersion");
    if (version2.product.toLowerCase().includes("firefox")) {
      throw new UnsupportedOperation("Firefox is not supported in BiDi over CDP mode.");
    }
    const bidiOverCdpConnection = await BiDi.connectBidiOverCdp(cdpConnection);
    return {
      cdpConnection,
      bidiConnection: bidiOverCdpConnection,
      closeCallback: async () => {
        await cdpConnection.send("Browser.close").catch(debugError);
      }
    };
  }
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  const getWebSocketTransportClass = async () => {
    return isNode$2 ? (await Promise.resolve().then(() => NodeWebSocketTransport$1)).NodeWebSocketTransport : (await Promise.resolve().then(() => BrowserWebSocketTransport$1)).BrowserWebSocketTransport;
  };
  async function _connectToBrowser(options) {
    const { connectionTransport, endpointUrl } = await getConnectionTransport(options);
    if (options.protocol === "webDriverBiDi") {
      const bidiBrowser = await _connectToBiDiBrowser(connectionTransport, endpointUrl, options);
      return bidiBrowser;
    } else {
      const cdpBrowser = await _connectToCdpBrowser(connectionTransport, endpointUrl, options);
      return cdpBrowser;
    }
  }
  async function getConnectionTransport(options) {
    const { browserWSEndpoint, browserURL, transport, headers = {} } = options;
    assert$1(Number(!!browserWSEndpoint) + Number(!!browserURL) + Number(!!transport) === 1, "Exactly one of browserWSEndpoint, browserURL or transport must be passed to puppeteer.connect");
    if (transport) {
      return { connectionTransport: transport, endpointUrl: "" };
    } else if (browserWSEndpoint) {
      const WebSocketClass = await getWebSocketTransportClass();
      const connectionTransport = await WebSocketClass.create(browserWSEndpoint, headers);
      return {
        connectionTransport,
        endpointUrl: browserWSEndpoint
      };
    } else if (browserURL) {
      const connectionURL = await getWSEndpoint(browserURL);
      const WebSocketClass = await getWebSocketTransportClass();
      const connectionTransport = await WebSocketClass.create(connectionURL);
      return {
        connectionTransport,
        endpointUrl: connectionURL
      };
    }
    throw new Error("Invalid connection options");
  }
  async function getWSEndpoint(browserURL) {
    const endpointURL = new URL("/json/version", browserURL);
    try {
      const result = await globalThis.fetch(endpointURL.toString(), {
        method: "GET"
      });
      if (!result.ok) {
        throw new Error(`HTTP ${result.statusText}`);
      }
      const data = await result.json();
      return data.webSocketDebuggerUrl;
    } catch (error) {
      if (isErrorLike(error)) {
        error.message = `Failed to fetch browser webSocket URL from ${endpointURL}: ` + error.message;
      }
      throw error;
    }
  }
  /**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class Puppeteer {
    /**
     * @internal
     */
    constructor(settings) {
      /**
       * @internal
       */
      __publicField(this, "_isPuppeteerCore");
      /**
       * @internal
       */
      __publicField(this, "_changedBrowsers", false);
      this._isPuppeteerCore = settings.isPuppeteerCore;
      this.connect = this.connect.bind(this);
    }
    /**
     * Registers a {@link CustomQueryHandler | custom query handler}.
     *
     * @remarks
     * After registration, the handler can be used everywhere where a selector is
     * expected by prepending the selection string with `<name>/`. The name is only
     * allowed to consist of lower- and upper case latin letters.
     *
     * @example
     *
     * ```
     * import {Puppeteer}, puppeteer from 'puppeteer';
     *
     * Puppeteer.registerCustomQueryHandler('text', { … });
     * const aHandle = await page.$('text/…');
     * ```
     *
     * @param name - The name that the custom query handler will be registered
     * under.
     * @param queryHandler - The {@link CustomQueryHandler | custom query handler}
     * to register.
     *
     * @public
     */
    static registerCustomQueryHandler(name, queryHandler) {
      return this.customQueryHandlers.register(name, queryHandler);
    }
    /**
     * Unregisters a custom query handler for a given name.
     */
    static unregisterCustomQueryHandler(name) {
      return this.customQueryHandlers.unregister(name);
    }
    /**
     * Gets the names of all custom query handlers.
     */
    static customQueryHandlerNames() {
      return this.customQueryHandlers.names();
    }
    /**
     * Unregisters all custom query handlers.
     */
    static clearCustomQueryHandlers() {
      return this.customQueryHandlers.clear();
    }
    /**
     * This method attaches Puppeteer to an existing browser instance.
     *
     * @remarks
     *
     * @param options - Set of configurable options to set on the browser.
     * @returns Promise which resolves to browser instance.
     */
    connect(options) {
      return _connectToBrowser(options);
    }
  }
  /**
   * Operations for {@link CustomQueryHandler | custom query handlers}. See
   * {@link CustomQueryHandlerRegistry}.
   *
   * @internal
   */
  __publicField(Puppeteer, "customQueryHandlers", customQueryHandlers);
  /**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  const puppeteer = new Puppeteer({
    isPuppeteerCore: true
  });
  const {
    /**
     * @public
     */
    connect
  } = puppeteer;
  const createLogger = (namespace) => {
    const prefix = `[${namespace}]`;
    return {
      debug: (...args) => {
      },
      info: (...args) => console.info(prefix, ...args),
      warning: (...args) => console.warn(prefix, ...args),
      error: (...args) => console.error(prefix, ...args),
      group: (label) => console.group(`${prefix} ${label}`),
      groupEnd: () => console.groupEnd()
    };
  };
  class HashedDomElement {
    /**
     * Hash of the dom element to be used as a unique identifier
     */
    constructor(branchPathHash, attributesHash, xpathHash) {
      this.branchPathHash = branchPathHash;
      this.attributesHash = attributesHash;
      this.xpathHash = xpathHash;
    }
  }
  class DOMHistoryElement {
    constructor(tagName, xpath, highlightIndex, entireParentBranchPath, attributes, shadowRoot = false, cssSelector = null, pageCoordinates = null, viewportCoordinates = null, viewportInfo = null) {
      this.tagName = tagName;
      this.xpath = xpath;
      this.highlightIndex = highlightIndex;
      this.entireParentBranchPath = entireParentBranchPath;
      this.attributes = attributes;
      this.shadowRoot = shadowRoot;
      this.cssSelector = cssSelector;
      this.pageCoordinates = pageCoordinates;
      this.viewportCoordinates = viewportCoordinates;
      this.viewportInfo = viewportInfo;
    }
    toDict() {
      return {
        tagName: this.tagName,
        xpath: this.xpath,
        highlightIndex: this.highlightIndex,
        entireParentBranchPath: this.entireParentBranchPath,
        attributes: this.attributes,
        shadowRoot: this.shadowRoot,
        cssSelector: this.cssSelector,
        pageCoordinates: this.pageCoordinates,
        viewportCoordinates: this.viewportCoordinates,
        viewportInfo: this.viewportInfo
      };
    }
  }
  function convertDomElementToHistoryElement(domElement) {
    const parentBranchPath = _getParentBranchPath$1(domElement);
    const cssSelector = domElement.getEnhancedCssSelector();
    return new DOMHistoryElement(
      domElement.tagName ?? "",
      // Provide empty string as fallback
      domElement.xpath ?? "",
      // Provide empty string as fallback
      domElement.highlightIndex ?? null,
      parentBranchPath,
      domElement.attributes,
      domElement.shadowRoot,
      cssSelector,
      domElement.pageCoordinates ?? null,
      domElement.viewportCoordinates ?? null,
      domElement.viewportInfo ?? null
    );
  }
  async function findHistoryElementInTree(domHistoryElement, tree) {
    const hashedDomHistoryElement = await hashDomHistoryElement(domHistoryElement);
    const processNode = async (node) => {
      if (node.highlightIndex != null) {
        const hashedNode = await hashDomElement$1(node);
        if (hashedNode.branchPathHash === hashedDomHistoryElement.branchPathHash && hashedNode.attributesHash === hashedDomHistoryElement.attributesHash && hashedNode.xpathHash === hashedDomHistoryElement.xpathHash) {
          return node;
        }
      }
      for (const child of node.children) {
        if (child instanceof DOMElementNode) {
          const result = await processNode(child);
          if (result !== null) {
            return result;
          }
        }
      }
      return null;
    };
    return processNode(tree);
  }
  async function compareHistoryElementAndDomElement(domHistoryElement, domElement) {
    const [hashedDomHistoryElement, hashedDomElement] = await Promise.all([
      hashDomHistoryElement(domHistoryElement),
      hashDomElement$1(domElement)
    ]);
    return hashedDomHistoryElement.branchPathHash === hashedDomElement.branchPathHash && hashedDomHistoryElement.attributesHash === hashedDomElement.attributesHash && hashedDomHistoryElement.xpathHash === hashedDomElement.xpathHash;
  }
  async function hashDomHistoryElement(domHistoryElement) {
    const [branchPathHash, attributesHash, xpathHash] = await Promise.all([
      _parentBranchPathHash$1(domHistoryElement.entireParentBranchPath),
      _attributesHash$1(domHistoryElement.attributes),
      _xpathHash$1(domHistoryElement.xpath ?? "")
    ]);
    return new HashedDomElement(branchPathHash, attributesHash, xpathHash);
  }
  async function hashDomElement$1(domElement) {
    const parentBranchPath = _getParentBranchPath$1(domElement);
    const [branchPathHash, attributesHash, xpathHash] = await Promise.all([
      _parentBranchPathHash$1(parentBranchPath),
      _attributesHash$1(domElement.attributes),
      _xpathHash$1(domElement.xpath ?? "")
    ]);
    return new HashedDomElement(branchPathHash, attributesHash, xpathHash);
  }
  function _getParentBranchPath$1(domElement) {
    const parents = [];
    let currentElement = domElement;
    while (currentElement.parent != null) {
      parents.push(currentElement);
      currentElement = currentElement.parent;
    }
    parents.reverse();
    return parents.map((parent) => parent.tagName ?? "");
  }
  async function _parentBranchPathHash$1(parentBranchPath) {
    if (parentBranchPath.length === 0) return "";
    return _createSHA256Hash(parentBranchPath.join("/"));
  }
  async function _attributesHash$1(attributes) {
    const attributesString = Object.entries(attributes).map(([key, value]) => `${key}=${value}`).join("");
    return _createSHA256Hash(attributesString);
  }
  async function _xpathHash$1(xpath) {
    return _createSHA256Hash(xpath);
  }
  async function _textHash(domElement) {
    const textString = domElement.getAllTextTillNextClickableElement();
    return _createSHA256Hash(textString);
  }
  async function _createSHA256Hash(input) {
    const encoder = new TextEncoder();
    const data = encoder.encode(input);
    const hashBuffer = await crypto.subtle.digest("SHA-256", data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  const HistoryTreeProcessor = {
    convertDomElementToHistoryElement,
    findHistoryElementInTree,
    compareHistoryElementAndDomElement,
    hashDomElement: hashDomElement$1,
    _getParentBranchPath: _getParentBranchPath$1,
    _parentBranchPathHash: _parentBranchPathHash$1,
    _attributesHash: _attributesHash$1,
    _xpathHash: _xpathHash$1,
    _textHash
  };
  class DOMBaseNode {
    constructor(isVisible, parent) {
      this.isVisible = isVisible;
      this.parent = parent ?? null;
    }
  }
  class DOMTextNode extends DOMBaseNode {
    constructor(text, isVisible, parent) {
      super(isVisible, parent);
      this.type = "TEXT_NODE";
      this.text = text;
    }
    hasParentWithHighlightIndex() {
      let current = this.parent;
      while (current != null) {
        if (current.highlightIndex !== null) {
          return true;
        }
        current = current.parent;
      }
      return false;
    }
    isParentInViewport() {
      if (this.parent === null) {
        return false;
      }
      return this.parent.isInViewport;
    }
    isParentTopElement() {
      if (this.parent === null) {
        return false;
      }
      return this.parent.isTopElement;
    }
  }
  class DOMElementNode extends DOMBaseNode {
    constructor(params) {
      super(params.isVisible, params.parent);
      this.tagName = params.tagName;
      this.xpath = params.xpath;
      this.attributes = params.attributes;
      this.children = params.children;
      this.isInteractive = params.isInteractive ?? false;
      this.isTopElement = params.isTopElement ?? false;
      this.isInViewport = params.isInViewport ?? false;
      this.shadowRoot = params.shadowRoot ?? false;
      this.highlightIndex = params.highlightIndex ?? null;
      this.viewportCoordinates = params.viewportCoordinates;
      this.pageCoordinates = params.pageCoordinates;
      this.viewportInfo = params.viewportInfo;
      this.isNew = params.isNew ?? null;
    }
    /**
     * Returns a hashed representation of this DOM element
     * Async equivalent of the Python @cached_property hash method
     *
     * @returns {Promise<HashedDomElement>} A promise that resolves to the hashed DOM element
     * @throws {Error} If the hashing operation fails
     */
    async hash() {
      if (this._hashedValue) {
        return this._hashedValue;
      }
      if (!this._hashPromise) {
        this._hashPromise = HistoryTreeProcessor.hashDomElement(this).then((result) => {
          this._hashedValue = result;
          this._hashPromise = void 0;
          return result;
        }).catch((error) => {
          this._hashPromise = void 0;
          console.error("Error computing DOM element hash:", error);
          const enhancedError = new Error(
            `Failed to hash DOM element (${this.tagName || "unknown"}): ${error.message}`
          );
          if (error.stack) {
            enhancedError.stack = error.stack;
          }
          throw enhancedError;
        });
      }
      return this._hashPromise;
    }
    /**
     * Clears the cached hash value, forcing recalculation on next hash() call
     */
    clearHashCache() {
      this._hashedValue = void 0;
      this._hashPromise = void 0;
    }
    getAllTextTillNextClickableElement(maxDepth = -1) {
      const textParts = [];
      const collectText = (node, currentDepth) => {
        if (maxDepth !== -1 && currentDepth > maxDepth) {
          return;
        }
        if (node instanceof DOMElementNode && node !== this && node.highlightIndex !== null) {
          return;
        }
        if (node instanceof DOMTextNode) {
          textParts.push(node.text);
        } else if (node instanceof DOMElementNode) {
          for (const child of node.children) {
            collectText(child, currentDepth + 1);
          }
        }
      };
      collectText(this, 0);
      return textParts.join("\n").trim();
    }
    clickableElementsToString(includeAttributes = []) {
      const formattedText = [];
      const processNode = (node, depth) => {
        let nextDepth = depth;
        const depthStr = "	".repeat(depth);
        if (node instanceof DOMElementNode) {
          if (node.highlightIndex !== null) {
            nextDepth += 1;
            const text = node.getAllTextTillNextClickableElement();
            let attributesHtmlStr = "";
            if (includeAttributes.length) {
              const attributesToInclude = {};
              for (const key of includeAttributes) {
                if (key in node.attributes) {
                  attributesToInclude[key] = String(node.attributes[key]);
                }
              }
              if (node.tagName === attributesToInclude.role) {
                attributesToInclude.role = null;
              }
              if ("aria-label" in attributesToInclude && attributesToInclude["aria-label"].trim() === text.trim()) {
                attributesToInclude["aria-label"] = null;
              }
              if ("placeholder" in attributesToInclude && attributesToInclude.placeholder.trim() === text.trim()) {
                attributesToInclude.placeholder = null;
              }
              if (Object.keys(attributesToInclude).length > 0) {
                attributesHtmlStr = Object.entries(attributesToInclude).filter(([, value]) => value !== null).map(([key, value]) => `${key}='${value}'`).join(" ");
              }
            }
            const highlightIndicator = node.isNew ? `*[${node.highlightIndex}]*` : `[${node.highlightIndex}]`;
            let line = `${depthStr}${highlightIndicator}<${node.tagName}`;
            if (attributesHtmlStr) {
              line += ` ${attributesHtmlStr}`;
            }
            if (text) {
              if (!attributesHtmlStr) {
                line += " ";
              }
              line += `>${text}`;
            } else if (!attributesHtmlStr) {
              line += " ";
            }
            line += " />";
            formattedText.push(line);
          }
          for (const child of node.children) {
            processNode(child, nextDepth);
          }
        } else if (node instanceof DOMTextNode) {
          if (!node.hasParentWithHighlightIndex() && node.parent && node.parent.isVisible && node.parent.isTopElement) {
            formattedText.push(`${depthStr}${node.text}`);
          }
        }
      };
      processNode(this, 0);
      return formattedText.join("\n");
    }
    getFileUploadElement(checkSiblings = true) {
      var _a3;
      if (this.tagName === "input" && ((_a3 = this.attributes) == null ? void 0 : _a3.type) === "file") {
        return this;
      }
      for (const child of this.children) {
        if (child instanceof DOMElementNode) {
          const result = child.getFileUploadElement(false);
          if (result) return result;
        }
      }
      if (checkSiblings && this.parent) {
        for (const sibling of this.parent.children) {
          if (sibling !== this && sibling instanceof DOMElementNode) {
            const result = sibling.getFileUploadElement(false);
            if (result) return result;
          }
        }
      }
      return null;
    }
    getEnhancedCssSelector() {
      return this.enhancedCssSelectorForElement();
    }
    convertSimpleXPathToCssSelector(xpath) {
      if (!xpath) {
        return "";
      }
      const cleanXpath = xpath.replace(/^\//, "");
      const parts = cleanXpath.split("/");
      const cssParts = [];
      for (const part of parts) {
        if (!part) {
          continue;
        }
        if (part.includes(":") && !part.includes("[")) {
          const basePart = part.replace(/:/g, "\\:");
          cssParts.push(basePart);
          continue;
        }
        if (part.includes("[")) {
          const bracketIndex = part.indexOf("[");
          let basePart = part.substring(0, bracketIndex);
          if (basePart.includes(":")) {
            basePart = basePart.replace(/:/g, "\\:");
          }
          const indexPart = part.substring(bracketIndex);
          const indices = indexPart.split("]").slice(0, -1).map((i2) => i2.replace("[", ""));
          for (const idx of indices) {
            if (/^\d+$/.test(idx)) {
              try {
                const index = Number.parseInt(idx, 10) - 1;
                basePart += `:nth-of-type(${index + 1})`;
              } catch (error) {
              }
            } else if (idx === "last()") {
              basePart += ":last-of-type";
            } else if (idx.includes("position()")) {
              if (idx.includes(">1")) {
                basePart += ":nth-of-type(n+2)";
              }
            }
          }
          cssParts.push(basePart);
        } else {
          cssParts.push(part);
        }
      }
      const baseSelector = cssParts.join(" > ");
      return baseSelector;
    }
    enhancedCssSelectorForElement(includeDynamicAttributes = true) {
      try {
        if (!this.xpath) {
          return "";
        }
        let cssSelector = this.convertSimpleXPathToCssSelector(this.xpath);
        const classValue = this.attributes.class;
        if (classValue && includeDynamicAttributes) {
          const validClassNamePattern = /^[a-zA-Z_][a-zA-Z0-9_-]*$/;
          const classes = classValue.trim().split(/\s+/);
          for (const className of classes) {
            if (!className.trim()) {
              continue;
            }
            if (validClassNamePattern.test(className)) {
              cssSelector += `.${className}`;
            }
          }
        }
        const SAFE_ATTRIBUTES = /* @__PURE__ */ new Set([
          // Data attributes (if they're stable in your application)
          "id",
          // Standard HTML attributes
          "name",
          "type",
          "placeholder",
          // Accessibility attributes
          "aria-label",
          "aria-labelledby",
          "aria-describedby",
          "role",
          // Common form attributes
          "for",
          "autocomplete",
          "required",
          "readonly",
          // Media attributes
          "alt",
          "title",
          "src",
          // Custom stable attributes
          "href",
          "target"
        ]);
        if (includeDynamicAttributes) {
          SAFE_ATTRIBUTES.add("data-id");
          SAFE_ATTRIBUTES.add("data-qa");
          SAFE_ATTRIBUTES.add("data-cy");
          SAFE_ATTRIBUTES.add("data-testid");
        }
        for (const [attribute, value] of Object.entries(this.attributes)) {
          if (attribute === "class") {
            continue;
          }
          if (!attribute.trim()) {
            continue;
          }
          if (!SAFE_ATTRIBUTES.has(attribute)) {
            continue;
          }
          const safeAttribute = attribute.replace(":", "\\:");
          if (value === "") {
            cssSelector += `[${safeAttribute}]`;
          } else if (/["'<>`\n\r\t]/.test(value)) {
            const collapsedValue = value.replace(/\s+/g, " ").trim();
            const safeValue = collapsedValue.replace(/"/g, '\\"');
            cssSelector += `[${safeAttribute}*="${safeValue}"]`;
          } else {
            cssSelector += `[${safeAttribute}="${value}"]`;
          }
        }
        return cssSelector;
      } catch (error) {
        const tagName = this.tagName || "*";
        return `${tagName}[highlightIndex='${this.highlightIndex}']`;
      }
    }
  }
  async function calcBranchPathHashSet(state) {
    const pathHashes = new Set(
      await Promise.all(Array.from(state.selectorMap.values()).map(async (value) => (await value.hash()).branchPathHash))
    );
    return pathHashes;
  }
  const logger$a = createLogger("DOMService");
  async function getClickableElements$1(tabId, url, highlightElements = true, focusElement = -1, viewportExpansion = 0, debugMode = false) {
    const [elementTree, selectorMap] = await _buildDomTree(
      tabId,
      url,
      highlightElements,
      focusElement,
      viewportExpansion,
      debugMode
    );
    return { elementTree, selectorMap };
  }
  async function _buildDomTree(tabId, url, highlightElements = true, focusElement = -1, viewportExpansion = 0, debugMode = false) {
    var _a3;
    if (url === "about:blank") {
      const elementTree = new DOMElementNode({
        tagName: "body",
        xpath: "",
        attributes: {},
        children: [],
        isVisible: false,
        isInteractive: false,
        isTopElement: false,
        isInViewport: false,
        parent: null
      });
      return [elementTree, /* @__PURE__ */ new Map()];
    }
    const results = await chrome.scripting.executeScript({
      target: { tabId },
      func: (args) => {
        return window.buildDomTree(args);
      },
      args: [
        {
          doHighlightElements: highlightElements,
          focusHighlightIndex: focusElement,
          viewportExpansion,
          debugMode
        }
      ]
    });
    const evalPage = (_a3 = results[0]) == null ? void 0 : _a3.result;
    if (!evalPage || !evalPage.map || !evalPage.rootId) {
      throw new Error("Failed to build DOM tree: No result returned or invalid structure");
    }
    if (debugMode && evalPage.perfMetrics) {
      logger$a.debug("DOM Tree Building Performance Metrics:", evalPage.perfMetrics);
    }
    return _constructDomTree(evalPage);
  }
  function _constructDomTree(evalPage) {
    const jsNodeMap = evalPage.map;
    const jsRootId = evalPage.rootId;
    const selectorMap = /* @__PURE__ */ new Map();
    const nodeMap = {};
    for (const [id, nodeData] of Object.entries(jsNodeMap)) {
      const [node] = _parse_node(nodeData);
      if (node === null) {
        continue;
      }
      nodeMap[id] = node;
      if (node instanceof DOMElementNode && node.highlightIndex !== void 0 && node.highlightIndex !== null) {
        selectorMap.set(node.highlightIndex, node);
      }
    }
    for (const [id, node] of Object.entries(nodeMap)) {
      if (node instanceof DOMElementNode) {
        const nodeData = jsNodeMap[id];
        const childrenIds = "children" in nodeData ? nodeData.children : [];
        for (const childId of childrenIds) {
          if (!(childId in nodeMap)) {
            continue;
          }
          const childNode = nodeMap[childId];
          childNode.parent = node;
          node.children.push(childNode);
        }
      }
    }
    const htmlToDict = nodeMap[jsRootId];
    if (htmlToDict === void 0 || !(htmlToDict instanceof DOMElementNode)) {
      throw new Error("Failed to parse HTML to dictionary");
    }
    return [htmlToDict, selectorMap];
  }
  function _parse_node(nodeData) {
    if (!nodeData) {
      return [null, []];
    }
    if ("type" in nodeData && nodeData.type === "TEXT_NODE") {
      const textNode = new DOMTextNode(nodeData.text, nodeData.isVisible, null);
      return [textNode, []];
    }
    const elementData = nodeData;
    let viewportInfo = void 0;
    if ("viewport" in nodeData && typeof nodeData.viewport === "object" && nodeData.viewport) {
      const viewportObj = nodeData.viewport;
      viewportInfo = {
        width: viewportObj.width,
        height: viewportObj.height,
        scrollX: 0,
        scrollY: 0
      };
    }
    const elementNode = new DOMElementNode({
      tagName: elementData.tagName,
      xpath: elementData.xpath,
      attributes: elementData.attributes ?? {},
      children: [],
      isVisible: elementData.isVisible ?? false,
      isInteractive: elementData.isInteractive ?? false,
      isTopElement: elementData.isTopElement ?? false,
      isInViewport: elementData.isInViewport ?? false,
      highlightIndex: elementData.highlightIndex ?? null,
      shadowRoot: elementData.shadowRoot ?? false,
      parent: null,
      viewportInfo
    });
    const childrenIds = elementData.children || [];
    return [elementNode, childrenIds];
  }
  async function removeHighlights(tabId) {
    try {
      await chrome.scripting.executeScript({
        target: { tabId },
        func: () => {
          const container = document.getElementById("playwright-highlight-container");
          if (container) {
            container.remove();
          }
          const highlightedElements = document.querySelectorAll('[browser-user-highlight-id^="playwright-highlight-"]');
          for (const el of Array.from(highlightedElements)) {
            el.removeAttribute("browser-user-highlight-id");
          }
        }
      });
    } catch (error) {
      logger$a.error("Failed to remove highlights:", error);
    }
  }
  async function getScrollInfo(tabId) {
    var _a3;
    const results = await chrome.scripting.executeScript({
      target: { tabId },
      func: () => {
        const scroll_y = window.scrollY;
        const viewport_height = window.innerHeight;
        const total_height = document.documentElement.scrollHeight;
        return {
          pixels_above: scroll_y,
          pixels_below: total_height - (scroll_y + viewport_height)
        };
      }
    });
    const result = (_a3 = results[0]) == null ? void 0 : _a3.result;
    if (!result) {
      throw new Error("Failed to get scroll information");
    }
    return [result.pixels_above, result.pixels_below];
  }
  async function getClickableElementsHashes(domElement) {
    const clickableElements = getClickableElements(domElement);
    const hashPromises = clickableElements.map((element) => hashDomElement(element));
    const hashes = await Promise.all(hashPromises);
    return new Set(hashes);
  }
  function getClickableElements(domElement) {
    const clickableElements = [];
    for (const child of domElement.children) {
      if (child instanceof DOMElementNode) {
        if (child.highlightIndex !== null) {
          clickableElements.push(child);
        }
        clickableElements.push(...getClickableElements(child));
      }
    }
    return clickableElements;
  }
  async function hashDomElement(domElement) {
    const parentBranchPath = _getParentBranchPath(domElement);
    const [branchPathHash, attributesHash, xpathHash] = await Promise.all([
      _parentBranchPathHash(parentBranchPath),
      _attributesHash(domElement.attributes),
      _xpathHash(domElement.xpath)
      // _textHash(domElement) // Uncomment if needed
    ]);
    return _hashString(`${branchPathHash}-${attributesHash}-${xpathHash}`);
  }
  function _getParentBranchPath(domElement) {
    const parents = [];
    let currentElement = domElement;
    while ((currentElement == null ? void 0 : currentElement.parent) !== null) {
      parents.push(currentElement);
      currentElement = currentElement.parent;
    }
    parents.reverse();
    return parents.map((parent) => parent.tagName || "");
  }
  async function _parentBranchPathHash(parentBranchPath) {
    const parentBranchPathString = parentBranchPath.join("/");
    return createSHA256Hash(parentBranchPathString);
  }
  async function _attributesHash(attributes) {
    const attributesString = Object.entries(attributes).map(([key, value]) => `${key}=${value}`).join("");
    return createSHA256Hash(attributesString);
  }
  async function _xpathHash(xpath) {
    return createSHA256Hash(xpath || "");
  }
  async function createSHA256Hash(input) {
    const encoder = new TextEncoder();
    const data = encoder.encode(input);
    const hashBuffer = await crypto.subtle.digest("SHA-256", data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  function _hashString(string) {
    return string;
  }
  const ClickableElementProcessor = {
    getClickableElementsHashes,
    getClickableElements,
    hashDomElement
  };
  const logger$9 = createLogger("Page");
  function build_initial_state(tabId, url, title) {
    return {
      elementTree: new DOMElementNode({
        tagName: "root",
        isVisible: true,
        parent: null,
        xpath: "",
        attributes: {},
        children: []
      }),
      selectorMap: /* @__PURE__ */ new Map(),
      tabId: tabId || 0,
      url: url || "",
      title: title || "",
      screenshot: null,
      pixelsAbove: 0,
      pixelsBelow: 0
    };
  }
  class CachedStateClickableElementsHashes {
    constructor(url, hashes) {
      this.url = url;
      this.hashes = hashes;
    }
  }
  let Page$3 = class Page {
    constructor(tabId, url, title, config2 = {}) {
      this._browser = null;
      this._puppeteerPage = null;
      this._validWebPage = false;
      this._cachedState = null;
      this._cachedStateClickableElementsHashes = null;
      this._tabId = tabId;
      this._config = { ...DEFAULT_BROWSER_CONTEXT_CONFIG, ...config2 };
      this._state = build_initial_state(tabId, url, title);
      this._validWebPage = tabId && url && url.startsWith("http") || false;
    }
    get tabId() {
      return this._tabId;
    }
    get validWebPage() {
      return this._validWebPage;
    }
    get attached() {
      return this._validWebPage && this._puppeteerPage !== null;
    }
    async attachPuppeteer() {
      if (!this._validWebPage) {
        return false;
      }
      if (this._puppeteerPage) {
        return true;
      }
      logger$9.info("attaching puppeteer", this._tabId);
      const browser2 = await connect({
        transport: await ExtensionTransport.connectTab(this._tabId),
        defaultViewport: null,
        protocol: "cdp"
      });
      this._browser = browser2;
      const [page] = await browser2.pages();
      this._puppeteerPage = page;
      await this._addAntiDetectionScripts();
      return true;
    }
    async _addAntiDetectionScripts() {
      if (!this._puppeteerPage) {
        return;
      }
      await this._puppeteerPage.evaluateOnNewDocument(`
      // Webdriver property
      Object.defineProperty(navigator, 'webdriver', {
        get: () => undefined
      });

      // Languages
      // Object.defineProperty(navigator, 'languages', {
      //   get: () => ['en-US']
      // });

      // Plugins
      // Object.defineProperty(navigator, 'plugins', {
      //   get: () => [1, 2, 3, 4, 5]
      // });

      // Chrome runtime
      window.chrome = { runtime: {} };

      // Permissions
      const originalQuery = window.navigator.permissions.query;
      window.navigator.permissions.query = (parameters) => (
        parameters.name === 'notifications' ?
          Promise.resolve({ state: Notification.permission }) :
          originalQuery(parameters)
      );

      // Shadow DOM
      (function () {
        const originalAttachShadow = Element.prototype.attachShadow;
        Element.prototype.attachShadow = function attachShadow(options) {
          return originalAttachShadow.call(this, { ...options, mode: "open" });
        };
      })();
    `);
    }
    async detachPuppeteer() {
      if (this._browser) {
        await this._browser.disconnect();
        this._browser = null;
        this._puppeteerPage = null;
        this._state = build_initial_state(this._tabId);
      }
    }
    async removeHighlight() {
      if (this._config.highlightElements && this._validWebPage) {
        await removeHighlights(this._tabId);
      }
    }
    async getClickableElements(focusElement) {
      if (!this._validWebPage) {
        return null;
      }
      return getClickableElements$1(
        this._tabId,
        this.url(),
        this._config.highlightElements,
        focusElement,
        this._config.viewportExpansion
      );
    }
    // Get scroll position information for the current page.
    async getScrollInfo() {
      if (!this._validWebPage) {
        return [0, 0];
      }
      return getScrollInfo(this._tabId);
    }
    async getContent() {
      if (!this._puppeteerPage) {
        throw new Error("Puppeteer page is not connected");
      }
      return await this._puppeteerPage.content();
    }
    async getState(cacheClickableElementsHashes = false) {
      if (!this._validWebPage) {
        return build_initial_state(this._tabId);
      }
      await this.waitForPageAndFramesLoad();
      const updatedState = await this._updateState();
      if (cacheClickableElementsHashes) {
        if (this._cachedStateClickableElementsHashes && this._cachedStateClickableElementsHashes.url === updatedState.url) {
          const updatedStateClickableElements = ClickableElementProcessor.getClickableElements(updatedState.elementTree);
          for (const domElement of updatedStateClickableElements) {
            const hash = await ClickableElementProcessor.hashDomElement(domElement);
            domElement.isNew = !this._cachedStateClickableElementsHashes.hashes.has(hash);
          }
        }
        const newHashes = await ClickableElementProcessor.getClickableElementsHashes(updatedState.elementTree);
        this._cachedStateClickableElementsHashes = new CachedStateClickableElementsHashes(updatedState.url, newHashes);
      }
      this._cachedState = updatedState;
      return updatedState;
    }
    async _updateState(useVision = true, focusElement = -1) {
      var _a3, _b2, _c2;
      try {
        await this._puppeteerPage.evaluate("1");
      } catch (error) {
        logger$9.warning("Current page is no longer accessible:", error);
        if (this._browser) {
          const pages = await this._browser.pages();
          if (pages.length > 0) {
            this._puppeteerPage = pages[0];
          } else {
            throw new Error("Browser closed: no valid pages available");
          }
        }
      }
      try {
        await this.removeHighlight();
        const content = await this.getClickableElements(focusElement);
        if (!content) {
          logger$9.warning("Failed to get clickable elements");
          return this._state;
        }
        if ("selectorMap" in content) {
          logger$9.debug("content.selectorMap:", content.selectorMap.size);
        } else {
          logger$9.debug("content.selectorMap: not found");
        }
        if ("elementTree" in content) {
          logger$9.debug("content.elementTree:", (_a3 = content.elementTree) == null ? void 0 : _a3.tagName);
        } else {
          logger$9.debug("content.elementTree: not found");
        }
        const screenshot = useVision ? await this.takeScreenshot() : null;
        const [pixelsAbove, pixelsBelow] = await this.getScrollInfo();
        this._state.elementTree = content.elementTree;
        this._state.selectorMap = content.selectorMap;
        this._state.url = ((_b2 = this._puppeteerPage) == null ? void 0 : _b2.url()) || "";
        this._state.title = await ((_c2 = this._puppeteerPage) == null ? void 0 : _c2.title()) || "";
        this._state.screenshot = screenshot;
        this._state.pixelsAbove = pixelsAbove;
        this._state.pixelsBelow = pixelsBelow;
        return this._state;
      } catch (error) {
        logger$9.error("Failed to update state:", error);
        return this._state;
      }
    }
    async takeScreenshot(fullPage = false) {
      if (!this._puppeteerPage) {
        throw new Error("Puppeteer page is not connected");
      }
      try {
        await this._puppeteerPage.evaluate(() => {
          const styleId = "puppeteer-disable-animations";
          if (!document.getElementById(styleId)) {
            const style = document.createElement("style");
            style.id = styleId;
            style.textContent = `
            *, *::before, *::after {
              animation: none !important;
              transition: none !important;
            }
          `;
            document.head.appendChild(style);
          }
        });
        const screenshot = await this._puppeteerPage.screenshot({
          fullPage,
          encoding: "base64",
          type: "jpeg",
          quality: 80
          // Good balance between quality and file size
        });
        await this._puppeteerPage.evaluate(() => {
          const style = document.getElementById("puppeteer-disable-animations");
          if (style) {
            style.remove();
          }
        });
        return screenshot;
      } catch (error) {
        logger$9.error("Failed to take screenshot:", error);
        throw error;
      }
    }
    url() {
      if (this._puppeteerPage) {
        return this._puppeteerPage.url();
      }
      return this._state.url;
    }
    async title() {
      if (this._puppeteerPage) {
        return await this._puppeteerPage.title();
      }
      return this._state.title;
    }
    async navigateTo(url) {
      var _a3;
      if (!this._puppeteerPage) {
        return;
      }
      logger$9.info("navigateTo", url);
      if (!this._isUrlAllowed(url)) {
        const errorMessage = `Navigation to URL: ${url} is not allowed. Only these domains are allowed: ${(_a3 = this._config.allowedDomains) == null ? void 0 : _a3.join(", ")}`;
        logger$9.error(errorMessage);
        throw new URLNotAllowedError(errorMessage);
      }
      try {
        await Promise.all([this.waitForPageAndFramesLoad(), this._puppeteerPage.goto(url)]);
        logger$9.info("navigateTo complete");
      } catch (error) {
        if (error instanceof URLNotAllowedError) {
          throw error;
        }
        if (error instanceof Error && error.message.includes("timeout")) {
          logger$9.warning("Navigation timeout, but page might still be usable:", error);
          return;
        }
        logger$9.error("Navigation failed:", error);
        throw error;
      }
    }
    async refreshPage() {
      if (!this._puppeteerPage) return;
      try {
        await Promise.all([this.waitForPageAndFramesLoad(), this._puppeteerPage.reload()]);
        logger$9.info("Page refresh complete");
      } catch (error) {
        if (error instanceof URLNotAllowedError) {
          throw error;
        }
        if (error instanceof Error && error.message.includes("timeout")) {
          logger$9.warning("Refresh timeout, but page might still be usable:", error);
          return;
        }
        logger$9.error("Page refresh failed:", error);
        throw error;
      }
    }
    async goBack() {
      if (!this._puppeteerPage) return;
      try {
        await Promise.all([this.waitForPageAndFramesLoad(), this._puppeteerPage.goBack()]);
        logger$9.info("Navigation back completed");
      } catch (error) {
        if (error instanceof URLNotAllowedError) {
          throw error;
        }
        if (error instanceof Error && error.message.includes("timeout")) {
          logger$9.warning("Back navigation timeout, but page might still be usable:", error);
          return;
        }
        logger$9.error("Could not navigate back:", error);
        throw error;
      }
    }
    async goForward() {
      if (!this._puppeteerPage) return;
      try {
        await Promise.all([this.waitForPageAndFramesLoad(), this._puppeteerPage.goForward()]);
        logger$9.info("Navigation forward completed");
      } catch (error) {
        if (error instanceof URLNotAllowedError) {
          throw error;
        }
        if (error instanceof Error && error.message.includes("timeout")) {
          logger$9.warning("Forward navigation timeout, but page might still be usable:", error);
          return;
        }
        logger$9.error("Could not navigate forward:", error);
        throw error;
      }
    }
    async scrollDown(amount) {
      var _a3, _b2;
      if (this._puppeteerPage) {
        if (amount) {
          await ((_a3 = this._puppeteerPage) == null ? void 0 : _a3.evaluate(`window.scrollBy(0, ${amount});`));
        } else {
          await ((_b2 = this._puppeteerPage) == null ? void 0 : _b2.evaluate("window.scrollBy(0, window.innerHeight);"));
        }
      }
    }
    async scrollUp(amount) {
      var _a3, _b2;
      if (this._puppeteerPage) {
        if (amount) {
          await ((_a3 = this._puppeteerPage) == null ? void 0 : _a3.evaluate(`window.scrollBy(0, -${amount});`));
        } else {
          await ((_b2 = this._puppeteerPage) == null ? void 0 : _b2.evaluate("window.scrollBy(0, -window.innerHeight);"));
        }
      }
    }
    async sendKeys(keys) {
      if (!this._puppeteerPage) {
        throw new Error("Puppeteer page is not connected");
      }
      const keyParts = keys.split("+");
      const modifiers = keyParts.slice(0, -1);
      const mainKey = keyParts[keyParts.length - 1];
      try {
        for (const modifier of modifiers) {
          await this._puppeteerPage.keyboard.down(this._convertKey(modifier));
        }
        await Promise.all([
          this._puppeteerPage.keyboard.press(this._convertKey(mainKey)),
          this.waitForPageAndFramesLoad()
        ]);
        logger$9.info("sendKeys complete", keys);
      } catch (error) {
        logger$9.error("Failed to send keys:", error);
        throw new Error(`Failed to send keys: ${error instanceof Error ? error.message : String(error)}`);
      } finally {
        for (const modifier of [...modifiers].reverse()) {
          try {
            await this._puppeteerPage.keyboard.up(this._convertKey(modifier));
          } catch (releaseError) {
            logger$9.error("Failed to release modifier:", modifier, releaseError);
          }
        }
      }
    }
    _convertKey(key) {
      const lowerKey = key.trim().toLowerCase();
      const isMac = navigator.userAgent.toLowerCase().includes("mac os x");
      if (isMac) {
        if (lowerKey === "control" || lowerKey === "ctrl") {
          return "Meta";
        }
        if (lowerKey === "command" || lowerKey === "cmd") {
          return "Meta";
        }
        if (lowerKey === "option" || lowerKey === "opt") {
          return "Alt";
        }
      }
      const keyMap = {
        // Letters
        a: "KeyA",
        b: "KeyB",
        c: "KeyC",
        d: "KeyD",
        e: "KeyE",
        f: "KeyF",
        g: "KeyG",
        h: "KeyH",
        i: "KeyI",
        j: "KeyJ",
        k: "KeyK",
        l: "KeyL",
        m: "KeyM",
        n: "KeyN",
        o: "KeyO",
        p: "KeyP",
        q: "KeyQ",
        r: "KeyR",
        s: "KeyS",
        t: "KeyT",
        u: "KeyU",
        v: "KeyV",
        w: "KeyW",
        x: "KeyX",
        y: "KeyY",
        z: "KeyZ",
        // Numbers
        "0": "Digit0",
        "1": "Digit1",
        "2": "Digit2",
        "3": "Digit3",
        "4": "Digit4",
        "5": "Digit5",
        "6": "Digit6",
        "7": "Digit7",
        "8": "Digit8",
        "9": "Digit9",
        // Special keys
        control: "Control",
        shift: "Shift",
        alt: "Alt",
        meta: "Meta",
        enter: "Enter",
        backspace: "Backspace",
        delete: "Delete",
        arrowleft: "ArrowLeft",
        arrowright: "ArrowRight",
        arrowup: "ArrowUp",
        arrowdown: "ArrowDown",
        escape: "Escape",
        tab: "Tab",
        space: "Space"
      };
      const convertedKey = keyMap[lowerKey] || key;
      logger$9.info("convertedKey", convertedKey);
      return convertedKey;
    }
    async scrollToText(text) {
      if (!this._puppeteerPage) {
        throw new Error("Puppeteer is not connected");
      }
      try {
        const selectors = [
          // Using text selector (equivalent to get_by_text)
          `::-p-text(${text})`,
          // Using XPath selector (contains text) - case insensitive
          `::-p-xpath(//*[contains(translate(text(), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), '${text.toLowerCase()}')])`
        ];
        for (const selector of selectors) {
          try {
            const element = await this._puppeteerPage.$(selector);
            if (element) {
              const isVisible = await element.evaluate((el) => {
                const style = window.getComputedStyle(el);
                return style.display !== "none" && style.visibility !== "hidden" && style.opacity !== "0";
              });
              if (isVisible) {
                await this._scrollIntoViewIfNeeded(element);
                await new Promise((resolve) => setTimeout(resolve, 500));
                return true;
              }
            }
          } catch (e) {
            logger$9.debug(`Locator attempt failed: ${e}`);
          }
        }
        return false;
      } catch (error) {
        throw new Error(error instanceof Error ? error.message : String(error));
      }
    }
    async getDropdownOptions(index) {
      const selectorMap = this.getSelectorMap();
      const element = selectorMap == null ? void 0 : selectorMap.get(index);
      if (!element || !this._puppeteerPage) {
        throw new Error("Element not found or puppeteer is not connected");
      }
      try {
        const elementHandle = await this.locateElement(element);
        if (!elementHandle) {
          throw new Error("Dropdown element not found");
        }
        const options = await elementHandle.evaluate((select) => {
          if (!(select instanceof HTMLSelectElement)) {
            throw new Error("Element is not a select element");
          }
          return Array.from(select.options).map((option) => ({
            index: option.index,
            text: option.text,
            // Not trimming to maintain exact match for selection
            value: option.value
          }));
        });
        if (!options.length) {
          throw new Error("No options found in dropdown");
        }
        return options;
      } catch (error) {
        throw new Error(`Failed to get dropdown options: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
    async selectDropdownOption(index, text) {
      var _a3;
      const selectorMap = this.getSelectorMap();
      const element = selectorMap == null ? void 0 : selectorMap.get(index);
      if (!element || !this._puppeteerPage) {
        throw new Error("Element not found or puppeteer is not connected");
      }
      logger$9.debug(`Element attributes: ${JSON.stringify(element.attributes)}`);
      logger$9.debug(`Element tag: ${element.tagName}`);
      if (((_a3 = element.tagName) == null ? void 0 : _a3.toLowerCase()) !== "select") {
        const msg = `Cannot select option: Element with index ${index} is a ${element.tagName}, not a SELECT`;
        logger$9.error(msg);
        throw new Error(msg);
      }
      try {
        const elementHandle = await this.locateElement(element);
        if (!elementHandle) {
          throw new Error(`Dropdown element with index ${index} not found`);
        }
        const result = await elementHandle.evaluate(
          (select, optionText, elementIndex) => {
            if (!(select instanceof HTMLSelectElement)) {
              return {
                found: false,
                message: `Element with index ${elementIndex} is not a SELECT`
              };
            }
            const options = Array.from(select.options);
            const option = options.find((opt) => opt.text.trim() === optionText);
            if (!option) {
              const availableOptions = options.map((o) => o.text.trim()).join('", "');
              return {
                found: false,
                message: `Option "${optionText}" not found in dropdown element with index ${elementIndex}. Available options: "${availableOptions}"`
              };
            }
            const previousValue = select.value;
            select.value = option.value;
            if (previousValue !== option.value) {
              select.dispatchEvent(new Event("change", { bubbles: true }));
              select.dispatchEvent(new Event("input", { bubbles: true }));
            }
            return {
              found: true,
              message: `Selected option "${optionText}" with value "${option.value}"`
            };
          },
          text,
          index
        );
        logger$9.debug("Selection result:", result);
        return result.message;
      } catch (error) {
        const errorMessage = `${error instanceof Error ? error.message : String(error)}`;
        logger$9.error(errorMessage);
        throw new Error(errorMessage);
      }
    }
    async locateElement(element) {
      if (!this._puppeteerPage) {
        logger$9.warning("Puppeteer is not connected");
        return null;
      }
      let currentFrame = this._puppeteerPage;
      const parents = [];
      let current = element;
      while (current.parent) {
        parents.push(current.parent);
        current = current.parent;
      }
      const iframes = parents.reverse().filter((item) => item.tagName === "iframe");
      for (const parent of iframes) {
        const cssSelector2 = parent.enhancedCssSelectorForElement(this._config.includeDynamicAttributes);
        const frameElement = await currentFrame.$(cssSelector2);
        if (!frameElement) {
          logger$9.warning(`Could not find iframe with selector: ${cssSelector2}`);
          return null;
        }
        const frame = await frameElement.contentFrame();
        if (!frame) {
          logger$9.warning(`Could not access frame content for selector: ${cssSelector2}`);
          return null;
        }
        currentFrame = frame;
      }
      const cssSelector = element.enhancedCssSelectorForElement(this._config.includeDynamicAttributes);
      try {
        const elementHandle = await currentFrame.$(cssSelector);
        if (elementHandle) {
          const isHidden = await elementHandle.isHidden();
          if (!isHidden) {
            await this._scrollIntoViewIfNeeded(elementHandle);
          }
          return elementHandle;
        }
      } catch (error) {
        logger$9.error("Failed to locate element:", error);
      }
      return null;
    }
    async inputTextElementNode(useVision, elementNode, text) {
      if (!this._puppeteerPage) {
        throw new Error("Puppeteer is not connected");
      }
      try {
        const element = await this.locateElement(elementNode);
        if (!element) {
          throw new Error(`Element: ${elementNode} not found`);
        }
        try {
          await this._waitForElementStability(element, 1e3);
          const isHidden = await element.isHidden();
          if (!isHidden) {
            await this._scrollIntoViewIfNeeded(element, 1e3);
          }
        } catch (e) {
          logger$9.debug(`Non-critical error preparing element: ${e}`);
        }
        const tagName = await element.evaluate((el) => el.tagName.toLowerCase());
        const isContentEditable = await element.evaluate((el) => {
          if (el instanceof HTMLElement) {
            return el.isContentEditable;
          }
          return false;
        });
        const isReadOnly = await element.evaluate((el) => {
          if (el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement) {
            return el.readOnly;
          }
          return false;
        });
        const isDisabled = await element.evaluate((el) => {
          if (el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement) {
            return el.disabled;
          }
          return false;
        });
        if ((isContentEditable || tagName === "input") && !isReadOnly && !isDisabled) {
          await element.evaluate((el) => {
            if (el instanceof HTMLElement) {
              el.textContent = "";
            }
            if ("value" in el) {
              el.value = "";
            }
            el.dispatchEvent(new Event("input", { bubbles: true }));
            el.dispatchEvent(new Event("change", { bubbles: true }));
          });
          await element.type(text, { delay: 5 });
        } else {
          await element.evaluate((el, value) => {
            if (el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement) {
              el.value = value;
            } else if (el instanceof HTMLElement && el.isContentEditable) {
              el.textContent = value;
            }
            el.dispatchEvent(new Event("input", { bubbles: true }));
            el.dispatchEvent(new Event("change", { bubbles: true }));
          }, text);
        }
        await this.waitForPageAndFramesLoad();
      } catch (error) {
        const errorMsg = `Failed to input text into element: ${elementNode}. Error: ${error instanceof Error ? error.message : String(error)}`;
        logger$9.error(errorMsg);
        throw new Error(errorMsg);
      }
    }
    /**
     * Wait for an element to become stable (no position/size changes)
     * Similar to Playwright's wait_for_element_state('stable')
     */
    async _waitForElementStability(element, timeout2 = 1e3) {
      const startTime = Date.now();
      let lastRect = await element.boundingBox();
      while (Date.now() - startTime < timeout2) {
        await new Promise((resolve) => setTimeout(resolve, 50));
        const currentRect = await element.boundingBox();
        if (!currentRect) {
          break;
        }
        if (lastRect && Math.abs(lastRect.x - currentRect.x) < 2 && Math.abs(lastRect.y - currentRect.y) < 2 && Math.abs(lastRect.width - currentRect.width) < 2 && Math.abs(lastRect.height - currentRect.height) < 2) {
          await new Promise((resolve) => setTimeout(resolve, 50));
          return;
        }
        lastRect = currentRect;
      }
    }
    async _scrollIntoViewIfNeeded(element, timeout2 = 1e3) {
      const startTime = Date.now();
      while (true) {
        const isVisible = await element.evaluate((el) => {
          const rect = el.getBoundingClientRect();
          if (rect.width === 0 || rect.height === 0) return false;
          const style = window.getComputedStyle(el);
          if (style.visibility === "hidden" || style.display === "none" || style.opacity === "0") {
            return false;
          }
          const isInViewport = rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth);
          if (!isInViewport) {
            el.scrollIntoView({
              behavior: "auto",
              block: "center",
              inline: "center"
            });
            return false;
          }
          return true;
        });
        if (isVisible) break;
        if (Date.now() - startTime > timeout2) {
          throw new Error("Timed out while trying to scroll element into view");
        }
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
    }
    async clickElementNode(useVision, elementNode) {
      if (!this._puppeteerPage) {
        throw new Error("Puppeteer is not connected");
      }
      try {
        const element = await this.locateElement(elementNode);
        if (!element) {
          throw new Error(`Element: ${elementNode} not found`);
        }
        await this._scrollIntoViewIfNeeded(element);
        try {
          await Promise.race([
            element.click(),
            new Promise((_, reject) => setTimeout(() => reject(new Error("Click timeout")), 2e3))
          ]);
          await this._checkAndHandleNavigation();
        } catch (error) {
          if (error instanceof URLNotAllowedError) {
            throw error;
          }
          logger$9.info("Failed to click element, trying again", error);
          try {
            await element.evaluate((el) => el.click());
          } catch (secondError) {
            if (secondError instanceof URLNotAllowedError) {
              throw secondError;
            }
            throw new Error(
              `Failed to click element: ${secondError instanceof Error ? secondError.message : String(secondError)}`
            );
          }
        }
      } catch (error) {
        throw new Error(
          `Failed to click element: ${elementNode}. Error: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    }
    getSelectorMap() {
      if (this._cachedState === null) {
        return /* @__PURE__ */ new Map();
      }
      return this._cachedState.selectorMap;
    }
    async getElementByIndex(index) {
      const selectorMap = this.getSelectorMap();
      const element = selectorMap.get(index);
      if (!element) return null;
      return await this.locateElement(element);
    }
    getDomElementByIndex(index) {
      const selectorMap = this.getSelectorMap();
      return selectorMap.get(index) || null;
    }
    isFileUploader(elementNode, maxDepth = 3, currentDepth = 0) {
      var _a3;
      if (currentDepth > maxDepth) {
        return false;
      }
      if (elementNode.tagName === "input") {
        const attributes = elementNode.attributes;
        if (((_a3 = attributes["type"]) == null ? void 0 : _a3.toLowerCase()) === "file" || !!attributes["accept"]) {
          return true;
        }
      }
      if (elementNode.children && currentDepth < maxDepth) {
        for (const child of elementNode.children) {
          if ("tagName" in child) {
            if (this.isFileUploader(child, maxDepth, currentDepth + 1)) {
              return true;
            }
          }
        }
      }
      return false;
    }
    async waitForPageLoadState(timeout2) {
      var _a3;
      const timeoutValue = timeout2 || 8e3;
      await ((_a3 = this._puppeteerPage) == null ? void 0 : _a3.waitForNavigation({ timeout: timeoutValue }));
    }
    async _waitForStableNetwork() {
      if (!this._puppeteerPage) {
        throw new Error("Puppeteer page is not connected");
      }
      const RELEVANT_RESOURCE_TYPES = /* @__PURE__ */ new Set(["document", "stylesheet", "image", "font", "script", "iframe"]);
      const RELEVANT_CONTENT_TYPES = /* @__PURE__ */ new Set([
        "text/html",
        "text/css",
        "application/javascript",
        "image/",
        "font/",
        "application/json"
      ]);
      const IGNORED_URL_PATTERNS = /* @__PURE__ */ new Set([
        // Analytics and tracking
        "analytics",
        "tracking",
        "telemetry",
        "beacon",
        "metrics",
        // Ad-related
        "doubleclick",
        "adsystem",
        "adserver",
        "advertising",
        // Social media widgets
        "facebook.com/plugins",
        "platform.twitter",
        "linkedin.com/embed",
        // Live chat and support
        "livechat",
        "zendesk",
        "intercom",
        "crisp.chat",
        "hotjar",
        // Push notifications
        "push-notifications",
        "onesignal",
        "pushwoosh",
        // Background sync/heartbeat
        "heartbeat",
        "ping",
        "alive",
        // WebRTC and streaming
        "webrtc",
        "rtmp://",
        "wss://",
        // Common CDNs
        "cloudfront.net",
        "fastly.net"
      ]);
      const pendingRequests = /* @__PURE__ */ new Set();
      let lastActivity = Date.now();
      const onRequest = (request) => {
        const resourceType = request.resourceType();
        if (!RELEVANT_RESOURCE_TYPES.has(resourceType)) {
          return;
        }
        if (["websocket", "media", "eventsource", "manifest", "other"].includes(resourceType)) {
          return;
        }
        const url = request.url().toLowerCase();
        if (Array.from(IGNORED_URL_PATTERNS).some((pattern) => url.includes(pattern))) {
          return;
        }
        if (url.startsWith("data:") || url.startsWith("blob:")) {
          return;
        }
        const headers = request.headers();
        if (
          // biome-ignore lint/complexity/useLiteralKeys: <explanation>
          headers["purpose"] === "prefetch" || headers["sec-fetch-dest"] === "video" || headers["sec-fetch-dest"] === "audio"
        ) {
          return;
        }
        pendingRequests.add(request);
        lastActivity = Date.now();
      };
      const onResponse = (response) => {
        var _a3;
        const request = response.request();
        if (!pendingRequests.has(request)) {
          return;
        }
        const contentType = ((_a3 = response.headers()["content-type"]) == null ? void 0 : _a3.toLowerCase()) || "";
        if (["streaming", "video", "audio", "webm", "mp4", "event-stream", "websocket", "protobuf"].some(
          (t) => contentType.includes(t)
        )) {
          pendingRequests.delete(request);
          return;
        }
        if (!Array.from(RELEVANT_CONTENT_TYPES).some((ct) => contentType.includes(ct))) {
          pendingRequests.delete(request);
          return;
        }
        const contentLength = response.headers()["content-length"];
        if (contentLength && Number.parseInt(contentLength) > 5 * 1024 * 1024) {
          pendingRequests.delete(request);
          return;
        }
        pendingRequests.delete(request);
        lastActivity = Date.now();
      };
      this._puppeteerPage.on("request", onRequest);
      this._puppeteerPage.on("response", onResponse);
      try {
        const startTime = Date.now();
        while (true) {
          await new Promise((resolve) => setTimeout(resolve, 100));
          const now = Date.now();
          const timeSinceLastActivity = (now - lastActivity) / 1e3;
          if (pendingRequests.size === 0 && timeSinceLastActivity >= this._config.waitForNetworkIdlePageLoadTime) {
            break;
          }
          const elapsedTime = (now - startTime) / 1e3;
          if (elapsedTime > this._config.maximumWaitPageLoadTime) {
            console.debug(
              `Network timeout after ${this._config.maximumWaitPageLoadTime}s with ${pendingRequests.size} pending requests:`,
              Array.from(pendingRequests).map((r) => r.url())
            );
            break;
          }
        }
      } finally {
        this._puppeteerPage.off("request", onRequest);
        this._puppeteerPage.off("response", onResponse);
      }
      console.debug(`Network stabilized for ${this._config.waitForNetworkIdlePageLoadTime} seconds`);
    }
    async waitForPageAndFramesLoad(timeoutOverwrite) {
      const startTime = Date.now();
      try {
        await this._waitForStableNetwork();
        if (this._puppeteerPage) {
          await this._checkAndHandleNavigation();
        }
      } catch (error) {
        if (error instanceof URLNotAllowedError) {
          throw error;
        }
        console.warn("Page load failed, continuing...", error);
      }
      const elapsed2 = (Date.now() - startTime) / 1e3;
      const minWaitTime = timeoutOverwrite || this._config.minimumWaitPageLoadTime;
      const remaining = Math.max(minWaitTime - elapsed2, 0);
      console.debug(
        `--Page loaded in ${elapsed2.toFixed(2)} seconds, waiting for additional ${remaining.toFixed(2)} seconds`
      );
      if (remaining > 0) {
        await new Promise((resolve) => setTimeout(resolve, remaining * 1e3));
      }
    }
    /**
     * Check the current page URL and handle if it's not allowed
     * @throws URLNotAllowedError if the current URL is not allowed
     */
    async _checkAndHandleNavigation() {
      var _a3;
      if (!this._puppeteerPage) {
        return;
      }
      const currentUrl = this._puppeteerPage.url();
      if (!this._isUrlAllowed(currentUrl)) {
        const errorMessage = `Navigation to URL: ${currentUrl} is not allowed. Only these domains are allowed: ${(_a3 = this._config.allowedDomains) == null ? void 0 : _a3.join(", ")}`;
        logger$9.error(errorMessage);
        const safeUrl = this._config.homePageUrl || "about:blank";
        logger$9.info(`Redirecting to safe URL: ${safeUrl}`);
        try {
          await this._puppeteerPage.goto(safeUrl);
        } catch (error) {
          logger$9.error(`Failed to redirect to safe URL: ${error instanceof Error ? error.message : String(error)}`);
        }
        throw new URLNotAllowedError(errorMessage);
      }
    }
    /**
     * Check if a URL is allowed based on the allowlist configuration.
     * @param url - The URL to check
     * @returns True if the URL is allowed, false otherwise
     */
    _isUrlAllowed(url) {
      if (!this._config.allowedDomains || this._config.allowedDomains.length === 0) {
        return true;
      }
      try {
        if (url === "about:blank") {
          return true;
        }
        const parsedUrl = new URL(url);
        let domain = parsedUrl.hostname.toLowerCase();
        if (domain.includes(":")) {
          domain = domain.split(":")[0];
        }
        return this._config.allowedDomains.some(
          (allowedDomain) => domain === allowedDomain.toLowerCase() || domain.endsWith(`.${allowedDomain.toLowerCase()}`)
        );
      } catch (error) {
        logger$9.error(`⛔️ Error checking URL allowlist: ${error instanceof Error ? error.message : String(error)}`);
        return false;
      }
    }
  };
  const logger$8 = createLogger("BrowserContext");
  class BrowserContext {
    constructor(config2) {
      this._currentTabId = null;
      this._attachedPages = /* @__PURE__ */ new Map();
      this._config = { ...DEFAULT_BROWSER_CONTEXT_CONFIG, ...config2 };
    }
    getConfig() {
      return this._config;
    }
    updateCurrentTabId(tabId) {
      this._currentTabId = tabId;
    }
    async _getOrCreatePage(tab, forceUpdate = false) {
      if (!tab.id) {
        throw new Error("Tab ID is not available");
      }
      const existingPage = this._attachedPages.get(tab.id);
      if (existingPage) {
        logger$8.info("getOrCreatePage", tab.id, "already attached");
        if (!forceUpdate) {
          return existingPage;
        }
        await existingPage.detachPuppeteer();
        this._attachedPages.delete(tab.id);
      }
      logger$8.info("getOrCreatePage", tab.id, "creating new page");
      return new Page$3(tab.id, tab.url || "", tab.title || "", this._config);
    }
    async cleanup() {
      const currentPage = await this.getCurrentPage();
      currentPage == null ? void 0 : currentPage.removeHighlight();
      for (const page of this._attachedPages.values()) {
        await page.detachPuppeteer();
      }
      this._attachedPages.clear();
      this._currentTabId = null;
    }
    async attachPage(page) {
      if (this._attachedPages.has(page.tabId)) {
        logger$8.info("attachPage", page.tabId, "already attached");
        return true;
      }
      if (await page.attachPuppeteer()) {
        logger$8.info("attachPage", page.tabId, "attached");
        this._attachedPages.set(page.tabId, page);
        return true;
      }
      return false;
    }
    async detachPage(tabId) {
      const page = this._attachedPages.get(tabId);
      if (page) {
        await page.detachPuppeteer();
        this._attachedPages.delete(tabId);
      }
    }
    async getCurrentPage() {
      if (!this._currentTabId) {
        let activeTab;
        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
        if (!(tab == null ? void 0 : tab.id)) {
          const newTab = await chrome.tabs.create({ url: this._config.homePageUrl });
          if (!newTab.id) {
            throw new Error("No tab ID available");
          }
          activeTab = newTab;
        } else {
          activeTab = tab;
        }
        logger$8.info("active tab", activeTab.id, activeTab.url, activeTab.title);
        const page = await this._getOrCreatePage(activeTab);
        await this.attachPage(page);
        this._currentTabId = activeTab.id || null;
        return page;
      }
      const existingPage = this._attachedPages.get(this._currentTabId);
      if (!existingPage) {
        const tab = await chrome.tabs.get(this._currentTabId);
        const page = await this._getOrCreatePage(tab);
        await this.attachPage(page);
        return page;
      }
      return existingPage;
    }
    /**
     * Get all tab IDs from the browser and the current window.
     * @returns A set of tab IDs.
     */
    async getAllTabIds() {
      const tabs = await chrome.tabs.query({ currentWindow: true });
      return new Set(tabs.map((tab) => tab.id).filter((id) => id !== void 0));
    }
    /**
     * Wait for tab events to occur after a tab is created or updated.
     * @param tabId - The ID of the tab to wait for events on.
     * @param options - An object containing options for the wait.
     * @returns A promise that resolves when the tab events occur.
     */
    async waitForTabEvents(tabId, options = {}) {
      const { waitForUpdate = true, waitForActivation = true, timeoutMs = 5e3 } = options;
      const promises = [];
      if (waitForUpdate) {
        const updatePromise = new Promise((resolve) => {
          let hasUrl = false;
          let hasTitle = false;
          let isComplete = false;
          const onUpdatedHandler = (updatedTabId, changeInfo) => {
            if (updatedTabId !== tabId) return;
            if (changeInfo.url) hasUrl = true;
            if (changeInfo.title) hasTitle = true;
            if (changeInfo.status === "complete") isComplete = true;
            if (hasUrl && hasTitle && isComplete) {
              chrome.tabs.onUpdated.removeListener(onUpdatedHandler);
              resolve();
            }
          };
          chrome.tabs.onUpdated.addListener(onUpdatedHandler);
          chrome.tabs.get(tabId).then((tab) => {
            if (tab.url) hasUrl = true;
            if (tab.title) hasTitle = true;
            if (tab.status === "complete") isComplete = true;
            if (hasUrl && hasTitle && isComplete) {
              chrome.tabs.onUpdated.removeListener(onUpdatedHandler);
              resolve();
            }
          });
        });
        promises.push(updatePromise);
      }
      if (waitForActivation) {
        const activatedPromise = new Promise((resolve) => {
          const onActivatedHandler = (activeInfo) => {
            if (activeInfo.tabId === tabId) {
              chrome.tabs.onActivated.removeListener(onActivatedHandler);
              resolve();
            }
          };
          chrome.tabs.onActivated.addListener(onActivatedHandler);
          chrome.tabs.get(tabId).then((tab) => {
            if (tab.active) {
              chrome.tabs.onActivated.removeListener(onActivatedHandler);
              resolve();
            }
          });
        });
        promises.push(activatedPromise);
      }
      const timeoutPromise = new Promise(
        (_, reject) => setTimeout(() => reject(new Error(`Tab operation timed out after ${timeoutMs} ms`)), timeoutMs)
      );
      await Promise.race([Promise.all(promises), timeoutPromise]);
    }
    async switchTab(tabId) {
      logger$8.info("switchTab", tabId);
      await chrome.tabs.update(tabId, { active: true });
      await this.waitForTabEvents(tabId, { waitForUpdate: false });
      const page = await this._getOrCreatePage(await chrome.tabs.get(tabId));
      await this.attachPage(page);
      this._currentTabId = tabId;
      return page;
    }
    async navigateTo(url) {
      const page = await this.getCurrentPage();
      if (!page) {
        await this.openTab(url);
        return;
      }
      if (page.attached) {
        await page.navigateTo(url);
        return;
      }
      const tabId = page.tabId;
      await chrome.tabs.update(tabId, { url, active: true });
      await this.waitForTabEvents(tabId);
      const updatedPage = await this._getOrCreatePage(await chrome.tabs.get(tabId), true);
      await this.attachPage(updatedPage);
      this._currentTabId = tabId;
    }
    async openTab(url) {
      const tab = await chrome.tabs.create({ url, active: true });
      if (!tab.id) {
        throw new Error("No tab ID available");
      }
      await this.waitForTabEvents(tab.id);
      const updatedTab = await chrome.tabs.get(tab.id);
      const page = await this._getOrCreatePage(updatedTab);
      await this.attachPage(page);
      this._currentTabId = tab.id;
      return page;
    }
    async closeTab(tabId) {
      await this.detachPage(tabId);
      await chrome.tabs.remove(tabId);
      if (this._currentTabId === tabId) {
        this._currentTabId = null;
      }
    }
    /**
     * Remove a tab from the attached pages map. This will not run detachPuppeteer.
     * @param tabId - The ID of the tab to remove.
     */
    removeAttachedPage(tabId) {
      this._attachedPages.delete(tabId);
      if (this._currentTabId === tabId) {
        this._currentTabId = null;
      }
    }
    async getTabInfos() {
      const tabs = await chrome.tabs.query({});
      const tabInfos = [];
      for (const tab of tabs) {
        if (tab.id && tab.url && tab.title) {
          tabInfos.push({
            id: tab.id,
            url: tab.url,
            title: tab.title
          });
        }
      }
      return tabInfos;
    }
    async getState() {
      const currentPage = await this.getCurrentPage();
      const pageState = !currentPage ? build_initial_state() : await currentPage.getState();
      const tabInfos = await this.getTabInfos();
      const browserState = {
        ...pageState,
        tabs: tabInfos
      };
      return browserState;
    }
    async removeHighlight() {
      const page = await this.getCurrentPage();
      if (page) {
        await page.removeHighlight();
      }
    }
  }
  var util$1;
  (function(util2) {
    util2.assertEqual = (val) => val;
    function assertIs(_arg) {
    }
    util2.assertIs = assertIs;
    function assertNever2(_x2) {
      throw new Error();
    }
    util2.assertNever = assertNever2;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
      const filtered = {};
      for (const k of validKeys) {
        filtered[k] = obj[k];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e) {
        return obj[e];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
      const keys = [];
      for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    util2.find = (arr2, checker) => {
      for (const item of arr2) {
        if (checker(item))
          return item;
      }
      return void 0;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
      return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util$1 || (util$1 = {}));
  var objectUtil$1;
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first2, second) => {
      return {
        ...first2,
        ...second
        // second overwrites first
      };
    };
  })(objectUtil$1 || (objectUtil$1 = {}));
  const ZodParsedType$1 = util$1.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  const getParsedType$1 = (data) => {
    const t = typeof data;
    switch (t) {
      case "undefined":
        return ZodParsedType$1.undefined;
      case "string":
        return ZodParsedType$1.string;
      case "number":
        return isNaN(data) ? ZodParsedType$1.nan : ZodParsedType$1.number;
      case "boolean":
        return ZodParsedType$1.boolean;
      case "function":
        return ZodParsedType$1.function;
      case "bigint":
        return ZodParsedType$1.bigint;
      case "symbol":
        return ZodParsedType$1.symbol;
      case "object":
        if (Array.isArray(data)) {
          return ZodParsedType$1.array;
        }
        if (data === null) {
          return ZodParsedType$1.null;
        }
        if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
          return ZodParsedType$1.promise;
        }
        if (typeof Map !== "undefined" && data instanceof Map) {
          return ZodParsedType$1.map;
        }
        if (typeof Set !== "undefined" && data instanceof Set) {
          return ZodParsedType$1.set;
        }
        if (typeof Date !== "undefined" && data instanceof Date) {
          return ZodParsedType$1.date;
        }
        return ZodParsedType$1.object;
      default:
        return ZodParsedType$1.unknown;
    }
  };
  const ZodIssueCode$1 = util$1.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  const quotelessJson$1 = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
  };
  let ZodError$1 = class ZodError2 extends Error {
    get errors() {
      return this.issues;
    }
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    format(_mapper2) {
      const mapper = _mapper2 || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error) => {
        for (const issue of error.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i2 = 0;
            while (i2 < issue.path.length) {
              const el = issue.path[i2];
              const terminal = i2 === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i2++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    static assert(value) {
      if (!(value instanceof ZodError2)) {
        throw new Error(`Not a ZodError: ${value}`);
      }
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util$1.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
          fieldErrors[sub.path[0]].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  };
  ZodError$1.create = (issues) => {
    const error = new ZodError$1(issues);
    return error;
  };
  const errorMap$1 = (issue, _ctx) => {
    let message;
    switch (issue.code) {
      case ZodIssueCode$1.invalid_type:
        if (issue.received === ZodParsedType$1.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue.expected}, received ${issue.received}`;
        }
        break;
      case ZodIssueCode$1.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util$1.jsonStringifyReplacer)}`;
        break;
      case ZodIssueCode$1.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util$1.joinValues(issue.keys, ", ")}`;
        break;
      case ZodIssueCode$1.invalid_union:
        message = `Invalid input`;
        break;
      case ZodIssueCode$1.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util$1.joinValues(issue.options)}`;
        break;
      case ZodIssueCode$1.invalid_enum_value:
        message = `Invalid enum value. Expected ${util$1.joinValues(issue.options)}, received '${issue.received}'`;
        break;
      case ZodIssueCode$1.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodIssueCode$1.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodIssueCode$1.invalid_date:
        message = `Invalid date`;
        break;
      case ZodIssueCode$1.invalid_string:
        if (typeof issue.validation === "object") {
          if ("includes" in issue.validation) {
            message = `Invalid input: must include "${issue.validation.includes}"`;
            if (typeof issue.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
            }
          } else if ("startsWith" in issue.validation) {
            message = `Invalid input: must start with "${issue.validation.startsWith}"`;
          } else if ("endsWith" in issue.validation) {
            message = `Invalid input: must end with "${issue.validation.endsWith}"`;
          } else {
            util$1.assertNever(issue.validation);
          }
        } else if (issue.validation !== "regex") {
          message = `Invalid ${issue.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodIssueCode$1.too_small:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode$1.too_big:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "bigint")
          message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode$1.custom:
        message = `Invalid input`;
        break;
      case ZodIssueCode$1.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodIssueCode$1.not_multiple_of:
        message = `Number must be a multiple of ${issue.multipleOf}`;
        break;
      case ZodIssueCode$1.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util$1.assertNever(issue);
    }
    return { message };
  };
  let overrideErrorMap$1 = errorMap$1;
  function setErrorMap$1(map2) {
    overrideErrorMap$1 = map2;
  }
  function getErrorMap$1() {
    return overrideErrorMap$1;
  }
  const makeIssue$1 = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...issueData.path || []];
    const fullIssue = {
      ...issueData,
      path: fullPath
    };
    if (issueData.message !== void 0) {
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message
      };
    }
    let errorMessage = "";
    const maps = errorMaps.filter((m) => !!m).slice().reverse();
    for (const map2 of maps) {
      errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
      ...issueData,
      path: fullPath,
      message: errorMessage
    };
  };
  const EMPTY_PATH$1 = [];
  function addIssueToContext$1(ctx, issueData) {
    const overrideMap = getErrorMap$1();
    const issue = makeIssue$1({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        // contextual error map is first priority
        ctx.schemaErrorMap,
        // then schema-bound map if available
        overrideMap,
        // then global override map
        overrideMap === errorMap$1 ? void 0 : errorMap$1
        // then global default map
      ].filter((x) => !!x)
    });
    ctx.common.issues.push(issue);
  }
  let ParseStatus$1 = class ParseStatus2 {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      if (this.value === "valid")
        this.value = "dirty";
    }
    abort() {
      if (this.value !== "aborted")
        this.value = "aborted";
    }
    static mergeArray(status, results) {
      const arrayValue = [];
      for (const s of results) {
        if (s.status === "aborted")
          return INVALID$1;
        if (s.status === "dirty")
          status.dirty();
        arrayValue.push(s.value);
      }
      return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
      const syncPairs = [];
      for (const pair of pairs) {
        const key = await pair.key;
        const value = await pair.value;
        syncPairs.push({
          key,
          value
        });
      }
      return ParseStatus2.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
      const finalObject = {};
      for (const pair of pairs) {
        const { key, value } = pair;
        if (key.status === "aborted")
          return INVALID$1;
        if (value.status === "aborted")
          return INVALID$1;
        if (key.status === "dirty")
          status.dirty();
        if (value.status === "dirty")
          status.dirty();
        if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
          finalObject[key.value] = value.value;
        }
      }
      return { status: status.value, value: finalObject };
    }
  };
  const INVALID$1 = Object.freeze({
    status: "aborted"
  });
  const DIRTY$1 = (value) => ({ status: "dirty", value });
  const OK$1 = (value) => ({ status: "valid", value });
  const isAborted$1 = (x) => x.status === "aborted";
  const isDirty$1 = (x) => x.status === "dirty";
  const isValid$1 = (x) => x.status === "valid";
  const isAsync$1 = (x) => typeof Promise !== "undefined" && x instanceof Promise;
  function __classPrivateFieldGet$e(receiver, state, kind2, f) {
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return state.get(receiver);
  }
  function __classPrivateFieldSet$c(receiver, state, value, kind2, f) {
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return state.set(receiver, value), value;
  }
  typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };
  var errorUtil$1;
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
  })(errorUtil$1 || (errorUtil$1 = {}));
  var _ZodEnum_cache$1, _ZodNativeEnum_cache$1;
  let ParseInputLazyPath$1 = class ParseInputLazyPath {
    constructor(parent, value, path, key) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path;
      this._key = key;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (this._key instanceof Array) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  };
  const handleResult$1 = (ctx, result) => {
    if (isValid$1(result)) {
      return { success: true, data: result.value };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error)
            return this._error;
          const error = new ZodError$1(ctx.common.issues);
          this._error = error;
          return this._error;
        }
      };
    }
  };
  function processCreateParams$1(params) {
    if (!params)
      return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2)
      return { errorMap: errorMap2, description };
    const customMap = (iss, ctx) => {
      var _a3, _b2;
      const { message } = params;
      if (iss.code === "invalid_enum_value") {
        return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
      }
      if (typeof ctx.data === "undefined") {
        return { message: (_a3 = message !== null && message !== void 0 ? message : required_error) !== null && _a3 !== void 0 ? _a3 : ctx.defaultError };
      }
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      return { message: (_b2 = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b2 !== void 0 ? _b2 : ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }
  let ZodType$1 = class ZodType {
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return getParsedType$1(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType$1(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      };
    }
    _processInputParams(input) {
      return {
        status: new ParseStatus$1(),
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType$1(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        }
      };
    }
    _parseSync(input) {
      const result = this._parse(input);
      if (isAsync$1(result)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result;
    }
    _parseAsync(input) {
      const result = this._parse(input);
      return Promise.resolve(result);
    }
    parse(data, params) {
      const result = this.safeParse(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    safeParse(data, params) {
      var _a3;
      const ctx = {
        common: {
          issues: [],
          async: (_a3 = params === null || params === void 0 ? void 0 : params.async) !== null && _a3 !== void 0 ? _a3 : false,
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType$1(data)
      };
      const result = this._parseSync({ data, path: ctx.path, parent: ctx });
      return handleResult$1(ctx, result);
    }
    "~validate"(data) {
      var _a3, _b2;
      const ctx = {
        common: {
          issues: [],
          async: !!this["~standard"].async
        },
        path: [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType$1(data)
      };
      if (!this["~standard"].async) {
        try {
          const result = this._parseSync({ data, path: [], parent: ctx });
          return isValid$1(result) ? {
            value: result.value
          } : {
            issues: ctx.common.issues
          };
        } catch (err) {
          if ((_b2 = (_a3 = err === null || err === void 0 ? void 0 : err.message) === null || _a3 === void 0 ? void 0 : _a3.toLowerCase()) === null || _b2 === void 0 ? void 0 : _b2.includes("encountered")) {
            this["~standard"].async = true;
          }
          ctx.common = {
            issues: [],
            async: true
          };
        }
      }
      return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid$1(result) ? {
        value: result.value
      } : {
        issues: ctx.common.issues
      });
    }
    async parseAsync(data, params) {
      const result = await this.safeParseAsync(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    async safeParseAsync(data, params) {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
          async: true
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType$1(data)
      };
      const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
      const result = await (isAsync$1(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
      return handleResult$1(ctx, result);
    }
    refine(check, message) {
      const getIssueProperties = (val) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return { message };
        } else if (typeof message === "function") {
          return message(val);
        } else {
          return message;
        }
      };
      return this._refinement((val, ctx) => {
        const result = check(val);
        const setError = () => ctx.addIssue({
          code: ZodIssueCode$1.custom,
          ...getIssueProperties(val)
        });
        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then((data) => {
            if (!data) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check, refinementData) {
      return this._refinement((val, ctx) => {
        if (!check(val)) {
          ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects$1({
        schema: this,
        typeName: ZodFirstPartyTypeKind$1.ZodEffects,
        effect: { type: "refinement", refinement }
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    constructor(def) {
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.readonly = this.readonly.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
      this["~standard"] = {
        version: 1,
        vendor: "zod",
        validate: (data) => this["~validate"](data)
      };
    }
    optional() {
      return ZodOptional$1.create(this, this._def);
    }
    nullable() {
      return ZodNullable$1.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray$1.create(this);
    }
    promise() {
      return ZodPromise$1.create(this, this._def);
    }
    or(option) {
      return ZodUnion$1.create([this, option], this._def);
    }
    and(incoming) {
      return ZodIntersection$1.create(this, incoming, this._def);
    }
    transform(transform) {
      return new ZodEffects$1({
        ...processCreateParams$1(this._def),
        schema: this,
        typeName: ZodFirstPartyTypeKind$1.ZodEffects,
        effect: { type: "transform", transform }
      });
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault$1({
        ...processCreateParams$1(this._def),
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind$1.ZodDefault
      });
    }
    brand() {
      return new ZodBranded$1({
        typeName: ZodFirstPartyTypeKind$1.ZodBranded,
        type: this,
        ...processCreateParams$1(this._def)
      });
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch$1({
        ...processCreateParams$1(this._def),
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind$1.ZodCatch
      });
    }
    describe(description) {
      const This = this.constructor;
      return new This({
        ...this._def,
        description
      });
    }
    pipe(target) {
      return ZodPipeline$1.create(this, target);
    }
    readonly() {
      return ZodReadonly$1.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  };
  const cuidRegex$1 = /^c[^\s-]{8,}$/i;
  const cuid2Regex$1 = /^[0-9a-z]+$/;
  const ulidRegex$1 = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
  const uuidRegex$1 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  const nanoidRegex$1 = /^[a-z0-9_-]{21}$/i;
  const jwtRegex$1 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
  const durationRegex$1 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  const emailRegex$1 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  const _emojiRegex$1 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  let emojiRegex$5;
  const ipv4Regex$1 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  const ipv4CidrRegex$1 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
  const ipv6Regex$1 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
  const ipv6CidrRegex$1 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  const base64Regex$1 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  const base64urlRegex$1 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
  const dateRegexSource$1 = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
  const dateRegex$1 = new RegExp(`^${dateRegexSource$1}$`);
  function timeRegexSource$1(args) {
    let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
    if (args.precision) {
      regex = `${regex}\\.\\d{${args.precision}}`;
    } else if (args.precision == null) {
      regex = `${regex}(\\.\\d+)?`;
    }
    return regex;
  }
  function timeRegex$1(args) {
    return new RegExp(`^${timeRegexSource$1(args)}$`);
  }
  function datetimeRegex$1(args) {
    let regex = `${dateRegexSource$1}T${timeRegexSource$1(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset)
      opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
  }
  function isValidIP$1(ip, version2) {
    if ((version2 === "v4" || !version2) && ipv4Regex$1.test(ip)) {
      return true;
    }
    if ((version2 === "v6" || !version2) && ipv6Regex$1.test(ip)) {
      return true;
    }
    return false;
  }
  function isValidJWT$1(jwt, alg) {
    if (!jwtRegex$1.test(jwt))
      return false;
    try {
      const [header] = jwt.split(".");
      const base642 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
      const decoded = JSON.parse(atob(base642));
      if (typeof decoded !== "object" || decoded === null)
        return false;
      if (!decoded.typ || !decoded.alg)
        return false;
      if (alg && decoded.alg !== alg)
        return false;
      return true;
    } catch (_a3) {
      return false;
    }
  }
  function isValidCidr$1(ip, version2) {
    if ((version2 === "v4" || !version2) && ipv4CidrRegex$1.test(ip)) {
      return true;
    }
    if ((version2 === "v6" || !version2) && ipv6CidrRegex$1.test(ip)) {
      return true;
    }
    return false;
  }
  let ZodString$1 = class ZodString2 extends ZodType$1 {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType$1.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext$1(ctx2, {
          code: ZodIssueCode$1.invalid_type,
          expected: ZodParsedType$1.string,
          received: ctx2.parsedType
        });
        return INVALID$1;
      }
      const status = new ParseStatus$1();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              code: ZodIssueCode$1.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              code: ZodIssueCode$1.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext$1(ctx, {
                code: ZodIssueCode$1.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              addIssueToContext$1(ctx, {
                code: ZodIssueCode$1.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex$1.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              validation: "email",
              code: ZodIssueCode$1.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex$5) {
            emojiRegex$5 = new RegExp(_emojiRegex$1, "u");
          }
          if (!emojiRegex$5.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              validation: "emoji",
              code: ZodIssueCode$1.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex$1.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              validation: "uuid",
              code: ZodIssueCode$1.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "nanoid") {
          if (!nanoidRegex$1.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              validation: "nanoid",
              code: ZodIssueCode$1.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex$1.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              validation: "cuid",
              code: ZodIssueCode$1.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex$1.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              validation: "cuid2",
              code: ZodIssueCode$1.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex$1.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              validation: "ulid",
              code: ZodIssueCode$1.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch (_a3) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              validation: "url",
              code: ZodIssueCode$1.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              validation: "regex",
              code: ZodIssueCode$1.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              code: ZodIssueCode$1.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              code: ZodIssueCode$1.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              code: ZodIssueCode$1.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex = datetimeRegex$1(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              code: ZodIssueCode$1.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "date") {
          const regex = dateRegex$1;
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              code: ZodIssueCode$1.invalid_string,
              validation: "date",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "time") {
          const regex = timeRegex$1(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              code: ZodIssueCode$1.invalid_string,
              validation: "time",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "duration") {
          if (!durationRegex$1.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              validation: "duration",
              code: ZodIssueCode$1.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP$1(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              validation: "ip",
              code: ZodIssueCode$1.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "jwt") {
          if (!isValidJWT$1(input.data, check.alg)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              validation: "jwt",
              code: ZodIssueCode$1.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cidr") {
          if (!isValidCidr$1(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              validation: "cidr",
              code: ZodIssueCode$1.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64") {
          if (!base64Regex$1.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              validation: "base64",
              code: ZodIssueCode$1.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64url") {
          if (!base64urlRegex$1.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              validation: "base64url",
              code: ZodIssueCode$1.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util$1.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
      return this.refinement((data) => regex.test(data), {
        validation,
        code: ZodIssueCode$1.invalid_string,
        ...errorUtil$1.errToObj(message)
      });
    }
    _addCheck(check) {
      return new ZodString2({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil$1.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil$1.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil$1.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil$1.errToObj(message) });
    }
    nanoid(message) {
      return this._addCheck({ kind: "nanoid", ...errorUtil$1.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil$1.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil$1.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil$1.errToObj(message) });
    }
    base64(message) {
      return this._addCheck({ kind: "base64", ...errorUtil$1.errToObj(message) });
    }
    base64url(message) {
      return this._addCheck({
        kind: "base64url",
        ...errorUtil$1.errToObj(message)
      });
    }
    jwt(options) {
      return this._addCheck({ kind: "jwt", ...errorUtil$1.errToObj(options) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil$1.errToObj(options) });
    }
    cidr(options) {
      return this._addCheck({ kind: "cidr", ...errorUtil$1.errToObj(options) });
    }
    datetime(options) {
      var _a3, _b2;
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          local: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
        offset: (_a3 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a3 !== void 0 ? _a3 : false,
        local: (_b2 = options === null || options === void 0 ? void 0 : options.local) !== null && _b2 !== void 0 ? _b2 : false,
        ...errorUtil$1.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    date(message) {
      return this._addCheck({ kind: "date", message });
    }
    time(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "time",
          precision: null,
          message: options
        });
      }
      return this._addCheck({
        kind: "time",
        precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
        ...errorUtil$1.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    duration(message) {
      return this._addCheck({ kind: "duration", ...errorUtil$1.errToObj(message) });
    }
    regex(regex, message) {
      return this._addCheck({
        kind: "regex",
        regex,
        ...errorUtil$1.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options === null || options === void 0 ? void 0 : options.position,
        ...errorUtil$1.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil$1.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil$1.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil$1.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil$1.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil$1.errToObj(message)
      });
    }
    /**
     * Equivalent to `.min(1)`
     */
    nonempty(message) {
      return this.min(1, errorUtil$1.errToObj(message));
    }
    trim() {
      return new ZodString2({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new ZodString2({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new ZodString2({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((ch) => ch.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((ch) => ch.kind === "base64url");
    }
    get minLength() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodString$1.create = (params) => {
    var _a3;
    return new ZodString$1({
      checks: [],
      typeName: ZodFirstPartyTypeKind$1.ZodString,
      coerce: (_a3 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a3 !== void 0 ? _a3 : false,
      ...processCreateParams$1(params)
    });
  };
  function floatSafeRemainder$1(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / Math.pow(10, decCount);
  }
  let ZodNumber$1 = class ZodNumber2 extends ZodType$1 {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType$1.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext$1(ctx2, {
          code: ZodIssueCode$1.invalid_type,
          expected: ZodParsedType$1.number,
          received: ctx2.parsedType
        });
        return INVALID$1;
      }
      let ctx = void 0;
      const status = new ParseStatus$1();
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util$1.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              code: ZodIssueCode$1.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              code: ZodIssueCode$1.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              code: ZodIssueCode$1.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder$1(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              code: ZodIssueCode$1.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              code: ZodIssueCode$1.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util$1.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil$1.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil$1.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil$1.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil$1.toString(message));
    }
    setLimit(kind2, value, inclusive, message) {
      return new ZodNumber2({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: kind2,
            value,
            inclusive,
            message: errorUtil$1.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodNumber2({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil$1.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil$1.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil$1.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil$1.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil$1.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil$1.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil$1.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil$1.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil$1.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$1.isInteger(ch.value));
    }
    get isFinite() {
      let max = null, min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        } else if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  };
  ZodNumber$1.create = (params) => {
    return new ZodNumber$1({
      checks: [],
      typeName: ZodFirstPartyTypeKind$1.ZodNumber,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams$1(params)
    });
  };
  let ZodBigInt$1 = class ZodBigInt2 extends ZodType$1 {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        try {
          input.data = BigInt(input.data);
        } catch (_a3) {
          return this._getInvalidInput(input);
        }
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType$1.bigint) {
        return this._getInvalidInput(input);
      }
      let ctx = void 0;
      const status = new ParseStatus$1();
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              code: ZodIssueCode$1.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              code: ZodIssueCode$1.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              code: ZodIssueCode$1.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util$1.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _getInvalidInput(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.bigint,
        received: ctx.parsedType
      });
      return INVALID$1;
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil$1.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil$1.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil$1.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil$1.toString(message));
    }
    setLimit(kind2, value, inclusive, message) {
      return new ZodBigInt2({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: kind2,
            value,
            inclusive,
            message: errorUtil$1.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodBigInt2({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil$1.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil$1.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil$1.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil$1.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil$1.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodBigInt$1.create = (params) => {
    var _a3;
    return new ZodBigInt$1({
      checks: [],
      typeName: ZodFirstPartyTypeKind$1.ZodBigInt,
      coerce: (_a3 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a3 !== void 0 ? _a3 : false,
      ...processCreateParams$1(params)
    });
  };
  let ZodBoolean$1 = class ZodBoolean extends ZodType$1 {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType$1.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext$1(ctx, {
          code: ZodIssueCode$1.invalid_type,
          expected: ZodParsedType$1.boolean,
          received: ctx.parsedType
        });
        return INVALID$1;
      }
      return OK$1(input.data);
    }
  };
  ZodBoolean$1.create = (params) => {
    return new ZodBoolean$1({
      typeName: ZodFirstPartyTypeKind$1.ZodBoolean,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams$1(params)
    });
  };
  let ZodDate$1 = class ZodDate2 extends ZodType$1 {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType$1.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext$1(ctx2, {
          code: ZodIssueCode$1.invalid_type,
          expected: ZodParsedType$1.date,
          received: ctx2.parsedType
        });
        return INVALID$1;
      }
      if (isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext$1(ctx2, {
          code: ZodIssueCode$1.invalid_date
        });
        return INVALID$1;
      }
      const status = new ParseStatus$1();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              code: ZodIssueCode$1.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext$1(ctx, {
              code: ZodIssueCode$1.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util$1.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new ZodDate2({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil$1.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil$1.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  };
  ZodDate$1.create = (params) => {
    return new ZodDate$1({
      checks: [],
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      typeName: ZodFirstPartyTypeKind$1.ZodDate,
      ...processCreateParams$1(params)
    });
  };
  let ZodSymbol$1 = class ZodSymbol extends ZodType$1 {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType$1.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext$1(ctx, {
          code: ZodIssueCode$1.invalid_type,
          expected: ZodParsedType$1.symbol,
          received: ctx.parsedType
        });
        return INVALID$1;
      }
      return OK$1(input.data);
    }
  };
  ZodSymbol$1.create = (params) => {
    return new ZodSymbol$1({
      typeName: ZodFirstPartyTypeKind$1.ZodSymbol,
      ...processCreateParams$1(params)
    });
  };
  let ZodUndefined$1 = class ZodUndefined extends ZodType$1 {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType$1.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext$1(ctx, {
          code: ZodIssueCode$1.invalid_type,
          expected: ZodParsedType$1.undefined,
          received: ctx.parsedType
        });
        return INVALID$1;
      }
      return OK$1(input.data);
    }
  };
  ZodUndefined$1.create = (params) => {
    return new ZodUndefined$1({
      typeName: ZodFirstPartyTypeKind$1.ZodUndefined,
      ...processCreateParams$1(params)
    });
  };
  let ZodNull$1 = class ZodNull extends ZodType$1 {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType$1.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext$1(ctx, {
          code: ZodIssueCode$1.invalid_type,
          expected: ZodParsedType$1.null,
          received: ctx.parsedType
        });
        return INVALID$1;
      }
      return OK$1(input.data);
    }
  };
  ZodNull$1.create = (params) => {
    return new ZodNull$1({
      typeName: ZodFirstPartyTypeKind$1.ZodNull,
      ...processCreateParams$1(params)
    });
  };
  let ZodAny$1 = class ZodAny extends ZodType$1 {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK$1(input.data);
    }
  };
  ZodAny$1.create = (params) => {
    return new ZodAny$1({
      typeName: ZodFirstPartyTypeKind$1.ZodAny,
      ...processCreateParams$1(params)
    });
  };
  let ZodUnknown$1 = class ZodUnknown extends ZodType$1 {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK$1(input.data);
    }
  };
  ZodUnknown$1.create = (params) => {
    return new ZodUnknown$1({
      typeName: ZodFirstPartyTypeKind$1.ZodUnknown,
      ...processCreateParams$1(params)
    });
  };
  let ZodNever$1 = class ZodNever extends ZodType$1 {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext$1(ctx, {
        code: ZodIssueCode$1.invalid_type,
        expected: ZodParsedType$1.never,
        received: ctx.parsedType
      });
      return INVALID$1;
    }
  };
  ZodNever$1.create = (params) => {
    return new ZodNever$1({
      typeName: ZodFirstPartyTypeKind$1.ZodNever,
      ...processCreateParams$1(params)
    });
  };
  let ZodVoid$1 = class ZodVoid extends ZodType$1 {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType$1.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext$1(ctx, {
          code: ZodIssueCode$1.invalid_type,
          expected: ZodParsedType$1.void,
          received: ctx.parsedType
        });
        return INVALID$1;
      }
      return OK$1(input.data);
    }
  };
  ZodVoid$1.create = (params) => {
    return new ZodVoid$1({
      typeName: ZodFirstPartyTypeKind$1.ZodVoid,
      ...processCreateParams$1(params)
    });
  };
  let ZodArray$1 = class ZodArray2 extends ZodType$1 {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType$1.array) {
        addIssueToContext$1(ctx, {
          code: ZodIssueCode$1.invalid_type,
          expected: ZodParsedType$1.array,
          received: ctx.parsedType
        });
        return INVALID$1;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext$1(ctx, {
            code: tooBig ? ZodIssueCode$1.too_big : ZodIssueCode$1.too_small,
            minimum: tooSmall ? def.exactLength.value : void 0,
            maximum: tooBig ? def.exactLength.value : void 0,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i2) => {
          return def.type._parseAsync(new ParseInputLazyPath$1(ctx, item, ctx.path, i2));
        })).then((result2) => {
          return ParseStatus$1.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i2) => {
        return def.type._parseSync(new ParseInputLazyPath$1(ctx, item, ctx.path, i2));
      });
      return ParseStatus$1.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new ZodArray2({
        ...this._def,
        minLength: { value: minLength, message: errorUtil$1.toString(message) }
      });
    }
    max(maxLength, message) {
      return new ZodArray2({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil$1.toString(message) }
      });
    }
    length(len, message) {
      return new ZodArray2({
        ...this._def,
        exactLength: { value: len, message: errorUtil$1.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodArray$1.create = (schema, params) => {
    return new ZodArray$1({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind$1.ZodArray,
      ...processCreateParams$1(params)
    });
  };
  function deepPartialify$1(schema) {
    if (schema instanceof ZodObject$1) {
      const newShape = {};
      for (const key in schema.shape) {
        const fieldSchema = schema.shape[key];
        newShape[key] = ZodOptional$1.create(deepPartialify$1(fieldSchema));
      }
      return new ZodObject$1({
        ...schema._def,
        shape: () => newShape
      });
    } else if (schema instanceof ZodArray$1) {
      return new ZodArray$1({
        ...schema._def,
        type: deepPartialify$1(schema.element)
      });
    } else if (schema instanceof ZodOptional$1) {
      return ZodOptional$1.create(deepPartialify$1(schema.unwrap()));
    } else if (schema instanceof ZodNullable$1) {
      return ZodNullable$1.create(deepPartialify$1(schema.unwrap()));
    } else if (schema instanceof ZodTuple$1) {
      return ZodTuple$1.create(schema.items.map((item) => deepPartialify$1(item)));
    } else {
      return schema;
    }
  }
  let ZodObject$1 = class ZodObject2 extends ZodType$1 {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys = util$1.objectKeys(shape);
      return this._cached = { shape, keys };
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType$1.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext$1(ctx2, {
          code: ZodIssueCode$1.invalid_type,
          expected: ZodParsedType$1.object,
          received: ctx2.parsedType
        });
        return INVALID$1;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever$1 && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath$1(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever$1) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext$1(ctx, {
              code: ZodIssueCode$1.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip") ;
        else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(
              new ParseInputLazyPath$1(ctx, value, ctx.path, key)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
              key,
              value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return ParseStatus$1.mergeObjectSync(status, syncPairs);
        });
      } else {
        return ParseStatus$1.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil$1.errToObj;
      return new ZodObject2({
        ...this._def,
        unknownKeys: "strict",
        ...message !== void 0 ? {
          errorMap: (issue, ctx) => {
            var _a3, _b2, _c2, _d2;
            const defaultError = (_c2 = (_b2 = (_a3 = this._def).errorMap) === null || _b2 === void 0 ? void 0 : _b2.call(_a3, issue, ctx).message) !== null && _c2 !== void 0 ? _c2 : ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: (_d2 = errorUtil$1.errToObj(message).message) !== null && _d2 !== void 0 ? _d2 : defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new ZodObject2({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new ZodObject2({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
      return new ZodObject2({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
      const merged = new ZodObject2({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind$1.ZodObject
      });
      return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
      return new ZodObject2({
        ...this._def,
        catchall: index
      });
    }
    pick(mask) {
      const shape = {};
      util$1.objectKeys(mask).forEach((key) => {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject2({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      util$1.objectKeys(this.shape).forEach((key) => {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject2({
        ...this._def,
        shape: () => shape
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return deepPartialify$1(this);
    }
    partial(mask) {
      const newShape = {};
      util$1.objectKeys(this.shape).forEach((key) => {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      });
      return new ZodObject2({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      util$1.objectKeys(this.shape).forEach((key) => {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional$1) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      });
      return new ZodObject2({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum$1(util$1.objectKeys(this.shape));
    }
  };
  ZodObject$1.create = (shape, params) => {
    return new ZodObject$1({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever$1.create(),
      typeName: ZodFirstPartyTypeKind$1.ZodObject,
      ...processCreateParams$1(params)
    });
  };
  ZodObject$1.strictCreate = (shape, params) => {
    return new ZodObject$1({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever$1.create(),
      typeName: ZodFirstPartyTypeKind$1.ZodObject,
      ...processCreateParams$1(params)
    });
  };
  ZodObject$1.lazycreate = (shape, params) => {
    return new ZodObject$1({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever$1.create(),
      typeName: ZodFirstPartyTypeKind$1.ZodObject,
      ...processCreateParams$1(params)
    });
  };
  let ZodUnion$1 = class ZodUnion extends ZodType$1 {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError$1(result.ctx.common.issues));
        addIssueToContext$1(ctx, {
          code: ZodIssueCode$1.invalid_union,
          unionErrors
        });
        return INVALID$1;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = void 0;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError$1(issues2));
        addIssueToContext$1(ctx, {
          code: ZodIssueCode$1.invalid_union,
          unionErrors
        });
        return INVALID$1;
      }
    }
    get options() {
      return this._def.options;
    }
  };
  ZodUnion$1.create = (types, params) => {
    return new ZodUnion$1({
      options: types,
      typeName: ZodFirstPartyTypeKind$1.ZodUnion,
      ...processCreateParams$1(params)
    });
  };
  const getDiscriminator$1 = (type) => {
    if (type instanceof ZodLazy$1) {
      return getDiscriminator$1(type.schema);
    } else if (type instanceof ZodEffects$1) {
      return getDiscriminator$1(type.innerType());
    } else if (type instanceof ZodLiteral$1) {
      return [type.value];
    } else if (type instanceof ZodEnum$1) {
      return type.options;
    } else if (type instanceof ZodNativeEnum$1) {
      return util$1.objectValues(type.enum);
    } else if (type instanceof ZodDefault$1) {
      return getDiscriminator$1(type._def.innerType);
    } else if (type instanceof ZodUndefined$1) {
      return [void 0];
    } else if (type instanceof ZodNull$1) {
      return [null];
    } else if (type instanceof ZodOptional$1) {
      return [void 0, ...getDiscriminator$1(type.unwrap())];
    } else if (type instanceof ZodNullable$1) {
      return [null, ...getDiscriminator$1(type.unwrap())];
    } else if (type instanceof ZodBranded$1) {
      return getDiscriminator$1(type.unwrap());
    } else if (type instanceof ZodReadonly$1) {
      return getDiscriminator$1(type.unwrap());
    } else if (type instanceof ZodCatch$1) {
      return getDiscriminator$1(type._def.innerType);
    } else {
      return [];
    }
  };
  let ZodDiscriminatedUnion$1 = class ZodDiscriminatedUnion2 extends ZodType$1 {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType$1.object) {
        addIssueToContext$1(ctx, {
          code: ZodIssueCode$1.invalid_type,
          expected: ZodParsedType$1.object,
          received: ctx.parsedType
        });
        return INVALID$1;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        addIssueToContext$1(ctx, {
          code: ZodIssueCode$1.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return INVALID$1;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
      const optionsMap = /* @__PURE__ */ new Map();
      for (const type of options) {
        const discriminatorValues = getDiscriminator$1(type.shape[discriminator]);
        if (!discriminatorValues.length) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new ZodDiscriminatedUnion2({
        typeName: ZodFirstPartyTypeKind$1.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams$1(params)
      });
    }
  };
  function mergeValues$1(a, b) {
    const aType = getParsedType$1(a);
    const bType = getParsedType$1(b);
    if (a === b) {
      return { valid: true, data: a };
    } else if (aType === ZodParsedType$1.object && bType === ZodParsedType$1.object) {
      const bKeys = util$1.objectKeys(b);
      const sharedKeys = util$1.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = { ...a, ...b };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues$1(a[key], b[key]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === ZodParsedType$1.array && bType === ZodParsedType$1.array) {
      if (a.length !== b.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index = 0; index < a.length; index++) {
        const itemA = a[index];
        const itemB = b[index];
        const sharedValue = mergeValues$1(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === ZodParsedType$1.date && bType === ZodParsedType$1.date && +a === +b) {
      return { valid: true, data: a };
    } else {
      return { valid: false };
    }
  }
  let ZodIntersection$1 = class ZodIntersection extends ZodType$1 {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted$1(parsedLeft) || isAborted$1(parsedRight)) {
          return INVALID$1;
        }
        const merged = mergeValues$1(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.invalid_intersection_types
          });
          return INVALID$1;
        }
        if (isDirty$1(parsedLeft) || isDirty$1(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  };
  ZodIntersection$1.create = (left, right, params) => {
    return new ZodIntersection$1({
      left,
      right,
      typeName: ZodFirstPartyTypeKind$1.ZodIntersection,
      ...processCreateParams$1(params)
    });
  };
  let ZodTuple$1 = class ZodTuple2 extends ZodType$1 {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType$1.array) {
        addIssueToContext$1(ctx, {
          code: ZodIssueCode$1.invalid_type,
          expected: ZodParsedType$1.array,
          received: ctx.parsedType
        });
        return INVALID$1;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext$1(ctx, {
          code: ZodIssueCode$1.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID$1;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext$1(ctx, {
          code: ZodIssueCode$1.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath$1(ctx, item, ctx.path, itemIndex));
      }).filter((x) => !!x);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus$1.mergeArray(status, results);
        });
      } else {
        return ParseStatus$1.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new ZodTuple2({
        ...this._def,
        rest
      });
    }
  };
  ZodTuple$1.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple$1({
      items: schemas,
      typeName: ZodFirstPartyTypeKind$1.ZodTuple,
      rest: null,
      ...processCreateParams$1(params)
    });
  };
  let ZodRecord$1 = class ZodRecord2 extends ZodType$1 {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType$1.object) {
        addIssueToContext$1(ctx, {
          code: ZodIssueCode$1.invalid_type,
          expected: ZodParsedType$1.object,
          received: ctx.parsedType
        });
        return INVALID$1;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath$1(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath$1(ctx, ctx.data[key], ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (ctx.common.async) {
        return ParseStatus$1.mergeObjectAsync(status, pairs);
      } else {
        return ParseStatus$1.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first2, second, third) {
      if (second instanceof ZodType$1) {
        return new ZodRecord2({
          keyType: first2,
          valueType: second,
          typeName: ZodFirstPartyTypeKind$1.ZodRecord,
          ...processCreateParams$1(third)
        });
      }
      return new ZodRecord2({
        keyType: ZodString$1.create(),
        valueType: first2,
        typeName: ZodFirstPartyTypeKind$1.ZodRecord,
        ...processCreateParams$1(second)
      });
    }
  };
  let ZodMap$1 = class ZodMap extends ZodType$1 {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType$1.map) {
        addIssueToContext$1(ctx, {
          code: ZodIssueCode$1.invalid_type,
          expected: ZodParsedType$1.map,
          received: ctx.parsedType
        });
        return INVALID$1;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index) => {
        return {
          key: keyType._parse(new ParseInputLazyPath$1(ctx, key, ctx.path, [index, "key"])),
          value: valueType._parse(new ParseInputLazyPath$1(ctx, value, ctx.path, [index, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID$1;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = /* @__PURE__ */ new Map();
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID$1;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  };
  ZodMap$1.create = (keyType, valueType, params) => {
    return new ZodMap$1({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind$1.ZodMap,
      ...processCreateParams$1(params)
    });
  };
  let ZodSet$1 = class ZodSet2 extends ZodType$1 {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType$1.set) {
        addIssueToContext$1(ctx, {
          code: ZodIssueCode$1.invalid_type,
          expected: ZodParsedType$1.set,
          received: ctx.parsedType
        });
        return INVALID$1;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext$1(ctx, {
            code: ZodIssueCode$1.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = /* @__PURE__ */ new Set();
        for (const element of elements2) {
          if (element.status === "aborted")
            return INVALID$1;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath$1(ctx, item, ctx.path, i2)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new ZodSet2({
        ...this._def,
        minSize: { value: minSize, message: errorUtil$1.toString(message) }
      });
    }
    max(maxSize, message) {
      return new ZodSet2({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil$1.toString(message) }
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodSet$1.create = (valueType, params) => {
    return new ZodSet$1({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind$1.ZodSet,
      ...processCreateParams$1(params)
    });
  };
  let ZodFunction$1 = class ZodFunction2 extends ZodType$1 {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType$1.function) {
        addIssueToContext$1(ctx, {
          code: ZodIssueCode$1.invalid_type,
          expected: ZodParsedType$1.function,
          received: ctx.parsedType
        });
        return INVALID$1;
      }
      function makeArgsIssue(args, error) {
        return makeIssue$1({
          data: args,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap$1(),
            errorMap$1
          ].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode$1.invalid_arguments,
            argumentsError: error
          }
        });
      }
      function makeReturnsIssue(returns, error) {
        return makeIssue$1({
          data: returns,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap$1(),
            errorMap$1
          ].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode$1.invalid_return_type,
            returnTypeError: error
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise$1) {
        const me = this;
        return OK$1(async function(...args) {
          const error = new ZodError$1([]);
          const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
            error.addIssue(makeArgsIssue(args, e));
            throw error;
          });
          const result = await Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
            error.addIssue(makeReturnsIssue(result, e));
            throw error;
          });
          return parsedReturns;
        });
      } else {
        const me = this;
        return OK$1(function(...args) {
          const parsedArgs = me._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError$1([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = Reflect.apply(fn, this, parsedArgs.data);
          const parsedReturns = me._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError$1([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new ZodFunction2({
        ...this._def,
        args: ZodTuple$1.create(items).rest(ZodUnknown$1.create())
      });
    }
    returns(returnType) {
      return new ZodFunction2({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new ZodFunction2({
        args: args ? args : ZodTuple$1.create([]).rest(ZodUnknown$1.create()),
        returns: returns || ZodUnknown$1.create(),
        typeName: ZodFirstPartyTypeKind$1.ZodFunction,
        ...processCreateParams$1(params)
      });
    }
  };
  let ZodLazy$1 = class ZodLazy extends ZodType$1 {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  };
  ZodLazy$1.create = (getter, params) => {
    return new ZodLazy$1({
      getter,
      typeName: ZodFirstPartyTypeKind$1.ZodLazy,
      ...processCreateParams$1(params)
    });
  };
  let ZodLiteral$1 = class ZodLiteral extends ZodType$1 {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext$1(ctx, {
          received: ctx.data,
          code: ZodIssueCode$1.invalid_literal,
          expected: this._def.value
        });
        return INVALID$1;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  };
  ZodLiteral$1.create = (value, params) => {
    return new ZodLiteral$1({
      value,
      typeName: ZodFirstPartyTypeKind$1.ZodLiteral,
      ...processCreateParams$1(params)
    });
  };
  function createZodEnum$1(values, params) {
    return new ZodEnum$1({
      values,
      typeName: ZodFirstPartyTypeKind$1.ZodEnum,
      ...processCreateParams$1(params)
    });
  }
  let ZodEnum$1 = class ZodEnum2 extends ZodType$1 {
    constructor() {
      super(...arguments);
      _ZodEnum_cache$1.set(this, void 0);
    }
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext$1(ctx, {
          expected: util$1.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode$1.invalid_type
        });
        return INVALID$1;
      }
      if (!__classPrivateFieldGet$e(this, _ZodEnum_cache$1)) {
        __classPrivateFieldSet$c(this, _ZodEnum_cache$1, new Set(this._def.values));
      }
      if (!__classPrivateFieldGet$e(this, _ZodEnum_cache$1).has(input.data)) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext$1(ctx, {
          received: ctx.data,
          code: ZodIssueCode$1.invalid_enum_value,
          options: expectedValues
        });
        return INVALID$1;
      }
      return OK$1(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values, newDef = this._def) {
      return ZodEnum2.create(values, {
        ...this._def,
        ...newDef
      });
    }
    exclude(values, newDef = this._def) {
      return ZodEnum2.create(this.options.filter((opt) => !values.includes(opt)), {
        ...this._def,
        ...newDef
      });
    }
  };
  _ZodEnum_cache$1 = /* @__PURE__ */ new WeakMap();
  ZodEnum$1.create = createZodEnum$1;
  let ZodNativeEnum$1 = class ZodNativeEnum extends ZodType$1 {
    constructor() {
      super(...arguments);
      _ZodNativeEnum_cache$1.set(this, void 0);
    }
    _parse(input) {
      const nativeEnumValues = util$1.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType$1.string && ctx.parsedType !== ZodParsedType$1.number) {
        const expectedValues = util$1.objectValues(nativeEnumValues);
        addIssueToContext$1(ctx, {
          expected: util$1.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode$1.invalid_type
        });
        return INVALID$1;
      }
      if (!__classPrivateFieldGet$e(this, _ZodNativeEnum_cache$1)) {
        __classPrivateFieldSet$c(this, _ZodNativeEnum_cache$1, new Set(util$1.getValidEnumValues(this._def.values)));
      }
      if (!__classPrivateFieldGet$e(this, _ZodNativeEnum_cache$1).has(input.data)) {
        const expectedValues = util$1.objectValues(nativeEnumValues);
        addIssueToContext$1(ctx, {
          received: ctx.data,
          code: ZodIssueCode$1.invalid_enum_value,
          options: expectedValues
        });
        return INVALID$1;
      }
      return OK$1(input.data);
    }
    get enum() {
      return this._def.values;
    }
  };
  _ZodNativeEnum_cache$1 = /* @__PURE__ */ new WeakMap();
  ZodNativeEnum$1.create = (values, params) => {
    return new ZodNativeEnum$1({
      values,
      typeName: ZodFirstPartyTypeKind$1.ZodNativeEnum,
      ...processCreateParams$1(params)
    });
  };
  let ZodPromise$1 = class ZodPromise extends ZodType$1 {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType$1.promise && ctx.common.async === false) {
        addIssueToContext$1(ctx, {
          code: ZodIssueCode$1.invalid_type,
          expected: ZodParsedType$1.promise,
          received: ctx.parsedType
        });
        return INVALID$1;
      }
      const promisified = ctx.parsedType === ZodParsedType$1.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK$1(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  };
  ZodPromise$1.create = (schema, params) => {
    return new ZodPromise$1({
      type: schema,
      typeName: ZodFirstPartyTypeKind$1.ZodPromise,
      ...processCreateParams$1(params)
    });
  };
  let ZodEffects$1 = class ZodEffects extends ZodType$1 {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind$1.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext$1(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(processed).then(async (processed2) => {
            if (status.value === "aborted")
              return INVALID$1;
            const result = await this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID$1;
            if (result.status === "dirty")
              return DIRTY$1(result.value);
            if (status.value === "dirty")
              return DIRTY$1(result.value);
            return result;
          });
        } else {
          if (status.value === "aborted")
            return INVALID$1;
          const result = this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID$1;
          if (result.status === "dirty")
            return DIRTY$1(result.value);
          if (status.value === "dirty")
            return DIRTY$1(result.value);
          return result;
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return INVALID$1;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return INVALID$1;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid$1(base))
            return base;
          const result = effect.transform(base.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
            if (!isValid$1(base))
              return base;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
          });
        }
      }
      util$1.assertNever(effect);
    }
  };
  ZodEffects$1.create = (schema, effect, params) => {
    return new ZodEffects$1({
      schema,
      typeName: ZodFirstPartyTypeKind$1.ZodEffects,
      effect,
      ...processCreateParams$1(params)
    });
  };
  ZodEffects$1.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects$1({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind$1.ZodEffects,
      ...processCreateParams$1(params)
    });
  };
  let ZodOptional$1 = class ZodOptional extends ZodType$1 {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType$1.undefined) {
        return OK$1(void 0);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodOptional$1.create = (type, params) => {
    return new ZodOptional$1({
      innerType: type,
      typeName: ZodFirstPartyTypeKind$1.ZodOptional,
      ...processCreateParams$1(params)
    });
  };
  let ZodNullable$1 = class ZodNullable extends ZodType$1 {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType$1.null) {
        return OK$1(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodNullable$1.create = (type, params) => {
    return new ZodNullable$1({
      innerType: type,
      typeName: ZodFirstPartyTypeKind$1.ZodNullable,
      ...processCreateParams$1(params)
    });
  };
  let ZodDefault$1 = class ZodDefault extends ZodType$1 {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === ZodParsedType$1.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  };
  ZodDefault$1.create = (type, params) => {
    return new ZodDefault$1({
      innerType: type,
      typeName: ZodFirstPartyTypeKind$1.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams$1(params)
    });
  };
  let ZodCatch$1 = class ZodCatch extends ZodType$1 {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if (isAsync$1(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError$1(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError$1(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  };
  ZodCatch$1.create = (type, params) => {
    return new ZodCatch$1({
      innerType: type,
      typeName: ZodFirstPartyTypeKind$1.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams$1(params)
    });
  };
  let ZodNaN$1 = class ZodNaN extends ZodType$1 {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType$1.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext$1(ctx, {
          code: ZodIssueCode$1.invalid_type,
          expected: ZodParsedType$1.nan,
          received: ctx.parsedType
        });
        return INVALID$1;
      }
      return { status: "valid", value: input.data };
    }
  };
  ZodNaN$1.create = (params) => {
    return new ZodNaN$1({
      typeName: ZodFirstPartyTypeKind$1.ZodNaN,
      ...processCreateParams$1(params)
    });
  };
  const BRAND$1 = Symbol("zod_brand");
  let ZodBranded$1 = class ZodBranded extends ZodType$1 {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  };
  let ZodPipeline$1 = class ZodPipeline2 extends ZodType$1 {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID$1;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY$1(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID$1;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a, b) {
      return new ZodPipeline2({
        in: a,
        out: b,
        typeName: ZodFirstPartyTypeKind$1.ZodPipeline
      });
    }
  };
  let ZodReadonly$1 = class ZodReadonly extends ZodType$1 {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      const freeze = (data) => {
        if (isValid$1(data)) {
          data.value = Object.freeze(data.value);
        }
        return data;
      };
      return isAsync$1(result) ? result.then((data) => freeze(data)) : freeze(result);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodReadonly$1.create = (type, params) => {
    return new ZodReadonly$1({
      innerType: type,
      typeName: ZodFirstPartyTypeKind$1.ZodReadonly,
      ...processCreateParams$1(params)
    });
  };
  function custom$1(check, params = {}, fatal) {
    if (check)
      return ZodAny$1.create().superRefine((data, ctx) => {
        var _a3, _b2;
        if (!check(data)) {
          const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
          const _fatal = (_b2 = (_a3 = p.fatal) !== null && _a3 !== void 0 ? _a3 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
          const p2 = typeof p === "string" ? { message: p } : p;
          ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
        }
      });
    return ZodAny$1.create();
  }
  const late$1 = {
    object: ZodObject$1.lazycreate
  };
  var ZodFirstPartyTypeKind$1;
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind$1 || (ZodFirstPartyTypeKind$1 = {}));
  const instanceOfType$1 = (cls, params = {
    message: `Input not instance of ${cls.name}`
  }) => custom$1((data) => data instanceof cls, params);
  const stringType$1 = ZodString$1.create;
  const numberType$1 = ZodNumber$1.create;
  const nanType$1 = ZodNaN$1.create;
  const bigIntType$1 = ZodBigInt$1.create;
  const booleanType$1 = ZodBoolean$1.create;
  const dateType$1 = ZodDate$1.create;
  const symbolType$1 = ZodSymbol$1.create;
  const undefinedType$1 = ZodUndefined$1.create;
  const nullType$1 = ZodNull$1.create;
  const anyType$1 = ZodAny$1.create;
  const unknownType$1 = ZodUnknown$1.create;
  const neverType$1 = ZodNever$1.create;
  const voidType$1 = ZodVoid$1.create;
  const arrayType$1 = ZodArray$1.create;
  const objectType$1 = ZodObject$1.create;
  const strictObjectType$1 = ZodObject$1.strictCreate;
  const unionType$1 = ZodUnion$1.create;
  const discriminatedUnionType$1 = ZodDiscriminatedUnion$1.create;
  const intersectionType$1 = ZodIntersection$1.create;
  const tupleType$1 = ZodTuple$1.create;
  const recordType$1 = ZodRecord$1.create;
  const mapType$1 = ZodMap$1.create;
  const setType$1 = ZodSet$1.create;
  const functionType$1 = ZodFunction$1.create;
  const lazyType$1 = ZodLazy$1.create;
  const literalType$1 = ZodLiteral$1.create;
  const enumType$1 = ZodEnum$1.create;
  const nativeEnumType$1 = ZodNativeEnum$1.create;
  const promiseType$1 = ZodPromise$1.create;
  const effectsType$1 = ZodEffects$1.create;
  const optionalType$1 = ZodOptional$1.create;
  const nullableType$1 = ZodNullable$1.create;
  const preprocessType$1 = ZodEffects$1.createWithPreprocess;
  const pipelineType$1 = ZodPipeline$1.create;
  const ostring$1 = () => stringType$1().optional();
  const onumber$1 = () => numberType$1().optional();
  const oboolean$1 = () => booleanType$1().optional();
  const coerce$1 = {
    string: (arg) => ZodString$1.create({ ...arg, coerce: true }),
    number: (arg) => ZodNumber$1.create({ ...arg, coerce: true }),
    boolean: (arg) => ZodBoolean$1.create({
      ...arg,
      coerce: true
    }),
    bigint: (arg) => ZodBigInt$1.create({ ...arg, coerce: true }),
    date: (arg) => ZodDate$1.create({ ...arg, coerce: true })
  };
  const NEVER$1 = INVALID$1;
  var z$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    defaultErrorMap: errorMap$1,
    setErrorMap: setErrorMap$1,
    getErrorMap: getErrorMap$1,
    makeIssue: makeIssue$1,
    EMPTY_PATH: EMPTY_PATH$1,
    addIssueToContext: addIssueToContext$1,
    ParseStatus: ParseStatus$1,
    INVALID: INVALID$1,
    DIRTY: DIRTY$1,
    OK: OK$1,
    isAborted: isAborted$1,
    isDirty: isDirty$1,
    isValid: isValid$1,
    isAsync: isAsync$1,
    get util() {
      return util$1;
    },
    get objectUtil() {
      return objectUtil$1;
    },
    ZodParsedType: ZodParsedType$1,
    getParsedType: getParsedType$1,
    ZodType: ZodType$1,
    datetimeRegex: datetimeRegex$1,
    ZodString: ZodString$1,
    ZodNumber: ZodNumber$1,
    ZodBigInt: ZodBigInt$1,
    ZodBoolean: ZodBoolean$1,
    ZodDate: ZodDate$1,
    ZodSymbol: ZodSymbol$1,
    ZodUndefined: ZodUndefined$1,
    ZodNull: ZodNull$1,
    ZodAny: ZodAny$1,
    ZodUnknown: ZodUnknown$1,
    ZodNever: ZodNever$1,
    ZodVoid: ZodVoid$1,
    ZodArray: ZodArray$1,
    ZodObject: ZodObject$1,
    ZodUnion: ZodUnion$1,
    ZodDiscriminatedUnion: ZodDiscriminatedUnion$1,
    ZodIntersection: ZodIntersection$1,
    ZodTuple: ZodTuple$1,
    ZodRecord: ZodRecord$1,
    ZodMap: ZodMap$1,
    ZodSet: ZodSet$1,
    ZodFunction: ZodFunction$1,
    ZodLazy: ZodLazy$1,
    ZodLiteral: ZodLiteral$1,
    ZodEnum: ZodEnum$1,
    ZodNativeEnum: ZodNativeEnum$1,
    ZodPromise: ZodPromise$1,
    ZodEffects: ZodEffects$1,
    ZodTransformer: ZodEffects$1,
    ZodOptional: ZodOptional$1,
    ZodNullable: ZodNullable$1,
    ZodDefault: ZodDefault$1,
    ZodCatch: ZodCatch$1,
    ZodNaN: ZodNaN$1,
    BRAND: BRAND$1,
    ZodBranded: ZodBranded$1,
    ZodPipeline: ZodPipeline$1,
    ZodReadonly: ZodReadonly$1,
    custom: custom$1,
    Schema: ZodType$1,
    ZodSchema: ZodType$1,
    late: late$1,
    get ZodFirstPartyTypeKind() {
      return ZodFirstPartyTypeKind$1;
    },
    coerce: coerce$1,
    any: anyType$1,
    array: arrayType$1,
    bigint: bigIntType$1,
    boolean: booleanType$1,
    date: dateType$1,
    discriminatedUnion: discriminatedUnionType$1,
    effect: effectsType$1,
    "enum": enumType$1,
    "function": functionType$1,
    "instanceof": instanceOfType$1,
    intersection: intersectionType$1,
    lazy: lazyType$1,
    literal: literalType$1,
    map: mapType$1,
    nan: nanType$1,
    nativeEnum: nativeEnumType$1,
    never: neverType$1,
    "null": nullType$1,
    nullable: nullableType$1,
    number: numberType$1,
    object: objectType$1,
    oboolean: oboolean$1,
    onumber: onumber$1,
    optional: optionalType$1,
    ostring: ostring$1,
    pipeline: pipelineType$1,
    preprocess: preprocessType$1,
    promise: promiseType$1,
    record: recordType$1,
    set: setType$1,
    strictObject: strictObjectType$1,
    string: stringType$1,
    symbol: symbolType$1,
    transformer: effectsType$1,
    tuple: tupleType$1,
    "undefined": undefinedType$1,
    union: unionType$1,
    unknown: unknownType$1,
    "void": voidType$1,
    NEVER: NEVER$1,
    ZodIssueCode: ZodIssueCode$1,
    quotelessJson: quotelessJson$1,
    ZodError: ZodError$1
  });
  var Actors = /* @__PURE__ */ ((Actors2) => {
    Actors2["SYSTEM"] = "system";
    Actors2["USER"] = "user";
    Actors2["PLANNER"] = "planner";
    Actors2["NAVIGATOR"] = "navigator";
    Actors2["VALIDATOR"] = "validator";
    return Actors2;
  })(Actors || {});
  var EventType = /* @__PURE__ */ ((EventType2) => {
    EventType2["EXECUTION"] = "execution";
    return EventType2;
  })(EventType || {});
  var ExecutionState = /* @__PURE__ */ ((ExecutionState2) => {
    ExecutionState2["TASK_START"] = "task.start";
    ExecutionState2["TASK_OK"] = "task.ok";
    ExecutionState2["TASK_FAIL"] = "task.fail";
    ExecutionState2["TASK_PAUSE"] = "task.pause";
    ExecutionState2["TASK_RESUME"] = "task.resume";
    ExecutionState2["TASK_CANCEL"] = "task.cancel";
    ExecutionState2["STEP_START"] = "step.start";
    ExecutionState2["STEP_OK"] = "step.ok";
    ExecutionState2["STEP_FAIL"] = "step.fail";
    ExecutionState2["STEP_CANCEL"] = "step.cancel";
    ExecutionState2["ACT_START"] = "act.start";
    ExecutionState2["ACT_OK"] = "act.ok";
    ExecutionState2["ACT_FAIL"] = "act.fail";
    return ExecutionState2;
  })(ExecutionState || {});
  class AgentEvent {
    /**
     * Represents a state change event in the task execution system.
     * Each event has a type, a specific state that changed,
     * the actor that triggered the change, and associated data.
     */
    constructor(actor, state, data, timestamp = Date.now(), type = "execution") {
      this.actor = actor;
      this.state = state;
      this.data = data;
      this.timestamp = timestamp;
      this.type = type;
    }
  }
  const DEFAULT_AGENT_OPTIONS = {
    maxSteps: 100,
    maxActionsPerStep: 10,
    maxFailures: 3,
    maxValidatorFailures: 3,
    retryDelay: 10,
    maxInputTokens: 128e3,
    maxErrorLength: 400,
    useVision: false,
    useVisionForPlanner: false,
    validateOutput: true,
    includeAttributes: [
      "title",
      "type",
      "name",
      "role",
      "tabindex",
      "aria-label",
      "placeholder",
      "value",
      "alt",
      "aria-expanded",
      "data-date-format"
    ],
    planningInterval: 3
  };
  class AgentContext {
    constructor(taskId, browserContext2, messageManager, eventManager, options) {
      this.taskId = taskId;
      this.browserContext = browserContext2;
      this.messageManager = messageManager;
      this.eventManager = eventManager;
      this.options = { ...DEFAULT_AGENT_OPTIONS, ...options };
      this.paused = false;
      this.stopped = false;
      this.nSteps = 0;
      this.consecutiveFailures = 0;
      this.consecutiveValidatorFailures = 0;
      this.stepInfo = null;
      this.actionResults = [];
      this.stateMessageAdded = false;
    }
    async emitEvent(actor, state, eventDetails) {
      const event = new AgentEvent(actor, state, {
        taskId: this.taskId,
        step: this.nSteps,
        maxSteps: this.options.maxSteps,
        details: eventDetails
      });
      await this.eventManager.emit(event);
    }
    async pause() {
      this.paused = true;
    }
    async resume() {
      this.paused = false;
    }
    async stop() {
      this.stopped = true;
    }
  }
  class ActionResult {
    constructor(params = {}) {
      this.isDone = params.isDone ?? false;
      this.extractedContent = params.extractedContent ?? null;
      this.error = params.error ?? null;
      this.includeInMemory = params.includeInMemory ?? false;
    }
  }
  const agentBrainSchema = z$1.object({
    evaluation_previous_goal: z$1.string(),
    memory: z$1.string(),
    next_goal: z$1.string()
  });
  function parseJsonMarkdown(s, parser = parsePartialJson) {
    s = s.trim();
    const match = /```(json)?(.*)```/s.exec(s);
    if (!match) {
      return parser(s);
    } else {
      return parser(match[2]);
    }
  }
  function parsePartialJson(s) {
    if (typeof s === "undefined") {
      return null;
    }
    try {
      return JSON.parse(s);
    } catch (error) {
    }
    let new_s = "";
    const stack = [];
    let isInsideString = false;
    let escaped = false;
    for (let char of s) {
      if (isInsideString) {
        if (char === '"' && !escaped) {
          isInsideString = false;
        } else if (char === "\n" && !escaped) {
          char = "\\n";
        } else if (char === "\\") {
          escaped = !escaped;
        } else {
          escaped = false;
        }
      } else {
        if (char === '"') {
          isInsideString = true;
          escaped = false;
        } else if (char === "{") {
          stack.push("}");
        } else if (char === "[") {
          stack.push("]");
        } else if (char === "}" || char === "]") {
          if (stack && stack[stack.length - 1] === char) {
            stack.pop();
          } else {
            return null;
          }
        }
      }
      new_s += char;
    }
    if (isInsideString) {
      new_s += '"';
    }
    for (let i2 = stack.length - 1; i2 >= 0; i2 -= 1) {
      new_s += stack[i2];
    }
    try {
      return JSON.parse(new_s);
    } catch (error) {
      return null;
    }
  }
  var decamelize;
  var hasRequiredDecamelize;
  function requireDecamelize() {
    if (hasRequiredDecamelize) return decamelize;
    hasRequiredDecamelize = 1;
    decamelize = function(str2, sep) {
      if (typeof str2 !== "string") {
        throw new TypeError("Expected a string");
      }
      sep = typeof sep === "undefined" ? "_" : sep;
      return str2.replace(/([a-z\d])([A-Z])/g, "$1" + sep + "$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1" + sep + "$2").toLowerCase();
    };
    return decamelize;
  }
  var decamelizeExports = requireDecamelize();
  const snakeCase = /* @__PURE__ */ getDefaultExportFromCjs(decamelizeExports);
  var camelcase = { exports: {} };
  var hasRequiredCamelcase;
  function requireCamelcase() {
    if (hasRequiredCamelcase) return camelcase.exports;
    hasRequiredCamelcase = 1;
    const UPPERCASE = /[\p{Lu}]/u;
    const LOWERCASE = /[\p{Ll}]/u;
    const LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
    const IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
    const SEPARATORS = /[_.\- ]+/;
    const LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source);
    const SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
    const NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu");
    const preserveCamelCase = (string, toLowerCase, toUpperCase) => {
      let isLastCharLower = false;
      let isLastCharUpper = false;
      let isLastLastCharUpper = false;
      for (let i2 = 0; i2 < string.length; i2++) {
        const character = string[i2];
        if (isLastCharLower && UPPERCASE.test(character)) {
          string = string.slice(0, i2) + "-" + string.slice(i2);
          isLastCharLower = false;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = true;
          i2++;
        } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
          string = string.slice(0, i2 - 1) + "-" + string.slice(i2 - 1);
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = false;
          isLastCharLower = true;
        } else {
          isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
        }
      }
      return string;
    };
    const preserveConsecutiveUppercase = (input, toLowerCase) => {
      LEADING_CAPITAL.lastIndex = 0;
      return input.replace(LEADING_CAPITAL, (m1) => toLowerCase(m1));
    };
    const postProcess = (input, toUpperCase) => {
      SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
      NUMBERS_AND_IDENTIFIER.lastIndex = 0;
      return input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier)).replace(NUMBERS_AND_IDENTIFIER, (m) => toUpperCase(m));
    };
    const camelCase = (input, options) => {
      if (!(typeof input === "string" || Array.isArray(input))) {
        throw new TypeError("Expected the input to be `string | string[]`");
      }
      options = {
        pascalCase: false,
        preserveConsecutiveUppercase: false,
        ...options
      };
      if (Array.isArray(input)) {
        input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
      } else {
        input = input.trim();
      }
      if (input.length === 0) {
        return "";
      }
      const toLowerCase = options.locale === false ? (string) => string.toLowerCase() : (string) => string.toLocaleLowerCase(options.locale);
      const toUpperCase = options.locale === false ? (string) => string.toUpperCase() : (string) => string.toLocaleUpperCase(options.locale);
      if (input.length === 1) {
        return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
      }
      const hasUpperCase = input !== toLowerCase(input);
      if (hasUpperCase) {
        input = preserveCamelCase(input, toLowerCase, toUpperCase);
      }
      input = input.replace(LEADING_SEPARATORS, "");
      if (options.preserveConsecutiveUppercase) {
        input = preserveConsecutiveUppercase(input, toLowerCase);
      } else {
        input = toLowerCase(input);
      }
      if (options.pascalCase) {
        input = toUpperCase(input.charAt(0)) + input.slice(1);
      }
      return postProcess(input, toUpperCase);
    };
    camelcase.exports = camelCase;
    camelcase.exports.default = camelCase;
    return camelcase.exports;
  }
  requireCamelcase();
  function keyToJson(key, map2) {
    return (map2 == null ? void 0 : map2[key]) || snakeCase(key);
  }
  function mapKeys(fields, mapper, map2) {
    const mapped = {};
    for (const key in fields) {
      if (Object.hasOwn(fields, key)) {
        mapped[mapper(key, map2)] = fields[key];
      }
    }
    return mapped;
  }
  function shallowCopy(obj) {
    return Array.isArray(obj) ? [...obj] : { ...obj };
  }
  function replaceSecrets(root2, secretsMap) {
    const result = shallowCopy(root2);
    for (const [path, secretId] of Object.entries(secretsMap)) {
      const [last2, ...partsReverse] = path.split(".").reverse();
      let current = result;
      for (const part of partsReverse.reverse()) {
        if (current[part] === void 0) {
          break;
        }
        current[part] = shallowCopy(current[part]);
        current = current[part];
      }
      if (current[last2] !== void 0) {
        current[last2] = {
          lc: 1,
          type: "secret",
          id: [secretId]
        };
      }
    }
    return result;
  }
  function get_lc_unique_name(serializableClass) {
    const parentClass = Object.getPrototypeOf(serializableClass);
    const lcNameIsSubclassed = typeof serializableClass.lc_name === "function" && (typeof parentClass.lc_name !== "function" || serializableClass.lc_name() !== parentClass.lc_name());
    if (lcNameIsSubclassed) {
      return serializableClass.lc_name();
    } else {
      return serializableClass.name;
    }
  }
  class Serializable {
    /**
     * The name of the serializable. Override to provide an alias or
     * to preserve the serialized module name in minified environments.
     *
     * Implemented as a static method to support loading logic.
     */
    static lc_name() {
      return this.name;
    }
    /**
     * The final serialized identifier for the module.
     */
    get lc_id() {
      return [
        ...this.lc_namespace,
        get_lc_unique_name(this.constructor)
      ];
    }
    /**
     * A map of secrets, which will be omitted from serialization.
     * Keys are paths to the secret in constructor args, e.g. "foo.bar.baz".
     * Values are the secret ids, which will be used when deserializing.
     */
    get lc_secrets() {
      return void 0;
    }
    /**
     * A map of additional attributes to merge with constructor args.
     * Keys are the attribute names, e.g. "foo".
     * Values are the attribute values, which will be serialized.
     * These attributes need to be accepted by the constructor as arguments.
     */
    get lc_attributes() {
      return void 0;
    }
    /**
     * A map of aliases for constructor args.
     * Keys are the attribute names, e.g. "foo".
     * Values are the alias that will replace the key in serialization.
     * This is used to eg. make argument names match Python.
     */
    get lc_aliases() {
      return void 0;
    }
    /**
     * A manual list of keys that should be serialized.
     * If not overridden, all fields passed into the constructor will be serialized.
     */
    get lc_serializable_keys() {
      return void 0;
    }
    constructor(kwargs, ..._args3) {
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "lc_kwargs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      if (this.lc_serializable_keys !== void 0) {
        this.lc_kwargs = Object.fromEntries(Object.entries(kwargs || {}).filter(([key]) => {
          var _a3;
          return (_a3 = this.lc_serializable_keys) == null ? void 0 : _a3.includes(key);
        }));
      } else {
        this.lc_kwargs = kwargs ?? {};
      }
    }
    toJSON() {
      if (!this.lc_serializable) {
        return this.toJSONNotImplemented();
      }
      if (
        // eslint-disable-next-line no-instanceof/no-instanceof
        this.lc_kwargs instanceof Serializable || typeof this.lc_kwargs !== "object" || Array.isArray(this.lc_kwargs)
      ) {
        return this.toJSONNotImplemented();
      }
      const aliases = {};
      const secrets = {};
      const kwargs = Object.keys(this.lc_kwargs).reduce((acc, key) => {
        acc[key] = key in this ? this[key] : this.lc_kwargs[key];
        return acc;
      }, {});
      for (let current = Object.getPrototypeOf(this); current; current = Object.getPrototypeOf(current)) {
        Object.assign(aliases, Reflect.get(current, "lc_aliases", this));
        Object.assign(secrets, Reflect.get(current, "lc_secrets", this));
        Object.assign(kwargs, Reflect.get(current, "lc_attributes", this));
      }
      Object.keys(secrets).forEach((keyPath) => {
        let read = this;
        let write = kwargs;
        const [last2, ...partsReverse] = keyPath.split(".").reverse();
        for (const key of partsReverse.reverse()) {
          if (!(key in read) || read[key] === void 0)
            return;
          if (!(key in write) || write[key] === void 0) {
            if (typeof read[key] === "object" && read[key] != null) {
              write[key] = {};
            } else if (Array.isArray(read[key])) {
              write[key] = [];
            }
          }
          read = read[key];
          write = write[key];
        }
        if (last2 in read && read[last2] !== void 0) {
          write[last2] = write[last2] || read[last2];
        }
      });
      return {
        lc: 1,
        type: "constructor",
        id: this.lc_id,
        kwargs: mapKeys(Object.keys(secrets).length ? replaceSecrets(kwargs, secrets) : kwargs, keyToJson, aliases)
      };
    }
    toJSONNotImplemented() {
      return {
        lc: 1,
        type: "not_implemented",
        id: this.lc_id
      };
    }
  }
  function mergeContent(firstContent, secondContent) {
    if (typeof firstContent === "string") {
      if (firstContent === "") {
        return secondContent;
      }
      if (typeof secondContent === "string") {
        return firstContent + secondContent;
      } else {
        return [{ type: "text", text: firstContent }, ...secondContent];
      }
    } else if (Array.isArray(secondContent)) {
      return _mergeLists(firstContent, secondContent) ?? [
        ...firstContent,
        ...secondContent
      ];
    } else {
      if (secondContent === "") {
        return firstContent;
      }
      return [...firstContent, { type: "text", text: secondContent }];
    }
  }
  function _mergeStatus(left, right) {
    if (left === "error" || right === "error") {
      return "error";
    }
    return "success";
  }
  function stringifyWithDepthLimit(obj, depthLimit) {
    function helper(obj2, currentDepth) {
      if (typeof obj2 !== "object" || obj2 === null || obj2 === void 0) {
        return obj2;
      }
      if (currentDepth >= depthLimit) {
        if (Array.isArray(obj2)) {
          return "[Array]";
        }
        return "[Object]";
      }
      if (Array.isArray(obj2)) {
        return obj2.map((item) => helper(item, currentDepth + 1));
      }
      const result = {};
      for (const key of Object.keys(obj2)) {
        result[key] = helper(obj2[key], currentDepth + 1);
      }
      return result;
    }
    return JSON.stringify(helper(obj, 0), null, 2);
  }
  class BaseMessage extends Serializable {
    get lc_aliases() {
      return {
        additional_kwargs: "additional_kwargs",
        response_metadata: "response_metadata"
      };
    }
    /**
     * Get text content of the message.
     */
    get text() {
      if (typeof this.content === "string") {
        return this.content;
      }
      if (!Array.isArray(this.content))
        return "";
      return this.content.map((c) => {
        if (typeof c === "string")
          return c;
        if (c.type === "text")
          return c.text;
        return "";
      }).join("");
    }
    /** The type of the message. */
    getType() {
      return this._getType();
    }
    constructor(fields, kwargs) {
      if (typeof fields === "string") {
        fields = {
          content: fields,
          additional_kwargs: kwargs,
          response_metadata: {}
        };
      }
      if (!fields.additional_kwargs) {
        fields.additional_kwargs = {};
      }
      if (!fields.response_metadata) {
        fields.response_metadata = {};
      }
      super(fields);
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ["langchain_core", "messages"]
      });
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "content", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "additional_kwargs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "response_metadata", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "id", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.name = fields.name;
      this.content = fields.content;
      this.additional_kwargs = fields.additional_kwargs;
      this.response_metadata = fields.response_metadata;
      this.id = fields.id;
    }
    toDict() {
      return {
        type: this._getType(),
        data: this.toJSON().kwargs
      };
    }
    static lc_name() {
      return "BaseMessage";
    }
    // Can't be protected for silly reasons
    get _printableFields() {
      return {
        id: this.id,
        content: this.content,
        name: this.name,
        additional_kwargs: this.additional_kwargs,
        response_metadata: this.response_metadata
      };
    }
    // this private method is used to update the ID for the runtime
    // value as well as in lc_kwargs for serialisation
    _updateId(value) {
      this.id = value;
      this.lc_kwargs.id = value;
    }
    get [Symbol.toStringTag]() {
      return this.constructor.lc_name();
    }
    // Override the default behavior of console.log
    [Symbol.for("nodejs.util.inspect.custom")](depth) {
      if (depth === null) {
        return this;
      }
      const printable = stringifyWithDepthLimit(this._printableFields, Math.max(4, depth));
      return `${this.constructor.lc_name()} ${printable}`;
    }
  }
  function _mergeDicts(left, right) {
    const merged = { ...left };
    for (const [key, value] of Object.entries(right)) {
      if (merged[key] == null) {
        merged[key] = value;
      } else if (value == null) {
        continue;
      } else if (typeof merged[key] !== typeof value || Array.isArray(merged[key]) !== Array.isArray(value)) {
        throw new Error(`field[${key}] already exists in the message chunk, but with a different type.`);
      } else if (typeof merged[key] === "string") {
        if (key === "type") {
          continue;
        }
        merged[key] += value;
      } else if (typeof merged[key] === "object" && !Array.isArray(merged[key])) {
        merged[key] = _mergeDicts(merged[key], value);
      } else if (Array.isArray(merged[key])) {
        merged[key] = _mergeLists(merged[key], value);
      } else if (merged[key] === value) {
        continue;
      } else {
        console.warn(`field[${key}] already exists in this message chunk and value has unsupported type.`);
      }
    }
    return merged;
  }
  function _mergeLists(left, right) {
    if (left === void 0 && right === void 0) {
      return void 0;
    } else if (left === void 0 || right === void 0) {
      return left || right;
    } else {
      const merged = [...left];
      for (const item of right) {
        if (typeof item === "object" && "index" in item && typeof item.index === "number") {
          const toMerge = merged.findIndex((leftItem) => leftItem.index === item.index);
          if (toMerge !== -1) {
            merged[toMerge] = _mergeDicts(merged[toMerge], item);
          } else {
            merged.push(item);
          }
        } else if (typeof item === "object" && "text" in item && item.text === "") {
          continue;
        } else {
          merged.push(item);
        }
      }
      return merged;
    }
  }
  function _mergeObj(left, right) {
    if (!left && !right) {
      throw new Error("Cannot merge two undefined objects.");
    }
    if (!left || !right) {
      return left || right;
    } else if (typeof left !== typeof right) {
      throw new Error(`Cannot merge objects of different types.
Left ${typeof left}
Right ${typeof right}`);
    } else if (typeof left === "string" && typeof right === "string") {
      return left + right;
    } else if (Array.isArray(left) && Array.isArray(right)) {
      return _mergeLists(left, right);
    } else if (typeof left === "object" && typeof right === "object") {
      return _mergeDicts(left, right);
    } else if (left === right) {
      return left;
    } else {
      throw new Error(`Can not merge objects of different types.
Left ${left}
Right ${right}`);
    }
  }
  class BaseMessageChunk extends BaseMessage {
  }
  function _isMessageFieldWithRole(x) {
    return typeof x.role === "string";
  }
  function isBaseMessage(messageLike) {
    return typeof (messageLike == null ? void 0 : messageLike._getType) === "function";
  }
  function isBaseMessageChunk(messageLike) {
    return isBaseMessage(messageLike) && typeof messageLike.concat === "function";
  }
  class ToolMessage extends BaseMessage {
    static lc_name() {
      return "ToolMessage";
    }
    get lc_aliases() {
      return { tool_call_id: "tool_call_id" };
    }
    constructor(fields, tool_call_id, name) {
      if (typeof fields === "string") {
        fields = { content: fields, name, tool_call_id };
      }
      super(fields);
      Object.defineProperty(this, "lc_direct_tool_output", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "status", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "tool_call_id", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "artifact", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.tool_call_id = fields.tool_call_id;
      this.artifact = fields.artifact;
      this.status = fields.status;
    }
    _getType() {
      return "tool";
    }
    static isInstance(message) {
      return message._getType() === "tool";
    }
    get _printableFields() {
      return {
        ...super._printableFields,
        tool_call_id: this.tool_call_id,
        artifact: this.artifact
      };
    }
  }
  class ToolMessageChunk extends BaseMessageChunk {
    constructor(fields) {
      super(fields);
      Object.defineProperty(this, "tool_call_id", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "status", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "artifact", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.tool_call_id = fields.tool_call_id;
      this.artifact = fields.artifact;
      this.status = fields.status;
    }
    static lc_name() {
      return "ToolMessageChunk";
    }
    _getType() {
      return "tool";
    }
    concat(chunk) {
      return new ToolMessageChunk({
        content: mergeContent(this.content, chunk.content),
        additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
        response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),
        artifact: _mergeObj(this.artifact, chunk.artifact),
        tool_call_id: this.tool_call_id,
        id: this.id ?? chunk.id,
        status: _mergeStatus(this.status, chunk.status)
      });
    }
    get _printableFields() {
      return {
        ...super._printableFields,
        tool_call_id: this.tool_call_id,
        artifact: this.artifact
      };
    }
  }
  function defaultToolCallParser(rawToolCalls) {
    const toolCalls = [];
    const invalidToolCalls = [];
    for (const toolCall of rawToolCalls) {
      if (!toolCall.function) {
        continue;
      } else {
        const functionName = toolCall.function.name;
        try {
          const functionArgs = JSON.parse(toolCall.function.arguments);
          const parsed = {
            name: functionName || "",
            args: functionArgs || {},
            id: toolCall.id
          };
          toolCalls.push(parsed);
        } catch (error) {
          invalidToolCalls.push({
            name: functionName,
            args: toolCall.function.arguments,
            id: toolCall.id,
            error: "Malformed args."
          });
        }
      }
    }
    return [toolCalls, invalidToolCalls];
  }
  class AIMessage extends BaseMessage {
    get lc_aliases() {
      return {
        ...super.lc_aliases,
        tool_calls: "tool_calls",
        invalid_tool_calls: "invalid_tool_calls"
      };
    }
    constructor(fields, kwargs) {
      var _a3;
      let initParams;
      if (typeof fields === "string") {
        initParams = {
          content: fields,
          tool_calls: [],
          invalid_tool_calls: [],
          additional_kwargs: kwargs ?? {}
        };
      } else {
        initParams = fields;
        const rawToolCalls = (_a3 = initParams.additional_kwargs) == null ? void 0 : _a3.tool_calls;
        const toolCalls = initParams.tool_calls;
        if (!(rawToolCalls == null) && rawToolCalls.length > 0 && (toolCalls === void 0 || toolCalls.length === 0)) {
          console.warn([
            "New LangChain packages are available that more efficiently handle",
            "tool calling.\n\nPlease upgrade your packages to versions that set",
            "message tool calls. e.g., `yarn add @langchain/anthropic`,",
            "yarn add @langchain/openai`, etc."
          ].join(" "));
        }
        try {
          if (!(rawToolCalls == null) && toolCalls === void 0) {
            const [toolCalls2, invalidToolCalls] = defaultToolCallParser(rawToolCalls);
            initParams.tool_calls = toolCalls2 ?? [];
            initParams.invalid_tool_calls = invalidToolCalls ?? [];
          } else {
            initParams.tool_calls = initParams.tool_calls ?? [];
            initParams.invalid_tool_calls = initParams.invalid_tool_calls ?? [];
          }
        } catch (e) {
          initParams.tool_calls = [];
          initParams.invalid_tool_calls = [];
        }
      }
      super(initParams);
      Object.defineProperty(this, "tool_calls", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
      Object.defineProperty(this, "invalid_tool_calls", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
      Object.defineProperty(this, "usage_metadata", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      if (typeof initParams !== "string") {
        this.tool_calls = initParams.tool_calls ?? this.tool_calls;
        this.invalid_tool_calls = initParams.invalid_tool_calls ?? this.invalid_tool_calls;
      }
      this.usage_metadata = initParams.usage_metadata;
    }
    static lc_name() {
      return "AIMessage";
    }
    _getType() {
      return "ai";
    }
    get _printableFields() {
      return {
        ...super._printableFields,
        tool_calls: this.tool_calls,
        invalid_tool_calls: this.invalid_tool_calls,
        usage_metadata: this.usage_metadata
      };
    }
  }
  function isAIMessage(x) {
    return x._getType() === "ai";
  }
  function isAIMessageChunk(x) {
    return x._getType() === "ai";
  }
  class AIMessageChunk extends BaseMessageChunk {
    constructor(fields) {
      let initParams;
      if (typeof fields === "string") {
        initParams = {
          content: fields,
          tool_calls: [],
          invalid_tool_calls: [],
          tool_call_chunks: []
        };
      } else if (fields.tool_call_chunks === void 0) {
        initParams = {
          ...fields,
          tool_calls: fields.tool_calls ?? [],
          invalid_tool_calls: [],
          tool_call_chunks: [],
          usage_metadata: fields.usage_metadata !== void 0 ? fields.usage_metadata : void 0
        };
      } else {
        const toolCalls = [];
        const invalidToolCalls = [];
        for (const toolCallChunk of fields.tool_call_chunks) {
          let parsedArgs = {};
          try {
            parsedArgs = parsePartialJson(toolCallChunk.args || "{}");
            if (parsedArgs === null || typeof parsedArgs !== "object" || Array.isArray(parsedArgs)) {
              throw new Error("Malformed tool call chunk args.");
            }
            toolCalls.push({
              name: toolCallChunk.name ?? "",
              args: parsedArgs,
              id: toolCallChunk.id,
              type: "tool_call"
            });
          } catch (e) {
            invalidToolCalls.push({
              name: toolCallChunk.name,
              args: toolCallChunk.args,
              id: toolCallChunk.id,
              error: "Malformed args.",
              type: "invalid_tool_call"
            });
          }
        }
        initParams = {
          ...fields,
          tool_calls: toolCalls,
          invalid_tool_calls: invalidToolCalls,
          usage_metadata: fields.usage_metadata !== void 0 ? fields.usage_metadata : void 0
        };
      }
      super(initParams);
      Object.defineProperty(this, "tool_calls", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
      Object.defineProperty(this, "invalid_tool_calls", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
      Object.defineProperty(this, "tool_call_chunks", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
      Object.defineProperty(this, "usage_metadata", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.tool_call_chunks = initParams.tool_call_chunks ?? this.tool_call_chunks;
      this.tool_calls = initParams.tool_calls ?? this.tool_calls;
      this.invalid_tool_calls = initParams.invalid_tool_calls ?? this.invalid_tool_calls;
      this.usage_metadata = initParams.usage_metadata;
    }
    get lc_aliases() {
      return {
        ...super.lc_aliases,
        tool_calls: "tool_calls",
        invalid_tool_calls: "invalid_tool_calls",
        tool_call_chunks: "tool_call_chunks"
      };
    }
    static lc_name() {
      return "AIMessageChunk";
    }
    _getType() {
      return "ai";
    }
    get _printableFields() {
      return {
        ...super._printableFields,
        tool_calls: this.tool_calls,
        tool_call_chunks: this.tool_call_chunks,
        invalid_tool_calls: this.invalid_tool_calls,
        usage_metadata: this.usage_metadata
      };
    }
    concat(chunk) {
      var _a3, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2, _k2, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x2, _y2, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N;
      const combinedFields = {
        content: mergeContent(this.content, chunk.content),
        additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
        response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),
        tool_call_chunks: [],
        id: this.id ?? chunk.id
      };
      if (this.tool_call_chunks !== void 0 || chunk.tool_call_chunks !== void 0) {
        const rawToolCalls = _mergeLists(this.tool_call_chunks, chunk.tool_call_chunks);
        if (rawToolCalls !== void 0 && rawToolCalls.length > 0) {
          combinedFields.tool_call_chunks = rawToolCalls;
        }
      }
      if (this.usage_metadata !== void 0 || chunk.usage_metadata !== void 0) {
        const inputTokenDetails = {
          ...(((_b2 = (_a3 = this.usage_metadata) == null ? void 0 : _a3.input_token_details) == null ? void 0 : _b2.audio) !== void 0 || ((_d2 = (_c2 = chunk.usage_metadata) == null ? void 0 : _c2.input_token_details) == null ? void 0 : _d2.audio) !== void 0) && {
            audio: (((_f2 = (_e2 = this.usage_metadata) == null ? void 0 : _e2.input_token_details) == null ? void 0 : _f2.audio) ?? 0) + (((_h2 = (_g2 = chunk.usage_metadata) == null ? void 0 : _g2.input_token_details) == null ? void 0 : _h2.audio) ?? 0)
          },
          ...(((_j2 = (_i2 = this.usage_metadata) == null ? void 0 : _i2.input_token_details) == null ? void 0 : _j2.cache_read) !== void 0 || ((_l = (_k2 = chunk.usage_metadata) == null ? void 0 : _k2.input_token_details) == null ? void 0 : _l.cache_read) !== void 0) && {
            cache_read: (((_n = (_m = this.usage_metadata) == null ? void 0 : _m.input_token_details) == null ? void 0 : _n.cache_read) ?? 0) + (((_p = (_o = chunk.usage_metadata) == null ? void 0 : _o.input_token_details) == null ? void 0 : _p.cache_read) ?? 0)
          },
          ...(((_r = (_q = this.usage_metadata) == null ? void 0 : _q.input_token_details) == null ? void 0 : _r.cache_creation) !== void 0 || ((_t = (_s = chunk.usage_metadata) == null ? void 0 : _s.input_token_details) == null ? void 0 : _t.cache_creation) !== void 0) && {
            cache_creation: (((_v = (_u = this.usage_metadata) == null ? void 0 : _u.input_token_details) == null ? void 0 : _v.cache_creation) ?? 0) + (((_x2 = (_w = chunk.usage_metadata) == null ? void 0 : _w.input_token_details) == null ? void 0 : _x2.cache_creation) ?? 0)
          }
        };
        const outputTokenDetails = {
          ...(((_z = (_y2 = this.usage_metadata) == null ? void 0 : _y2.output_token_details) == null ? void 0 : _z.audio) !== void 0 || ((_B = (_A = chunk.usage_metadata) == null ? void 0 : _A.output_token_details) == null ? void 0 : _B.audio) !== void 0) && {
            audio: (((_D = (_C = this.usage_metadata) == null ? void 0 : _C.output_token_details) == null ? void 0 : _D.audio) ?? 0) + (((_F = (_E = chunk.usage_metadata) == null ? void 0 : _E.output_token_details) == null ? void 0 : _F.audio) ?? 0)
          },
          ...(((_H = (_G = this.usage_metadata) == null ? void 0 : _G.output_token_details) == null ? void 0 : _H.reasoning) !== void 0 || ((_J = (_I = chunk.usage_metadata) == null ? void 0 : _I.output_token_details) == null ? void 0 : _J.reasoning) !== void 0) && {
            reasoning: (((_L = (_K = this.usage_metadata) == null ? void 0 : _K.output_token_details) == null ? void 0 : _L.reasoning) ?? 0) + (((_N = (_M = chunk.usage_metadata) == null ? void 0 : _M.output_token_details) == null ? void 0 : _N.reasoning) ?? 0)
          }
        };
        const left = this.usage_metadata ?? {
          input_tokens: 0,
          output_tokens: 0,
          total_tokens: 0
        };
        const right = chunk.usage_metadata ?? {
          input_tokens: 0,
          output_tokens: 0,
          total_tokens: 0
        };
        const usage_metadata = {
          input_tokens: left.input_tokens + right.input_tokens,
          output_tokens: left.output_tokens + right.output_tokens,
          total_tokens: left.total_tokens + right.total_tokens,
          // Do not include `input_token_details` / `output_token_details` keys in combined fields
          // unless their values are defined.
          ...Object.keys(inputTokenDetails).length > 0 && {
            input_token_details: inputTokenDetails
          },
          ...Object.keys(outputTokenDetails).length > 0 && {
            output_token_details: outputTokenDetails
          }
        };
        combinedFields.usage_metadata = usage_metadata;
      }
      return new AIMessageChunk(combinedFields);
    }
  }
  class ChatMessage extends BaseMessage {
    static lc_name() {
      return "ChatMessage";
    }
    static _chatMessageClass() {
      return ChatMessage;
    }
    constructor(fields, role) {
      if (typeof fields === "string") {
        fields = { content: fields, role };
      }
      super(fields);
      Object.defineProperty(this, "role", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.role = fields.role;
    }
    _getType() {
      return "generic";
    }
    static isInstance(message) {
      return message._getType() === "generic";
    }
    get _printableFields() {
      return {
        ...super._printableFields,
        role: this.role
      };
    }
  }
  class ChatMessageChunk extends BaseMessageChunk {
    static lc_name() {
      return "ChatMessageChunk";
    }
    constructor(fields, role) {
      if (typeof fields === "string") {
        fields = { content: fields, role };
      }
      super(fields);
      Object.defineProperty(this, "role", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.role = fields.role;
    }
    _getType() {
      return "generic";
    }
    concat(chunk) {
      return new ChatMessageChunk({
        content: mergeContent(this.content, chunk.content),
        additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
        response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),
        role: this.role,
        id: this.id ?? chunk.id
      });
    }
    get _printableFields() {
      return {
        ...super._printableFields,
        role: this.role
      };
    }
  }
  class FunctionMessageChunk extends BaseMessageChunk {
    static lc_name() {
      return "FunctionMessageChunk";
    }
    _getType() {
      return "function";
    }
    concat(chunk) {
      return new FunctionMessageChunk({
        content: mergeContent(this.content, chunk.content),
        additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
        response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),
        name: this.name ?? "",
        id: this.id ?? chunk.id
      });
    }
  }
  class HumanMessage extends BaseMessage {
    static lc_name() {
      return "HumanMessage";
    }
    _getType() {
      return "human";
    }
  }
  class HumanMessageChunk extends BaseMessageChunk {
    static lc_name() {
      return "HumanMessageChunk";
    }
    _getType() {
      return "human";
    }
    concat(chunk) {
      return new HumanMessageChunk({
        content: mergeContent(this.content, chunk.content),
        additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
        response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),
        id: this.id ?? chunk.id
      });
    }
  }
  class SystemMessage extends BaseMessage {
    static lc_name() {
      return "SystemMessage";
    }
    _getType() {
      return "system";
    }
  }
  class SystemMessageChunk extends BaseMessageChunk {
    static lc_name() {
      return "SystemMessageChunk";
    }
    _getType() {
      return "system";
    }
    concat(chunk) {
      return new SystemMessageChunk({
        content: mergeContent(this.content, chunk.content),
        additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
        response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),
        id: this.id ?? chunk.id
      });
    }
  }
  function addLangChainErrorFields$3(error, lc_error_code) {
    error.lc_error_code = lc_error_code;
    error.message = `${error.message}

Troubleshooting URL: https://js.langchain.com/docs/troubleshooting/errors/${lc_error_code}/
`;
    return error;
  }
  function _isToolCall(toolCall) {
    return !!(toolCall && typeof toolCall === "object" && "type" in toolCall && toolCall.type === "tool_call");
  }
  class ToolInputParsingException extends Error {
    constructor(message, output) {
      super(message);
      Object.defineProperty(this, "output", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.output = output;
    }
  }
  function _coerceToolCall(toolCall) {
    if (_isToolCall(toolCall)) {
      return toolCall;
    } else if (typeof toolCall.id === "string" && toolCall.type === "function" && typeof toolCall.function === "object" && toolCall.function !== null && "arguments" in toolCall.function && typeof toolCall.function.arguments === "string" && "name" in toolCall.function && typeof toolCall.function.name === "string") {
      return {
        id: toolCall.id,
        args: JSON.parse(toolCall.function.arguments),
        name: toolCall.function.name,
        type: "tool_call"
      };
    } else {
      return toolCall;
    }
  }
  function isSerializedConstructor(x) {
    return typeof x === "object" && x != null && x.lc === 1 && Array.isArray(x.id) && x.kwargs != null && typeof x.kwargs === "object";
  }
  function _constructMessageFromParams(params) {
    let type;
    let rest;
    if (isSerializedConstructor(params)) {
      const className = params.id.at(-1);
      if (className === "HumanMessage" || className === "HumanMessageChunk") {
        type = "user";
      } else if (className === "AIMessage" || className === "AIMessageChunk") {
        type = "assistant";
      } else if (className === "SystemMessage" || className === "SystemMessageChunk") {
        type = "system";
      } else if (className === "FunctionMessage" || className === "FunctionMessageChunk") {
        type = "function";
      } else if (className === "ToolMessage" || className === "ToolMessageChunk") {
        type = "tool";
      } else {
        type = "unknown";
      }
      rest = params.kwargs;
    } else {
      const { type: extractedType, ...otherParams } = params;
      type = extractedType;
      rest = otherParams;
    }
    if (type === "human" || type === "user") {
      return new HumanMessage(rest);
    } else if (type === "ai" || type === "assistant") {
      const { tool_calls: rawToolCalls, ...other } = rest;
      if (!Array.isArray(rawToolCalls)) {
        return new AIMessage(rest);
      }
      const tool_calls = rawToolCalls.map(_coerceToolCall);
      return new AIMessage({ ...other, tool_calls });
    } else if (type === "system") {
      return new SystemMessage(rest);
    } else if (type === "developer") {
      return new SystemMessage({
        ...rest,
        additional_kwargs: {
          ...rest.additional_kwargs,
          __openai_role__: "developer"
        }
      });
    } else if (type === "tool" && "tool_call_id" in rest) {
      return new ToolMessage({
        ...rest,
        content: rest.content,
        tool_call_id: rest.tool_call_id,
        name: rest.name
      });
    } else {
      const error = addLangChainErrorFields$3(new Error(`Unable to coerce message from array: only human, AI, system, developer, or tool message coercion is currently supported.

Received: ${JSON.stringify(params, null, 2)}`), "MESSAGE_COERCION_FAILURE");
      throw error;
    }
  }
  function coerceMessageLikeToMessage(messageLike) {
    if (typeof messageLike === "string") {
      return new HumanMessage(messageLike);
    } else if (isBaseMessage(messageLike)) {
      return messageLike;
    }
    if (Array.isArray(messageLike)) {
      const [type, content] = messageLike;
      return _constructMessageFromParams({ type, content });
    } else if (_isMessageFieldWithRole(messageLike)) {
      const { role: type, ...rest } = messageLike;
      return _constructMessageFromParams({ ...rest, type });
    } else {
      return _constructMessageFromParams(messageLike);
    }
  }
  function getBufferString(messages, humanPrefix = "Human", aiPrefix = "AI") {
    const string_messages = [];
    for (const m of messages) {
      let role;
      if (m._getType() === "human") {
        role = humanPrefix;
      } else if (m._getType() === "ai") {
        role = aiPrefix;
      } else if (m._getType() === "system") {
        role = "System";
      } else if (m._getType() === "function") {
        role = "Function";
      } else if (m._getType() === "tool") {
        role = "Tool";
      } else if (m._getType() === "generic") {
        role = m.role;
      } else {
        throw new Error(`Got unsupported message type: ${m._getType()}`);
      }
      const nameStr = m.name ? `${m.name}, ` : "";
      const readableContent = typeof m.content === "string" ? m.content : JSON.stringify(m.content, null, 2);
      string_messages.push(`${role}: ${nameStr}${readableContent}`);
    }
    return string_messages.join("\n");
  }
  function convertToChunk(message) {
    var _a3;
    const type = message._getType();
    if (type === "human") {
      return new HumanMessageChunk({ ...message });
    } else if (type === "ai") {
      let aiChunkFields = {
        ...message
      };
      if ("tool_calls" in aiChunkFields) {
        aiChunkFields = {
          ...aiChunkFields,
          tool_call_chunks: (_a3 = aiChunkFields.tool_calls) == null ? void 0 : _a3.map((tc) => ({
            ...tc,
            type: "tool_call_chunk",
            index: void 0,
            args: JSON.stringify(tc.args)
          }))
        };
      }
      return new AIMessageChunk({ ...aiChunkFields });
    } else if (type === "system") {
      return new SystemMessageChunk({ ...message });
    } else if (type === "function") {
      return new FunctionMessageChunk({ ...message });
    } else if (ChatMessage.isInstance(message)) {
      return new ChatMessageChunk({ ...message });
    } else {
      throw new Error("Unknown message type.");
    }
  }
  var util;
  (function(util2) {
    util2.assertEqual = (val) => val;
    function assertIs(_arg) {
    }
    util2.assertIs = assertIs;
    function assertNever2(_x2) {
      throw new Error();
    }
    util2.assertNever = assertNever2;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
      const filtered = {};
      for (const k of validKeys) {
        filtered[k] = obj[k];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e) {
        return obj[e];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
      const keys = [];
      for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    util2.find = (arr2, checker) => {
      for (const item of arr2) {
        if (checker(item))
          return item;
      }
      return void 0;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
      return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util || (util = {}));
  var objectUtil;
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first2, second) => {
      return {
        ...first2,
        ...second
        // second overwrites first
      };
    };
  })(objectUtil || (objectUtil = {}));
  const ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "undefined":
        return ZodParsedType.undefined;
      case "string":
        return ZodParsedType.string;
      case "number":
        return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
      case "boolean":
        return ZodParsedType.boolean;
      case "function":
        return ZodParsedType.function;
      case "bigint":
        return ZodParsedType.bigint;
      case "symbol":
        return ZodParsedType.symbol;
      case "object":
        if (Array.isArray(data)) {
          return ZodParsedType.array;
        }
        if (data === null) {
          return ZodParsedType.null;
        }
        if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
          return ZodParsedType.promise;
        }
        if (typeof Map !== "undefined" && data instanceof Map) {
          return ZodParsedType.map;
        }
        if (typeof Set !== "undefined" && data instanceof Set) {
          return ZodParsedType.set;
        }
        if (typeof Date !== "undefined" && data instanceof Date) {
          return ZodParsedType.date;
        }
        return ZodParsedType.object;
      default:
        return ZodParsedType.unknown;
    }
  };
  const ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
  };
  class ZodError extends Error {
    get errors() {
      return this.issues;
    }
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    format(_mapper2) {
      const mapper = _mapper2 || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error) => {
        for (const issue of error.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i2 = 0;
            while (i2 < issue.path.length) {
              const el = issue.path[i2];
              const terminal = i2 === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i2++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    static assert(value) {
      if (!(value instanceof ZodError)) {
        throw new Error(`Not a ZodError: ${value}`);
      }
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
          fieldErrors[sub.path[0]].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  }
  ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
  };
  const errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
      case ZodIssueCode.invalid_type:
        if (issue.received === ZodParsedType.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue.expected}, received ${issue.received}`;
        }
        break;
      case ZodIssueCode.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
        break;
      case ZodIssueCode.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
        break;
      case ZodIssueCode.invalid_union:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
        break;
      case ZodIssueCode.invalid_enum_value:
        message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
        break;
      case ZodIssueCode.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodIssueCode.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodIssueCode.invalid_date:
        message = `Invalid date`;
        break;
      case ZodIssueCode.invalid_string:
        if (typeof issue.validation === "object") {
          if ("includes" in issue.validation) {
            message = `Invalid input: must include "${issue.validation.includes}"`;
            if (typeof issue.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
            }
          } else if ("startsWith" in issue.validation) {
            message = `Invalid input: must start with "${issue.validation.startsWith}"`;
          } else if ("endsWith" in issue.validation) {
            message = `Invalid input: must end with "${issue.validation.endsWith}"`;
          } else {
            util.assertNever(issue.validation);
          }
        } else if (issue.validation !== "regex") {
          message = `Invalid ${issue.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodIssueCode.too_small:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.too_big:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "bigint")
          message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.custom:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodIssueCode.not_multiple_of:
        message = `Number must be a multiple of ${issue.multipleOf}`;
        break;
      case ZodIssueCode.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util.assertNever(issue);
    }
    return { message };
  };
  let overrideErrorMap = errorMap;
  function setErrorMap(map2) {
    overrideErrorMap = map2;
  }
  function getErrorMap() {
    return overrideErrorMap;
  }
  const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...issueData.path || []];
    const fullIssue = {
      ...issueData,
      path: fullPath
    };
    if (issueData.message !== void 0) {
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message
      };
    }
    let errorMessage = "";
    const maps = errorMaps.filter((m) => !!m).slice().reverse();
    for (const map2 of maps) {
      errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
      ...issueData,
      path: fullPath,
      message: errorMessage
    };
  };
  const EMPTY_PATH = [];
  function addIssueToContext(ctx, issueData) {
    const overrideMap = getErrorMap();
    const issue = makeIssue({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        // contextual error map is first priority
        ctx.schemaErrorMap,
        // then schema-bound map if available
        overrideMap,
        // then global override map
        overrideMap === errorMap ? void 0 : errorMap
        // then global default map
      ].filter((x) => !!x)
    });
    ctx.common.issues.push(issue);
  }
  class ParseStatus {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      if (this.value === "valid")
        this.value = "dirty";
    }
    abort() {
      if (this.value !== "aborted")
        this.value = "aborted";
    }
    static mergeArray(status, results) {
      const arrayValue = [];
      for (const s of results) {
        if (s.status === "aborted")
          return INVALID;
        if (s.status === "dirty")
          status.dirty();
        arrayValue.push(s.value);
      }
      return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
      const syncPairs = [];
      for (const pair of pairs) {
        const key = await pair.key;
        const value = await pair.value;
        syncPairs.push({
          key,
          value
        });
      }
      return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
      const finalObject = {};
      for (const pair of pairs) {
        const { key, value } = pair;
        if (key.status === "aborted")
          return INVALID;
        if (value.status === "aborted")
          return INVALID;
        if (key.status === "dirty")
          status.dirty();
        if (value.status === "dirty")
          status.dirty();
        if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
          finalObject[key.value] = value.value;
        }
      }
      return { status: status.value, value: finalObject };
    }
  }
  const INVALID = Object.freeze({
    status: "aborted"
  });
  const DIRTY = (value) => ({ status: "dirty", value });
  const OK = (value) => ({ status: "valid", value });
  const isAborted = (x) => x.status === "aborted";
  const isDirty = (x) => x.status === "dirty";
  const isValid = (x) => x.status === "valid";
  const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
  function __classPrivateFieldGet$d(receiver, state, kind2, f) {
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return state.get(receiver);
  }
  function __classPrivateFieldSet$b(receiver, state, value, kind2, f) {
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return state.set(receiver, value), value;
  }
  typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };
  var errorUtil;
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
  })(errorUtil || (errorUtil = {}));
  var _ZodEnum_cache, _ZodNativeEnum_cache;
  class ParseInputLazyPath {
    constructor(parent, value, path, key) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path;
      this._key = key;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (this._key instanceof Array) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  }
  const handleResult = (ctx, result) => {
    if (isValid(result)) {
      return { success: true, data: result.value };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error)
            return this._error;
          const error = new ZodError(ctx.common.issues);
          this._error = error;
          return this._error;
        }
      };
    }
  };
  function processCreateParams(params) {
    if (!params)
      return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2)
      return { errorMap: errorMap2, description };
    const customMap = (iss, ctx) => {
      var _a3, _b2;
      const { message } = params;
      if (iss.code === "invalid_enum_value") {
        return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
      }
      if (typeof ctx.data === "undefined") {
        return { message: (_a3 = message !== null && message !== void 0 ? message : required_error) !== null && _a3 !== void 0 ? _a3 : ctx.defaultError };
      }
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      return { message: (_b2 = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b2 !== void 0 ? _b2 : ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }
  class ZodType {
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      };
    }
    _processInputParams(input) {
      return {
        status: new ParseStatus(),
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        }
      };
    }
    _parseSync(input) {
      const result = this._parse(input);
      if (isAsync(result)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result;
    }
    _parseAsync(input) {
      const result = this._parse(input);
      return Promise.resolve(result);
    }
    parse(data, params) {
      const result = this.safeParse(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    safeParse(data, params) {
      var _a3;
      const ctx = {
        common: {
          issues: [],
          async: (_a3 = params === null || params === void 0 ? void 0 : params.async) !== null && _a3 !== void 0 ? _a3 : false,
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const result = this._parseSync({ data, path: ctx.path, parent: ctx });
      return handleResult(ctx, result);
    }
    "~validate"(data) {
      var _a3, _b2;
      const ctx = {
        common: {
          issues: [],
          async: !!this["~standard"].async
        },
        path: [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      if (!this["~standard"].async) {
        try {
          const result = this._parseSync({ data, path: [], parent: ctx });
          return isValid(result) ? {
            value: result.value
          } : {
            issues: ctx.common.issues
          };
        } catch (err) {
          if ((_b2 = (_a3 = err === null || err === void 0 ? void 0 : err.message) === null || _a3 === void 0 ? void 0 : _a3.toLowerCase()) === null || _b2 === void 0 ? void 0 : _b2.includes("encountered")) {
            this["~standard"].async = true;
          }
          ctx.common = {
            issues: [],
            async: true
          };
        }
      }
      return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
        value: result.value
      } : {
        issues: ctx.common.issues
      });
    }
    async parseAsync(data, params) {
      const result = await this.safeParseAsync(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    async safeParseAsync(data, params) {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
          async: true
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
      const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
      return handleResult(ctx, result);
    }
    refine(check, message) {
      const getIssueProperties = (val) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return { message };
        } else if (typeof message === "function") {
          return message(val);
        } else {
          return message;
        }
      };
      return this._refinement((val, ctx) => {
        const result = check(val);
        const setError = () => ctx.addIssue({
          code: ZodIssueCode.custom,
          ...getIssueProperties(val)
        });
        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then((data) => {
            if (!data) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check, refinementData) {
      return this._refinement((val, ctx) => {
        if (!check(val)) {
          ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects({
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "refinement", refinement }
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    constructor(def) {
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.readonly = this.readonly.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
      this["~standard"] = {
        version: 1,
        vendor: "zod",
        validate: (data) => this["~validate"](data)
      };
    }
    optional() {
      return ZodOptional.create(this, this._def);
    }
    nullable() {
      return ZodNullable.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray.create(this);
    }
    promise() {
      return ZodPromise.create(this, this._def);
    }
    or(option) {
      return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
      return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
      return new ZodEffects({
        ...processCreateParams(this._def),
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "transform", transform }
      });
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault({
        ...processCreateParams(this._def),
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodDefault
      });
    }
    brand() {
      return new ZodBranded({
        typeName: ZodFirstPartyTypeKind.ZodBranded,
        type: this,
        ...processCreateParams(this._def)
      });
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch({
        ...processCreateParams(this._def),
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodCatch
      });
    }
    describe(description) {
      const This = this.constructor;
      return new This({
        ...this._def,
        description
      });
    }
    pipe(target) {
      return ZodPipeline.create(this, target);
    }
    readonly() {
      return ZodReadonly.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  const cuidRegex = /^c[^\s-]{8,}$/i;
  const cuid2Regex = /^[0-9a-z]+$/;
  const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
  const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  const nanoidRegex = /^[a-z0-9_-]{21}$/i;
  const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
  const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  let emojiRegex$4;
  const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
  const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
  const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
  const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
  const dateRegex = new RegExp(`^${dateRegexSource}$`);
  function timeRegexSource(args) {
    let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
    if (args.precision) {
      regex = `${regex}\\.\\d{${args.precision}}`;
    } else if (args.precision == null) {
      regex = `${regex}(\\.\\d+)?`;
    }
    return regex;
  }
  function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
  }
  function datetimeRegex(args) {
    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset)
      opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
  }
  function isValidIP(ip, version2) {
    if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
      return true;
    }
    if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
      return true;
    }
    return false;
  }
  function isValidJWT(jwt, alg) {
    if (!jwtRegex.test(jwt))
      return false;
    try {
      const [header] = jwt.split(".");
      const base642 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
      const decoded = JSON.parse(atob(base642));
      if (typeof decoded !== "object" || decoded === null)
        return false;
      if (!decoded.typ || !decoded.alg)
        return false;
      if (alg && decoded.alg !== alg)
        return false;
      return true;
    } catch (_a3) {
      return false;
    }
  }
  function isValidCidr(ip, version2) {
    if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
      return true;
    }
    if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
      return true;
    }
    return false;
  }
  class ZodString extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex$4) {
            emojiRegex$4 = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex$4.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "nanoid") {
          if (!nanoidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "nanoid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch (_a3) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex = datetimeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "date") {
          const regex = dateRegex;
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "date",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "time") {
          const regex = timeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "time",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "duration") {
          if (!durationRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "duration",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "jwt") {
          if (!isValidJWT(input.data, check.alg)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "jwt",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cidr") {
          if (!isValidCidr(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cidr",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64") {
          if (!base64Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64url") {
          if (!base64urlRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
      return this.refinement((data) => regex.test(data), {
        validation,
        code: ZodIssueCode.invalid_string,
        ...errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    nanoid(message) {
      return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    base64(message) {
      return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
    }
    base64url(message) {
      return this._addCheck({
        kind: "base64url",
        ...errorUtil.errToObj(message)
      });
    }
    jwt(options) {
      return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    cidr(options) {
      return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
      var _a3, _b2;
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          local: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
        offset: (_a3 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a3 !== void 0 ? _a3 : false,
        local: (_b2 = options === null || options === void 0 ? void 0 : options.local) !== null && _b2 !== void 0 ? _b2 : false,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    date(message) {
      return this._addCheck({ kind: "date", message });
    }
    time(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "time",
          precision: null,
          message: options
        });
      }
      return this._addCheck({
        kind: "time",
        precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    duration(message) {
      return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
    }
    regex(regex, message) {
      return this._addCheck({
        kind: "regex",
        regex,
        ...errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options === null || options === void 0 ? void 0 : options.position,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil.errToObj(message)
      });
    }
    /**
     * Equivalent to `.min(1)`
     */
    nonempty(message) {
      return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((ch) => ch.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((ch) => ch.kind === "base64url");
    }
    get minLength() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  }
  ZodString.create = (params) => {
    var _a3;
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: (_a3 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a3 !== void 0 ? _a3 : false,
      ...processCreateParams(params)
    });
  };
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / Math.pow(10, decCount);
  }
  class ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind2, value, inclusive, message) {
      return new ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: kind2,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
    }
    get isFinite() {
      let max = null, min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        } else if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  }
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  class ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        try {
          input.data = BigInt(input.data);
        } catch (_a3) {
          return this._getInvalidInput(input);
        }
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.bigint) {
        return this._getInvalidInput(input);
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _getInvalidInput(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx.parsedType
      });
      return INVALID;
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind2, value, inclusive, message) {
      return new ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: kind2,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  }
  ZodBigInt.create = (params) => {
    var _a3;
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: (_a3 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a3 !== void 0 ? _a3 : false,
      ...processCreateParams(params)
    });
  };
  class ZodBoolean extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  class ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      if (isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_date
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new ZodDate({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  }
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };
  class ZodSymbol extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  class ZodUndefined extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  class ZodNull extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };
  class ZodAny extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  }
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };
  class ZodUnknown extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  }
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  class ZodNever extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType
      });
      return INVALID;
    }
  }
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };
  class ZodVoid extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };
  class ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : void 0,
            maximum: tooBig ? def.exactLength.value : void 0,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i2) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
        })).then((result2) => {
          return ParseStatus.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i2) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
      });
      return ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  ZodArray.create = (schema, params) => {
    return new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
      const newShape = {};
      for (const key in schema.shape) {
        const fieldSchema = schema.shape[key];
        newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
      }
      return new ZodObject({
        ...schema._def,
        shape: () => newShape
      });
    } else if (schema instanceof ZodArray) {
      return new ZodArray({
        ...schema._def,
        type: deepPartialify(schema.element)
      });
    } else if (schema instanceof ZodOptional) {
      return ZodOptional.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable) {
      return ZodNullable.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple) {
      return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    } else {
      return schema;
    }
  }
  class ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys = util.objectKeys(shape);
      return this._cached = { shape, keys };
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip") ;
        else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(
              new ParseInputLazyPath(ctx, value, ctx.path, key)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
              key,
              value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== void 0 ? {
          errorMap: (issue, ctx) => {
            var _a3, _b2, _c2, _d2;
            const defaultError = (_c2 = (_b2 = (_a3 = this._def).errorMap) === null || _b2 === void 0 ? void 0 : _b2.call(_a3, issue, ctx).message) !== null && _c2 !== void 0 ? _c2 : ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: (_d2 = errorUtil.errToObj(message).message) !== null && _d2 !== void 0 ? _d2 : defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
      return new ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
      const merged = new ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
      return new ZodObject({
        ...this._def,
        catchall: index
      });
    }
    pick(mask) {
      const shape = {};
      util.objectKeys(mask).forEach((key) => {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util.objectKeys(this.shape));
    }
  }
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  class ZodUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = void 0;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError(issues2));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  }
  ZodUnion.create = (types, params) => {
    return new ZodUnion({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  const getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
      return getDiscriminator(type.schema);
    } else if (type instanceof ZodEffects) {
      return getDiscriminator(type.innerType());
    } else if (type instanceof ZodLiteral) {
      return [type.value];
    } else if (type instanceof ZodEnum) {
      return type.options;
    } else if (type instanceof ZodNativeEnum) {
      return util.objectValues(type.enum);
    } else if (type instanceof ZodDefault) {
      return getDiscriminator(type._def.innerType);
    } else if (type instanceof ZodUndefined) {
      return [void 0];
    } else if (type instanceof ZodNull) {
      return [null];
    } else if (type instanceof ZodOptional) {
      return [void 0, ...getDiscriminator(type.unwrap())];
    } else if (type instanceof ZodNullable) {
      return [null, ...getDiscriminator(type.unwrap())];
    } else if (type instanceof ZodBranded) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodReadonly) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodCatch) {
      return getDiscriminator(type._def.innerType);
    } else {
      return [];
    }
  };
  class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
      const optionsMap = /* @__PURE__ */ new Map();
      for (const type of options) {
        const discriminatorValues = getDiscriminator(type.shape[discriminator]);
        if (!discriminatorValues.length) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams(params)
      });
    }
  }
  function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
      return { valid: true, data: a };
    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
      const bKeys = util.objectKeys(b);
      const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = { ...a, ...b };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues(a[key], b[key]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
      if (a.length !== b.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index = 0; index < a.length; index++) {
        const itemA = a[index];
        const itemB = b[index];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
      return { valid: true, data: a };
    } else {
      return { valid: false };
    }
  }
  class ZodIntersection extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_intersection_types
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  }
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  class ZodTuple extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x) => !!x);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus.mergeArray(status, results);
        });
      } else {
        return ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new ZodTuple({
        ...this._def,
        rest
      });
    }
  }
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  class ZodRecord extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (ctx.common.async) {
        return ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first2, second, third) {
      if (second instanceof ZodType) {
        return new ZodRecord({
          keyType: first2,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new ZodRecord({
        keyType: ZodString.create(),
        valueType: first2,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second)
      });
    }
  }
  class ZodMap extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = /* @__PURE__ */ new Map();
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  }
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };
  class ZodSet extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = /* @__PURE__ */ new Set();
        for (const element of elements2) {
          if (element.status === "aborted")
            return INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil.toString(message) }
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };
  class ZodFunction extends ZodType {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.function) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.function,
          received: ctx.parsedType
        });
        return INVALID;
      }
      function makeArgsIssue(args, error) {
        return makeIssue({
          data: args,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_arguments,
            argumentsError: error
          }
        });
      }
      function makeReturnsIssue(returns, error) {
        return makeIssue({
          data: returns,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_return_type,
            returnTypeError: error
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise) {
        const me = this;
        return OK(async function(...args) {
          const error = new ZodError([]);
          const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
            error.addIssue(makeArgsIssue(args, e));
            throw error;
          });
          const result = await Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
            error.addIssue(makeReturnsIssue(result, e));
            throw error;
          });
          return parsedReturns;
        });
      } else {
        const me = this;
        return OK(function(...args) {
          const parsedArgs = me._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = Reflect.apply(fn, this, parsedArgs.data);
          const parsedReturns = me._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new ZodFunction({
        ...this._def,
        args: ZodTuple.create(items).rest(ZodUnknown.create())
      });
    }
    returns(returnType) {
      return new ZodFunction({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new ZodFunction({
        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params)
      });
    }
  }
  class ZodLazy extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  }
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };
  class ZodLiteral extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  }
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  function createZodEnum(values, params) {
    return new ZodEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodEnum,
      ...processCreateParams(params)
    });
  }
  class ZodEnum extends ZodType {
    constructor() {
      super(...arguments);
      _ZodEnum_cache.set(this, void 0);
    }
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!__classPrivateFieldGet$d(this, _ZodEnum_cache)) {
        __classPrivateFieldSet$b(this, _ZodEnum_cache, new Set(this._def.values));
      }
      if (!__classPrivateFieldGet$d(this, _ZodEnum_cache).has(input.data)) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values, newDef = this._def) {
      return ZodEnum.create(values, {
        ...this._def,
        ...newDef
      });
    }
    exclude(values, newDef = this._def) {
      return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
        ...this._def,
        ...newDef
      });
    }
  }
  _ZodEnum_cache = /* @__PURE__ */ new WeakMap();
  ZodEnum.create = createZodEnum;
  class ZodNativeEnum extends ZodType {
    constructor() {
      super(...arguments);
      _ZodNativeEnum_cache.set(this, void 0);
    }
    _parse(input) {
      const nativeEnumValues = util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!__classPrivateFieldGet$d(this, _ZodNativeEnum_cache)) {
        __classPrivateFieldSet$b(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)));
      }
      if (!__classPrivateFieldGet$d(this, _ZodNativeEnum_cache).has(input.data)) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  _ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  class ZodPromise extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  }
  ZodPromise.create = (schema, params) => {
    return new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };
  class ZodEffects extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(processed).then(async (processed2) => {
            if (status.value === "aborted")
              return INVALID;
            const result = await this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY(result.value);
            if (status.value === "dirty")
              return DIRTY(result.value);
            return result;
          });
        } else {
          if (status.value === "aborted")
            return INVALID;
          const result = this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid(base))
            return base;
          const result = effect.transform(base.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
            if (!isValid(base))
              return base;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
          });
        }
      }
      util.assertNever(effect);
    }
  }
  ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };
  class ZodOptional extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.undefined) {
        return OK(void 0);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodOptional.create = (type, params) => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };
  class ZodNullable extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.null) {
        return OK(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodNullable.create = (type, params) => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };
  class ZodDefault extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  ZodDefault.create = (type, params) => {
    return new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  class ZodCatch extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if (isAsync(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  ZodCatch.create = (type, params) => {
    return new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  class ZodNaN extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
  }
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  const BRAND = Symbol("zod_brand");
  class ZodBranded extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  }
  class ZodPipeline extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a, b) {
      return new ZodPipeline({
        in: a,
        out: b,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  }
  class ZodReadonly extends ZodType {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      const freeze = (data) => {
        if (isValid(data)) {
          data.value = Object.freeze(data.value);
        }
        return data;
      };
      return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params)
    });
  };
  function cleanParams(params, data) {
    const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
    const p2 = typeof p === "string" ? { message: p } : p;
    return p2;
  }
  function custom(check, _params = {}, fatal) {
    if (check)
      return ZodAny.create().superRefine((data, ctx) => {
        var _a3, _b2;
        const r = check(data);
        if (r instanceof Promise) {
          return r.then((r2) => {
            var _a4, _b3;
            if (!r2) {
              const params = cleanParams(_params, data);
              const _fatal = (_b3 = (_a4 = params.fatal) !== null && _a4 !== void 0 ? _a4 : fatal) !== null && _b3 !== void 0 ? _b3 : true;
              ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
            }
          });
        }
        if (!r) {
          const params = cleanParams(_params, data);
          const _fatal = (_b2 = (_a3 = params.fatal) !== null && _a3 !== void 0 ? _a3 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
          ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
        }
        return;
      });
    return ZodAny.create();
  }
  const late = {
    object: ZodObject.lazycreate
  };
  var ZodFirstPartyTypeKind;
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  const instanceOfType = (cls, params = {
    message: `Input not instance of ${cls.name}`
  }) => custom((data) => data instanceof cls, params);
  const stringType = ZodString.create;
  const numberType = ZodNumber.create;
  const nanType = ZodNaN.create;
  const bigIntType = ZodBigInt.create;
  const booleanType = ZodBoolean.create;
  const dateType = ZodDate.create;
  const symbolType = ZodSymbol.create;
  const undefinedType = ZodUndefined.create;
  const nullType = ZodNull.create;
  const anyType = ZodAny.create;
  const unknownType = ZodUnknown.create;
  const neverType = ZodNever.create;
  const voidType = ZodVoid.create;
  const arrayType = ZodArray.create;
  const objectType = ZodObject.create;
  const strictObjectType = ZodObject.strictCreate;
  const unionType = ZodUnion.create;
  const discriminatedUnionType = ZodDiscriminatedUnion.create;
  const intersectionType = ZodIntersection.create;
  const tupleType = ZodTuple.create;
  const recordType = ZodRecord.create;
  const mapType = ZodMap.create;
  const setType = ZodSet.create;
  const functionType = ZodFunction.create;
  const lazyType = ZodLazy.create;
  const literalType = ZodLiteral.create;
  const enumType = ZodEnum.create;
  const nativeEnumType = ZodNativeEnum.create;
  const promiseType = ZodPromise.create;
  const effectsType = ZodEffects.create;
  const optionalType = ZodOptional.create;
  const nullableType = ZodNullable.create;
  const preprocessType = ZodEffects.createWithPreprocess;
  const pipelineType = ZodPipeline.create;
  const ostring = () => stringType().optional();
  const onumber = () => numberType().optional();
  const oboolean = () => booleanType().optional();
  const coerce = {
    string: (arg) => ZodString.create({ ...arg, coerce: true }),
    number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
    boolean: (arg) => ZodBoolean.create({
      ...arg,
      coerce: true
    }),
    bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
    date: (arg) => ZodDate.create({ ...arg, coerce: true })
  };
  const NEVER = INVALID;
  var z = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    defaultErrorMap: errorMap,
    setErrorMap,
    getErrorMap,
    makeIssue,
    EMPTY_PATH,
    addIssueToContext,
    ParseStatus,
    INVALID,
    DIRTY,
    OK,
    isAborted,
    isDirty,
    isValid,
    isAsync,
    get util() {
      return util;
    },
    get objectUtil() {
      return objectUtil;
    },
    ZodParsedType,
    getParsedType,
    ZodType,
    datetimeRegex,
    ZodString,
    ZodNumber,
    ZodBigInt,
    ZodBoolean,
    ZodDate,
    ZodSymbol,
    ZodUndefined,
    ZodNull,
    ZodAny,
    ZodUnknown,
    ZodNever,
    ZodVoid,
    ZodArray,
    ZodObject,
    ZodUnion,
    ZodDiscriminatedUnion,
    ZodIntersection,
    ZodTuple,
    ZodRecord,
    ZodMap,
    ZodSet,
    ZodFunction,
    ZodLazy,
    ZodLiteral,
    ZodEnum,
    ZodNativeEnum,
    ZodPromise,
    ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional,
    ZodNullable,
    ZodDefault,
    ZodCatch,
    ZodNaN,
    BRAND,
    ZodBranded,
    ZodPipeline,
    ZodReadonly,
    custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late,
    get ZodFirstPartyTypeKind() {
      return ZodFirstPartyTypeKind;
    },
    coerce,
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    "enum": enumType,
    "function": functionType,
    "instanceof": instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    "null": nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean,
    onumber,
    optional: optionalType,
    ostring,
    pipeline: pipelineType,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    symbol: symbolType,
    transformer: effectsType,
    tuple: tupleType,
    "undefined": undefinedType,
    union: unionType,
    unknown: unknownType,
    "void": voidType,
    NEVER,
    ZodIssueCode,
    quotelessJson,
    ZodError
  });
  var pRetry$1 = { exports: {} };
  var retry$1 = {};
  var retry_operation;
  var hasRequiredRetry_operation;
  function requireRetry_operation() {
    if (hasRequiredRetry_operation) return retry_operation;
    hasRequiredRetry_operation = 1;
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      this._timer = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    retry_operation = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts.slice(0);
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._timer) {
        clearTimeout(this._timer);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout2 = this._timeouts.shift();
      if (timeout2 === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1);
          timeout2 = this._cachedTimeouts.slice(-1);
        } else {
          return false;
        }
      }
      var self2 = this;
      this._timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout2);
      if (this._options.unref) {
        this._timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = (/* @__PURE__ */ new Date()).getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i2 = 0; i2 < this._errors.length; i2++) {
        var error = this._errors[i2];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
    return retry_operation;
  }
  var hasRequiredRetry$1;
  function requireRetry$1() {
    if (hasRequiredRetry$1) return retry$1;
    hasRequiredRetry$1 = 1;
    (function(exports) {
      var RetryOperation = requireRetry_operation();
      exports.operation = function(options) {
        var timeouts = exports.timeouts(options);
        return new RetryOperation(timeouts, {
          forever: options && (options.forever || options.retries === Infinity),
          unref: options && options.unref,
          maxRetryTime: options && options.maxRetryTime
        });
      };
      exports.timeouts = function(options) {
        if (options instanceof Array) {
          return [].concat(options);
        }
        var opts = {
          retries: 10,
          factor: 2,
          minTimeout: 1 * 1e3,
          maxTimeout: Infinity,
          randomize: false
        };
        for (var key in options) {
          opts[key] = options[key];
        }
        if (opts.minTimeout > opts.maxTimeout) {
          throw new Error("minTimeout is greater than maxTimeout");
        }
        var timeouts = [];
        for (var i2 = 0; i2 < opts.retries; i2++) {
          timeouts.push(this.createTimeout(i2, opts));
        }
        if (options && options.forever && !timeouts.length) {
          timeouts.push(this.createTimeout(i2, opts));
        }
        timeouts.sort(function(a, b) {
          return a - b;
        });
        return timeouts;
      };
      exports.createTimeout = function(attempt, opts) {
        var random = opts.randomize ? Math.random() + 1 : 1;
        var timeout2 = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
        timeout2 = Math.min(timeout2, opts.maxTimeout);
        return timeout2;
      };
      exports.wrap = function(obj, options, methods2) {
        if (options instanceof Array) {
          methods2 = options;
          options = null;
        }
        if (!methods2) {
          methods2 = [];
          for (var key in obj) {
            if (typeof obj[key] === "function") {
              methods2.push(key);
            }
          }
        }
        for (var i2 = 0; i2 < methods2.length; i2++) {
          var method = methods2[i2];
          var original = obj[method];
          obj[method] = (function retryWrapper(original2) {
            var op = exports.operation(options);
            var args = Array.prototype.slice.call(arguments, 1);
            var callback = args.pop();
            args.push(function(err) {
              if (op.retry(err)) {
                return;
              }
              if (err) {
                arguments[0] = op.mainError();
              }
              callback.apply(this, arguments);
            });
            op.attempt(function() {
              original2.apply(obj, args);
            });
          }).bind(obj, original);
          obj[method].options = options;
        }
      };
    })(retry$1);
    return retry$1;
  }
  var retry;
  var hasRequiredRetry;
  function requireRetry() {
    if (hasRequiredRetry) return retry;
    hasRequiredRetry = 1;
    retry = requireRetry$1();
    return retry;
  }
  var hasRequiredPRetry;
  function requirePRetry() {
    if (hasRequiredPRetry) return pRetry$1.exports;
    hasRequiredPRetry = 1;
    const retry2 = requireRetry();
    const networkErrorMsgs = [
      "Failed to fetch",
      // Chrome
      "NetworkError when attempting to fetch resource.",
      // Firefox
      "The Internet connection appears to be offline.",
      // Safari
      "Network request failed"
      // `cross-fetch`
    ];
    class AbortError extends Error {
      constructor(message) {
        super();
        if (message instanceof Error) {
          this.originalError = message;
          ({ message } = message);
        } else {
          this.originalError = new Error(message);
          this.originalError.stack = this.stack;
        }
        this.name = "AbortError";
        this.message = message;
      }
    }
    const decorateErrorWithCounts = (error, attemptNumber, options) => {
      const retriesLeft = options.retries - (attemptNumber - 1);
      error.attemptNumber = attemptNumber;
      error.retriesLeft = retriesLeft;
      return error;
    };
    const isNetworkError = (errorMessage) => networkErrorMsgs.includes(errorMessage);
    const pRetry2 = (input, options) => new Promise((resolve, reject) => {
      options = {
        onFailedAttempt: () => {
        },
        retries: 10,
        ...options
      };
      const operation = retry2.operation(options);
      operation.attempt(async (attemptNumber) => {
        try {
          resolve(await input(attemptNumber));
        } catch (error) {
          if (!(error instanceof Error)) {
            reject(new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`));
            return;
          }
          if (error instanceof AbortError) {
            operation.stop();
            reject(error.originalError);
          } else if (error instanceof TypeError && !isNetworkError(error.message)) {
            operation.stop();
            reject(error);
          } else {
            decorateErrorWithCounts(error, attemptNumber, options);
            try {
              await options.onFailedAttempt(error);
            } catch (error2) {
              reject(error2);
              return;
            }
            if (!operation.retry(error)) {
              reject(operation.mainError());
            }
          }
        }
      });
    });
    pRetry$1.exports = pRetry2;
    pRetry$1.exports.default = pRetry2;
    pRetry$1.exports.AbortError = AbortError;
    return pRetry$1.exports;
  }
  var pRetryExports = requirePRetry();
  const pRetry = /* @__PURE__ */ getDefaultExportFromCjs(pRetryExports);
  const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
  function validate$1(uuid2) {
    return typeof uuid2 === "string" && REGEX.test(uuid2);
  }
  var byteToHex = [];
  for (var i = 0; i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr2, offset = 0) {
    return (byteToHex[arr2[offset + 0]] + byteToHex[arr2[offset + 1]] + byteToHex[arr2[offset + 2]] + byteToHex[arr2[offset + 3]] + "-" + byteToHex[arr2[offset + 4]] + byteToHex[arr2[offset + 5]] + "-" + byteToHex[arr2[offset + 6]] + byteToHex[arr2[offset + 7]] + "-" + byteToHex[arr2[offset + 8]] + byteToHex[arr2[offset + 9]] + "-" + byteToHex[arr2[offset + 10]] + byteToHex[arr2[offset + 11]] + byteToHex[arr2[offset + 12]] + byteToHex[arr2[offset + 13]] + byteToHex[arr2[offset + 14]] + byteToHex[arr2[offset + 15]]).toLowerCase();
  }
  var getRandomValues;
  var rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }
  var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
  const native = {
    randomUUID
  };
  function v4(options, buf, offset) {
    if (native.randomUUID && !buf && !options) {
      return native.randomUUID();
    }
    options = options || {};
    var rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    return unsafeStringify(rnds);
  }
  var dist = {};
  var eventemitter3 = { exports: {} };
  var hasRequiredEventemitter3;
  function requireEventemitter3() {
    if (hasRequiredEventemitter3) return eventemitter3.exports;
    hasRequiredEventemitter3 = 1;
    (function(module) {
      var has2 = Object.prototype.hasOwnProperty, prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__) prefix = false;
      }
      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
        else emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0) emitter._events = new Events();
        else delete emitter._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names = [], events2, name;
        if (this._eventsCount === 0) return names;
        for (name in events2 = this._events) {
          if (has2.call(events2, name)) names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events2));
        }
        return names;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers) return [];
        if (handlers.fn) return [handlers.fn];
        for (var i2 = 0, l = handlers.length, ee = new Array(l); i2 < l; i2++) {
          ee[i2] = handlers[i2].fn;
        }
        return ee;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners) return 0;
        if (listeners.fn) return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return false;
        var listeners = this._events[evt], len = arguments.length, args, i2;
        if (listeners.fn) {
          if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
            args[i2 - 1] = arguments[i2];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j;
          for (i2 = 0; i2 < length; i2++) {
            if (listeners[i2].once) this.removeListener(event, listeners[i2].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i2].fn.call(listeners[i2].context);
                break;
              case 2:
                listeners[i2].fn.call(listeners[i2].context, a1);
                break;
              case 3:
                listeners[i2].fn.call(listeners[i2].context, a1, a2);
                break;
              case 4:
                listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
                break;
              default:
                if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
                listeners[i2].fn.apply(listeners[i2].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on(event, fn, context) {
        return addListener(this, event, fn, context, false);
      };
      EventEmitter2.prototype.once = function once(event, fn, context) {
        return addListener(this, event, fn, context, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i2 = 0, events2 = [], length = listeners.length; i2 < length; i2++) {
            if (listeners[i2].fn !== fn || once && !listeners[i2].once || context && listeners[i2].context !== context) {
              events2.push(listeners[i2]);
            }
          }
          if (events2.length) this._events[evt] = events2.length === 1 ? events2[0] : events2;
          else clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt]) clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      {
        module.exports = EventEmitter2;
      }
    })(eventemitter3);
    return eventemitter3.exports;
  }
  var pTimeout = { exports: {} };
  var pFinally;
  var hasRequiredPFinally;
  function requirePFinally() {
    if (hasRequiredPFinally) return pFinally;
    hasRequiredPFinally = 1;
    pFinally = (promise, onFinally) => {
      onFinally = onFinally || (() => {
      });
      return promise.then(
        (val) => new Promise((resolve) => {
          resolve(onFinally());
        }).then(() => val),
        (err) => new Promise((resolve) => {
          resolve(onFinally());
        }).then(() => {
          throw err;
        })
      );
    };
    return pFinally;
  }
  var hasRequiredPTimeout;
  function requirePTimeout() {
    if (hasRequiredPTimeout) return pTimeout.exports;
    hasRequiredPTimeout = 1;
    const pFinally2 = requirePFinally();
    class TimeoutError2 extends Error {
      constructor(message) {
        super(message);
        this.name = "TimeoutError";
      }
    }
    const pTimeout$1 = (promise, milliseconds, fallback) => new Promise((resolve, reject) => {
      if (typeof milliseconds !== "number" || milliseconds < 0) {
        throw new TypeError("Expected `milliseconds` to be a positive number");
      }
      if (milliseconds === Infinity) {
        resolve(promise);
        return;
      }
      const timer2 = setTimeout(() => {
        if (typeof fallback === "function") {
          try {
            resolve(fallback());
          } catch (error) {
            reject(error);
          }
          return;
        }
        const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
        const timeoutError = fallback instanceof Error ? fallback : new TimeoutError2(message);
        if (typeof promise.cancel === "function") {
          promise.cancel();
        }
        reject(timeoutError);
      }, milliseconds);
      pFinally2(
        // eslint-disable-next-line promise/prefer-await-to-then
        promise.then(resolve, reject),
        () => {
          clearTimeout(timer2);
        }
      );
    });
    pTimeout.exports = pTimeout$1;
    pTimeout.exports.default = pTimeout$1;
    pTimeout.exports.TimeoutError = TimeoutError2;
    return pTimeout.exports;
  }
  var priorityQueue = {};
  var lowerBound = {};
  var hasRequiredLowerBound;
  function requireLowerBound() {
    if (hasRequiredLowerBound) return lowerBound;
    hasRequiredLowerBound = 1;
    Object.defineProperty(lowerBound, "__esModule", { value: true });
    function lowerBound$1(array, value, comparator2) {
      let first2 = 0;
      let count = array.length;
      while (count > 0) {
        const step = count / 2 | 0;
        let it = first2 + step;
        if (comparator2(array[it], value) <= 0) {
          first2 = ++it;
          count -= step + 1;
        } else {
          count = step;
        }
      }
      return first2;
    }
    lowerBound.default = lowerBound$1;
    return lowerBound;
  }
  var hasRequiredPriorityQueue;
  function requirePriorityQueue() {
    if (hasRequiredPriorityQueue) return priorityQueue;
    hasRequiredPriorityQueue = 1;
    Object.defineProperty(priorityQueue, "__esModule", { value: true });
    const lower_bound_1 = requireLowerBound();
    class PriorityQueue {
      constructor() {
        this._queue = [];
      }
      enqueue(run, options) {
        options = Object.assign({ priority: 0 }, options);
        const element = {
          priority: options.priority,
          run
        };
        if (this.size && this._queue[this.size - 1].priority >= options.priority) {
          this._queue.push(element);
          return;
        }
        const index = lower_bound_1.default(this._queue, element, (a, b) => b.priority - a.priority);
        this._queue.splice(index, 0, element);
      }
      dequeue() {
        const item = this._queue.shift();
        return item === null || item === void 0 ? void 0 : item.run;
      }
      filter(options) {
        return this._queue.filter((element) => element.priority === options.priority).map((element) => element.run);
      }
      get size() {
        return this._queue.length;
      }
    }
    priorityQueue.default = PriorityQueue;
    return priorityQueue;
  }
  var hasRequiredDist;
  function requireDist() {
    if (hasRequiredDist) return dist;
    hasRequiredDist = 1;
    Object.defineProperty(dist, "__esModule", { value: true });
    const EventEmitter2 = requireEventemitter3();
    const p_timeout_1 = requirePTimeout();
    const priority_queue_1 = requirePriorityQueue();
    const empty = () => {
    };
    const timeoutError = new p_timeout_1.TimeoutError();
    class PQueue extends EventEmitter2 {
      constructor(options) {
        var _a3, _b2, _c2, _d2;
        super();
        this._intervalCount = 0;
        this._intervalEnd = 0;
        this._pendingCount = 0;
        this._resolveEmpty = empty;
        this._resolveIdle = empty;
        options = Object.assign({ carryoverConcurrencyCount: false, intervalCap: Infinity, interval: 0, concurrency: Infinity, autoStart: true, queueClass: priority_queue_1.default }, options);
        if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
          throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b2 = (_a3 = options.intervalCap) === null || _a3 === void 0 ? void 0 : _a3.toString()) !== null && _b2 !== void 0 ? _b2 : ""}\` (${typeof options.intervalCap})`);
        }
        if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
          throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d2 = (_c2 = options.interval) === null || _c2 === void 0 ? void 0 : _c2.toString()) !== null && _d2 !== void 0 ? _d2 : ""}\` (${typeof options.interval})`);
        }
        this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;
        this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;
        this._intervalCap = options.intervalCap;
        this._interval = options.interval;
        this._queue = new options.queueClass();
        this._queueClass = options.queueClass;
        this.concurrency = options.concurrency;
        this._timeout = options.timeout;
        this._throwOnTimeout = options.throwOnTimeout === true;
        this._isPaused = options.autoStart === false;
      }
      get _doesIntervalAllowAnother() {
        return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
      }
      get _doesConcurrentAllowAnother() {
        return this._pendingCount < this._concurrency;
      }
      _next() {
        this._pendingCount--;
        this._tryToStartAnother();
        this.emit("next");
      }
      _resolvePromises() {
        this._resolveEmpty();
        this._resolveEmpty = empty;
        if (this._pendingCount === 0) {
          this._resolveIdle();
          this._resolveIdle = empty;
          this.emit("idle");
        }
      }
      _onResumeInterval() {
        this._onInterval();
        this._initializeIntervalIfNeeded();
        this._timeoutId = void 0;
      }
      _isIntervalPaused() {
        const now = Date.now();
        if (this._intervalId === void 0) {
          const delay = this._intervalEnd - now;
          if (delay < 0) {
            this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
          } else {
            if (this._timeoutId === void 0) {
              this._timeoutId = setTimeout(() => {
                this._onResumeInterval();
              }, delay);
            }
            return true;
          }
        }
        return false;
      }
      _tryToStartAnother() {
        if (this._queue.size === 0) {
          if (this._intervalId) {
            clearInterval(this._intervalId);
          }
          this._intervalId = void 0;
          this._resolvePromises();
          return false;
        }
        if (!this._isPaused) {
          const canInitializeInterval = !this._isIntervalPaused();
          if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
            const job = this._queue.dequeue();
            if (!job) {
              return false;
            }
            this.emit("active");
            job();
            if (canInitializeInterval) {
              this._initializeIntervalIfNeeded();
            }
            return true;
          }
        }
        return false;
      }
      _initializeIntervalIfNeeded() {
        if (this._isIntervalIgnored || this._intervalId !== void 0) {
          return;
        }
        this._intervalId = setInterval(() => {
          this._onInterval();
        }, this._interval);
        this._intervalEnd = Date.now() + this._interval;
      }
      _onInterval() {
        if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {
          clearInterval(this._intervalId);
          this._intervalId = void 0;
        }
        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
        this._processQueue();
      }
      /**
      Executes all queued functions until it reaches the limit.
      */
      _processQueue() {
        while (this._tryToStartAnother()) {
        }
      }
      get concurrency() {
        return this._concurrency;
      }
      set concurrency(newConcurrency) {
        if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
          throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
        }
        this._concurrency = newConcurrency;
        this._processQueue();
      }
      /**
      Adds a sync or async task to the queue. Always returns a promise.
      */
      async add(fn, options = {}) {
        return new Promise((resolve, reject) => {
          const run = async () => {
            this._pendingCount++;
            this._intervalCount++;
            try {
              const operation = this._timeout === void 0 && options.timeout === void 0 ? fn() : p_timeout_1.default(Promise.resolve(fn()), options.timeout === void 0 ? this._timeout : options.timeout, () => {
                if (options.throwOnTimeout === void 0 ? this._throwOnTimeout : options.throwOnTimeout) {
                  reject(timeoutError);
                }
                return void 0;
              });
              resolve(await operation);
            } catch (error) {
              reject(error);
            }
            this._next();
          };
          this._queue.enqueue(run, options);
          this._tryToStartAnother();
          this.emit("add");
        });
      }
      /**
      		    Same as `.add()`, but accepts an array of sync or async functions.
      
      		    @returns A promise that resolves when all functions are resolved.
      		    */
      async addAll(functions, options) {
        return Promise.all(functions.map(async (function_) => this.add(function_, options)));
      }
      /**
      Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
      */
      start() {
        if (!this._isPaused) {
          return this;
        }
        this._isPaused = false;
        this._processQueue();
        return this;
      }
      /**
      Put queue execution on hold.
      */
      pause() {
        this._isPaused = true;
      }
      /**
      Clear the queue.
      */
      clear() {
        this._queue = new this._queueClass();
      }
      /**
      		    Can be called multiple times. Useful if you for example add additional items at a later time.
      
      		    @returns A promise that settles when the queue becomes empty.
      		    */
      async onEmpty() {
        if (this._queue.size === 0) {
          return;
        }
        return new Promise((resolve) => {
          const existingResolve = this._resolveEmpty;
          this._resolveEmpty = () => {
            existingResolve();
            resolve();
          };
        });
      }
      /**
      		    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
      
      		    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
      		    */
      async onIdle() {
        if (this._pendingCount === 0 && this._queue.size === 0) {
          return;
        }
        return new Promise((resolve) => {
          const existingResolve = this._resolveIdle;
          this._resolveIdle = () => {
            existingResolve();
            resolve();
          };
        });
      }
      /**
      Size of the queue.
      */
      get size() {
        return this._queue.size;
      }
      /**
      		    Size of the queue, filtered by the given options.
      
      		    For example, this can be used to find the number of items remaining in the queue with a specific priority level.
      		    */
      sizeBy(options) {
        return this._queue.filter(options).length;
      }
      /**
      Number of pending promises.
      */
      get pending() {
        return this._pendingCount;
      }
      /**
      Whether the queue is currently paused.
      */
      get isPaused() {
        return this._isPaused;
      }
      get timeout() {
        return this._timeout;
      }
      /**
      Set the timeout for future operations.
      */
      set timeout(milliseconds) {
        this._timeout = milliseconds;
      }
    }
    dist.default = PQueue;
    return dist;
  }
  var distExports = requireDist();
  const PQueueMod = /* @__PURE__ */ getDefaultExportFromCjs(distExports);
  const DEFAULT_FETCH_IMPLEMENTATION = (...args) => fetch(...args);
  const LANGSMITH_FETCH_IMPLEMENTATION_KEY = Symbol.for("ls:fetch_implementation");
  const _getFetchImplementation = () => {
    return globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] ?? DEFAULT_FETCH_IMPLEMENTATION;
  };
  const STATUS_NO_RETRY$1 = [
    400,
    // Bad Request
    401,
    // Unauthorized
    403,
    // Forbidden
    404,
    // Not Found
    405,
    // Method Not Allowed
    406,
    // Not Acceptable
    407,
    // Proxy Authentication Required
    408
    // Request Timeout
  ];
  const STATUS_IGNORE = [
    409
    // Conflict
  ];
  let AsyncCaller$1 = class AsyncCaller {
    constructor(params) {
      Object.defineProperty(this, "maxConcurrency", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "maxRetries", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "queue", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "onFailedResponseHook", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.maxConcurrency = params.maxConcurrency ?? Infinity;
      this.maxRetries = params.maxRetries ?? 6;
      if ("default" in PQueueMod) {
        this.queue = new PQueueMod.default({
          concurrency: this.maxConcurrency
        });
      } else {
        this.queue = new PQueueMod({ concurrency: this.maxConcurrency });
      }
      this.onFailedResponseHook = params == null ? void 0 : params.onFailedResponseHook;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    call(callable, ...args) {
      const onFailedResponseHook = this.onFailedResponseHook;
      return this.queue.add(() => pRetry(() => callable(...args).catch((error) => {
        if (error instanceof Error) {
          throw error;
        } else {
          throw new Error(error);
        }
      }), {
        async onFailedAttempt(error) {
          if (error.message.startsWith("Cancel") || error.message.startsWith("TimeoutError") || error.message.startsWith("AbortError")) {
            throw error;
          }
          if ((error == null ? void 0 : error.code) === "ECONNABORTED") {
            throw error;
          }
          const response = error == null ? void 0 : error.response;
          const status = response == null ? void 0 : response.status;
          if (status) {
            if (STATUS_NO_RETRY$1.includes(+status)) {
              throw error;
            } else if (STATUS_IGNORE.includes(+status)) {
              return;
            }
            if (onFailedResponseHook) {
              await onFailedResponseHook(response);
            }
          }
        },
        // If needed we can change some of the defaults here,
        // but they're quite sensible.
        retries: this.maxRetries,
        randomize: true
      }), { throwOnTimeout: true });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    callWithOptions(options, callable, ...args) {
      if (options.signal) {
        return Promise.race([
          this.call(callable, ...args),
          new Promise((_, reject) => {
            var _a3;
            (_a3 = options.signal) == null ? void 0 : _a3.addEventListener("abort", () => {
              reject(new Error("AbortError"));
            });
          })
        ]);
      }
      return this.call(callable, ...args);
    }
    fetch(...args) {
      return this.call(() => _getFetchImplementation()(...args).then((res) => res.ok ? res : Promise.reject(res)));
    }
  };
  function isLangChainMessage(message) {
    return typeof (message == null ? void 0 : message._getType) === "function";
  }
  function convertLangChainMessageToExample(message) {
    const converted = {
      type: message._getType(),
      data: { content: message.content }
    };
    if ((message == null ? void 0 : message.additional_kwargs) && Object.keys(message.additional_kwargs).length > 0) {
      converted.data.additional_kwargs = { ...message.additional_kwargs };
    }
    return converted;
  }
  function assertUuid(str2, which) {
    if (!validate$1(str2)) {
      const msg = which !== void 0 ? `Invalid UUID for ${which}: ${str2}` : `Invalid UUID: ${str2}`;
      throw new Error(msg);
    }
    return str2;
  }
  const warnedMessages = {};
  function warnOnce(message) {
    if (!warnedMessages[message]) {
      console.warn(message);
      warnedMessages[message] = true;
    }
  }
  var re = { exports: {} };
  var constants;
  var hasRequiredConstants;
  function requireConstants() {
    if (hasRequiredConstants) return constants;
    hasRequiredConstants = 1;
    const SEMVER_SPEC_VERSION = "2.0.0";
    const MAX_LENGTH = 256;
    const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    const MAX_SAFE_COMPONENT_LENGTH = 16;
    const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    const RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    constants = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
    return constants;
  }
  var debug_1;
  var hasRequiredDebug;
  function requireDebug() {
    if (hasRequiredDebug) return debug_1;
    hasRequiredDebug = 1;
    const debug2 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    debug_1 = debug2;
    return debug_1;
  }
  var hasRequiredRe;
  function requireRe() {
    if (hasRequiredRe) return re.exports;
    hasRequiredRe = 1;
    (function(module, exports) {
      const {
        MAX_SAFE_COMPONENT_LENGTH,
        MAX_SAFE_BUILD_LENGTH,
        MAX_LENGTH
      } = requireConstants();
      const debug2 = requireDebug();
      exports = module.exports = {};
      const re2 = exports.re = [];
      const safeRe = exports.safeRe = [];
      const src = exports.src = [];
      const t = exports.t = {};
      let R = 0;
      const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
      const safeRegexReplacements = [
        ["\\s", 1],
        ["\\d", MAX_LENGTH],
        [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
      ];
      const makeSafeRegex = (value) => {
        for (const [token, max] of safeRegexReplacements) {
          value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
        }
        return value;
      };
      const createToken = (name, value, isGlobal) => {
        const safe = makeSafeRegex(value);
        const index = R++;
        debug2(name, index, value);
        t[name] = index;
        src[index] = value;
        re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
        safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
      };
      createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
      createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
      createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
      createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
      createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
      createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
      createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
      createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
      createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
      createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
      createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
      createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
      createToken("FULL", `^${src[t.FULLPLAIN]}$`);
      createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
      createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
      createToken("GTLT", "((?:<|>)?=?)");
      createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
      createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
      createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
      createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
      createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
      createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
      createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
      createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
      createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
      createToken("COERCERTL", src[t.COERCE], true);
      createToken("COERCERTLFULL", src[t.COERCEFULL], true);
      createToken("LONETILDE", "(?:~>?)");
      createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
      exports.tildeTrimReplace = "$1~";
      createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
      createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
      createToken("LONECARET", "(?:\\^)");
      createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
      exports.caretTrimReplace = "$1^";
      createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
      createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
      createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
      createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
      createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
      exports.comparatorTrimReplace = "$1$2$3";
      createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
      createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
      createToken("STAR", "(<|>)?=?\\s*\\*");
      createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
      createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
    })(re, re.exports);
    return re.exports;
  }
  var parseOptions_1;
  var hasRequiredParseOptions;
  function requireParseOptions() {
    if (hasRequiredParseOptions) return parseOptions_1;
    hasRequiredParseOptions = 1;
    const looseOption = Object.freeze({ loose: true });
    const emptyOpts = Object.freeze({});
    const parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    parseOptions_1 = parseOptions;
    return parseOptions_1;
  }
  var identifiers;
  var hasRequiredIdentifiers;
  function requireIdentifiers() {
    if (hasRequiredIdentifiers) return identifiers;
    hasRequiredIdentifiers = 1;
    const numeric = /^[0-9]+$/;
    const compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    identifiers = {
      compareIdentifiers,
      rcompareIdentifiers
    };
    return identifiers;
  }
  var semver$1;
  var hasRequiredSemver$1;
  function requireSemver$1() {
    if (hasRequiredSemver$1) return semver$1;
    hasRequiredSemver$1 = 1;
    const debug2 = requireDebug();
    const { MAX_LENGTH, MAX_SAFE_INTEGER } = requireConstants();
    const { safeRe: re2, t } = requireRe();
    const parseOptions = requireParseOptions();
    const { compareIdentifiers } = requireIdentifiers();
    class SemVer {
      constructor(version2, options) {
        options = parseOptions(options);
        if (version2 instanceof SemVer) {
          if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
            return version2;
          } else {
            version2 = version2.version;
          }
        } else if (typeof version2 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
        }
        if (version2.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug2("SemVer", version2, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version2.trim().match(options.loose ? re2[t.LOOSE] : re2[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        this.raw = version2;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug2("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i2 = 0;
        do {
          const a = this.prerelease[i2];
          const b = other.prerelease[i2];
          debug2("prerelease compare", i2, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i2);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i2 = 0;
        do {
          const a = this.build[i2];
          const b = other.build[i2];
          debug2("build compare", i2, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i2);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i2 = this.prerelease.length;
              while (--i2 >= 0) {
                if (typeof this.prerelease[i2] === "number") {
                  this.prerelease[i2]++;
                  i2 = -2;
                }
              }
              if (i2 === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    }
    semver$1 = SemVer;
    return semver$1;
  }
  var parse_1;
  var hasRequiredParse;
  function requireParse() {
    if (hasRequiredParse) return parse_1;
    hasRequiredParse = 1;
    const SemVer = requireSemver$1();
    const parse = (version2, options, throwErrors = false) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      try {
        return new SemVer(version2, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    parse_1 = parse;
    return parse_1;
  }
  var valid_1;
  var hasRequiredValid$1;
  function requireValid$1() {
    if (hasRequiredValid$1) return valid_1;
    hasRequiredValid$1 = 1;
    const parse = requireParse();
    const valid2 = (version2, options) => {
      const v = parse(version2, options);
      return v ? v.version : null;
    };
    valid_1 = valid2;
    return valid_1;
  }
  var clean_1;
  var hasRequiredClean;
  function requireClean() {
    if (hasRequiredClean) return clean_1;
    hasRequiredClean = 1;
    const parse = requireParse();
    const clean = (version2, options) => {
      const s = parse(version2.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    clean_1 = clean;
    return clean_1;
  }
  var inc_1;
  var hasRequiredInc;
  function requireInc() {
    if (hasRequiredInc) return inc_1;
    hasRequiredInc = 1;
    const SemVer = requireSemver$1();
    const inc = (version2, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version2 instanceof SemVer ? version2.version : version2,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    inc_1 = inc;
    return inc_1;
  }
  var diff_1;
  var hasRequiredDiff;
  function requireDiff() {
    if (hasRequiredDiff) return diff_1;
    hasRequiredDiff = 1;
    const parse = requireParse();
    const diff = (version1, version2) => {
      const v1 = parse(version1, null, true);
      const v2 = parse(version2, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (highVersion.patch) {
          return "patch";
        }
        if (highVersion.minor) {
          return "minor";
        }
        return "major";
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    diff_1 = diff;
    return diff_1;
  }
  var major_1;
  var hasRequiredMajor;
  function requireMajor() {
    if (hasRequiredMajor) return major_1;
    hasRequiredMajor = 1;
    const SemVer = requireSemver$1();
    const major = (a, loose) => new SemVer(a, loose).major;
    major_1 = major;
    return major_1;
  }
  var minor_1;
  var hasRequiredMinor;
  function requireMinor() {
    if (hasRequiredMinor) return minor_1;
    hasRequiredMinor = 1;
    const SemVer = requireSemver$1();
    const minor = (a, loose) => new SemVer(a, loose).minor;
    minor_1 = minor;
    return minor_1;
  }
  var patch_1;
  var hasRequiredPatch;
  function requirePatch() {
    if (hasRequiredPatch) return patch_1;
    hasRequiredPatch = 1;
    const SemVer = requireSemver$1();
    const patch = (a, loose) => new SemVer(a, loose).patch;
    patch_1 = patch;
    return patch_1;
  }
  var prerelease_1;
  var hasRequiredPrerelease;
  function requirePrerelease() {
    if (hasRequiredPrerelease) return prerelease_1;
    hasRequiredPrerelease = 1;
    const parse = requireParse();
    const prerelease = (version2, options) => {
      const parsed = parse(version2, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    prerelease_1 = prerelease;
    return prerelease_1;
  }
  var compare_1;
  var hasRequiredCompare;
  function requireCompare() {
    if (hasRequiredCompare) return compare_1;
    hasRequiredCompare = 1;
    const SemVer = requireSemver$1();
    const compare2 = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    compare_1 = compare2;
    return compare_1;
  }
  var rcompare_1;
  var hasRequiredRcompare;
  function requireRcompare() {
    if (hasRequiredRcompare) return rcompare_1;
    hasRequiredRcompare = 1;
    const compare2 = requireCompare();
    const rcompare = (a, b, loose) => compare2(b, a, loose);
    rcompare_1 = rcompare;
    return rcompare_1;
  }
  var compareLoose_1;
  var hasRequiredCompareLoose;
  function requireCompareLoose() {
    if (hasRequiredCompareLoose) return compareLoose_1;
    hasRequiredCompareLoose = 1;
    const compare2 = requireCompare();
    const compareLoose = (a, b) => compare2(a, b, true);
    compareLoose_1 = compareLoose;
    return compareLoose_1;
  }
  var compareBuild_1;
  var hasRequiredCompareBuild;
  function requireCompareBuild() {
    if (hasRequiredCompareBuild) return compareBuild_1;
    hasRequiredCompareBuild = 1;
    const SemVer = requireSemver$1();
    const compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    compareBuild_1 = compareBuild;
    return compareBuild_1;
  }
  var sort_1;
  var hasRequiredSort;
  function requireSort() {
    if (hasRequiredSort) return sort_1;
    hasRequiredSort = 1;
    const compareBuild = requireCompareBuild();
    const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    sort_1 = sort;
    return sort_1;
  }
  var rsort_1;
  var hasRequiredRsort;
  function requireRsort() {
    if (hasRequiredRsort) return rsort_1;
    hasRequiredRsort = 1;
    const compareBuild = requireCompareBuild();
    const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    rsort_1 = rsort;
    return rsort_1;
  }
  var gt_1;
  var hasRequiredGt;
  function requireGt() {
    if (hasRequiredGt) return gt_1;
    hasRequiredGt = 1;
    const compare2 = requireCompare();
    const gt = (a, b, loose) => compare2(a, b, loose) > 0;
    gt_1 = gt;
    return gt_1;
  }
  var lt_1;
  var hasRequiredLt;
  function requireLt() {
    if (hasRequiredLt) return lt_1;
    hasRequiredLt = 1;
    const compare2 = requireCompare();
    const lt = (a, b, loose) => compare2(a, b, loose) < 0;
    lt_1 = lt;
    return lt_1;
  }
  var eq_1;
  var hasRequiredEq;
  function requireEq() {
    if (hasRequiredEq) return eq_1;
    hasRequiredEq = 1;
    const compare2 = requireCompare();
    const eq = (a, b, loose) => compare2(a, b, loose) === 0;
    eq_1 = eq;
    return eq_1;
  }
  var neq_1;
  var hasRequiredNeq;
  function requireNeq() {
    if (hasRequiredNeq) return neq_1;
    hasRequiredNeq = 1;
    const compare2 = requireCompare();
    const neq = (a, b, loose) => compare2(a, b, loose) !== 0;
    neq_1 = neq;
    return neq_1;
  }
  var gte_1;
  var hasRequiredGte;
  function requireGte() {
    if (hasRequiredGte) return gte_1;
    hasRequiredGte = 1;
    const compare2 = requireCompare();
    const gte = (a, b, loose) => compare2(a, b, loose) >= 0;
    gte_1 = gte;
    return gte_1;
  }
  var lte_1;
  var hasRequiredLte;
  function requireLte() {
    if (hasRequiredLte) return lte_1;
    hasRequiredLte = 1;
    const compare2 = requireCompare();
    const lte = (a, b, loose) => compare2(a, b, loose) <= 0;
    lte_1 = lte;
    return lte_1;
  }
  var cmp_1;
  var hasRequiredCmp;
  function requireCmp() {
    if (hasRequiredCmp) return cmp_1;
    hasRequiredCmp = 1;
    const eq = requireEq();
    const neq = requireNeq();
    const gt = requireGt();
    const gte = requireGte();
    const lt = requireLt();
    const lte = requireLte();
    const cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    cmp_1 = cmp;
    return cmp_1;
  }
  var coerce_1;
  var hasRequiredCoerce;
  function requireCoerce() {
    if (hasRequiredCoerce) return coerce_1;
    hasRequiredCoerce = 1;
    const SemVer = requireSemver$1();
    const parse = requireParse();
    const { safeRe: re2, t } = requireRe();
    const coerce2 = (version2, options) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 === "number") {
        version2 = String(version2);
      }
      if (typeof version2 !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version2.match(options.includePrerelease ? re2[t.COERCEFULL] : re2[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re2[t.COERCERTLFULL] : re2[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    coerce_1 = coerce2;
    return coerce_1;
  }
  var lrucache;
  var hasRequiredLrucache;
  function requireLrucache() {
    if (hasRequiredLrucache) return lrucache;
    hasRequiredLrucache = 1;
    class LRUCache {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    }
    lrucache = LRUCache;
    return lrucache;
  }
  var range;
  var hasRequiredRange;
  function requireRange() {
    if (hasRequiredRange) return range;
    hasRequiredRange = 1;
    const SPACE_CHARACTERS = /\s+/g;
    class Range {
      constructor(range2, options) {
        options = parseOptions(options);
        if (range2 instanceof Range) {
          if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
            return range2;
          } else {
            return new Range(range2.raw, options);
          }
        }
        if (range2 instanceof Comparator) {
          this.raw = range2.value;
          this.set = [[range2]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range2.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first2 = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first2];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i2 = 0; i2 < this.set.length; i2++) {
            if (i2 > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i2];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range2) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range2;
        const cached = cache2.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re2[t.HYPHENRANGELOOSE] : re2[t.HYPHENRANGE];
        range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug2("hyphen replace", range2);
        range2 = range2.replace(re2[t.COMPARATORTRIM], comparatorTrimReplace);
        debug2("comparator trim", range2);
        range2 = range2.replace(re2[t.TILDETRIM], tildeTrimReplace);
        debug2("tilde trim", range2);
        range2 = range2.replace(re2[t.CARETTRIM], caretTrimReplace);
        debug2("caret trim", range2);
        let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug2("loose invalid filter", comp, this.options);
            return !!comp.match(re2[t.COMPARATORLOOSE]);
          });
        }
        debug2("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache2.set(memoKey, result);
        return result;
      }
      intersects(range2, options) {
        if (!(range2 instanceof Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version2) {
        if (!version2) {
          return false;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i2 = 0; i2 < this.set.length; i2++) {
          if (testSet(this.set[i2], version2, this.options)) {
            return true;
          }
        }
        return false;
      }
    }
    range = Range;
    const LRU = requireLrucache();
    const cache2 = new LRU();
    const parseOptions = requireParseOptions();
    const Comparator = requireComparator();
    const debug2 = requireDebug();
    const SemVer = requireSemver$1();
    const {
      safeRe: re2,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = requireRe();
    const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = requireConstants();
    const isNullSet = (c) => c.value === "<0.0.0-0";
    const isAny = (c) => c.value === "";
    const isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    const parseComparator = (comp, options) => {
      debug2("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug2("caret", comp);
      comp = replaceTildes(comp, options);
      debug2("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug2("xrange", comp);
      comp = replaceStars(comp, options);
      debug2("stars", comp);
      return comp;
    };
    const isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    const replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    const replaceTilde = (comp, options) => {
      const r = options.loose ? re2[t.TILDELOOSE] : re2[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug2("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug2("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug2("tilde return", ret);
        return ret;
      });
    };
    const replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    const replaceCaret = (comp, options) => {
      debug2("caret", comp, options);
      const r = options.loose ? re2[t.CARETLOOSE] : re2[t.CARET];
      const z2 = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug2("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z2} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z2} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z2} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug2("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug2("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z2} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z2} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug2("caret return", ret);
        return ret;
      });
    };
    const replaceXRanges = (comp, options) => {
      debug2("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    const replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re2[t.XRANGELOOSE] : re2[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug2("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug2("xRange return", ret);
        return ret;
      });
    };
    const replaceStars = (comp, options) => {
      debug2("replaceStars", comp, options);
      return comp.trim().replace(re2[t.STAR], "");
    };
    const replaceGTE0 = (comp, options) => {
      debug2("replaceGTE0", comp, options);
      return comp.trim().replace(re2[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    const hyphenReplace = (incPr) => ($0, from2, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from2 = "";
      } else if (isX(fm)) {
        from2 = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from2 = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from2 = `>=${from2}`;
      } else {
        from2 = `>=${from2}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from2} ${to}`.trim();
    };
    const testSet = (set, version2, options) => {
      for (let i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options.includePrerelease) {
        for (let i2 = 0; i2 < set.length; i2++) {
          debug2(set[i2].semver);
          if (set[i2].semver === Comparator.ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            const allowed = set[i2].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
    return range;
  }
  var comparator;
  var hasRequiredComparator;
  function requireComparator() {
    if (hasRequiredComparator) return comparator;
    hasRequiredComparator = 1;
    const ANY = Symbol("SemVer ANY");
    class Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug2("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug2("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re2[t.COMPARATORLOOSE] : re2[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version2) {
        debug2("Comparator.test", version2, this.options.loose);
        if (this.semver === ANY || version2 === ANY) {
          return true;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version2, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    }
    comparator = Comparator;
    const parseOptions = requireParseOptions();
    const { safeRe: re2, t } = requireRe();
    const cmp = requireCmp();
    const debug2 = requireDebug();
    const SemVer = requireSemver$1();
    const Range = requireRange();
    return comparator;
  }
  var satisfies_1;
  var hasRequiredSatisfies;
  function requireSatisfies() {
    if (hasRequiredSatisfies) return satisfies_1;
    hasRequiredSatisfies = 1;
    const Range = requireRange();
    const satisfies = (version2, range2, options) => {
      try {
        range2 = new Range(range2, options);
      } catch (er) {
        return false;
      }
      return range2.test(version2);
    };
    satisfies_1 = satisfies;
    return satisfies_1;
  }
  var toComparators_1;
  var hasRequiredToComparators;
  function requireToComparators() {
    if (hasRequiredToComparators) return toComparators_1;
    hasRequiredToComparators = 1;
    const Range = requireRange();
    const toComparators = (range2, options) => new Range(range2, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    toComparators_1 = toComparators;
    return toComparators_1;
  }
  var maxSatisfying_1;
  var hasRequiredMaxSatisfying;
  function requireMaxSatisfying() {
    if (hasRequiredMaxSatisfying) return maxSatisfying_1;
    hasRequiredMaxSatisfying = 1;
    const SemVer = requireSemver$1();
    const Range = requireRange();
    const maxSatisfying = (versions, range2, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range2, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    maxSatisfying_1 = maxSatisfying;
    return maxSatisfying_1;
  }
  var minSatisfying_1;
  var hasRequiredMinSatisfying;
  function requireMinSatisfying() {
    if (hasRequiredMinSatisfying) return minSatisfying_1;
    hasRequiredMinSatisfying = 1;
    const SemVer = requireSemver$1();
    const Range = requireRange();
    const minSatisfying = (versions, range2, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range2, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    minSatisfying_1 = minSatisfying;
    return minSatisfying_1;
  }
  var minVersion_1;
  var hasRequiredMinVersion;
  function requireMinVersion() {
    if (hasRequiredMinVersion) return minVersion_1;
    hasRequiredMinVersion = 1;
    const SemVer = requireSemver$1();
    const Range = requireRange();
    const gt = requireGt();
    const minVersion = (range2, loose) => {
      range2 = new Range(range2, loose);
      let minver = new SemVer("0.0.0");
      if (range2.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range2.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i2 = 0; i2 < range2.set.length; ++i2) {
        const comparators = range2.set[i2];
        let setMin = null;
        comparators.forEach((comparator2) => {
          const compver = new SemVer(comparator2.semver.version);
          switch (comparator2.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator2.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range2.test(minver)) {
        return minver;
      }
      return null;
    };
    minVersion_1 = minVersion;
    return minVersion_1;
  }
  var valid;
  var hasRequiredValid;
  function requireValid() {
    if (hasRequiredValid) return valid;
    hasRequiredValid = 1;
    const Range = requireRange();
    const validRange = (range2, options) => {
      try {
        return new Range(range2, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    valid = validRange;
    return valid;
  }
  var outside_1;
  var hasRequiredOutside;
  function requireOutside() {
    if (hasRequiredOutside) return outside_1;
    hasRequiredOutside = 1;
    const SemVer = requireSemver$1();
    const Comparator = requireComparator();
    const { ANY } = Comparator;
    const Range = requireRange();
    const satisfies = requireSatisfies();
    const gt = requireGt();
    const lt = requireLt();
    const lte = requireLte();
    const gte = requireGte();
    const outside = (version2, range2, hilo, options) => {
      version2 = new SemVer(version2, options);
      range2 = new Range(range2, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version2, range2, options)) {
        return false;
      }
      for (let i2 = 0; i2 < range2.set.length; ++i2) {
        const comparators = range2.set[i2];
        let high = null;
        let low = null;
        comparators.forEach((comparator2) => {
          if (comparator2.semver === ANY) {
            comparator2 = new Comparator(">=0.0.0");
          }
          high = high || comparator2;
          low = low || comparator2;
          if (gtfn(comparator2.semver, high.semver, options)) {
            high = comparator2;
          } else if (ltfn(comparator2.semver, low.semver, options)) {
            low = comparator2;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    };
    outside_1 = outside;
    return outside_1;
  }
  var gtr_1;
  var hasRequiredGtr;
  function requireGtr() {
    if (hasRequiredGtr) return gtr_1;
    hasRequiredGtr = 1;
    const outside = requireOutside();
    const gtr = (version2, range2, options) => outside(version2, range2, ">", options);
    gtr_1 = gtr;
    return gtr_1;
  }
  var ltr_1;
  var hasRequiredLtr;
  function requireLtr() {
    if (hasRequiredLtr) return ltr_1;
    hasRequiredLtr = 1;
    const outside = requireOutside();
    const ltr = (version2, range2, options) => outside(version2, range2, "<", options);
    ltr_1 = ltr;
    return ltr_1;
  }
  var intersects_1;
  var hasRequiredIntersects;
  function requireIntersects() {
    if (hasRequiredIntersects) return intersects_1;
    hasRequiredIntersects = 1;
    const Range = requireRange();
    const intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    intersects_1 = intersects;
    return intersects_1;
  }
  var simplify;
  var hasRequiredSimplify;
  function requireSimplify() {
    if (hasRequiredSimplify) return simplify;
    hasRequiredSimplify = 1;
    const satisfies = requireSatisfies();
    const compare2 = requireCompare();
    simplify = (versions, range2, options) => {
      const set = [];
      let first2 = null;
      let prev = null;
      const v = versions.sort((a, b) => compare2(a, b, options));
      for (const version2 of v) {
        const included = satisfies(version2, range2, options);
        if (included) {
          prev = version2;
          if (!first2) {
            first2 = version2;
          }
        } else {
          if (prev) {
            set.push([first2, prev]);
          }
          prev = null;
          first2 = null;
        }
      }
      if (first2) {
        set.push([first2, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range2.raw === "string" ? range2.raw : String(range2);
      return simplified.length < original.length ? simplified : range2;
    };
    return simplify;
  }
  var subset_1;
  var hasRequiredSubset;
  function requireSubset() {
    if (hasRequiredSubset) return subset_1;
    hasRequiredSubset = 1;
    const Range = requireRange();
    const Comparator = requireComparator();
    const { ANY } = Comparator;
    const satisfies = requireSatisfies();
    const compare2 = requireCompare();
    const subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    const minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    const minimumVersion = [new Comparator(">=0.0.0")];
    const simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare2(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    const higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare2(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    const lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare2(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    subset_1 = subset;
    return subset_1;
  }
  var semver;
  var hasRequiredSemver;
  function requireSemver() {
    if (hasRequiredSemver) return semver;
    hasRequiredSemver = 1;
    const internalRe = requireRe();
    const constants2 = requireConstants();
    const SemVer = requireSemver$1();
    const identifiers2 = requireIdentifiers();
    const parse = requireParse();
    const valid2 = requireValid$1();
    const clean = requireClean();
    const inc = requireInc();
    const diff = requireDiff();
    const major = requireMajor();
    const minor = requireMinor();
    const patch = requirePatch();
    const prerelease = requirePrerelease();
    const compare2 = requireCompare();
    const rcompare = requireRcompare();
    const compareLoose = requireCompareLoose();
    const compareBuild = requireCompareBuild();
    const sort = requireSort();
    const rsort = requireRsort();
    const gt = requireGt();
    const lt = requireLt();
    const eq = requireEq();
    const neq = requireNeq();
    const gte = requireGte();
    const lte = requireLte();
    const cmp = requireCmp();
    const coerce2 = requireCoerce();
    const Comparator = requireComparator();
    const Range = requireRange();
    const satisfies = requireSatisfies();
    const toComparators = requireToComparators();
    const maxSatisfying = requireMaxSatisfying();
    const minSatisfying = requireMinSatisfying();
    const minVersion = requireMinVersion();
    const validRange = requireValid();
    const outside = requireOutside();
    const gtr = requireGtr();
    const ltr = requireLtr();
    const intersects = requireIntersects();
    const simplifyRange = requireSimplify();
    const subset = requireSubset();
    semver = {
      parse,
      valid: valid2,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare: compare2,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce: coerce2,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants2.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants2.RELEASE_TYPES,
      compareIdentifiers: identifiers2.compareIdentifiers,
      rcompareIdentifiers: identifiers2.rcompareIdentifiers
    };
    return semver;
  }
  requireSemver();
  function parsePromptIdentifier(identifier) {
    if (!identifier || identifier.split("/").length > 2 || identifier.startsWith("/") || identifier.endsWith("/") || identifier.split(":").length > 2) {
      throw new Error(`Invalid identifier format: ${identifier}`);
    }
    const [ownerNamePart, commitPart] = identifier.split(":");
    const commit = commitPart || "latest";
    if (ownerNamePart.includes("/")) {
      const [owner, name] = ownerNamePart.split("/", 2);
      if (!owner || !name) {
        throw new Error(`Invalid identifier format: ${identifier}`);
      }
      return [owner, name, commit];
    } else {
      if (!ownerNamePart) {
        throw new Error(`Invalid identifier format: ${identifier}`);
      }
      return ["-", ownerNamePart, commit];
    }
  }
  class LangSmithConflictError extends Error {
    constructor(message) {
      super(message);
      this.name = "LangSmithConflictError";
    }
  }
  async function raiseForStatus(response, context, consume) {
    let errorBody;
    if (response.ok) {
      if (consume) {
        errorBody = await response.text();
      }
      return;
    }
    errorBody = await response.text();
    const fullMessage = `Failed to ${context}. Received status [${response.status}]: ${response.statusText}. Server response: ${errorBody}`;
    if (response.status === 409) {
      throw new LangSmithConflictError(fullMessage);
    }
    throw new Error(fullMessage);
  }
  var LIMIT_REPLACE_NODE = "[...]";
  var CIRCULAR_REPLACE_NODE = { result: "[Circular]" };
  var arr = [];
  var replacerStack = [];
  function defaultOptions$4() {
    return {
      depthLimit: Number.MAX_SAFE_INTEGER,
      edgesLimit: Number.MAX_SAFE_INTEGER
    };
  }
  function stringify$2(obj, replacer, spacer, options) {
    var _a3;
    try {
      return JSON.stringify(obj, replacer, spacer);
    } catch (e) {
      if (!((_a3 = e.message) == null ? void 0 : _a3.includes("Converting circular structure to JSON"))) {
        console.warn("[WARNING]: LangSmith received unserializable value.");
        return "[Unserializable]";
      }
      console.warn("[WARNING]: LangSmith received circular JSON. This will decrease tracer performance.");
      if (typeof options === "undefined") {
        options = defaultOptions$4();
      }
      decirc(obj, "", 0, [], void 0, 0, options);
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(obj, replacer, spacer);
        } else {
          res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
  }
  function setReplace(replace, val, k, parent) {
    var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
    if (propertyDescriptor.get !== void 0) {
      if (propertyDescriptor.configurable) {
        Object.defineProperty(parent, k, { value: replace });
        arr.push([parent, k, val, propertyDescriptor]);
      } else {
        replacerStack.push([val, k, replace]);
      }
    } else {
      parent[k] = replace;
      arr.push([parent, k, val]);
    }
  }
  function decirc(val, k, edgeIndex, stack, parent, depth, options) {
    depth += 1;
    var i2;
    if (typeof val === "object" && val !== null) {
      for (i2 = 0; i2 < stack.length; i2++) {
        if (stack[i2] === val) {
          setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
          return;
        }
      }
      if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
        setReplace(LIMIT_REPLACE_NODE, val, k, parent);
        return;
      }
      if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
        setReplace(LIMIT_REPLACE_NODE, val, k, parent);
        return;
      }
      stack.push(val);
      if (Array.isArray(val)) {
        for (i2 = 0; i2 < val.length; i2++) {
          decirc(val[i2], i2, i2, stack, val, depth, options);
        }
      } else {
        var keys = Object.keys(val);
        for (i2 = 0; i2 < keys.length; i2++) {
          var key = keys[i2];
          decirc(val[key], key, i2, stack, val, depth, options);
        }
      }
      stack.pop();
    }
  }
  function replaceGetterValues(replacer) {
    replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
      return v;
    };
    return function(key, val) {
      if (replacerStack.length > 0) {
        for (var i2 = 0; i2 < replacerStack.length; i2++) {
          var part = replacerStack[i2];
          if (part[1] === key && part[0] === val) {
            val = part[2];
            replacerStack.splice(i2, 1);
            break;
          }
        }
      }
      return replacer.call(this, key, val);
    };
  }
  function mergeRuntimeEnvIntoRunCreate(run) {
    const runtimeEnv = getRuntimeEnvironment$1();
    const envVars = getLangChainEnvVarsMetadata();
    const extra = run.extra ?? {};
    const metadata = extra.metadata;
    run.extra = {
      ...extra,
      runtime: {
        ...runtimeEnv,
        ...extra == null ? void 0 : extra.runtime
      },
      metadata: {
        ...envVars,
        ...envVars.revision_id || run.revision_id ? { revision_id: run.revision_id ?? envVars.revision_id } : {},
        ...metadata
      }
    };
    return run;
  }
  const getTracingSamplingRate = () => {
    const samplingRateStr = getLangSmithEnvironmentVariable("TRACING_SAMPLING_RATE");
    if (samplingRateStr === void 0) {
      return void 0;
    }
    const samplingRate = parseFloat(samplingRateStr);
    if (samplingRate < 0 || samplingRate > 1) {
      throw new Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);
    }
    return samplingRate;
  };
  const isLocalhost = (url) => {
    const strippedUrl = url.replace("http://", "").replace("https://", "");
    const hostname = strippedUrl.split("/")[0].split(":")[0];
    return hostname === "localhost" || hostname === "127.0.0.1" || hostname === "::1";
  };
  async function toArray(iterable) {
    const result = [];
    for await (const item of iterable) {
      result.push(item);
    }
    return result;
  }
  function trimQuotes(str2) {
    if (str2 === void 0) {
      return void 0;
    }
    return str2.trim().replace(/^"(.*)"$/, "$1").replace(/^'(.*)'$/, "$1");
  }
  const handle429 = async (response) => {
    if ((response == null ? void 0 : response.status) === 429) {
      const retryAfter = parseInt(response.headers.get("retry-after") ?? "30", 10) * 1e3;
      if (retryAfter > 0) {
        await new Promise((resolve) => setTimeout(resolve, retryAfter));
        return true;
      }
    }
    return false;
  };
  class AutoBatchQueue {
    constructor() {
      Object.defineProperty(this, "items", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
      Object.defineProperty(this, "sizeBytes", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 0
      });
    }
    peek() {
      return this.items[0];
    }
    push(item) {
      let itemPromiseResolve;
      const itemPromise = new Promise((resolve) => {
        itemPromiseResolve = resolve;
      });
      const size = stringify$2(item.item).length;
      this.items.push({
        action: item.action,
        payload: item.item,
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        itemPromiseResolve,
        itemPromise,
        size
      });
      this.sizeBytes += size;
      return itemPromise;
    }
    pop(upToSizeBytes) {
      var _a3;
      if (upToSizeBytes < 1) {
        throw new Error("Number of bytes to pop off may not be less than 1.");
      }
      const popped = [];
      let poppedSizeBytes = 0;
      while (poppedSizeBytes + (((_a3 = this.peek()) == null ? void 0 : _a3.size) ?? 0) < upToSizeBytes && this.items.length > 0) {
        const item = this.items.shift();
        if (item) {
          popped.push(item);
          poppedSizeBytes += item.size;
          this.sizeBytes -= item.size;
        }
      }
      if (popped.length === 0 && this.items.length > 0) {
        const item = this.items.shift();
        popped.push(item);
        poppedSizeBytes += item.size;
        this.sizeBytes -= item.size;
      }
      return [
        popped.map((it) => ({ action: it.action, item: it.payload })),
        () => popped.forEach((it) => it.itemPromiseResolve())
      ];
    }
  }
  const DEFAULT_BATCH_SIZE_LIMIT_BYTES = 20971520;
  const SERVER_INFO_REQUEST_TIMEOUT = 2500;
  class Client {
    constructor(config2 = {}) {
      var _a3;
      Object.defineProperty(this, "apiKey", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "apiUrl", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "webUrl", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "caller", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "batchIngestCaller", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "timeout_ms", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "_tenantId", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: null
      });
      Object.defineProperty(this, "hideInputs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "hideOutputs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "tracingSampleRate", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "filteredPostUuids", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /* @__PURE__ */ new Set()
      });
      Object.defineProperty(this, "autoBatchTracing", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "autoBatchQueue", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: new AutoBatchQueue()
      });
      Object.defineProperty(this, "autoBatchTimeout", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "autoBatchAggregationDelayMs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 250
      });
      Object.defineProperty(this, "batchSizeBytesLimit", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "fetchOptions", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "settings", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "blockOnRootRunFinalization", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: getEnvironmentVariable$1("LANGSMITH_TRACING_BACKGROUND") === "false"
      });
      Object.defineProperty(this, "traceBatchConcurrency", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 5
      });
      Object.defineProperty(this, "_serverInfo", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "_getServerInfoPromise", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "manualFlushMode", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      const defaultConfig = Client.getDefaultClientConfig();
      this.tracingSampleRate = getTracingSamplingRate();
      this.apiUrl = trimQuotes(config2.apiUrl ?? defaultConfig.apiUrl) ?? "";
      if (this.apiUrl.endsWith("/")) {
        this.apiUrl = this.apiUrl.slice(0, -1);
      }
      this.apiKey = trimQuotes(config2.apiKey ?? defaultConfig.apiKey);
      this.webUrl = trimQuotes(config2.webUrl ?? defaultConfig.webUrl);
      if ((_a3 = this.webUrl) == null ? void 0 : _a3.endsWith("/")) {
        this.webUrl = this.webUrl.slice(0, -1);
      }
      this.timeout_ms = config2.timeout_ms ?? 9e4;
      this.caller = new AsyncCaller$1(config2.callerOptions ?? {});
      this.traceBatchConcurrency = config2.traceBatchConcurrency ?? this.traceBatchConcurrency;
      if (this.traceBatchConcurrency < 1) {
        throw new Error("Trace batch concurrency must be positive.");
      }
      this.batchIngestCaller = new AsyncCaller$1({
        maxRetries: 2,
        maxConcurrency: this.traceBatchConcurrency,
        ...config2.callerOptions ?? {},
        onFailedResponseHook: handle429
      });
      this.hideInputs = config2.hideInputs ?? config2.anonymizer ?? defaultConfig.hideInputs;
      this.hideOutputs = config2.hideOutputs ?? config2.anonymizer ?? defaultConfig.hideOutputs;
      this.autoBatchTracing = config2.autoBatchTracing ?? this.autoBatchTracing;
      this.blockOnRootRunFinalization = config2.blockOnRootRunFinalization ?? this.blockOnRootRunFinalization;
      this.batchSizeBytesLimit = config2.batchSizeBytesLimit;
      this.fetchOptions = config2.fetchOptions || {};
      this.manualFlushMode = config2.manualFlushMode ?? this.manualFlushMode;
    }
    static getDefaultClientConfig() {
      const apiKey = getLangSmithEnvironmentVariable("API_KEY");
      const apiUrl = getLangSmithEnvironmentVariable("ENDPOINT") ?? "https://api.smith.langchain.com";
      const hideInputs = getLangSmithEnvironmentVariable("HIDE_INPUTS") === "true";
      const hideOutputs = getLangSmithEnvironmentVariable("HIDE_OUTPUTS") === "true";
      return {
        apiUrl,
        apiKey,
        webUrl: void 0,
        hideInputs,
        hideOutputs
      };
    }
    getHostUrl() {
      if (this.webUrl) {
        return this.webUrl;
      } else if (isLocalhost(this.apiUrl)) {
        this.webUrl = "http://localhost:3000";
        return this.webUrl;
      } else if (this.apiUrl.endsWith("/api/v1")) {
        this.webUrl = this.apiUrl.replace("/api/v1", "");
        return this.webUrl;
      } else if (this.apiUrl.includes("/api") && !this.apiUrl.split(".", 1)[0].endsWith("api")) {
        this.webUrl = this.apiUrl.replace("/api", "");
        return this.webUrl;
      } else if (this.apiUrl.split(".", 1)[0].includes("dev")) {
        this.webUrl = "https://dev.smith.langchain.com";
        return this.webUrl;
      } else if (this.apiUrl.split(".", 1)[0].includes("eu")) {
        this.webUrl = "https://eu.smith.langchain.com";
        return this.webUrl;
      } else if (this.apiUrl.split(".", 1)[0].includes("beta")) {
        this.webUrl = "https://beta.smith.langchain.com";
        return this.webUrl;
      } else {
        this.webUrl = "https://smith.langchain.com";
        return this.webUrl;
      }
    }
    get headers() {
      const headers = {
        "User-Agent": `langsmith-js/${__version__}`
      };
      if (this.apiKey) {
        headers["x-api-key"] = `${this.apiKey}`;
      }
      return headers;
    }
    processInputs(inputs) {
      if (this.hideInputs === false) {
        return inputs;
      }
      if (this.hideInputs === true) {
        return {};
      }
      if (typeof this.hideInputs === "function") {
        return this.hideInputs(inputs);
      }
      return inputs;
    }
    processOutputs(outputs) {
      if (this.hideOutputs === false) {
        return outputs;
      }
      if (this.hideOutputs === true) {
        return {};
      }
      if (typeof this.hideOutputs === "function") {
        return this.hideOutputs(outputs);
      }
      return outputs;
    }
    prepareRunCreateOrUpdateInputs(run) {
      const runParams = { ...run };
      if (runParams.inputs !== void 0) {
        runParams.inputs = this.processInputs(runParams.inputs);
      }
      if (runParams.outputs !== void 0) {
        runParams.outputs = this.processOutputs(runParams.outputs);
      }
      return runParams;
    }
    async _getResponse(path, queryParams) {
      const paramsString = (queryParams == null ? void 0 : queryParams.toString()) ?? "";
      const url = `${this.apiUrl}${path}?${paramsString}`;
      const response = await this.caller.call(_getFetchImplementation(), url, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, `Failed to fetch ${path}`);
      return response;
    }
    async _get(path, queryParams) {
      const response = await this._getResponse(path, queryParams);
      return response.json();
    }
    async *_getPaginated(path, queryParams = new URLSearchParams(), transform) {
      let offset = Number(queryParams.get("offset")) || 0;
      const limit2 = Number(queryParams.get("limit")) || 100;
      while (true) {
        queryParams.set("offset", String(offset));
        queryParams.set("limit", String(limit2));
        const url = `${this.apiUrl}${path}?${queryParams}`;
        const response = await this.caller.call(_getFetchImplementation(), url, {
          method: "GET",
          headers: this.headers,
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions
        });
        await raiseForStatus(response, `Failed to fetch ${path}`);
        const items = transform ? transform(await response.json()) : await response.json();
        if (items.length === 0) {
          break;
        }
        yield items;
        if (items.length < limit2) {
          break;
        }
        offset += items.length;
      }
    }
    async *_getCursorPaginatedList(path, body = null, requestMethod = "POST", dataKey = "runs") {
      const bodyParams = body ? { ...body } : {};
      while (true) {
        const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}${path}`, {
          method: requestMethod,
          headers: { ...this.headers, "Content-Type": "application/json" },
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions,
          body: JSON.stringify(bodyParams)
        });
        const responseBody = await response.json();
        if (!responseBody) {
          break;
        }
        if (!responseBody[dataKey]) {
          break;
        }
        yield responseBody[dataKey];
        const cursors = responseBody.cursors;
        if (!cursors) {
          break;
        }
        if (!cursors.next) {
          break;
        }
        bodyParams.cursor = cursors.next;
      }
    }
    _filterForSampling(runs, patch = false) {
      if (this.tracingSampleRate === void 0) {
        return runs;
      }
      if (patch) {
        const sampled = [];
        for (const run of runs) {
          if (!this.filteredPostUuids.has(run.id)) {
            sampled.push(run);
          } else {
            this.filteredPostUuids.delete(run.id);
          }
        }
        return sampled;
      } else {
        const sampled = [];
        for (const run of runs) {
          if (run.id !== run.trace_id && !this.filteredPostUuids.has(run.trace_id) || Math.random() < this.tracingSampleRate) {
            sampled.push(run);
          } else {
            this.filteredPostUuids.add(run.id);
          }
        }
        return sampled;
      }
    }
    async _getBatchSizeLimitBytes() {
      var _a3;
      const serverInfo = await this._ensureServerInfo();
      return this.batchSizeBytesLimit ?? ((_a3 = serverInfo.batch_ingest_config) == null ? void 0 : _a3.size_limit_bytes) ?? DEFAULT_BATCH_SIZE_LIMIT_BYTES;
    }
    async _getMultiPartSupport() {
      var _a3;
      const serverInfo = await this._ensureServerInfo();
      return ((_a3 = serverInfo.instance_flags) == null ? void 0 : _a3.dataset_examples_multipart_enabled) ?? false;
    }
    drainAutoBatchQueue(batchSizeLimit) {
      const promises = [];
      while (this.autoBatchQueue.items.length > 0) {
        const [batch, done] = this.autoBatchQueue.pop(batchSizeLimit);
        if (!batch.length) {
          done();
          break;
        }
        const batchPromise = this._processBatch(batch, done).catch(console.error);
        promises.push(batchPromise);
      }
      return Promise.all(promises);
    }
    async _processBatch(batch, done) {
      var _a3;
      if (!batch.length) {
        done();
        return;
      }
      try {
        const ingestParams = {
          runCreates: batch.filter((item) => item.action === "create").map((item) => item.item),
          runUpdates: batch.filter((item) => item.action === "update").map((item) => item.item)
        };
        const serverInfo = await this._ensureServerInfo();
        if ((_a3 = serverInfo == null ? void 0 : serverInfo.batch_ingest_config) == null ? void 0 : _a3.use_multipart_endpoint) {
          await this.multipartIngestRuns(ingestParams);
        } else {
          await this.batchIngestRuns(ingestParams);
        }
      } finally {
        done();
      }
    }
    async processRunOperation(item) {
      clearTimeout(this.autoBatchTimeout);
      this.autoBatchTimeout = void 0;
      if (item.action === "create") {
        item.item = mergeRuntimeEnvIntoRunCreate(item.item);
      }
      const itemPromise = this.autoBatchQueue.push(item);
      if (this.manualFlushMode) {
        return itemPromise;
      }
      const sizeLimitBytes = await this._getBatchSizeLimitBytes();
      if (this.autoBatchQueue.sizeBytes > sizeLimitBytes) {
        void this.drainAutoBatchQueue(sizeLimitBytes);
      }
      if (this.autoBatchQueue.items.length > 0) {
        this.autoBatchTimeout = setTimeout(() => {
          this.autoBatchTimeout = void 0;
          void this.drainAutoBatchQueue(sizeLimitBytes);
        }, this.autoBatchAggregationDelayMs);
      }
      return itemPromise;
    }
    async _getServerInfo() {
      const response = await _getFetchImplementation()(`${this.apiUrl}/info`, {
        method: "GET",
        headers: { Accept: "application/json" },
        signal: AbortSignal.timeout(SERVER_INFO_REQUEST_TIMEOUT),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "get server info");
      return response.json();
    }
    async _ensureServerInfo() {
      if (this._getServerInfoPromise === void 0) {
        this._getServerInfoPromise = (async () => {
          if (this._serverInfo === void 0) {
            try {
              this._serverInfo = await this._getServerInfo();
            } catch (e) {
              console.warn(`[WARNING]: LangSmith failed to fetch info on supported operations. Falling back to batch operations and default limits.`);
            }
          }
          return this._serverInfo ?? {};
        })();
      }
      return this._getServerInfoPromise.then((serverInfo) => {
        if (this._serverInfo === void 0) {
          this._getServerInfoPromise = void 0;
        }
        return serverInfo;
      });
    }
    async _getSettings() {
      if (!this.settings) {
        this.settings = this._get("/settings");
      }
      return await this.settings;
    }
    /**
     * Flushes current queued traces.
     */
    async flush() {
      const sizeLimitBytes = await this._getBatchSizeLimitBytes();
      await this.drainAutoBatchQueue(sizeLimitBytes);
    }
    async createRun(run) {
      if (!this._filterForSampling([run]).length) {
        return;
      }
      const headers = { ...this.headers, "Content-Type": "application/json" };
      const session_name = run.project_name;
      delete run.project_name;
      const runCreate = this.prepareRunCreateOrUpdateInputs({
        session_name,
        ...run,
        start_time: run.start_time ?? Date.now()
      });
      if (this.autoBatchTracing && runCreate.trace_id !== void 0 && runCreate.dotted_order !== void 0) {
        void this.processRunOperation({
          action: "create",
          item: runCreate
        }).catch(console.error);
        return;
      }
      const mergedRunCreateParam = mergeRuntimeEnvIntoRunCreate(runCreate);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/runs`, {
        method: "POST",
        headers,
        body: stringify$2(mergedRunCreateParam),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "create run", true);
    }
    /**
     * Batch ingest/upsert multiple runs in the Langsmith system.
     * @param runs
     */
    async batchIngestRuns({ runCreates, runUpdates }) {
      if (runCreates === void 0 && runUpdates === void 0) {
        return;
      }
      let preparedCreateParams = (runCreates == null ? void 0 : runCreates.map((create) => this.prepareRunCreateOrUpdateInputs(create))) ?? [];
      let preparedUpdateParams = (runUpdates == null ? void 0 : runUpdates.map((update) => this.prepareRunCreateOrUpdateInputs(update))) ?? [];
      if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {
        const createById = preparedCreateParams.reduce((params, run) => {
          if (!run.id) {
            return params;
          }
          params[run.id] = run;
          return params;
        }, {});
        const standaloneUpdates = [];
        for (const updateParam of preparedUpdateParams) {
          if (updateParam.id !== void 0 && createById[updateParam.id]) {
            createById[updateParam.id] = {
              ...createById[updateParam.id],
              ...updateParam
            };
          } else {
            standaloneUpdates.push(updateParam);
          }
        }
        preparedCreateParams = Object.values(createById);
        preparedUpdateParams = standaloneUpdates;
      }
      const rawBatch = {
        post: this._filterForSampling(preparedCreateParams),
        patch: this._filterForSampling(preparedUpdateParams, true)
      };
      if (!rawBatch.post.length && !rawBatch.patch.length) {
        return;
      }
      const batchChunks = {
        post: [],
        patch: []
      };
      for (const k of ["post", "patch"]) {
        const key = k;
        const batchItems = rawBatch[key].reverse();
        let batchItem = batchItems.pop();
        while (batchItem !== void 0) {
          batchChunks[key].push(batchItem);
          batchItem = batchItems.pop();
        }
      }
      if (batchChunks.post.length > 0 || batchChunks.patch.length > 0) {
        await this._postBatchIngestRuns(stringify$2(batchChunks));
      }
    }
    async _postBatchIngestRuns(body) {
      const headers = {
        ...this.headers,
        "Content-Type": "application/json",
        Accept: "application/json"
      };
      const response = await this.batchIngestCaller.call(_getFetchImplementation(), `${this.apiUrl}/runs/batch`, {
        method: "POST",
        headers,
        body,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "batch create run", true);
    }
    /**
     * Batch ingest/upsert multiple runs in the Langsmith system.
     * @param runs
     */
    async multipartIngestRuns({ runCreates, runUpdates }) {
      if (runCreates === void 0 && runUpdates === void 0) {
        return;
      }
      const allAttachments = {};
      let preparedCreateParams = [];
      for (const create of runCreates ?? []) {
        const preparedCreate = this.prepareRunCreateOrUpdateInputs(create);
        if (preparedCreate.id !== void 0 && preparedCreate.attachments !== void 0) {
          allAttachments[preparedCreate.id] = preparedCreate.attachments;
        }
        delete preparedCreate.attachments;
        preparedCreateParams.push(preparedCreate);
      }
      let preparedUpdateParams = [];
      for (const update of runUpdates ?? []) {
        preparedUpdateParams.push(this.prepareRunCreateOrUpdateInputs(update));
      }
      const invalidRunCreate = preparedCreateParams.find((runCreate) => {
        return runCreate.trace_id === void 0 || runCreate.dotted_order === void 0;
      });
      if (invalidRunCreate !== void 0) {
        throw new Error(`Multipart ingest requires "trace_id" and "dotted_order" to be set when creating a run`);
      }
      const invalidRunUpdate = preparedUpdateParams.find((runUpdate) => {
        return runUpdate.trace_id === void 0 || runUpdate.dotted_order === void 0;
      });
      if (invalidRunUpdate !== void 0) {
        throw new Error(`Multipart ingest requires "trace_id" and "dotted_order" to be set when updating a run`);
      }
      if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {
        const createById = preparedCreateParams.reduce((params, run) => {
          if (!run.id) {
            return params;
          }
          params[run.id] = run;
          return params;
        }, {});
        const standaloneUpdates = [];
        for (const updateParam of preparedUpdateParams) {
          if (updateParam.id !== void 0 && createById[updateParam.id]) {
            createById[updateParam.id] = {
              ...createById[updateParam.id],
              ...updateParam
            };
          } else {
            standaloneUpdates.push(updateParam);
          }
        }
        preparedCreateParams = Object.values(createById);
        preparedUpdateParams = standaloneUpdates;
      }
      if (preparedCreateParams.length === 0 && preparedUpdateParams.length === 0) {
        return;
      }
      const accumulatedContext = [];
      const accumulatedParts = [];
      for (const [method, payloads] of [
        ["post", preparedCreateParams],
        ["patch", preparedUpdateParams]
      ]) {
        for (const originalPayload of payloads) {
          const { inputs, outputs, events: events2, attachments, ...payload } = originalPayload;
          const fields = { inputs, outputs, events: events2 };
          const stringifiedPayload = stringify$2(payload);
          accumulatedParts.push({
            name: `${method}.${payload.id}`,
            payload: new Blob([stringifiedPayload], {
              type: `application/json; length=${stringifiedPayload.length}`
              // encoding=gzip
            })
          });
          for (const [key, value] of Object.entries(fields)) {
            if (value === void 0) {
              continue;
            }
            const stringifiedValue = stringify$2(value);
            accumulatedParts.push({
              name: `${method}.${payload.id}.${key}`,
              payload: new Blob([stringifiedValue], {
                type: `application/json; length=${stringifiedValue.length}`
              })
            });
          }
          if (payload.id !== void 0) {
            const attachments2 = allAttachments[payload.id];
            if (attachments2) {
              delete allAttachments[payload.id];
              for (const [name, attachment] of Object.entries(attachments2)) {
                let contentType;
                let content;
                if (Array.isArray(attachment)) {
                  [contentType, content] = attachment;
                } else {
                  contentType = attachment.mimeType;
                  content = attachment.data;
                }
                if (name.includes(".")) {
                  console.warn(`Skipping attachment '${name}' for run ${payload.id}: Invalid attachment name. Attachment names must not contain periods ('.'). Please rename the attachment and try again.`);
                  continue;
                }
                accumulatedParts.push({
                  name: `attachment.${payload.id}.${name}`,
                  payload: new Blob([content], {
                    type: `${contentType}; length=${content.byteLength}`
                  })
                });
              }
            }
          }
          accumulatedContext.push(`trace=${payload.trace_id},id=${payload.id}`);
        }
      }
      await this._sendMultipartRequest(accumulatedParts, accumulatedContext.join("; "));
    }
    async _sendMultipartRequest(parts, context) {
      try {
        const boundary = "----LangSmithFormBoundary" + Math.random().toString(36).slice(2);
        const chunks = [];
        for (const part of parts) {
          chunks.push(new Blob([`--${boundary}\r
`]));
          chunks.push(new Blob([
            `Content-Disposition: form-data; name="${part.name}"\r
`,
            `Content-Type: ${part.payload.type}\r
\r
`
          ]));
          chunks.push(part.payload);
          chunks.push(new Blob(["\r\n"]));
        }
        chunks.push(new Blob([`--${boundary}--\r
`]));
        const body = new Blob(chunks);
        const arrayBuffer = await body.arrayBuffer();
        const res = await this.batchIngestCaller.call(_getFetchImplementation(), `${this.apiUrl}/runs/multipart`, {
          method: "POST",
          headers: {
            ...this.headers,
            "Content-Type": `multipart/form-data; boundary=${boundary}`
          },
          body: arrayBuffer,
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions
        });
        await raiseForStatus(res, "ingest multipart runs", true);
      } catch (e) {
        console.warn(`${e.message.trim()}

Context: ${context}`);
      }
    }
    async updateRun(runId, run) {
      assertUuid(runId);
      if (run.inputs) {
        run.inputs = this.processInputs(run.inputs);
      }
      if (run.outputs) {
        run.outputs = this.processOutputs(run.outputs);
      }
      const data = { ...run, id: runId };
      if (!this._filterForSampling([data], true).length) {
        return;
      }
      if (this.autoBatchTracing && data.trace_id !== void 0 && data.dotted_order !== void 0) {
        if (run.end_time !== void 0 && data.parent_run_id === void 0 && this.blockOnRootRunFinalization && !this.manualFlushMode) {
          await this.processRunOperation({ action: "update", item: data }).catch(console.error);
          return;
        } else {
          void this.processRunOperation({ action: "update", item: data }).catch(console.error);
        }
        return;
      }
      const headers = { ...this.headers, "Content-Type": "application/json" };
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/runs/${runId}`, {
        method: "PATCH",
        headers,
        body: stringify$2(run),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "update run", true);
    }
    async readRun(runId, { loadChildRuns } = { loadChildRuns: false }) {
      assertUuid(runId);
      let run = await this._get(`/runs/${runId}`);
      if (loadChildRuns && run.child_run_ids) {
        run = await this._loadChildRuns(run);
      }
      return run;
    }
    async getRunUrl({ runId, run, projectOpts }) {
      if (run !== void 0) {
        let sessionId;
        if (run.session_id) {
          sessionId = run.session_id;
        } else if (projectOpts == null ? void 0 : projectOpts.projectName) {
          sessionId = (await this.readProject({ projectName: projectOpts == null ? void 0 : projectOpts.projectName })).id;
        } else if (projectOpts == null ? void 0 : projectOpts.projectId) {
          sessionId = projectOpts == null ? void 0 : projectOpts.projectId;
        } else {
          const project = await this.readProject({
            projectName: getLangSmithEnvironmentVariable("PROJECT") || "default"
          });
          sessionId = project.id;
        }
        const tenantId = await this._getTenantId();
        return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;
      } else if (runId !== void 0) {
        const run_ = await this.readRun(runId);
        if (!run_.app_path) {
          throw new Error(`Run ${runId} has no app_path`);
        }
        const baseUrl = this.getHostUrl();
        return `${baseUrl}${run_.app_path}`;
      } else {
        throw new Error("Must provide either runId or run");
      }
    }
    async _loadChildRuns(run) {
      const childRuns = await toArray(this.listRuns({ id: run.child_run_ids }));
      const treemap = {};
      const runs = {};
      childRuns.sort((a, b) => ((a == null ? void 0 : a.dotted_order) ?? "").localeCompare((b == null ? void 0 : b.dotted_order) ?? ""));
      for (const childRun of childRuns) {
        if (childRun.parent_run_id === null || childRun.parent_run_id === void 0) {
          throw new Error(`Child run ${childRun.id} has no parent`);
        }
        if (!(childRun.parent_run_id in treemap)) {
          treemap[childRun.parent_run_id] = [];
        }
        treemap[childRun.parent_run_id].push(childRun);
        runs[childRun.id] = childRun;
      }
      run.child_runs = treemap[run.id] || [];
      for (const runId in treemap) {
        if (runId !== run.id) {
          runs[runId].child_runs = treemap[runId];
        }
      }
      return run;
    }
    /**
     * List runs from the LangSmith server.
     * @param projectId - The ID of the project to filter by.
     * @param projectName - The name of the project to filter by.
     * @param parentRunId - The ID of the parent run to filter by.
     * @param traceId - The ID of the trace to filter by.
     * @param referenceExampleId - The ID of the reference example to filter by.
     * @param startTime - The start time to filter by.
     * @param isRoot - Indicates whether to only return root runs.
     * @param runType - The run type to filter by.
     * @param error - Indicates whether to filter by error runs.
     * @param id - The ID of the run to filter by.
     * @param query - The query string to filter by.
     * @param filter - The filter string to apply to the run spans.
     * @param traceFilter - The filter string to apply on the root run of the trace.
     * @param limit - The maximum number of runs to retrieve.
     * @returns {AsyncIterable<Run>} - The runs.
     *
     * @example
     * // List all runs in a project
     * const projectRuns = client.listRuns({ projectName: "<your_project>" });
     *
     * @example
     * // List LLM and Chat runs in the last 24 hours
     * const todaysLLMRuns = client.listRuns({
     *   projectName: "<your_project>",
     *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),
     *   run_type: "llm",
     * });
     *
     * @example
     * // List traces in a project
     * const rootRuns = client.listRuns({
     *   projectName: "<your_project>",
     *   execution_order: 1,
     * });
     *
     * @example
     * // List runs without errors
     * const correctRuns = client.listRuns({
     *   projectName: "<your_project>",
     *   error: false,
     * });
     *
     * @example
     * // List runs by run ID
     * const runIds = [
     *   "a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836",
     *   "9398e6be-964f-4aa4-8ae9-ad78cd4b7074",
     * ];
     * const selectedRuns = client.listRuns({ run_ids: runIds });
     *
     * @example
     * // List all "chain" type runs that took more than 10 seconds and had `total_tokens` greater than 5000
     * const chainRuns = client.listRuns({
     *   projectName: "<your_project>",
     *   filter: 'and(eq(run_type, "chain"), gt(latency, 10), gt(total_tokens, 5000))',
     * });
     *
     * @example
     * // List all runs called "extractor" whose root of the trace was assigned feedback "user_score" score of 1
     * const goodExtractorRuns = client.listRuns({
     *   projectName: "<your_project>",
     *   filter: 'eq(name, "extractor")',
     *   traceFilter: 'and(eq(feedback_key, "user_score"), eq(feedback_score, 1))',
     * });
     *
     * @example
     * // List all runs that started after a specific timestamp and either have "error" not equal to null or a "Correctness" feedback score equal to 0
     * const complexRuns = client.listRuns({
     *   projectName: "<your_project>",
     *   filter: 'and(gt(start_time, "2023-07-15T12:34:56Z"), or(neq(error, null), and(eq(feedback_key, "Correctness"), eq(feedback_score, 0.0))))',
     * });
     *
     * @example
     * // List all runs where `tags` include "experimental" or "beta" and `latency` is greater than 2 seconds
     * const taggedRuns = client.listRuns({
     *   projectName: "<your_project>",
     *   filter: 'and(or(has(tags, "experimental"), has(tags, "beta")), gt(latency, 2))',
     * });
     */
    async *listRuns(props) {
      const { projectId, projectName, parentRunId, traceId, referenceExampleId, startTime, executionOrder, isRoot, runType, error, id, query, filter: filter2, traceFilter, treeFilter, limit: limit2, select } = props;
      let projectIds = [];
      if (projectId) {
        projectIds = Array.isArray(projectId) ? projectId : [projectId];
      }
      if (projectName) {
        const projectNames = Array.isArray(projectName) ? projectName : [projectName];
        const projectIds_ = await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)));
        projectIds.push(...projectIds_);
      }
      const default_select = [
        "app_path",
        "child_run_ids",
        "completion_cost",
        "completion_tokens",
        "dotted_order",
        "end_time",
        "error",
        "events",
        "extra",
        "feedback_stats",
        "first_token_time",
        "id",
        "inputs",
        "name",
        "outputs",
        "parent_run_id",
        "parent_run_ids",
        "prompt_cost",
        "prompt_tokens",
        "reference_example_id",
        "run_type",
        "session_id",
        "start_time",
        "status",
        "tags",
        "total_cost",
        "total_tokens",
        "trace_id"
      ];
      const body = {
        session: projectIds.length ? projectIds : null,
        run_type: runType,
        reference_example: referenceExampleId,
        query,
        filter: filter2,
        trace_filter: traceFilter,
        tree_filter: treeFilter,
        execution_order: executionOrder,
        parent_run: parentRunId,
        start_time: startTime ? startTime.toISOString() : null,
        error,
        id,
        limit: limit2,
        trace: traceId,
        select: select ? select : default_select,
        is_root: isRoot
      };
      let runsYielded = 0;
      for await (const runs of this._getCursorPaginatedList("/runs/query", body)) {
        if (limit2) {
          if (runsYielded >= limit2) {
            break;
          }
          if (runs.length + runsYielded > limit2) {
            const newRuns = runs.slice(0, limit2 - runsYielded);
            yield* newRuns;
            break;
          }
          runsYielded += runs.length;
          yield* runs;
        } else {
          yield* runs;
        }
      }
    }
    async getRunStats({ id, trace, parentRun, runType, projectNames, projectIds, referenceExampleIds, startTime, endTime, error, query, filter: filter2, traceFilter, treeFilter, isRoot, dataSourceType }) {
      let projectIds_ = projectIds || [];
      if (projectNames) {
        projectIds_ = [
          ...projectIds || [],
          ...await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)))
        ];
      }
      const payload = {
        id,
        trace,
        parent_run: parentRun,
        run_type: runType,
        session: projectIds_,
        reference_example: referenceExampleIds,
        start_time: startTime,
        end_time: endTime,
        error,
        query,
        filter: filter2,
        trace_filter: traceFilter,
        tree_filter: treeFilter,
        is_root: isRoot,
        data_source_type: dataSourceType
      };
      const filteredPayload = Object.fromEntries(Object.entries(payload).filter(([_, value]) => value !== void 0));
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/runs/stats`, {
        method: "POST",
        headers: this.headers,
        body: JSON.stringify(filteredPayload),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      const result = await response.json();
      return result;
    }
    async shareRun(runId, { shareId } = {}) {
      const data = {
        run_id: runId,
        share_token: shareId || v4()
      };
      assertUuid(runId);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/runs/${runId}/share`, {
        method: "PUT",
        headers: this.headers,
        body: JSON.stringify(data),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      const result = await response.json();
      if (result === null || !("share_token" in result)) {
        throw new Error("Invalid response from server");
      }
      return `${this.getHostUrl()}/public/${result["share_token"]}/r`;
    }
    async unshareRun(runId) {
      assertUuid(runId);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/runs/${runId}/share`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "unshare run", true);
    }
    async readRunSharedLink(runId) {
      assertUuid(runId);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/runs/${runId}/share`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      const result = await response.json();
      if (result === null || !("share_token" in result)) {
        return void 0;
      }
      return `${this.getHostUrl()}/public/${result["share_token"]}/r`;
    }
    async listSharedRuns(shareToken, { runIds } = {}) {
      const queryParams = new URLSearchParams({
        share_token: shareToken
      });
      if (runIds !== void 0) {
        for (const runId of runIds) {
          queryParams.append("id", runId);
        }
      }
      assertUuid(shareToken);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      const runs = await response.json();
      return runs;
    }
    async readDatasetSharedSchema(datasetId, datasetName) {
      if (!datasetId && !datasetName) {
        throw new Error("Either datasetId or datasetName must be given");
      }
      if (!datasetId) {
        const dataset = await this.readDataset({ datasetName });
        datasetId = dataset.id;
      }
      assertUuid(datasetId);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets/${datasetId}/share`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      const shareSchema = await response.json();
      shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;
      return shareSchema;
    }
    async shareDataset(datasetId, datasetName) {
      if (!datasetId && !datasetName) {
        throw new Error("Either datasetId or datasetName must be given");
      }
      if (!datasetId) {
        const dataset = await this.readDataset({ datasetName });
        datasetId = dataset.id;
      }
      const data = {
        dataset_id: datasetId
      };
      assertUuid(datasetId);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets/${datasetId}/share`, {
        method: "PUT",
        headers: this.headers,
        body: JSON.stringify(data),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      const shareSchema = await response.json();
      shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;
      return shareSchema;
    }
    async unshareDataset(datasetId) {
      assertUuid(datasetId);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets/${datasetId}/share`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "unshare dataset", true);
    }
    async readSharedDataset(shareToken) {
      assertUuid(shareToken);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/public/${shareToken}/datasets`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      const dataset = await response.json();
      return dataset;
    }
    /**
     * Get shared examples.
     *
     * @param {string} shareToken The share token to get examples for. A share token is the UUID (or LangSmith URL, including UUID) generated when explicitly marking an example as public.
     * @param {Object} [options] Additional options for listing the examples.
     * @param {string[] | undefined} [options.exampleIds] A list of example IDs to filter by.
     * @returns {Promise<Example[]>} The shared examples.
     */
    async listSharedExamples(shareToken, options) {
      const params = {};
      if (options == null ? void 0 : options.exampleIds) {
        params.id = options.exampleIds;
      }
      const urlParams = new URLSearchParams();
      Object.entries(params).forEach(([key, value]) => {
        if (Array.isArray(value)) {
          value.forEach((v) => urlParams.append(key, v));
        } else {
          urlParams.append(key, value);
        }
      });
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/public/${shareToken}/examples?${urlParams.toString()}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      const result = await response.json();
      if (!response.ok) {
        if ("detail" in result) {
          throw new Error(`Failed to list shared examples.
Status: ${response.status}
Message: ${result.detail.join("\n")}`);
        }
        throw new Error(`Failed to list shared examples: ${response.status} ${response.statusText}`);
      }
      return result.map((example) => ({
        ...example,
        _hostUrl: this.getHostUrl()
      }));
    }
    async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null }) {
      const upsert_ = upsert ? `?upsert=true` : "";
      const endpoint = `${this.apiUrl}/sessions${upsert_}`;
      const extra = projectExtra || {};
      if (metadata) {
        extra["metadata"] = metadata;
      }
      const body = {
        name: projectName,
        extra,
        description
      };
      if (referenceDatasetId !== null) {
        body["reference_dataset_id"] = referenceDatasetId;
      }
      const response = await this.caller.call(_getFetchImplementation(), endpoint, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        body: JSON.stringify(body),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "create project");
      const result = await response.json();
      return result;
    }
    async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null }) {
      const endpoint = `${this.apiUrl}/sessions/${projectId}`;
      let extra = projectExtra;
      if (metadata) {
        extra = { ...extra || {}, metadata };
      }
      const body = {
        name,
        extra,
        description,
        end_time: endTime ? new Date(endTime).toISOString() : null
      };
      const response = await this.caller.call(_getFetchImplementation(), endpoint, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        body: JSON.stringify(body),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "update project");
      const result = await response.json();
      return result;
    }
    async hasProject({ projectId, projectName }) {
      let path = "/sessions";
      const params = new URLSearchParams();
      if (projectId !== void 0 && projectName !== void 0) {
        throw new Error("Must provide either projectName or projectId, not both");
      } else if (projectId !== void 0) {
        assertUuid(projectId);
        path += `/${projectId}`;
      } else if (projectName !== void 0) {
        params.append("name", projectName);
      } else {
        throw new Error("Must provide projectName or projectId");
      }
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}${path}?${params}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      try {
        const result = await response.json();
        if (!response.ok) {
          return false;
        }
        if (Array.isArray(result)) {
          return result.length > 0;
        }
        return true;
      } catch (e) {
        return false;
      }
    }
    async readProject({ projectId, projectName, includeStats }) {
      let path = "/sessions";
      const params = new URLSearchParams();
      if (projectId !== void 0 && projectName !== void 0) {
        throw new Error("Must provide either projectName or projectId, not both");
      } else if (projectId !== void 0) {
        assertUuid(projectId);
        path += `/${projectId}`;
      } else if (projectName !== void 0) {
        params.append("name", projectName);
      } else {
        throw new Error("Must provide projectName or projectId");
      }
      if (includeStats !== void 0) {
        params.append("include_stats", includeStats.toString());
      }
      const response = await this._get(path, params);
      let result;
      if (Array.isArray(response)) {
        if (response.length === 0) {
          throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);
        }
        result = response[0];
      } else {
        result = response;
      }
      return result;
    }
    async getProjectUrl({ projectId, projectName }) {
      if (projectId === void 0 && projectName === void 0) {
        throw new Error("Must provide either projectName or projectId");
      }
      const project = await this.readProject({ projectId, projectName });
      const tenantId = await this._getTenantId();
      return `${this.getHostUrl()}/o/${tenantId}/projects/p/${project.id}`;
    }
    async getDatasetUrl({ datasetId, datasetName }) {
      if (datasetId === void 0 && datasetName === void 0) {
        throw new Error("Must provide either datasetName or datasetId");
      }
      const dataset = await this.readDataset({ datasetId, datasetName });
      const tenantId = await this._getTenantId();
      return `${this.getHostUrl()}/o/${tenantId}/datasets/${dataset.id}`;
    }
    async _getTenantId() {
      if (this._tenantId !== null) {
        return this._tenantId;
      }
      const queryParams = new URLSearchParams({ limit: "1" });
      for await (const projects of this._getPaginated("/sessions", queryParams)) {
        this._tenantId = projects[0].tenant_id;
        return projects[0].tenant_id;
      }
      throw new Error("No projects found to resolve tenant.");
    }
    async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, referenceFree, metadata } = {}) {
      const params = new URLSearchParams();
      if (projectIds !== void 0) {
        for (const projectId of projectIds) {
          params.append("id", projectId);
        }
      }
      if (name !== void 0) {
        params.append("name", name);
      }
      if (nameContains !== void 0) {
        params.append("name_contains", nameContains);
      }
      if (referenceDatasetId !== void 0) {
        params.append("reference_dataset", referenceDatasetId);
      } else if (referenceDatasetName !== void 0) {
        const dataset = await this.readDataset({
          datasetName: referenceDatasetName
        });
        params.append("reference_dataset", dataset.id);
      }
      if (referenceFree !== void 0) {
        params.append("reference_free", referenceFree.toString());
      }
      if (metadata !== void 0) {
        params.append("metadata", JSON.stringify(metadata));
      }
      for await (const projects of this._getPaginated("/sessions", params)) {
        yield* projects;
      }
    }
    async deleteProject({ projectId, projectName }) {
      let projectId_;
      if (projectId === void 0 && projectName === void 0) {
        throw new Error("Must provide projectName or projectId");
      } else if (projectId !== void 0 && projectName !== void 0) {
        throw new Error("Must provide either projectName or projectId, not both");
      } else if (projectId === void 0) {
        projectId_ = (await this.readProject({ projectName })).id;
      } else {
        projectId_ = projectId;
      }
      assertUuid(projectId_);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/sessions/${projectId_}`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, `delete session ${projectId_} (${projectName})`, true);
    }
    async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name }) {
      const url = `${this.apiUrl}/datasets/upload`;
      const formData = new FormData();
      formData.append("file", csvFile, fileName);
      inputKeys.forEach((key) => {
        formData.append("input_keys", key);
      });
      outputKeys.forEach((key) => {
        formData.append("output_keys", key);
      });
      if (description) {
        formData.append("description", description);
      }
      if (dataType) {
        formData.append("data_type", dataType);
      }
      if (name) {
        formData.append("name", name);
      }
      const response = await this.caller.call(_getFetchImplementation(), url, {
        method: "POST",
        headers: this.headers,
        body: formData,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "upload CSV");
      const result = await response.json();
      return result;
    }
    async createDataset(name, { description, dataType, inputsSchema, outputsSchema, metadata } = {}) {
      const body = {
        name,
        description,
        extra: metadata ? { metadata } : void 0
      };
      if (dataType) {
        body.data_type = dataType;
      }
      if (inputsSchema) {
        body.inputs_schema_definition = inputsSchema;
      }
      if (outputsSchema) {
        body.outputs_schema_definition = outputsSchema;
      }
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        body: JSON.stringify(body),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "create dataset");
      const result = await response.json();
      return result;
    }
    async readDataset({ datasetId, datasetName }) {
      let path = "/datasets";
      const params = new URLSearchParams({ limit: "1" });
      if (datasetId !== void 0 && datasetName !== void 0) {
        throw new Error("Must provide either datasetName or datasetId, not both");
      } else if (datasetId !== void 0) {
        assertUuid(datasetId);
        path += `/${datasetId}`;
      } else if (datasetName !== void 0) {
        params.append("name", datasetName);
      } else {
        throw new Error("Must provide datasetName or datasetId");
      }
      const response = await this._get(path, params);
      let result;
      if (Array.isArray(response)) {
        if (response.length === 0) {
          throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);
        }
        result = response[0];
      } else {
        result = response;
      }
      return result;
    }
    async hasDataset({ datasetId, datasetName }) {
      try {
        await this.readDataset({ datasetId, datasetName });
        return true;
      } catch (e) {
        if (
          // eslint-disable-next-line no-instanceof/no-instanceof
          e instanceof Error && e.message.toLocaleLowerCase().includes("not found")
        ) {
          return false;
        }
        throw e;
      }
    }
    async diffDatasetVersions({ datasetId, datasetName, fromVersion, toVersion }) {
      let datasetId_ = datasetId;
      if (datasetId_ === void 0 && datasetName === void 0) {
        throw new Error("Must provide either datasetName or datasetId");
      } else if (datasetId_ !== void 0 && datasetName !== void 0) {
        throw new Error("Must provide either datasetName or datasetId, not both");
      } else if (datasetId_ === void 0) {
        const dataset = await this.readDataset({ datasetName });
        datasetId_ = dataset.id;
      }
      const urlParams = new URLSearchParams({
        from_version: typeof fromVersion === "string" ? fromVersion : fromVersion.toISOString(),
        to_version: typeof toVersion === "string" ? toVersion : toVersion.toISOString()
      });
      const response = await this._get(`/datasets/${datasetId_}/versions/diff`, urlParams);
      return response;
    }
    async readDatasetOpenaiFinetuning({ datasetId, datasetName }) {
      const path = "/datasets";
      if (datasetId !== void 0) ;
      else if (datasetName !== void 0) {
        datasetId = (await this.readDataset({ datasetName })).id;
      } else {
        throw new Error("Must provide datasetName or datasetId");
      }
      const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);
      const datasetText = await response.text();
      const dataset = datasetText.trim().split("\n").map((line) => JSON.parse(line));
      return dataset;
    }
    async *listDatasets({ limit: limit2 = 100, offset = 0, datasetIds, datasetName, datasetNameContains, metadata } = {}) {
      const path = "/datasets";
      const params = new URLSearchParams({
        limit: limit2.toString(),
        offset: offset.toString()
      });
      if (datasetIds !== void 0) {
        for (const id_ of datasetIds) {
          params.append("id", id_);
        }
      }
      if (datasetName !== void 0) {
        params.append("name", datasetName);
      }
      if (datasetNameContains !== void 0) {
        params.append("name_contains", datasetNameContains);
      }
      if (metadata !== void 0) {
        params.append("metadata", JSON.stringify(metadata));
      }
      for await (const datasets of this._getPaginated(path, params)) {
        yield* datasets;
      }
    }
    /**
     * Update a dataset
     * @param props The dataset details to update
     * @returns The updated dataset
     */
    async updateDataset(props) {
      const { datasetId, datasetName, ...update } = props;
      if (!datasetId && !datasetName) {
        throw new Error("Must provide either datasetName or datasetId");
      }
      const _datasetId = datasetId ?? (await this.readDataset({ datasetName })).id;
      assertUuid(_datasetId);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets/${_datasetId}`, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        body: JSON.stringify(update),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "update dataset");
      return await response.json();
    }
    /**
     * Updates a tag on a dataset.
     *
     * If the tag is already assigned to a different version of this dataset,
     * the tag will be moved to the new version. The as_of parameter is used to
     * determine which version of the dataset to apply the new tags to.
     *
     * It must be an exact version of the dataset to succeed. You can
     * use the "readDatasetVersion" method to find the exact version
     * to apply the tags to.
     * @param params.datasetId The ID of the dataset to update. Must be provided if "datasetName" is not provided.
     * @param params.datasetName The name of the dataset to update. Must be provided if "datasetId" is not provided.
     * @param params.asOf The timestamp of the dataset to apply the new tags to.
     * @param params.tag The new tag to apply to the dataset.
     */
    async updateDatasetTag(props) {
      const { datasetId, datasetName, asOf, tag } = props;
      if (!datasetId && !datasetName) {
        throw new Error("Must provide either datasetName or datasetId");
      }
      const _datasetId = datasetId ?? (await this.readDataset({ datasetName })).id;
      assertUuid(_datasetId);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets/${_datasetId}/tags`, {
        method: "PUT",
        headers: { ...this.headers, "Content-Type": "application/json" },
        body: JSON.stringify({
          as_of: typeof asOf === "string" ? asOf : asOf.toISOString(),
          tag
        }),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "update dataset tags");
    }
    async deleteDataset({ datasetId, datasetName }) {
      let path = "/datasets";
      let datasetId_ = datasetId;
      if (datasetId !== void 0 && datasetName !== void 0) {
        throw new Error("Must provide either datasetName or datasetId, not both");
      } else if (datasetName !== void 0) {
        const dataset = await this.readDataset({ datasetName });
        datasetId_ = dataset.id;
      }
      if (datasetId_ !== void 0) {
        assertUuid(datasetId_);
        path += `/${datasetId_}`;
      } else {
        throw new Error("Must provide datasetName or datasetId");
      }
      const response = await this.caller.call(_getFetchImplementation(), this.apiUrl + path, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, `delete ${path}`);
      await response.json();
    }
    async indexDataset({ datasetId, datasetName, tag }) {
      let datasetId_ = datasetId;
      if (!datasetId_ && !datasetName) {
        throw new Error("Must provide either datasetName or datasetId");
      } else if (datasetId_ && datasetName) {
        throw new Error("Must provide either datasetName or datasetId, not both");
      } else if (!datasetId_) {
        const dataset = await this.readDataset({ datasetName });
        datasetId_ = dataset.id;
      }
      assertUuid(datasetId_);
      const data = {
        tag
      };
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets/${datasetId_}/index`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        body: JSON.stringify(data),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "index dataset");
      await response.json();
    }
    /**
     * Lets you run a similarity search query on a dataset.
     *
     * Requires the dataset to be indexed. Please see the `indexDataset` method to set up indexing.
     *
     * @param inputs      The input on which to run the similarity search. Must have the
     *                    same schema as the dataset.
     *
     * @param datasetId   The dataset to search for similar examples.
     *
     * @param limit       The maximum number of examples to return. Will return the top `limit` most
     *                    similar examples in order of most similar to least similar. If no similar
     *                    examples are found, random examples will be returned.
     *
     * @param filter      A filter string to apply to the search. Only examples will be returned that
     *                    match the filter string. Some examples of filters
     *
     *                    - eq(metadata.mykey, "value")
     *                    - and(neq(metadata.my.nested.key, "value"), neq(metadata.mykey, "value"))
     *                    - or(eq(metadata.mykey, "value"), eq(metadata.mykey, "othervalue"))
     *
     * @returns           A list of similar examples.
     *
     *
     * @example
     * dataset_id = "123e4567-e89b-12d3-a456-426614174000"
     * inputs = {"text": "How many people live in Berlin?"}
     * limit = 5
     * examples = await client.similarExamples(inputs, dataset_id, limit)
     */
    async similarExamples(inputs, datasetId, limit2, { filter: filter2 } = {}) {
      const data = {
        limit: limit2,
        inputs
      };
      if (filter2 !== void 0) {
        data["filter"] = filter2;
      }
      assertUuid(datasetId);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets/${datasetId}/search`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        body: JSON.stringify(data),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "fetch similar examples");
      const result = await response.json();
      return result["examples"];
    }
    async createExample(inputs, outputs, { datasetId, datasetName, createdAt, exampleId, metadata, split, sourceRunId }) {
      let datasetId_ = datasetId;
      if (datasetId_ === void 0 && datasetName === void 0) {
        throw new Error("Must provide either datasetName or datasetId");
      } else if (datasetId_ !== void 0 && datasetName !== void 0) {
        throw new Error("Must provide either datasetName or datasetId, not both");
      } else if (datasetId_ === void 0) {
        const dataset = await this.readDataset({ datasetName });
        datasetId_ = dataset.id;
      }
      const createdAt_ = createdAt || /* @__PURE__ */ new Date();
      const data = {
        dataset_id: datasetId_,
        inputs,
        outputs,
        created_at: createdAt_ == null ? void 0 : createdAt_.toISOString(),
        id: exampleId,
        metadata,
        split,
        source_run_id: sourceRunId
      };
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/examples`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        body: JSON.stringify(data),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "create example");
      const result = await response.json();
      return result;
    }
    async createExamples(props) {
      const { inputs, outputs, metadata, sourceRunIds, exampleIds, datasetId, datasetName } = props;
      let datasetId_ = datasetId;
      if (datasetId_ === void 0 && datasetName === void 0) {
        throw new Error("Must provide either datasetName or datasetId");
      } else if (datasetId_ !== void 0 && datasetName !== void 0) {
        throw new Error("Must provide either datasetName or datasetId, not both");
      } else if (datasetId_ === void 0) {
        const dataset = await this.readDataset({ datasetName });
        datasetId_ = dataset.id;
      }
      const formattedExamples = inputs.map((input, idx) => {
        return {
          dataset_id: datasetId_,
          inputs: input,
          outputs: outputs ? outputs[idx] : void 0,
          metadata: metadata ? metadata[idx] : void 0,
          split: props.splits ? props.splits[idx] : void 0,
          id: exampleIds ? exampleIds[idx] : void 0,
          source_run_id: sourceRunIds ? sourceRunIds[idx] : void 0
        };
      });
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/examples/bulk`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        body: JSON.stringify(formattedExamples),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "create examples");
      const result = await response.json();
      return result;
    }
    async createLLMExample(input, generation, options) {
      return this.createExample({ input }, { output: generation }, options);
    }
    async createChatExample(input, generations, options) {
      const finalInput = input.map((message) => {
        if (isLangChainMessage(message)) {
          return convertLangChainMessageToExample(message);
        }
        return message;
      });
      const finalOutput = isLangChainMessage(generations) ? convertLangChainMessageToExample(generations) : generations;
      return this.createExample({ input: finalInput }, { output: finalOutput }, options);
    }
    async readExample(exampleId) {
      assertUuid(exampleId);
      const path = `/examples/${exampleId}`;
      const rawExample = await this._get(path);
      const { attachment_urls, ...rest } = rawExample;
      const example = rest;
      if (attachment_urls) {
        example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value]) => {
          acc[key.slice("attachment.".length)] = {
            presigned_url: value.presigned_url,
            mime_type: value.mime_type
          };
          return acc;
        }, {});
      }
      return example;
    }
    async *listExamples({ datasetId, datasetName, exampleIds, asOf, splits, inlineS3Urls, metadata, limit: limit2, offset, filter: filter2, includeAttachments } = {}) {
      let datasetId_;
      if (datasetId !== void 0 && datasetName !== void 0) {
        throw new Error("Must provide either datasetName or datasetId, not both");
      } else if (datasetId !== void 0) {
        datasetId_ = datasetId;
      } else if (datasetName !== void 0) {
        const dataset = await this.readDataset({ datasetName });
        datasetId_ = dataset.id;
      } else {
        throw new Error("Must provide a datasetName or datasetId");
      }
      const params = new URLSearchParams({ dataset: datasetId_ });
      const dataset_version = asOf ? typeof asOf === "string" ? asOf : asOf == null ? void 0 : asOf.toISOString() : void 0;
      if (dataset_version) {
        params.append("as_of", dataset_version);
      }
      const inlineS3Urls_ = inlineS3Urls ?? true;
      params.append("inline_s3_urls", inlineS3Urls_.toString());
      if (exampleIds !== void 0) {
        for (const id_ of exampleIds) {
          params.append("id", id_);
        }
      }
      if (splits !== void 0) {
        for (const split of splits) {
          params.append("splits", split);
        }
      }
      if (metadata !== void 0) {
        const serializedMetadata = JSON.stringify(metadata);
        params.append("metadata", serializedMetadata);
      }
      if (limit2 !== void 0) {
        params.append("limit", limit2.toString());
      }
      if (offset !== void 0) {
        params.append("offset", offset.toString());
      }
      if (filter2 !== void 0) {
        params.append("filter", filter2);
      }
      if (includeAttachments === true) {
        ["attachment_urls", "outputs", "metadata"].forEach((field) => params.append("select", field));
      }
      let i2 = 0;
      for await (const rawExamples of this._getPaginated("/examples", params)) {
        for (const rawExample of rawExamples) {
          const { attachment_urls, ...rest } = rawExample;
          const example = rest;
          if (attachment_urls) {
            example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value]) => {
              acc[key.slice("attachment.".length)] = {
                presigned_url: value.presigned_url,
                mime_type: value.mime_type || void 0
              };
              return acc;
            }, {});
          }
          yield example;
          i2++;
        }
        if (limit2 !== void 0 && i2 >= limit2) {
          break;
        }
      }
    }
    async deleteExample(exampleId) {
      assertUuid(exampleId);
      const path = `/examples/${exampleId}`;
      const response = await this.caller.call(_getFetchImplementation(), this.apiUrl + path, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, `delete ${path}`);
      await response.json();
    }
    async updateExample(exampleId, update) {
      assertUuid(exampleId);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/examples/${exampleId}`, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        body: JSON.stringify(update),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "update example");
      const result = await response.json();
      return result;
    }
    async updateExamples(update) {
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/examples/bulk`, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        body: JSON.stringify(update),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "update examples");
      const result = await response.json();
      return result;
    }
    /**
     * Get dataset version by closest date or exact tag.
     *
     * Use this to resolve the nearest version to a given timestamp or for a given tag.
     *
     * @param options The options for getting the dataset version
     * @param options.datasetId The ID of the dataset
     * @param options.datasetName The name of the dataset
     * @param options.asOf The timestamp of the dataset to retrieve
     * @param options.tag The tag of the dataset to retrieve
     * @returns The dataset version
     */
    async readDatasetVersion({ datasetId, datasetName, asOf, tag }) {
      let resolvedDatasetId;
      if (!datasetId) {
        const dataset = await this.readDataset({ datasetName });
        resolvedDatasetId = dataset.id;
      } else {
        resolvedDatasetId = datasetId;
      }
      assertUuid(resolvedDatasetId);
      if (asOf && tag || !asOf && !tag) {
        throw new Error("Exactly one of asOf and tag must be specified.");
      }
      const params = new URLSearchParams();
      if (asOf !== void 0) {
        params.append("as_of", typeof asOf === "string" ? asOf : asOf.toISOString());
      }
      if (tag !== void 0) {
        params.append("tag", tag);
      }
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets/${resolvedDatasetId}/version?${params.toString()}`, {
        method: "GET",
        headers: { ...this.headers },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "read dataset version");
      return await response.json();
    }
    async listDatasetSplits({ datasetId, datasetName, asOf }) {
      let datasetId_;
      if (datasetId === void 0 && datasetName === void 0) {
        throw new Error("Must provide dataset name or ID");
      } else if (datasetId !== void 0 && datasetName !== void 0) {
        throw new Error("Must provide either datasetName or datasetId, not both");
      } else if (datasetId === void 0) {
        const dataset = await this.readDataset({ datasetName });
        datasetId_ = dataset.id;
      } else {
        datasetId_ = datasetId;
      }
      assertUuid(datasetId_);
      const params = new URLSearchParams();
      const dataset_version = asOf ? typeof asOf === "string" ? asOf : asOf == null ? void 0 : asOf.toISOString() : void 0;
      if (dataset_version) {
        params.append("as_of", dataset_version);
      }
      const response = await this._get(`/datasets/${datasetId_}/splits`, params);
      return response;
    }
    async updateDatasetSplits({ datasetId, datasetName, splitName, exampleIds, remove = false }) {
      let datasetId_;
      if (datasetId === void 0 && datasetName === void 0) {
        throw new Error("Must provide dataset name or ID");
      } else if (datasetId !== void 0 && datasetName !== void 0) {
        throw new Error("Must provide either datasetName or datasetId, not both");
      } else if (datasetId === void 0) {
        const dataset = await this.readDataset({ datasetName });
        datasetId_ = dataset.id;
      } else {
        datasetId_ = datasetId;
      }
      assertUuid(datasetId_);
      const data = {
        split_name: splitName,
        examples: exampleIds.map((id) => {
          assertUuid(id);
          return id;
        }),
        remove
      };
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets/${datasetId_}/splits`, {
        method: "PUT",
        headers: { ...this.headers, "Content-Type": "application/json" },
        body: JSON.stringify(data),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "update dataset splits", true);
    }
    /**
     * @deprecated This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.
     */
    async evaluateRun(run, evaluator, { sourceInfo, loadChildRuns, referenceExample } = { loadChildRuns: false }) {
      warnOnce("This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.");
      let run_;
      if (typeof run === "string") {
        run_ = await this.readRun(run, { loadChildRuns });
      } else if (typeof run === "object" && "id" in run) {
        run_ = run;
      } else {
        throw new Error(`Invalid run type: ${typeof run}`);
      }
      if (run_.reference_example_id !== null && run_.reference_example_id !== void 0) {
        referenceExample = await this.readExample(run_.reference_example_id);
      }
      const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);
      const [_, feedbacks] = await this._logEvaluationFeedback(feedbackResult, run_, sourceInfo);
      return feedbacks[0];
    }
    async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = "api", sourceRunId, feedbackId, feedbackConfig, projectId, comparativeExperimentId }) {
      var _a3;
      if (!runId && !projectId) {
        throw new Error("One of runId or projectId must be provided");
      }
      if (runId && projectId) {
        throw new Error("Only one of runId or projectId can be provided");
      }
      const feedback_source = {
        type: feedbackSourceType ?? "api",
        metadata: sourceInfo ?? {}
      };
      if (sourceRunId !== void 0 && (feedback_source == null ? void 0 : feedback_source.metadata) !== void 0 && !feedback_source.metadata["__run"]) {
        feedback_source.metadata["__run"] = { run_id: sourceRunId };
      }
      if ((feedback_source == null ? void 0 : feedback_source.metadata) !== void 0 && ((_a3 = feedback_source.metadata["__run"]) == null ? void 0 : _a3.run_id) !== void 0) {
        assertUuid(feedback_source.metadata["__run"].run_id);
      }
      const feedback = {
        id: feedbackId ?? v4(),
        run_id: runId,
        key,
        score,
        value,
        correction,
        comment,
        feedback_source,
        comparative_experiment_id: comparativeExperimentId,
        feedbackConfig,
        session_id: projectId
      };
      const url = `${this.apiUrl}/feedback`;
      const response = await this.caller.call(_getFetchImplementation(), url, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        body: JSON.stringify(feedback),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "create feedback", true);
      return feedback;
    }
    async updateFeedback(feedbackId, { score, value, correction, comment }) {
      const feedbackUpdate = {};
      if (score !== void 0 && score !== null) {
        feedbackUpdate["score"] = score;
      }
      if (value !== void 0 && value !== null) {
        feedbackUpdate["value"] = value;
      }
      if (correction !== void 0 && correction !== null) {
        feedbackUpdate["correction"] = correction;
      }
      if (comment !== void 0 && comment !== null) {
        feedbackUpdate["comment"] = comment;
      }
      assertUuid(feedbackId);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/feedback/${feedbackId}`, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        body: JSON.stringify(feedbackUpdate),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "update feedback", true);
    }
    async readFeedback(feedbackId) {
      assertUuid(feedbackId);
      const path = `/feedback/${feedbackId}`;
      const response = await this._get(path);
      return response;
    }
    async deleteFeedback(feedbackId) {
      assertUuid(feedbackId);
      const path = `/feedback/${feedbackId}`;
      const response = await this.caller.call(_getFetchImplementation(), this.apiUrl + path, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, `delete ${path}`);
      await response.json();
    }
    async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes } = {}) {
      const queryParams = new URLSearchParams();
      if (runIds) {
        queryParams.append("run", runIds.join(","));
      }
      if (feedbackKeys) {
        for (const key of feedbackKeys) {
          queryParams.append("key", key);
        }
      }
      if (feedbackSourceTypes) {
        for (const type of feedbackSourceTypes) {
          queryParams.append("source", type);
        }
      }
      for await (const feedbacks of this._getPaginated("/feedback", queryParams)) {
        yield* feedbacks;
      }
    }
    /**
     * Creates a presigned feedback token and URL.
     *
     * The token can be used to authorize feedback metrics without
     * needing an API key. This is useful for giving browser-based
     * applications the ability to submit feedback without needing
     * to expose an API key.
     *
     * @param runId - The ID of the run.
     * @param feedbackKey - The feedback key.
     * @param options - Additional options for the token.
     * @param options.expiration - The expiration time for the token.
     *
     * @returns A promise that resolves to a FeedbackIngestToken.
     */
    async createPresignedFeedbackToken(runId, feedbackKey, { expiration, feedbackConfig } = {}) {
      const body = {
        run_id: runId,
        feedback_key: feedbackKey,
        feedback_config: feedbackConfig
      };
      if (expiration) {
        if (typeof expiration === "string") {
          body["expires_at"] = expiration;
        } else if ((expiration == null ? void 0 : expiration.hours) || (expiration == null ? void 0 : expiration.minutes) || (expiration == null ? void 0 : expiration.days)) {
          body["expires_in"] = expiration;
        }
      } else {
        body["expires_in"] = {
          hours: 3
        };
      }
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/feedback/tokens`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        body: JSON.stringify(body),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      const result = await response.json();
      return result;
    }
    async createComparativeExperiment({ name, experimentIds, referenceDatasetId, createdAt, description, metadata, id }) {
      var _a3;
      if (experimentIds.length === 0) {
        throw new Error("At least one experiment is required");
      }
      if (!referenceDatasetId) {
        referenceDatasetId = (await this.readProject({
          projectId: experimentIds[0]
        })).reference_dataset_id;
      }
      if (!referenceDatasetId == null) {
        throw new Error("A reference dataset is required");
      }
      const body = {
        id,
        name,
        experiment_ids: experimentIds,
        reference_dataset_id: referenceDatasetId,
        description,
        created_at: (_a3 = createdAt ?? /* @__PURE__ */ new Date()) == null ? void 0 : _a3.toISOString(),
        extra: {}
      };
      if (metadata)
        body.extra["metadata"] = metadata;
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets/comparative`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        body: JSON.stringify(body),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await response.json();
    }
    /**
     * Retrieves a list of presigned feedback tokens for a given run ID.
     * @param runId The ID of the run.
     * @returns An async iterable of FeedbackIngestToken objects.
     */
    async *listPresignedFeedbackTokens(runId) {
      assertUuid(runId);
      const params = new URLSearchParams({ run_id: runId });
      for await (const tokens of this._getPaginated("/feedback/tokens", params)) {
        yield* tokens;
      }
    }
    _selectEvalResults(results) {
      let results_;
      if ("results" in results) {
        results_ = results.results;
      } else {
        results_ = [results];
      }
      return results_;
    }
    async _logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {
      const evalResults = this._selectEvalResults(evaluatorResponse);
      const feedbacks = [];
      for (const res of evalResults) {
        let sourceInfo_ = sourceInfo || {};
        if (res.evaluatorInfo) {
          sourceInfo_ = { ...res.evaluatorInfo, ...sourceInfo_ };
        }
        let runId_ = null;
        if (res.targetRunId) {
          runId_ = res.targetRunId;
        } else if (run) {
          runId_ = run.id;
        }
        feedbacks.push(await this.createFeedback(runId_, res.key, {
          score: res.score,
          value: res.value,
          comment: res.comment,
          correction: res.correction,
          sourceInfo: sourceInfo_,
          sourceRunId: res.sourceRunId,
          feedbackConfig: res.feedbackConfig,
          feedbackSourceType: "model"
        }));
      }
      return [evalResults, feedbacks];
    }
    async logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {
      const [results] = await this._logEvaluationFeedback(evaluatorResponse, run, sourceInfo);
      return results;
    }
    /**
     * API for managing annotation queues
     */
    /**
     * List the annotation queues on the LangSmith API.
     * @param options - The options for listing annotation queues
     * @param options.queueIds - The IDs of the queues to filter by
     * @param options.name - The name of the queue to filter by
     * @param options.nameContains - The substring that the queue name should contain
     * @param options.limit - The maximum number of queues to return
     * @returns An iterator of AnnotationQueue objects
     */
    async *listAnnotationQueues(options = {}) {
      const { queueIds, name, nameContains, limit: limit2 } = options;
      const params = new URLSearchParams();
      if (queueIds) {
        queueIds.forEach((id, i2) => {
          assertUuid(id, `queueIds[${i2}]`);
          params.append("ids", id);
        });
      }
      if (name)
        params.append("name", name);
      if (nameContains)
        params.append("name_contains", nameContains);
      params.append("limit", (limit2 !== void 0 ? Math.min(limit2, 100) : 100).toString());
      let count = 0;
      for await (const queues of this._getPaginated("/annotation-queues", params)) {
        yield* queues;
        count++;
        if (limit2 !== void 0 && count >= limit2)
          break;
      }
    }
    /**
     * Create an annotation queue on the LangSmith API.
     * @param options - The options for creating an annotation queue
     * @param options.name - The name of the annotation queue
     * @param options.description - The description of the annotation queue
     * @param options.queueId - The ID of the annotation queue
     * @returns The created AnnotationQueue object
     */
    async createAnnotationQueue(options) {
      const { name, description, queueId } = options;
      const body = {
        name,
        description,
        id: queueId || v4()
      };
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/annotation-queues`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        body: JSON.stringify(Object.fromEntries(Object.entries(body).filter(([_, v]) => v !== void 0))),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "create annotation queue");
      const data = await response.json();
      return data;
    }
    /**
     * Read an annotation queue with the specified queue ID.
     * @param queueId - The ID of the annotation queue to read
     * @returns The AnnotationQueue object
     */
    async readAnnotationQueue(queueId) {
      const queueIteratorResult = await this.listAnnotationQueues({
        queueIds: [queueId]
      }).next();
      if (queueIteratorResult.done) {
        throw new Error(`Annotation queue with ID ${queueId} not found`);
      }
      return queueIteratorResult.value;
    }
    /**
     * Update an annotation queue with the specified queue ID.
     * @param queueId - The ID of the annotation queue to update
     * @param options - The options for updating the annotation queue
     * @param options.name - The new name for the annotation queue
     * @param options.description - The new description for the annotation queue
     */
    async updateAnnotationQueue(queueId, options) {
      const { name, description } = options;
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}`, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        body: JSON.stringify({ name, description }),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "update annotation queue");
    }
    /**
     * Delete an annotation queue with the specified queue ID.
     * @param queueId - The ID of the annotation queue to delete
     */
    async deleteAnnotationQueue(queueId) {
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}`, {
        method: "DELETE",
        headers: { ...this.headers, Accept: "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "delete annotation queue");
    }
    /**
     * Add runs to an annotation queue with the specified queue ID.
     * @param queueId - The ID of the annotation queue
     * @param runIds - The IDs of the runs to be added to the annotation queue
     */
    async addRunsToAnnotationQueue(queueId, runIds) {
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}/runs`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        body: JSON.stringify(runIds.map((id, i2) => assertUuid(id, `runIds[${i2}]`).toString())),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "add runs to annotation queue");
    }
    /**
     * Get a run from an annotation queue at the specified index.
     * @param queueId - The ID of the annotation queue
     * @param index - The index of the run to retrieve
     * @returns A Promise that resolves to a RunWithAnnotationQueueInfo object
     * @throws {Error} If the run is not found at the given index or for other API-related errors
     */
    async getRunFromAnnotationQueue(queueId, index) {
      const baseUrl = `/annotation-queues/${assertUuid(queueId, "queueId")}/run`;
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}${baseUrl}/${index}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "get run from annotation queue");
      return await response.json();
    }
    /**
     * Delete a run from an an annotation queue.
     * @param queueId - The ID of the annotation queue to delete the run from
     * @param queueRunId - The ID of the run to delete from the annotation queue
     */
    async deleteRunFromAnnotationQueue(queueId, queueRunId) {
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}/runs/${assertUuid(queueRunId, "queueRunId")}`, {
        method: "DELETE",
        headers: { ...this.headers, Accept: "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "delete run from annotation queue");
    }
    /**
     * Get the size of an annotation queue.
     * @param queueId - The ID of the annotation queue
     */
    async getSizeFromAnnotationQueue(queueId) {
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}/size`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "get size from annotation queue");
      return await response.json();
    }
    async _currentTenantIsOwner(owner) {
      const settings = await this._getSettings();
      return owner == "-" || settings.tenant_handle === owner;
    }
    async _ownerConflictError(action, owner) {
      const settings = await this._getSettings();
      return new Error(`Cannot ${action} for another tenant.

      Current tenant: ${settings.tenant_handle}

      Requested tenant: ${owner}`);
    }
    async _getLatestCommitHash(promptOwnerAndName) {
      const res = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/commits/${promptOwnerAndName}/?limit=${1}&offset=${0}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      const json = await res.json();
      if (!res.ok) {
        const detail = typeof json.detail === "string" ? json.detail : JSON.stringify(json.detail);
        const error = new Error(`Error ${res.status}: ${res.statusText}
${detail}`);
        error.statusCode = res.status;
        throw error;
      }
      if (json.commits.length === 0) {
        return void 0;
      }
      return json.commits[0].commit_hash;
    }
    async _likeOrUnlikePrompt(promptIdentifier, like) {
      const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/likes/${owner}/${promptName}`, {
        method: "POST",
        body: JSON.stringify({ like }),
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, `${like ? "like" : "unlike"} prompt`);
      return await response.json();
    }
    async _getPromptUrl(promptIdentifier) {
      const [owner, promptName, commitHash] = parsePromptIdentifier(promptIdentifier);
      if (!await this._currentTenantIsOwner(owner)) {
        if (commitHash !== "latest") {
          return `${this.getHostUrl()}/hub/${owner}/${promptName}/${commitHash.substring(0, 8)}`;
        } else {
          return `${this.getHostUrl()}/hub/${owner}/${promptName}`;
        }
      } else {
        const settings = await this._getSettings();
        if (commitHash !== "latest") {
          return `${this.getHostUrl()}/prompts/${promptName}/${commitHash.substring(0, 8)}?organizationId=${settings.id}`;
        } else {
          return `${this.getHostUrl()}/prompts/${promptName}?organizationId=${settings.id}`;
        }
      }
    }
    async promptExists(promptIdentifier) {
      const prompt = await this.getPrompt(promptIdentifier);
      return !!prompt;
    }
    async likePrompt(promptIdentifier) {
      return this._likeOrUnlikePrompt(promptIdentifier, true);
    }
    async unlikePrompt(promptIdentifier) {
      return this._likeOrUnlikePrompt(promptIdentifier, false);
    }
    async *listCommits(promptOwnerAndName) {
      for await (const commits of this._getPaginated(`/commits/${promptOwnerAndName}/`, new URLSearchParams(), (res) => res.commits)) {
        yield* commits;
      }
    }
    async *listPrompts(options) {
      const params = new URLSearchParams();
      params.append("sort_field", (options == null ? void 0 : options.sortField) ?? "updated_at");
      params.append("sort_direction", "desc");
      params.append("is_archived", (!!(options == null ? void 0 : options.isArchived)).toString());
      if ((options == null ? void 0 : options.isPublic) !== void 0) {
        params.append("is_public", options.isPublic.toString());
      }
      if (options == null ? void 0 : options.query) {
        params.append("query", options.query);
      }
      for await (const prompts of this._getPaginated("/repos", params, (res) => res.repos)) {
        yield* prompts;
      }
    }
    async getPrompt(promptIdentifier) {
      const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/repos/${owner}/${promptName}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      if (response.status === 404) {
        return null;
      }
      await raiseForStatus(response, "get prompt");
      const result = await response.json();
      if (result.repo) {
        return result.repo;
      } else {
        return null;
      }
    }
    async createPrompt(promptIdentifier, options) {
      const settings = await this._getSettings();
      if ((options == null ? void 0 : options.isPublic) && !settings.tenant_handle) {
        throw new Error(`Cannot create a public prompt without first

        creating a LangChain Hub handle. 
        You can add a handle by creating a public prompt at:

        https://smith.langchain.com/prompts`);
      }
      const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
      if (!await this._currentTenantIsOwner(owner)) {
        throw await this._ownerConflictError("create a prompt", owner);
      }
      const data = {
        repo_handle: promptName,
        ...(options == null ? void 0 : options.description) && { description: options.description },
        ...(options == null ? void 0 : options.readme) && { readme: options.readme },
        ...(options == null ? void 0 : options.tags) && { tags: options.tags },
        is_public: !!(options == null ? void 0 : options.isPublic)
      };
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/repos/`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        body: JSON.stringify(data),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "create prompt");
      const { repo } = await response.json();
      return repo;
    }
    async createCommit(promptIdentifier, object, options) {
      if (!await this.promptExists(promptIdentifier)) {
        throw new Error("Prompt does not exist, you must create it first.");
      }
      const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
      const resolvedParentCommitHash = (options == null ? void 0 : options.parentCommitHash) === "latest" || !(options == null ? void 0 : options.parentCommitHash) ? await this._getLatestCommitHash(`${owner}/${promptName}`) : options == null ? void 0 : options.parentCommitHash;
      const payload = {
        manifest: JSON.parse(JSON.stringify(object)),
        parent_commit: resolvedParentCommitHash
      };
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/commits/${owner}/${promptName}`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        body: JSON.stringify(payload),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "create commit");
      const result = await response.json();
      return this._getPromptUrl(`${owner}/${promptName}${result.commit_hash ? `:${result.commit_hash}` : ""}`);
    }
    /**
     * Update examples with attachments using multipart form data.
     * @param updates List of ExampleUpdateWithAttachments objects to upsert
     * @returns Promise with the update response
     */
    async updateExamplesMultipart(datasetId, updates = []) {
      if (!await this._getMultiPartSupport()) {
        throw new Error("Your LangSmith version does not allow using the multipart examples endpoint, please update to the latest version.");
      }
      const formData = new FormData();
      for (const example of updates) {
        const exampleId = example.id;
        const exampleBody = {
          ...example.metadata && { metadata: example.metadata },
          ...example.split && { split: example.split }
        };
        const stringifiedExample = stringify$2(exampleBody);
        const exampleBlob = new Blob([stringifiedExample], {
          type: "application/json"
        });
        formData.append(exampleId, exampleBlob);
        if (example.inputs) {
          const stringifiedInputs = stringify$2(example.inputs);
          const inputsBlob = new Blob([stringifiedInputs], {
            type: "application/json"
          });
          formData.append(`${exampleId}.inputs`, inputsBlob);
        }
        if (example.outputs) {
          const stringifiedOutputs = stringify$2(example.outputs);
          const outputsBlob = new Blob([stringifiedOutputs], {
            type: "application/json"
          });
          formData.append(`${exampleId}.outputs`, outputsBlob);
        }
        if (example.attachments) {
          for (const [name, attachment] of Object.entries(example.attachments)) {
            let mimeType;
            let data;
            if (Array.isArray(attachment)) {
              [mimeType, data] = attachment;
            } else {
              mimeType = attachment.mimeType;
              data = attachment.data;
            }
            const attachmentBlob = new Blob([data], {
              type: `${mimeType}; length=${data.byteLength}`
            });
            formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);
          }
        }
        if (example.attachments_operations) {
          const stringifiedAttachmentsOperations = stringify$2(example.attachments_operations);
          const attachmentsOperationsBlob = new Blob([stringifiedAttachmentsOperations], {
            type: "application/json"
          });
          formData.append(`${exampleId}.attachments_operations`, attachmentsOperationsBlob);
        }
      }
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/v1/platform/datasets/${datasetId}/examples`, {
        method: "PATCH",
        headers: this.headers,
        body: formData
      });
      const result = await response.json();
      return result;
    }
    /**
     * Upload examples with attachments using multipart form data.
     * @param uploads List of ExampleUploadWithAttachments objects to upload
     * @returns Promise with the upload response
     */
    async uploadExamplesMultipart(datasetId, uploads = []) {
      if (!await this._getMultiPartSupport()) {
        throw new Error("Your LangSmith version does not allow using the multipart examples endpoint, please update to the latest version.");
      }
      const formData = new FormData();
      for (const example of uploads) {
        const exampleId = (example.id ?? v4()).toString();
        const exampleBody = {
          created_at: example.created_at,
          ...example.metadata && { metadata: example.metadata },
          ...example.split && { split: example.split }
        };
        const stringifiedExample = stringify$2(exampleBody);
        const exampleBlob = new Blob([stringifiedExample], {
          type: "application/json"
        });
        formData.append(exampleId, exampleBlob);
        const stringifiedInputs = stringify$2(example.inputs);
        const inputsBlob = new Blob([stringifiedInputs], {
          type: "application/json"
        });
        formData.append(`${exampleId}.inputs`, inputsBlob);
        if (example.outputs) {
          const stringifiedOutputs = stringify$2(example.outputs);
          const outputsBlob = new Blob([stringifiedOutputs], {
            type: "application/json"
          });
          formData.append(`${exampleId}.outputs`, outputsBlob);
        }
        if (example.attachments) {
          for (const [name, attachment] of Object.entries(example.attachments)) {
            let mimeType;
            let data;
            if (Array.isArray(attachment)) {
              [mimeType, data] = attachment;
            } else {
              mimeType = attachment.mimeType;
              data = attachment.data;
            }
            const attachmentBlob = new Blob([data], {
              type: `${mimeType}; length=${data.byteLength}`
            });
            formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);
          }
        }
      }
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/v1/platform/datasets/${datasetId}/examples`, {
        method: "POST",
        headers: this.headers,
        body: formData
      });
      const result = await response.json();
      return result;
    }
    async updatePrompt(promptIdentifier, options) {
      if (!await this.promptExists(promptIdentifier)) {
        throw new Error("Prompt does not exist, you must create it first.");
      }
      const [owner, promptName] = parsePromptIdentifier(promptIdentifier);
      if (!await this._currentTenantIsOwner(owner)) {
        throw await this._ownerConflictError("update a prompt", owner);
      }
      const payload = {};
      if ((options == null ? void 0 : options.description) !== void 0)
        payload.description = options.description;
      if ((options == null ? void 0 : options.readme) !== void 0)
        payload.readme = options.readme;
      if ((options == null ? void 0 : options.tags) !== void 0)
        payload.tags = options.tags;
      if ((options == null ? void 0 : options.isPublic) !== void 0)
        payload.is_public = options.isPublic;
      if ((options == null ? void 0 : options.isArchived) !== void 0)
        payload.is_archived = options.isArchived;
      if (Object.keys(payload).length === 0) {
        throw new Error("No valid update options provided");
      }
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/repos/${owner}/${promptName}`, {
        method: "PATCH",
        body: JSON.stringify(payload),
        headers: {
          ...this.headers,
          "Content-Type": "application/json"
        },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "update prompt");
      return response.json();
    }
    async deletePrompt(promptIdentifier) {
      if (!await this.promptExists(promptIdentifier)) {
        throw new Error("Prompt does not exist, you must create it first.");
      }
      const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
      if (!await this._currentTenantIsOwner(owner)) {
        throw await this._ownerConflictError("delete a prompt", owner);
      }
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/repos/${owner}/${promptName}`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await response.json();
    }
    async pullPromptCommit(promptIdentifier, options) {
      const [owner, promptName, commitHash] = parsePromptIdentifier(promptIdentifier);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/commits/${owner}/${promptName}/${commitHash}${(options == null ? void 0 : options.includeModel) ? "?include_model=true" : ""}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "pull prompt commit");
      const result = await response.json();
      return {
        owner,
        repo: promptName,
        commit_hash: result.commit_hash,
        manifest: result.manifest,
        examples: result.examples
      };
    }
    /**
     * This method should not be used directly, use `import { pull } from "langchain/hub"` instead.
     * Using this method directly returns the JSON string of the prompt rather than a LangChain object.
     * @private
     */
    async _pullPrompt(promptIdentifier, options) {
      const promptObject = await this.pullPromptCommit(promptIdentifier, {
        includeModel: options == null ? void 0 : options.includeModel
      });
      const prompt = JSON.stringify(promptObject.manifest);
      return prompt;
    }
    async pushPrompt(promptIdentifier, options) {
      if (await this.promptExists(promptIdentifier)) {
        if (options && Object.keys(options).some((key) => key !== "object")) {
          await this.updatePrompt(promptIdentifier, {
            description: options == null ? void 0 : options.description,
            readme: options == null ? void 0 : options.readme,
            tags: options == null ? void 0 : options.tags,
            isPublic: options == null ? void 0 : options.isPublic
          });
        }
      } else {
        await this.createPrompt(promptIdentifier, {
          description: options == null ? void 0 : options.description,
          readme: options == null ? void 0 : options.readme,
          tags: options == null ? void 0 : options.tags,
          isPublic: options == null ? void 0 : options.isPublic
        });
      }
      if (!(options == null ? void 0 : options.object)) {
        return await this._getPromptUrl(promptIdentifier);
      }
      const url = await this.createCommit(promptIdentifier, options == null ? void 0 : options.object, {
        parentCommitHash: options == null ? void 0 : options.parentCommitHash
      });
      return url;
    }
    /**
       * Clone a public dataset to your own langsmith tenant.
       * This operation is idempotent. If you already have a dataset with the given name,
       * this function will do nothing.
    
       * @param {string} tokenOrUrl The token of the public dataset to clone.
       * @param {Object} [options] Additional options for cloning the dataset.
       * @param {string} [options.sourceApiUrl] The URL of the langsmith server where the data is hosted. Defaults to the API URL of your current client.
       * @param {string} [options.datasetName] The name of the dataset to create in your tenant. Defaults to the name of the public dataset.
       * @returns {Promise<void>}
       */
    async clonePublicDataset(tokenOrUrl, options = {}) {
      const { sourceApiUrl = this.apiUrl, datasetName } = options;
      const [parsedApiUrl, tokenUuid] = this.parseTokenOrUrl(tokenOrUrl, sourceApiUrl);
      const sourceClient = new Client({
        apiUrl: parsedApiUrl,
        // Placeholder API key not needed anymore in most cases, but
        // some private deployments may have API key-based rate limiting
        // that would cause this to fail if we provide no value.
        apiKey: "placeholder"
      });
      const ds = await sourceClient.readSharedDataset(tokenUuid);
      const finalDatasetName = datasetName || ds.name;
      try {
        if (await this.hasDataset({ datasetId: finalDatasetName })) {
          console.log(`Dataset ${finalDatasetName} already exists in your tenant. Skipping.`);
          return;
        }
      } catch (_) {
      }
      const examples = await sourceClient.listSharedExamples(tokenUuid);
      const dataset = await this.createDataset(finalDatasetName, {
        description: ds.description,
        dataType: ds.data_type || "kv",
        inputsSchema: ds.inputs_schema_definition ?? void 0,
        outputsSchema: ds.outputs_schema_definition ?? void 0
      });
      try {
        await this.createExamples({
          inputs: examples.map((e) => e.inputs),
          outputs: examples.flatMap((e) => e.outputs ? [e.outputs] : []),
          datasetId: dataset.id
        });
      } catch (e) {
        console.error(`An error occurred while creating dataset ${finalDatasetName}. You should delete it manually.`);
        throw e;
      }
    }
    parseTokenOrUrl(urlOrToken, apiUrl, numParts = 2, kind2 = "dataset") {
      try {
        assertUuid(urlOrToken);
        return [apiUrl, urlOrToken];
      } catch (_) {
      }
      try {
        const parsedUrl = new URL(urlOrToken);
        const pathParts = parsedUrl.pathname.split("/").filter((part) => part !== "");
        if (pathParts.length >= numParts) {
          const tokenUuid = pathParts[pathParts.length - numParts];
          return [apiUrl, tokenUuid];
        } else {
          throw new Error(`Invalid public ${kind2} URL: ${urlOrToken}`);
        }
      } catch (error) {
        throw new Error(`Invalid public ${kind2} URL or token: ${urlOrToken}`);
      }
    }
    /**
     * Awaits all pending trace batches. Useful for environments where
     * you need to be sure that all tracing requests finish before execution ends,
     * such as serverless environments.
     *
     * @example
     * ```
     * import { Client } from "langsmith";
     *
     * const client = new Client();
     *
     * try {
     *   // Tracing happens here
     *   ...
     * } finally {
     *   await client.awaitPendingTraceBatches();
     * }
     * ```
     *
     * @returns A promise that resolves once all currently pending traces have sent.
     */
    awaitPendingTraceBatches() {
      if (this.manualFlushMode) {
        console.warn("[WARNING]: When tracing in manual flush mode, you must call `await client.flush()` manually to submit trace batches.");
        return Promise.resolve();
      }
      return Promise.all([
        ...this.autoBatchQueue.items.map(({ itemPromise }) => itemPromise),
        this.batchIngestCaller.queue.onIdle()
      ]);
    }
  }
  const __version__ = "0.3.4";
  let globalEnv;
  const isBrowser$1 = () => typeof window !== "undefined" && typeof window.document !== "undefined";
  const isWebWorker$1 = () => typeof globalThis === "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope";
  const isJsDom$1 = () => typeof window !== "undefined" && window.name === "nodejs" || typeof navigator !== "undefined" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom"));
  const isDeno$1 = () => typeof Deno !== "undefined";
  const isNode$1 = () => typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined" && !isDeno$1();
  const getEnv$1 = () => {
    if (globalEnv) {
      return globalEnv;
    }
    if (isBrowser$1()) {
      globalEnv = "browser";
    } else if (isNode$1()) {
      globalEnv = "node";
    } else if (isWebWorker$1()) {
      globalEnv = "webworker";
    } else if (isJsDom$1()) {
      globalEnv = "jsdom";
    } else if (isDeno$1()) {
      globalEnv = "deno";
    } else {
      globalEnv = "other";
    }
    return globalEnv;
  };
  let runtimeEnvironment$1;
  function getRuntimeEnvironment$1() {
    if (runtimeEnvironment$1 === void 0) {
      const env = getEnv$1();
      const releaseEnv = getShas();
      runtimeEnvironment$1 = {
        library: "langsmith",
        runtime: env,
        sdk: "langsmith-js",
        sdk_version: __version__,
        ...releaseEnv
      };
    }
    return runtimeEnvironment$1;
  }
  function getLangChainEnvVarsMetadata() {
    const allEnvVars = getEnvironmentVariables() || {};
    const envVars = {};
    const excluded = [
      "LANGCHAIN_API_KEY",
      "LANGCHAIN_ENDPOINT",
      "LANGCHAIN_TRACING_V2",
      "LANGCHAIN_PROJECT",
      "LANGCHAIN_SESSION",
      "LANGSMITH_API_KEY",
      "LANGSMITH_ENDPOINT",
      "LANGSMITH_TRACING_V2",
      "LANGSMITH_PROJECT",
      "LANGSMITH_SESSION"
    ];
    for (const [key, value] of Object.entries(allEnvVars)) {
      if ((key.startsWith("LANGCHAIN_") || key.startsWith("LANGSMITH_")) && typeof value === "string" && !excluded.includes(key) && !key.toLowerCase().includes("key") && !key.toLowerCase().includes("secret") && !key.toLowerCase().includes("token")) {
        if (key === "LANGCHAIN_REVISION_ID") {
          envVars["revision_id"] = value;
        } else {
          envVars[key] = value;
        }
      }
    }
    return envVars;
  }
  function getEnvironmentVariables() {
    try {
      if (typeof process !== "undefined" && process.env) {
        return Object.entries(process.env).reduce((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {});
      }
      return void 0;
    } catch (e) {
      return void 0;
    }
  }
  function getEnvironmentVariable$1(name) {
    var _a3;
    try {
      return typeof process !== "undefined" ? (
        // eslint-disable-next-line no-process-env
        (_a3 = process.env) == null ? void 0 : _a3[name]
      ) : void 0;
    } catch (e) {
      return void 0;
    }
  }
  function getLangSmithEnvironmentVariable(name) {
    return getEnvironmentVariable$1(`LANGSMITH_${name}`) || getEnvironmentVariable$1(`LANGCHAIN_${name}`);
  }
  let cachedCommitSHAs;
  function getShas() {
    if (cachedCommitSHAs !== void 0) {
      return cachedCommitSHAs;
    }
    const common_release_envs = [
      "VERCEL_GIT_COMMIT_SHA",
      "NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA",
      "COMMIT_REF",
      "RENDER_GIT_COMMIT",
      "CI_COMMIT_SHA",
      "CIRCLE_SHA1",
      "CF_PAGES_COMMIT_SHA",
      "REACT_APP_GIT_SHA",
      "SOURCE_VERSION",
      "GITHUB_SHA",
      "TRAVIS_COMMIT",
      "GIT_COMMIT",
      "BUILD_VCS_NUMBER",
      "bamboo_planRepository_revision",
      "Build.SourceVersion",
      "BITBUCKET_COMMIT",
      "DRONE_COMMIT_SHA",
      "SEMAPHORE_GIT_SHA",
      "BUILDKITE_COMMIT"
    ];
    const shas = {};
    for (const env of common_release_envs) {
      const envVar = getEnvironmentVariable$1(env);
      if (envVar !== void 0) {
        shas[env] = envVar;
      }
    }
    cachedCommitSHAs = shas;
    return shas;
  }
  const isTracingEnabled$1 = (tracingEnabled) => {
    const envVars = ["TRACING_V2", "TRACING"];
    return !!envVars.find((envVar) => getLangSmithEnvironmentVariable(envVar) === "true");
  };
  const _LC_CONTEXT_VARIABLES_KEY = Symbol.for("lc:context_variables");
  function stripNonAlphanumeric$1(input) {
    return input.replace(/[-:.]/g, "");
  }
  function convertToDottedOrderFormat$1(epoch, runId, executionOrder = 1) {
    const paddedOrder = executionOrder.toFixed(0).slice(0, 3).padStart(3, "0");
    return stripNonAlphanumeric$1(`${new Date(epoch).toISOString().slice(0, -1)}${paddedOrder}Z`) + runId;
  }
  class Baggage {
    constructor(metadata, tags) {
      Object.defineProperty(this, "metadata", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "tags", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.metadata = metadata;
      this.tags = tags;
    }
    static fromHeader(value) {
      const items = value.split(",");
      let metadata = {};
      let tags = [];
      for (const item of items) {
        const [key, uriValue] = item.split("=");
        const value2 = decodeURIComponent(uriValue);
        if (key === "langsmith-metadata") {
          metadata = JSON.parse(value2);
        } else if (key === "langsmith-tags") {
          tags = value2.split(",");
        }
      }
      return new Baggage(metadata, tags);
    }
    toHeader() {
      const items = [];
      if (this.metadata && Object.keys(this.metadata).length > 0) {
        items.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`);
      }
      if (this.tags && this.tags.length > 0) {
        items.push(`langsmith-tags=${encodeURIComponent(this.tags.join(","))}`);
      }
      return items.join(",");
    }
  }
  class RunTree {
    constructor(originalConfig) {
      var _a3;
      Object.defineProperty(this, "id", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "run_type", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "project_name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "parent_run", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "child_runs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "start_time", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "end_time", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "extra", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "tags", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "error", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "serialized", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "inputs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "outputs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "reference_example_id", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "client", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "events", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "trace_id", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "dotted_order", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "tracingEnabled", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "execution_order", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "child_execution_order", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "attachments", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      if (isRunTree(originalConfig)) {
        Object.assign(this, { ...originalConfig });
        return;
      }
      const defaultConfig = RunTree.getDefaultConfig();
      const { metadata, ...config2 } = originalConfig;
      const client2 = config2.client ?? RunTree.getSharedClient();
      const dedupedMetadata = {
        ...metadata,
        ...(_a3 = config2 == null ? void 0 : config2.extra) == null ? void 0 : _a3.metadata
      };
      config2.extra = { ...config2.extra, metadata: dedupedMetadata };
      Object.assign(this, { ...defaultConfig, ...config2, client: client2 });
      if (!this.trace_id) {
        if (this.parent_run) {
          this.trace_id = this.parent_run.trace_id ?? this.id;
        } else {
          this.trace_id = this.id;
        }
      }
      this.execution_order ?? (this.execution_order = 1);
      this.child_execution_order ?? (this.child_execution_order = 1);
      if (!this.dotted_order) {
        const currentDottedOrder = convertToDottedOrderFormat$1(this.start_time, this.id, this.execution_order);
        if (this.parent_run) {
          this.dotted_order = this.parent_run.dotted_order + "." + currentDottedOrder;
        } else {
          this.dotted_order = currentDottedOrder;
        }
      }
    }
    static getDefaultConfig() {
      return {
        id: v4(),
        run_type: "chain",
        project_name: getLangSmithEnvironmentVariable("PROJECT") ?? getEnvironmentVariable$1("LANGCHAIN_SESSION") ?? // TODO: Deprecate
        "default",
        child_runs: [],
        api_url: getEnvironmentVariable$1("LANGCHAIN_ENDPOINT") ?? "http://localhost:1984",
        api_key: getEnvironmentVariable$1("LANGCHAIN_API_KEY"),
        caller_options: {},
        start_time: Date.now(),
        serialized: {},
        inputs: {},
        extra: {}
      };
    }
    static getSharedClient() {
      if (!RunTree.sharedClient) {
        RunTree.sharedClient = new Client();
      }
      return RunTree.sharedClient;
    }
    createChild(config2) {
      var _a3, _b2, _c2, _d2, _e2, _f2;
      const child_execution_order = this.child_execution_order + 1;
      const child = new RunTree({
        ...config2,
        parent_run: this,
        project_name: this.project_name,
        client: this.client,
        tracingEnabled: this.tracingEnabled,
        execution_order: child_execution_order,
        child_execution_order
      });
      if (_LC_CONTEXT_VARIABLES_KEY in this) {
        child[_LC_CONTEXT_VARIABLES_KEY] = this[_LC_CONTEXT_VARIABLES_KEY];
      }
      const LC_CHILD = Symbol.for("lc:child_config");
      const presentConfig = ((_a3 = config2.extra) == null ? void 0 : _a3[LC_CHILD]) ?? this.extra[LC_CHILD];
      if (isRunnableConfigLike(presentConfig)) {
        const newConfig = { ...presentConfig };
        const callbacks = isCallbackManagerLike(newConfig.callbacks) ? (_c2 = (_b2 = newConfig.callbacks).copy) == null ? void 0 : _c2.call(_b2) : void 0;
        if (callbacks) {
          Object.assign(callbacks, { _parentRunId: child.id });
          (_f2 = (_e2 = (_d2 = callbacks.handlers) == null ? void 0 : _d2.find(isLangChainTracerLike)) == null ? void 0 : _e2.updateFromRunTree) == null ? void 0 : _f2.call(_e2, child);
          newConfig.callbacks = callbacks;
        }
        child.extra[LC_CHILD] = newConfig;
      }
      const visited = /* @__PURE__ */ new Set();
      let current = this;
      while (current != null && !visited.has(current.id)) {
        visited.add(current.id);
        current.child_execution_order = Math.max(current.child_execution_order, child_execution_order);
        current = current.parent_run;
      }
      this.child_runs.push(child);
      return child;
    }
    async end(outputs, error, endTime = Date.now(), metadata) {
      this.outputs = this.outputs ?? outputs;
      this.error = this.error ?? error;
      this.end_time = this.end_time ?? endTime;
      if (metadata && Object.keys(metadata).length > 0) {
        this.extra = this.extra ? { ...this.extra, metadata: { ...this.extra.metadata, ...metadata } } : { metadata };
      }
    }
    _convertToCreate(run, runtimeEnv, excludeChildRuns = true) {
      var _a3;
      const runExtra = run.extra ?? {};
      if (!runExtra.runtime) {
        runExtra.runtime = {};
      }
      if (runtimeEnv) {
        for (const [k, v] of Object.entries(runtimeEnv)) {
          if (!runExtra.runtime[k]) {
            runExtra.runtime[k] = v;
          }
        }
      }
      let child_runs;
      let parent_run_id;
      if (!excludeChildRuns) {
        child_runs = run.child_runs.map((child_run) => this._convertToCreate(child_run, runtimeEnv, excludeChildRuns));
        parent_run_id = void 0;
      } else {
        parent_run_id = (_a3 = run.parent_run) == null ? void 0 : _a3.id;
        child_runs = [];
      }
      const persistedRun = {
        id: run.id,
        name: run.name,
        start_time: run.start_time,
        end_time: run.end_time,
        run_type: run.run_type,
        reference_example_id: run.reference_example_id,
        extra: runExtra,
        serialized: run.serialized,
        error: run.error,
        inputs: run.inputs,
        outputs: run.outputs,
        session_name: run.project_name,
        child_runs,
        parent_run_id,
        trace_id: run.trace_id,
        dotted_order: run.dotted_order,
        tags: run.tags,
        attachments: run.attachments
      };
      return persistedRun;
    }
    async postRun(excludeChildRuns = true) {
      try {
        const runtimeEnv = getRuntimeEnvironment$1();
        const runCreate = await this._convertToCreate(this, runtimeEnv, true);
        await this.client.createRun(runCreate);
        if (!excludeChildRuns) {
          warnOnce("Posting with excludeChildRuns=false is deprecated and will be removed in a future version.");
          for (const childRun of this.child_runs) {
            await childRun.postRun(false);
          }
        }
      } catch (error) {
        console.error(`Error in postRun for run ${this.id}:`, error);
      }
    }
    async patchRun() {
      var _a3;
      try {
        const runUpdate = {
          end_time: this.end_time,
          error: this.error,
          inputs: this.inputs,
          outputs: this.outputs,
          parent_run_id: (_a3 = this.parent_run) == null ? void 0 : _a3.id,
          reference_example_id: this.reference_example_id,
          extra: this.extra,
          events: this.events,
          dotted_order: this.dotted_order,
          trace_id: this.trace_id,
          tags: this.tags,
          attachments: this.attachments
        };
        await this.client.updateRun(this.id, runUpdate);
      } catch (error) {
        console.error(`Error in patchRun for run ${this.id}`, error);
      }
    }
    toJSON() {
      return this._convertToCreate(this, void 0, false);
    }
    static fromRunnableConfig(parentConfig, props) {
      var _a3, _b2, _c2, _d2;
      const callbackManager = parentConfig == null ? void 0 : parentConfig.callbacks;
      let parentRun;
      let projectName;
      let client2;
      let tracingEnabled = isTracingEnabled$1();
      if (callbackManager) {
        const parentRunId = ((_a3 = callbackManager == null ? void 0 : callbackManager.getParentRunId) == null ? void 0 : _a3.call(callbackManager)) ?? "";
        const langChainTracer = (_b2 = callbackManager == null ? void 0 : callbackManager.handlers) == null ? void 0 : _b2.find((handler) => (handler == null ? void 0 : handler.name) == "langchain_tracer");
        parentRun = (_c2 = langChainTracer == null ? void 0 : langChainTracer.getRun) == null ? void 0 : _c2.call(langChainTracer, parentRunId);
        projectName = langChainTracer == null ? void 0 : langChainTracer.projectName;
        client2 = langChainTracer == null ? void 0 : langChainTracer.client;
        tracingEnabled = tracingEnabled || !!langChainTracer;
      }
      if (!parentRun) {
        return new RunTree({
          ...props,
          client: client2,
          tracingEnabled,
          project_name: projectName
        });
      }
      const parentRunTree = new RunTree({
        name: parentRun.name,
        id: parentRun.id,
        trace_id: parentRun.trace_id,
        dotted_order: parentRun.dotted_order,
        client: client2,
        tracingEnabled,
        project_name: projectName,
        tags: [
          ...new Set(((parentRun == null ? void 0 : parentRun.tags) ?? []).concat((parentConfig == null ? void 0 : parentConfig.tags) ?? []))
        ],
        extra: {
          metadata: {
            ...(_d2 = parentRun == null ? void 0 : parentRun.extra) == null ? void 0 : _d2.metadata,
            ...parentConfig == null ? void 0 : parentConfig.metadata
          }
        }
      });
      return parentRunTree.createChild(props);
    }
    static fromDottedOrder(dottedOrder) {
      return this.fromHeaders({ "langsmith-trace": dottedOrder });
    }
    static fromHeaders(headers, inheritArgs) {
      var _a3;
      const rawHeaders = "get" in headers && typeof headers.get === "function" ? {
        "langsmith-trace": headers.get("langsmith-trace"),
        baggage: headers.get("baggage")
      } : headers;
      const headerTrace = rawHeaders["langsmith-trace"];
      if (!headerTrace || typeof headerTrace !== "string")
        return void 0;
      const parentDottedOrder = headerTrace.trim();
      const parsedDottedOrder = parentDottedOrder.split(".").map((part) => {
        const [strTime, uuid2] = part.split("Z");
        return { strTime, time: Date.parse(strTime + "Z"), uuid: uuid2 };
      });
      const traceId = parsedDottedOrder[0].uuid;
      const config2 = {
        ...inheritArgs,
        name: (inheritArgs == null ? void 0 : inheritArgs["name"]) ?? "parent",
        run_type: (inheritArgs == null ? void 0 : inheritArgs["run_type"]) ?? "chain",
        start_time: (inheritArgs == null ? void 0 : inheritArgs["start_time"]) ?? Date.now(),
        id: (_a3 = parsedDottedOrder.at(-1)) == null ? void 0 : _a3.uuid,
        trace_id: traceId,
        dotted_order: parentDottedOrder
      };
      if (rawHeaders["baggage"] && typeof rawHeaders["baggage"] === "string") {
        const baggage = Baggage.fromHeader(rawHeaders["baggage"]);
        config2.metadata = baggage.metadata;
        config2.tags = baggage.tags;
      }
      return new RunTree(config2);
    }
    toHeaders(headers) {
      var _a3;
      const result = {
        "langsmith-trace": this.dotted_order,
        baggage: new Baggage((_a3 = this.extra) == null ? void 0 : _a3.metadata, this.tags).toHeader()
      };
      if (headers) {
        for (const [key, value] of Object.entries(result)) {
          headers.set(key, value);
        }
      }
      return result;
    }
  }
  Object.defineProperty(RunTree, "sharedClient", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: null
  });
  function isRunTree(x) {
    return x !== void 0 && typeof x.createChild === "function" && typeof x.postRun === "function";
  }
  function isLangChainTracerLike(x) {
    return typeof x === "object" && x != null && typeof x.name === "string" && x.name === "langchain_tracer";
  }
  function containsLangChainTracerLike(x) {
    return Array.isArray(x) && x.some((callback) => isLangChainTracerLike(callback));
  }
  function isCallbackManagerLike(x) {
    return typeof x === "object" && x != null && Array.isArray(x.handlers);
  }
  function isRunnableConfigLike(x) {
    var _a3;
    return x !== void 0 && typeof x.callbacks === "object" && // Callback manager with a langchain tracer
    (containsLangChainTracerLike((_a3 = x.callbacks) == null ? void 0 : _a3.handlers) || // Or it's an array with a LangChainTracerLike object within it
    containsLangChainTracerLike(x.callbacks));
  }
  let MockAsyncLocalStorage$1 = class MockAsyncLocalStorage {
    getStore() {
      return void 0;
    }
    run(_, callback) {
      return callback();
    }
  };
  const TRACING_ALS_KEY$1 = Symbol.for("ls:tracing_async_local_storage");
  const mockAsyncLocalStorage$1 = new MockAsyncLocalStorage$1();
  let AsyncLocalStorageProvider$1 = class AsyncLocalStorageProvider {
    getInstance() {
      return globalThis[TRACING_ALS_KEY$1] ?? mockAsyncLocalStorage$1;
    }
    initializeGlobalInstance(instance) {
      if (globalThis[TRACING_ALS_KEY$1] === void 0) {
        globalThis[TRACING_ALS_KEY$1] = instance;
      }
    }
  };
  const AsyncLocalStorageProviderSingleton$1 = new AsyncLocalStorageProvider$1();
  const getCurrentRunTree = () => {
    const runTree = AsyncLocalStorageProviderSingleton$1.getInstance().getStore();
    if (!isRunTree(runTree)) {
      throw new Error([
        "Could not get the current run tree.",
        "",
        "Please make sure you are calling this method within a traceable function and that tracing is enabled."
      ].join("\n"));
    }
    return runTree;
  };
  function isTraceableFunction(x) {
    return typeof x === "function" && "langsmith:traceable" in x;
  }
  /*!
   * https://github.com/Starcounter-Jack/JSON-Patch
   * (c) 2017-2022 Joachim Wester
   * MIT licensed
   */
  const _hasOwnProperty = Object.prototype.hasOwnProperty;
  function hasOwnProperty(obj, key) {
    return _hasOwnProperty.call(obj, key);
  }
  function _objectKeys(obj) {
    if (Array.isArray(obj)) {
      const keys2 = new Array(obj.length);
      for (let k = 0; k < keys2.length; k++) {
        keys2[k] = "" + k;
      }
      return keys2;
    }
    if (Object.keys) {
      return Object.keys(obj);
    }
    let keys = [];
    for (let i2 in obj) {
      if (hasOwnProperty(obj, i2)) {
        keys.push(i2);
      }
    }
    return keys;
  }
  function _deepClone(obj) {
    switch (typeof obj) {
      case "object":
        return JSON.parse(JSON.stringify(obj));
      //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5
      case "undefined":
        return null;
      //this is how JSON.stringify behaves for array items
      default:
        return obj;
    }
  }
  function isInteger(str2) {
    let i2 = 0;
    const len = str2.length;
    let charCode;
    while (i2 < len) {
      charCode = str2.charCodeAt(i2);
      if (charCode >= 48 && charCode <= 57) {
        i2++;
        continue;
      }
      return false;
    }
    return true;
  }
  function escapePathComponent(path) {
    if (path.indexOf("/") === -1 && path.indexOf("~") === -1)
      return path;
    return path.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  function unescapePathComponent(path) {
    return path.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  function hasUndefined(obj) {
    if (obj === void 0) {
      return true;
    }
    if (obj) {
      if (Array.isArray(obj)) {
        for (let i3 = 0, len = obj.length; i3 < len; i3++) {
          if (hasUndefined(obj[i3])) {
            return true;
          }
        }
      } else if (typeof obj === "object") {
        const objKeys = _objectKeys(obj);
        const objKeysLength = objKeys.length;
        for (var i2 = 0; i2 < objKeysLength; i2++) {
          if (hasUndefined(obj[objKeys[i2]])) {
            return true;
          }
        }
      }
    }
    return false;
  }
  function patchErrorMessageFormatter(message, args) {
    const messageParts = [message];
    for (const key in args) {
      const value = typeof args[key] === "object" ? JSON.stringify(args[key], null, 2) : args[key];
      if (typeof value !== "undefined") {
        messageParts.push(`${key}: ${value}`);
      }
    }
    return messageParts.join("\n");
  }
  class PatchError extends Error {
    constructor(message, name, index, operation, tree) {
      super(patchErrorMessageFormatter(message, { name, index, operation, tree }));
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: name
      });
      Object.defineProperty(this, "index", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: index
      });
      Object.defineProperty(this, "operation", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: operation
      });
      Object.defineProperty(this, "tree", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: tree
      });
      Object.setPrototypeOf(this, new.target.prototype);
      this.message = patchErrorMessageFormatter(message, {
        name,
        index,
        operation,
        tree
      });
    }
  }
  const JsonPatchError = PatchError;
  const objOps = {
    add: function(obj, key, document2) {
      obj[key] = this.value;
      return { newDocument: document2 };
    },
    remove: function(obj, key, document2) {
      var removed = obj[key];
      delete obj[key];
      return { newDocument: document2, removed };
    },
    replace: function(obj, key, document2) {
      var removed = obj[key];
      obj[key] = this.value;
      return { newDocument: document2, removed };
    },
    move: function(obj, key, document2) {
      let removed = getValueByPointer(document2, this.path);
      if (removed) {
        removed = _deepClone(removed);
      }
      const originalValue = applyOperation(document2, {
        op: "remove",
        path: this.from
      }).removed;
      applyOperation(document2, {
        op: "add",
        path: this.path,
        value: originalValue
      });
      return { newDocument: document2, removed };
    },
    copy: function(obj, key, document2) {
      const valueToCopy = getValueByPointer(document2, this.from);
      applyOperation(document2, {
        op: "add",
        path: this.path,
        value: _deepClone(valueToCopy)
      });
      return { newDocument: document2 };
    },
    test: function(obj, key, document2) {
      return { newDocument: document2, test: _areEquals(obj[key], this.value) };
    },
    _get: function(obj, key, document2) {
      this.value = obj[key];
      return { newDocument: document2 };
    }
  };
  var arrOps = {
    add: function(arr2, i2, document2) {
      if (isInteger(i2)) {
        arr2.splice(i2, 0, this.value);
      } else {
        arr2[i2] = this.value;
      }
      return { newDocument: document2, index: i2 };
    },
    remove: function(arr2, i2, document2) {
      var removedList = arr2.splice(i2, 1);
      return { newDocument: document2, removed: removedList[0] };
    },
    replace: function(arr2, i2, document2) {
      var removed = arr2[i2];
      arr2[i2] = this.value;
      return { newDocument: document2, removed };
    },
    move: objOps.move,
    copy: objOps.copy,
    test: objOps.test,
    _get: objOps._get
  };
  function getValueByPointer(document2, pointer) {
    if (pointer == "") {
      return document2;
    }
    var getOriginalDestination = { op: "_get", path: pointer };
    applyOperation(document2, getOriginalDestination);
    return getOriginalDestination.value;
  }
  function applyOperation(document2, operation, validateOperation = false, mutateDocument = true, banPrototypeModifications = true, index = 0) {
    if (validateOperation) {
      if (typeof validateOperation == "function") {
        validateOperation(operation, 0, document2, operation.path);
      } else {
        validator(operation, 0);
      }
    }
    if (operation.path === "") {
      let returnValue = { newDocument: document2 };
      if (operation.op === "add") {
        returnValue.newDocument = operation.value;
        return returnValue;
      } else if (operation.op === "replace") {
        returnValue.newDocument = operation.value;
        returnValue.removed = document2;
        return returnValue;
      } else if (operation.op === "move" || operation.op === "copy") {
        returnValue.newDocument = getValueByPointer(document2, operation.from);
        if (operation.op === "move") {
          returnValue.removed = document2;
        }
        return returnValue;
      } else if (operation.op === "test") {
        returnValue.test = _areEquals(document2, operation.value);
        if (returnValue.test === false) {
          throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
        }
        returnValue.newDocument = document2;
        return returnValue;
      } else if (operation.op === "remove") {
        returnValue.removed = document2;
        returnValue.newDocument = null;
        return returnValue;
      } else if (operation.op === "_get") {
        operation.value = document2;
        return returnValue;
      } else {
        if (validateOperation) {
          throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document2);
        } else {
          return returnValue;
        }
      }
    } else {
      if (!mutateDocument) {
        document2 = _deepClone(document2);
      }
      const path = operation.path || "";
      const keys = path.split("/");
      let obj = document2;
      let t = 1;
      let len = keys.length;
      let existingPathFragment = void 0;
      let key;
      let validateFunction;
      if (typeof validateOperation == "function") {
        validateFunction = validateOperation;
      } else {
        validateFunction = validator;
      }
      while (true) {
        key = keys[t];
        if (key && key.indexOf("~") != -1) {
          key = unescapePathComponent(key);
        }
        if (banPrototypeModifications && (key == "__proto__" || key == "prototype" && t > 0 && keys[t - 1] == "constructor")) {
          throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
        }
        if (validateOperation) {
          if (existingPathFragment === void 0) {
            if (obj[key] === void 0) {
              existingPathFragment = keys.slice(0, t).join("/");
            } else if (t == len - 1) {
              existingPathFragment = operation.path;
            }
            if (existingPathFragment !== void 0) {
              validateFunction(operation, 0, document2, existingPathFragment);
            }
          }
        }
        t++;
        if (Array.isArray(obj)) {
          if (key === "-") {
            key = obj.length;
          } else {
            if (validateOperation && !isInteger(key)) {
              throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index, operation, document2);
            } else if (isInteger(key)) {
              key = ~~key;
            }
          }
          if (t >= len) {
            if (validateOperation && operation.op === "add" && key > obj.length) {
              throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index, operation, document2);
            }
            const returnValue = arrOps[operation.op].call(operation, obj, key, document2);
            if (returnValue.test === false) {
              throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
            }
            return returnValue;
          }
        } else {
          if (t >= len) {
            const returnValue = objOps[operation.op].call(operation, obj, key, document2);
            if (returnValue.test === false) {
              throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
            }
            return returnValue;
          }
        }
        obj = obj[key];
        if (validateOperation && t < len && (!obj || typeof obj !== "object")) {
          throw new JsonPatchError("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", index, operation, document2);
        }
      }
    }
  }
  function applyPatch(document2, patch, validateOperation, mutateDocument = true, banPrototypeModifications = true) {
    if (validateOperation) {
      if (!Array.isArray(patch)) {
        throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
      }
    }
    if (!mutateDocument) {
      document2 = _deepClone(document2);
    }
    const results = new Array(patch.length);
    for (let i2 = 0, length = patch.length; i2 < length; i2++) {
      results[i2] = applyOperation(document2, patch[i2], validateOperation, true, banPrototypeModifications, i2);
      document2 = results[i2].newDocument;
    }
    results.newDocument = document2;
    return results;
  }
  function validator(operation, index, document2, existingPathFragment) {
    if (typeof operation !== "object" || operation === null || Array.isArray(operation)) {
      throw new JsonPatchError("Operation is not an object", "OPERATION_NOT_AN_OBJECT", index, operation, document2);
    } else if (!objOps[operation.op]) {
      throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document2);
    } else if (typeof operation.path !== "string") {
      throw new JsonPatchError("Operation `path` property is not a string", "OPERATION_PATH_INVALID", index, operation, document2);
    } else if (operation.path.indexOf("/") !== 0 && operation.path.length > 0) {
      throw new JsonPatchError('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", index, operation, document2);
    } else if ((operation.op === "move" || operation.op === "copy") && typeof operation.from !== "string") {
      throw new JsonPatchError("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", index, operation, document2);
    } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && operation.value === void 0) {
      throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", index, operation, document2);
    } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && hasUndefined(operation.value)) {
      throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", index, operation, document2);
    } else if (document2) {
      if (operation.op == "add") {
        var pathLen = operation.path.split("/").length;
        var existingPathLen = existingPathFragment.split("/").length;
        if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
          throw new JsonPatchError("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", index, operation, document2);
        }
      } else if (operation.op === "replace" || operation.op === "remove" || operation.op === "_get") {
        if (operation.path !== existingPathFragment) {
          throw new JsonPatchError("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", index, operation, document2);
        }
      } else if (operation.op === "move" || operation.op === "copy") {
        var existingValue = {
          op: "_get",
          path: operation.from,
          value: void 0
        };
        var error = validate([existingValue], document2);
        if (error && error.name === "OPERATION_PATH_UNRESOLVABLE") {
          throw new JsonPatchError("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", index, operation, document2);
        }
      }
    }
  }
  function validate(sequence, document2, externalValidator) {
    try {
      if (!Array.isArray(sequence)) {
        throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
      }
      if (document2) {
        applyPatch(_deepClone(document2), _deepClone(sequence), externalValidator || true);
      } else {
        externalValidator = externalValidator || validator;
        for (var i2 = 0; i2 < sequence.length; i2++) {
          externalValidator(sequence[i2], i2, document2, void 0);
        }
      }
    } catch (e) {
      if (e instanceof JsonPatchError) {
        return e;
      } else {
        throw e;
      }
    }
  }
  function _areEquals(a, b) {
    if (a === b)
      return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      var arrA = Array.isArray(a), arrB = Array.isArray(b), i2, length, key;
      if (arrA && arrB) {
        length = a.length;
        if (length != b.length)
          return false;
        for (i2 = length; i2-- !== 0; )
          if (!_areEquals(a[i2], b[i2]))
            return false;
        return true;
      }
      if (arrA != arrB)
        return false;
      var keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length)
        return false;
      for (i2 = length; i2-- !== 0; )
        if (!b.hasOwnProperty(keys[i2]))
          return false;
      for (i2 = length; i2-- !== 0; ) {
        key = keys[i2];
        if (!_areEquals(a[key], b[key]))
          return false;
      }
      return true;
    }
    return a !== a && b !== b;
  }
  /*!
   * https://github.com/Starcounter-Jack/JSON-Patch
   * (c) 2013-2021 Joachim Wester
   * MIT license
   */
  function _generate(mirror, obj, patches, path, invertible) {
    if (obj === mirror) {
      return;
    }
    if (typeof obj.toJSON === "function") {
      obj = obj.toJSON();
    }
    var newKeys = _objectKeys(obj);
    var oldKeys = _objectKeys(mirror);
    var deleted = false;
    for (var t = oldKeys.length - 1; t >= 0; t--) {
      var key = oldKeys[t];
      var oldVal = mirror[key];
      if (hasOwnProperty(obj, key) && !(obj[key] === void 0 && oldVal !== void 0 && Array.isArray(obj) === false)) {
        var newVal = obj[key];
        if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null && Array.isArray(oldVal) === Array.isArray(newVal)) {
          _generate(oldVal, newVal, patches, path + "/" + escapePathComponent(key), invertible);
        } else {
          if (oldVal !== newVal) {
            if (invertible) {
              patches.push({
                op: "test",
                path: path + "/" + escapePathComponent(key),
                value: _deepClone(oldVal)
              });
            }
            patches.push({
              op: "replace",
              path: path + "/" + escapePathComponent(key),
              value: _deepClone(newVal)
            });
          }
        }
      } else if (Array.isArray(mirror) === Array.isArray(obj)) {
        if (invertible) {
          patches.push({
            op: "test",
            path: path + "/" + escapePathComponent(key),
            value: _deepClone(oldVal)
          });
        }
        patches.push({
          op: "remove",
          path: path + "/" + escapePathComponent(key)
        });
        deleted = true;
      } else {
        if (invertible) {
          patches.push({ op: "test", path, value: mirror });
        }
        patches.push({ op: "replace", path, value: obj });
      }
    }
    if (!deleted && newKeys.length == oldKeys.length) {
      return;
    }
    for (var t = 0; t < newKeys.length; t++) {
      var key = newKeys[t];
      if (!hasOwnProperty(mirror, key) && obj[key] !== void 0) {
        patches.push({
          op: "add",
          path: path + "/" + escapePathComponent(key),
          value: _deepClone(obj[key])
        });
      }
    }
  }
  function compare(tree1, tree2, invertible = false) {
    var patches = [];
    _generate(tree1, tree2, patches, "", invertible);
    return patches;
  }
  const isBrowser = () => typeof window !== "undefined" && typeof window.document !== "undefined";
  const isWebWorker = () => typeof globalThis === "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope";
  const isJsDom = () => typeof window !== "undefined" && window.name === "nodejs" || typeof navigator !== "undefined" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom"));
  const isDeno = () => typeof Deno !== "undefined";
  const isNode = () => typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined" && !isDeno();
  const getEnv = () => {
    let env;
    if (isBrowser()) {
      env = "browser";
    } else if (isNode()) {
      env = "node";
    } else if (isWebWorker()) {
      env = "webworker";
    } else if (isJsDom()) {
      env = "jsdom";
    } else if (isDeno()) {
      env = "deno";
    } else {
      env = "other";
    }
    return env;
  };
  let runtimeEnvironment;
  async function getRuntimeEnvironment() {
    if (runtimeEnvironment === void 0) {
      const env = getEnv();
      runtimeEnvironment = {
        library: "langchain-js",
        runtime: env
      };
    }
    return runtimeEnvironment;
  }
  function getEnvironmentVariable(name) {
    var _a3;
    try {
      if (typeof process !== "undefined") {
        return (_a3 = process.env) == null ? void 0 : _a3[name];
      } else if (isDeno()) {
        return Deno == null ? void 0 : Deno.env.get(name);
      } else {
        return void 0;
      }
    } catch (e) {
      return void 0;
    }
  }
  class BaseCallbackHandlerMethodsClass {
  }
  function callbackHandlerPrefersStreaming(x) {
    return "lc_prefer_streaming" in x && x.lc_prefer_streaming;
  }
  class BaseCallbackHandler extends BaseCallbackHandlerMethodsClass {
    get lc_namespace() {
      return ["langchain_core", "callbacks", this.name];
    }
    get lc_secrets() {
      return void 0;
    }
    get lc_attributes() {
      return void 0;
    }
    get lc_aliases() {
      return void 0;
    }
    get lc_serializable_keys() {
      return void 0;
    }
    /**
     * The name of the serializable. Override to provide an alias or
     * to preserve the serialized module name in minified environments.
     *
     * Implemented as a static method to support loading logic.
     */
    static lc_name() {
      return this.name;
    }
    /**
     * The final serialized identifier for the module.
     */
    get lc_id() {
      return [
        ...this.lc_namespace,
        get_lc_unique_name(this.constructor)
      ];
    }
    constructor(input) {
      super();
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "lc_kwargs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "ignoreLLM", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "ignoreChain", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "ignoreAgent", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "ignoreRetriever", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "ignoreCustomEvent", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "raiseError", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "awaitHandlers", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: getEnvironmentVariable("LANGCHAIN_CALLBACKS_BACKGROUND") === "false"
      });
      this.lc_kwargs = input || {};
      if (input) {
        this.ignoreLLM = input.ignoreLLM ?? this.ignoreLLM;
        this.ignoreChain = input.ignoreChain ?? this.ignoreChain;
        this.ignoreAgent = input.ignoreAgent ?? this.ignoreAgent;
        this.ignoreRetriever = input.ignoreRetriever ?? this.ignoreRetriever;
        this.ignoreCustomEvent = input.ignoreCustomEvent ?? this.ignoreCustomEvent;
        this.raiseError = input.raiseError ?? this.raiseError;
        this.awaitHandlers = this.raiseError || (input._awaitHandler ?? this.awaitHandlers);
      }
    }
    copy() {
      return new this.constructor(this);
    }
    toJSON() {
      return Serializable.prototype.toJSON.call(this);
    }
    toJSONNotImplemented() {
      return Serializable.prototype.toJSONNotImplemented.call(this);
    }
    static fromMethods(methods2) {
      class Handler extends BaseCallbackHandler {
        constructor() {
          super();
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: v4()
          });
          Object.assign(this, methods2);
        }
      }
      return new Handler();
    }
  }
  const isBaseCallbackHandler = (x) => {
    const callbackHandler = x;
    return callbackHandler !== void 0 && typeof callbackHandler.copy === "function" && typeof callbackHandler.name === "string" && typeof callbackHandler.awaitHandlers === "boolean";
  };
  function _coerceToDict$1(value, defaultKey) {
    return value && !Array.isArray(value) && typeof value === "object" ? value : { [defaultKey]: value };
  }
  function stripNonAlphanumeric(input) {
    return input.replace(/[-:.]/g, "");
  }
  function convertToDottedOrderFormat(epoch, runId, executionOrder) {
    const paddedOrder = executionOrder.toFixed(0).slice(0, 3).padStart(3, "0");
    return stripNonAlphanumeric(`${new Date(epoch).toISOString().slice(0, -1)}${paddedOrder}Z`) + runId;
  }
  function isBaseTracer(x) {
    return typeof x._addRunToRunMap === "function";
  }
  class BaseTracer extends BaseCallbackHandler {
    constructor(_fields) {
      super(...arguments);
      Object.defineProperty(this, "runMap", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /* @__PURE__ */ new Map()
      });
    }
    copy() {
      return this;
    }
    stringifyError(error) {
      if (error instanceof Error) {
        return error.message + ((error == null ? void 0 : error.stack) ? `

${error.stack}` : "");
      }
      if (typeof error === "string") {
        return error;
      }
      return `${error}`;
    }
    _addChildRun(parentRun, childRun) {
      parentRun.child_runs.push(childRun);
    }
    _addRunToRunMap(run) {
      const currentDottedOrder = convertToDottedOrderFormat(run.start_time, run.id, run.execution_order);
      const storedRun = { ...run };
      if (storedRun.parent_run_id !== void 0) {
        const parentRun = this.runMap.get(storedRun.parent_run_id);
        if (parentRun) {
          this._addChildRun(parentRun, storedRun);
          parentRun.child_execution_order = Math.max(parentRun.child_execution_order, storedRun.child_execution_order);
          storedRun.trace_id = parentRun.trace_id;
          if (parentRun.dotted_order !== void 0) {
            storedRun.dotted_order = [
              parentRun.dotted_order,
              currentDottedOrder
            ].join(".");
          }
        }
      } else {
        storedRun.trace_id = storedRun.id;
        storedRun.dotted_order = currentDottedOrder;
      }
      this.runMap.set(storedRun.id, storedRun);
      return storedRun;
    }
    async _endTrace(run) {
      var _a3;
      const parentRun = run.parent_run_id !== void 0 && this.runMap.get(run.parent_run_id);
      if (parentRun) {
        parentRun.child_execution_order = Math.max(parentRun.child_execution_order, run.child_execution_order);
      } else {
        await this.persistRun(run);
      }
      this.runMap.delete(run.id);
      await ((_a3 = this.onRunUpdate) == null ? void 0 : _a3.call(this, run));
    }
    _getExecutionOrder(parentRunId) {
      const parentRun = parentRunId !== void 0 && this.runMap.get(parentRunId);
      if (!parentRun) {
        return 1;
      }
      return parentRun.child_execution_order + 1;
    }
    /**
     * Create and add a run to the run map for LLM start events.
     * This must sometimes be done synchronously to avoid race conditions
     * when callbacks are backgrounded, so we expose it as a separate method here.
     */
    _createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {
      const execution_order = this._getExecutionOrder(parentRunId);
      const start_time = Date.now();
      const finalExtraParams = metadata ? { ...extraParams, metadata } : extraParams;
      const run = {
        id: runId,
        name: name ?? llm.id[llm.id.length - 1],
        parent_run_id: parentRunId,
        start_time,
        serialized: llm,
        events: [
          {
            name: "start",
            time: new Date(start_time).toISOString()
          }
        ],
        inputs: { prompts },
        execution_order,
        child_runs: [],
        child_execution_order: execution_order,
        run_type: "llm",
        extra: finalExtraParams ?? {},
        tags: tags || []
      };
      return this._addRunToRunMap(run);
    }
    async handleLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {
      var _a3, _b2;
      const run = this.runMap.get(runId) ?? this._createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name);
      await ((_a3 = this.onRunCreate) == null ? void 0 : _a3.call(this, run));
      await ((_b2 = this.onLLMStart) == null ? void 0 : _b2.call(this, run));
      return run;
    }
    /**
     * Create and add a run to the run map for chat model start events.
     * This must sometimes be done synchronously to avoid race conditions
     * when callbacks are backgrounded, so we expose it as a separate method here.
     */
    _createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {
      const execution_order = this._getExecutionOrder(parentRunId);
      const start_time = Date.now();
      const finalExtraParams = metadata ? { ...extraParams, metadata } : extraParams;
      const run = {
        id: runId,
        name: name ?? llm.id[llm.id.length - 1],
        parent_run_id: parentRunId,
        start_time,
        serialized: llm,
        events: [
          {
            name: "start",
            time: new Date(start_time).toISOString()
          }
        ],
        inputs: { messages },
        execution_order,
        child_runs: [],
        child_execution_order: execution_order,
        run_type: "llm",
        extra: finalExtraParams ?? {},
        tags: tags || []
      };
      return this._addRunToRunMap(run);
    }
    async handleChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {
      var _a3, _b2;
      const run = this.runMap.get(runId) ?? this._createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name);
      await ((_a3 = this.onRunCreate) == null ? void 0 : _a3.call(this, run));
      await ((_b2 = this.onLLMStart) == null ? void 0 : _b2.call(this, run));
      return run;
    }
    async handleLLMEnd(output, runId, _parentRunId, _tags, extraParams) {
      var _a3;
      const run = this.runMap.get(runId);
      if (!run || (run == null ? void 0 : run.run_type) !== "llm") {
        throw new Error("No LLM run to end.");
      }
      run.end_time = Date.now();
      run.outputs = output;
      run.events.push({
        name: "end",
        time: new Date(run.end_time).toISOString()
      });
      run.extra = { ...run.extra, ...extraParams };
      await ((_a3 = this.onLLMEnd) == null ? void 0 : _a3.call(this, run));
      await this._endTrace(run);
      return run;
    }
    async handleLLMError(error, runId, _parentRunId, _tags, extraParams) {
      var _a3;
      const run = this.runMap.get(runId);
      if (!run || (run == null ? void 0 : run.run_type) !== "llm") {
        throw new Error("No LLM run to end.");
      }
      run.end_time = Date.now();
      run.error = this.stringifyError(error);
      run.events.push({
        name: "error",
        time: new Date(run.end_time).toISOString()
      });
      run.extra = { ...run.extra, ...extraParams };
      await ((_a3 = this.onLLMError) == null ? void 0 : _a3.call(this, run));
      await this._endTrace(run);
      return run;
    }
    /**
     * Create and add a run to the run map for chain start events.
     * This must sometimes be done synchronously to avoid race conditions
     * when callbacks are backgrounded, so we expose it as a separate method here.
     */
    _createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {
      const execution_order = this._getExecutionOrder(parentRunId);
      const start_time = Date.now();
      const run = {
        id: runId,
        name: name ?? chain.id[chain.id.length - 1],
        parent_run_id: parentRunId,
        start_time,
        serialized: chain,
        events: [
          {
            name: "start",
            time: new Date(start_time).toISOString()
          }
        ],
        inputs,
        execution_order,
        child_execution_order: execution_order,
        run_type: runType ?? "chain",
        child_runs: [],
        extra: metadata ? { metadata } : {},
        tags: tags || []
      };
      return this._addRunToRunMap(run);
    }
    async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {
      var _a3, _b2;
      const run = this.runMap.get(runId) ?? this._createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name);
      await ((_a3 = this.onRunCreate) == null ? void 0 : _a3.call(this, run));
      await ((_b2 = this.onChainStart) == null ? void 0 : _b2.call(this, run));
      return run;
    }
    async handleChainEnd(outputs, runId, _parentRunId, _tags, kwargs) {
      var _a3;
      const run = this.runMap.get(runId);
      if (!run) {
        throw new Error("No chain run to end.");
      }
      run.end_time = Date.now();
      run.outputs = _coerceToDict$1(outputs, "output");
      run.events.push({
        name: "end",
        time: new Date(run.end_time).toISOString()
      });
      if ((kwargs == null ? void 0 : kwargs.inputs) !== void 0) {
        run.inputs = _coerceToDict$1(kwargs.inputs, "input");
      }
      await ((_a3 = this.onChainEnd) == null ? void 0 : _a3.call(this, run));
      await this._endTrace(run);
      return run;
    }
    async handleChainError(error, runId, _parentRunId, _tags, kwargs) {
      var _a3;
      const run = this.runMap.get(runId);
      if (!run) {
        throw new Error("No chain run to end.");
      }
      run.end_time = Date.now();
      run.error = this.stringifyError(error);
      run.events.push({
        name: "error",
        time: new Date(run.end_time).toISOString()
      });
      if ((kwargs == null ? void 0 : kwargs.inputs) !== void 0) {
        run.inputs = _coerceToDict$1(kwargs.inputs, "input");
      }
      await ((_a3 = this.onChainError) == null ? void 0 : _a3.call(this, run));
      await this._endTrace(run);
      return run;
    }
    /**
     * Create and add a run to the run map for tool start events.
     * This must sometimes be done synchronously to avoid race conditions
     * when callbacks are backgrounded, so we expose it as a separate method here.
     */
    _createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name) {
      const execution_order = this._getExecutionOrder(parentRunId);
      const start_time = Date.now();
      const run = {
        id: runId,
        name: name ?? tool.id[tool.id.length - 1],
        parent_run_id: parentRunId,
        start_time,
        serialized: tool,
        events: [
          {
            name: "start",
            time: new Date(start_time).toISOString()
          }
        ],
        inputs: { input },
        execution_order,
        child_execution_order: execution_order,
        run_type: "tool",
        child_runs: [],
        extra: metadata ? { metadata } : {},
        tags: tags || []
      };
      return this._addRunToRunMap(run);
    }
    async handleToolStart(tool, input, runId, parentRunId, tags, metadata, name) {
      var _a3, _b2;
      const run = this.runMap.get(runId) ?? this._createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name);
      await ((_a3 = this.onRunCreate) == null ? void 0 : _a3.call(this, run));
      await ((_b2 = this.onToolStart) == null ? void 0 : _b2.call(this, run));
      return run;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async handleToolEnd(output, runId) {
      var _a3;
      const run = this.runMap.get(runId);
      if (!run || (run == null ? void 0 : run.run_type) !== "tool") {
        throw new Error("No tool run to end");
      }
      run.end_time = Date.now();
      run.outputs = { output };
      run.events.push({
        name: "end",
        time: new Date(run.end_time).toISOString()
      });
      await ((_a3 = this.onToolEnd) == null ? void 0 : _a3.call(this, run));
      await this._endTrace(run);
      return run;
    }
    async handleToolError(error, runId) {
      var _a3;
      const run = this.runMap.get(runId);
      if (!run || (run == null ? void 0 : run.run_type) !== "tool") {
        throw new Error("No tool run to end");
      }
      run.end_time = Date.now();
      run.error = this.stringifyError(error);
      run.events.push({
        name: "error",
        time: new Date(run.end_time).toISOString()
      });
      await ((_a3 = this.onToolError) == null ? void 0 : _a3.call(this, run));
      await this._endTrace(run);
      return run;
    }
    async handleAgentAction(action, runId) {
      var _a3;
      const run = this.runMap.get(runId);
      if (!run || (run == null ? void 0 : run.run_type) !== "chain") {
        return;
      }
      const agentRun = run;
      agentRun.actions = agentRun.actions || [];
      agentRun.actions.push(action);
      agentRun.events.push({
        name: "agent_action",
        time: (/* @__PURE__ */ new Date()).toISOString(),
        kwargs: { action }
      });
      await ((_a3 = this.onAgentAction) == null ? void 0 : _a3.call(this, run));
    }
    async handleAgentEnd(action, runId) {
      var _a3;
      const run = this.runMap.get(runId);
      if (!run || (run == null ? void 0 : run.run_type) !== "chain") {
        return;
      }
      run.events.push({
        name: "agent_end",
        time: (/* @__PURE__ */ new Date()).toISOString(),
        kwargs: { action }
      });
      await ((_a3 = this.onAgentEnd) == null ? void 0 : _a3.call(this, run));
    }
    /**
     * Create and add a run to the run map for retriever start events.
     * This must sometimes be done synchronously to avoid race conditions
     * when callbacks are backgrounded, so we expose it as a separate method here.
     */
    _createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {
      const execution_order = this._getExecutionOrder(parentRunId);
      const start_time = Date.now();
      const run = {
        id: runId,
        name: name ?? retriever.id[retriever.id.length - 1],
        parent_run_id: parentRunId,
        start_time,
        serialized: retriever,
        events: [
          {
            name: "start",
            time: new Date(start_time).toISOString()
          }
        ],
        inputs: { query },
        execution_order,
        child_execution_order: execution_order,
        run_type: "retriever",
        child_runs: [],
        extra: metadata ? { metadata } : {},
        tags: tags || []
      };
      return this._addRunToRunMap(run);
    }
    async handleRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {
      var _a3, _b2;
      const run = this.runMap.get(runId) ?? this._createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name);
      await ((_a3 = this.onRunCreate) == null ? void 0 : _a3.call(this, run));
      await ((_b2 = this.onRetrieverStart) == null ? void 0 : _b2.call(this, run));
      return run;
    }
    async handleRetrieverEnd(documents, runId) {
      var _a3;
      const run = this.runMap.get(runId);
      if (!run || (run == null ? void 0 : run.run_type) !== "retriever") {
        throw new Error("No retriever run to end");
      }
      run.end_time = Date.now();
      run.outputs = { documents };
      run.events.push({
        name: "end",
        time: new Date(run.end_time).toISOString()
      });
      await ((_a3 = this.onRetrieverEnd) == null ? void 0 : _a3.call(this, run));
      await this._endTrace(run);
      return run;
    }
    async handleRetrieverError(error, runId) {
      var _a3;
      const run = this.runMap.get(runId);
      if (!run || (run == null ? void 0 : run.run_type) !== "retriever") {
        throw new Error("No retriever run to end");
      }
      run.end_time = Date.now();
      run.error = this.stringifyError(error);
      run.events.push({
        name: "error",
        time: new Date(run.end_time).toISOString()
      });
      await ((_a3 = this.onRetrieverError) == null ? void 0 : _a3.call(this, run));
      await this._endTrace(run);
      return run;
    }
    async handleText(text, runId) {
      var _a3;
      const run = this.runMap.get(runId);
      if (!run || (run == null ? void 0 : run.run_type) !== "chain") {
        return;
      }
      run.events.push({
        name: "text",
        time: (/* @__PURE__ */ new Date()).toISOString(),
        kwargs: { text }
      });
      await ((_a3 = this.onText) == null ? void 0 : _a3.call(this, run));
    }
    async handleLLMNewToken(token, idx, runId, _parentRunId, _tags, fields) {
      var _a3;
      const run = this.runMap.get(runId);
      if (!run || (run == null ? void 0 : run.run_type) !== "llm") {
        throw new Error(`Invalid "runId" provided to "handleLLMNewToken" callback.`);
      }
      run.events.push({
        name: "new_token",
        time: (/* @__PURE__ */ new Date()).toISOString(),
        kwargs: { token, idx, chunk: fields == null ? void 0 : fields.chunk }
      });
      await ((_a3 = this.onLLMNewToken) == null ? void 0 : _a3.call(this, run, token, { chunk: fields == null ? void 0 : fields.chunk }));
      return run;
    }
  }
  var ansiStyles = { exports: {} };
  ansiStyles.exports;
  var hasRequiredAnsiStyles;
  function requireAnsiStyles() {
    if (hasRequiredAnsiStyles) return ansiStyles.exports;
    hasRequiredAnsiStyles = 1;
    (function(module) {
      const ANSI_BACKGROUND_OFFSET = 10;
      const wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
      const wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
      function assembleStyles() {
        const codes = /* @__PURE__ */ new Map();
        const styles2 = {
          modifier: {
            reset: [0, 0],
            // 21 isn't widely supported and 22 does the same thing
            bold: [1, 22],
            dim: [2, 22],
            italic: [3, 23],
            underline: [4, 24],
            overline: [53, 55],
            inverse: [7, 27],
            hidden: [8, 28],
            strikethrough: [9, 29]
          },
          color: {
            black: [30, 39],
            red: [31, 39],
            green: [32, 39],
            yellow: [33, 39],
            blue: [34, 39],
            magenta: [35, 39],
            cyan: [36, 39],
            white: [37, 39],
            // Bright color
            blackBright: [90, 39],
            redBright: [91, 39],
            greenBright: [92, 39],
            yellowBright: [93, 39],
            blueBright: [94, 39],
            magentaBright: [95, 39],
            cyanBright: [96, 39],
            whiteBright: [97, 39]
          },
          bgColor: {
            bgBlack: [40, 49],
            bgRed: [41, 49],
            bgGreen: [42, 49],
            bgYellow: [43, 49],
            bgBlue: [44, 49],
            bgMagenta: [45, 49],
            bgCyan: [46, 49],
            bgWhite: [47, 49],
            // Bright color
            bgBlackBright: [100, 49],
            bgRedBright: [101, 49],
            bgGreenBright: [102, 49],
            bgYellowBright: [103, 49],
            bgBlueBright: [104, 49],
            bgMagentaBright: [105, 49],
            bgCyanBright: [106, 49],
            bgWhiteBright: [107, 49]
          }
        };
        styles2.color.gray = styles2.color.blackBright;
        styles2.bgColor.bgGray = styles2.bgColor.bgBlackBright;
        styles2.color.grey = styles2.color.blackBright;
        styles2.bgColor.bgGrey = styles2.bgColor.bgBlackBright;
        for (const [groupName, group] of Object.entries(styles2)) {
          for (const [styleName, style] of Object.entries(group)) {
            styles2[styleName] = {
              open: `\x1B[${style[0]}m`,
              close: `\x1B[${style[1]}m`
            };
            group[styleName] = styles2[styleName];
            codes.set(style[0], style[1]);
          }
          Object.defineProperty(styles2, groupName, {
            value: group,
            enumerable: false
          });
        }
        Object.defineProperty(styles2, "codes", {
          value: codes,
          enumerable: false
        });
        styles2.color.close = "\x1B[39m";
        styles2.bgColor.close = "\x1B[49m";
        styles2.color.ansi256 = wrapAnsi256();
        styles2.color.ansi16m = wrapAnsi16m();
        styles2.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
        styles2.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
        Object.defineProperties(styles2, {
          rgbToAnsi256: {
            value: (red, green, blue) => {
              if (red === green && green === blue) {
                if (red < 8) {
                  return 16;
                }
                if (red > 248) {
                  return 231;
                }
                return Math.round((red - 8) / 247 * 24) + 232;
              }
              return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
            },
            enumerable: false
          },
          hexToRgb: {
            value: (hex) => {
              const matches = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex.toString(16));
              if (!matches) {
                return [0, 0, 0];
              }
              let { colorString } = matches.groups;
              if (colorString.length === 3) {
                colorString = colorString.split("").map((character) => character + character).join("");
              }
              const integer = Number.parseInt(colorString, 16);
              return [
                integer >> 16 & 255,
                integer >> 8 & 255,
                integer & 255
              ];
            },
            enumerable: false
          },
          hexToAnsi256: {
            value: (hex) => styles2.rgbToAnsi256(...styles2.hexToRgb(hex)),
            enumerable: false
          }
        });
        return styles2;
      }
      Object.defineProperty(module, "exports", {
        enumerable: true,
        get: assembleStyles
      });
    })(ansiStyles);
    return ansiStyles.exports;
  }
  var ansiStylesExports = requireAnsiStyles();
  const styles = /* @__PURE__ */ getDefaultExportFromCjs(ansiStylesExports);
  function wrap(style, text) {
    return `${style.open}${text}${style.close}`;
  }
  function tryJsonStringify(obj, fallback) {
    try {
      return JSON.stringify(obj, null, 2);
    } catch (err) {
      return fallback;
    }
  }
  function formatKVMapItem(value) {
    if (typeof value === "string") {
      return value.trim();
    }
    if (value === null || value === void 0) {
      return value;
    }
    return tryJsonStringify(value, value.toString());
  }
  function elapsed(run) {
    if (!run.end_time)
      return "";
    const elapsed2 = run.end_time - run.start_time;
    if (elapsed2 < 1e3) {
      return `${elapsed2}ms`;
    }
    return `${(elapsed2 / 1e3).toFixed(2)}s`;
  }
  const { color } = styles;
  class ConsoleCallbackHandler extends BaseTracer {
    constructor() {
      super(...arguments);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "console_callback_handler"
      });
    }
    /**
     * Method used to persist the run. In this case, it simply returns a
     * resolved promise as there's no persistence logic.
     * @param _run The run to persist.
     * @returns A resolved promise.
     */
    persistRun(_run) {
      return Promise.resolve();
    }
    // utility methods
    /**
     * Method used to get all the parent runs of a given run.
     * @param run The run whose parents are to be retrieved.
     * @returns An array of parent runs.
     */
    getParents(run) {
      const parents = [];
      let currentRun = run;
      while (currentRun.parent_run_id) {
        const parent = this.runMap.get(currentRun.parent_run_id);
        if (parent) {
          parents.push(parent);
          currentRun = parent;
        } else {
          break;
        }
      }
      return parents;
    }
    /**
     * Method used to get a string representation of the run's lineage, which
     * is used in logging.
     * @param run The run whose lineage is to be retrieved.
     * @returns A string representation of the run's lineage.
     */
    getBreadcrumbs(run) {
      const parents = this.getParents(run).reverse();
      const string = [...parents, run].map((parent, i2, arr2) => {
        const name = `${parent.execution_order}:${parent.run_type}:${parent.name}`;
        return i2 === arr2.length - 1 ? wrap(styles.bold, name) : name;
      }).join(" > ");
      return wrap(color.grey, string);
    }
    // logging methods
    /**
     * Method used to log the start of a chain run.
     * @param run The chain run that has started.
     * @returns void
     */
    onChainStart(run) {
      const crumbs = this.getBreadcrumbs(run);
      console.log(`${wrap(color.green, "[chain/start]")} [${crumbs}] Entering Chain run with input: ${tryJsonStringify(run.inputs, "[inputs]")}`);
    }
    /**
     * Method used to log the end of a chain run.
     * @param run The chain run that has ended.
     * @returns void
     */
    onChainEnd(run) {
      const crumbs = this.getBreadcrumbs(run);
      console.log(`${wrap(color.cyan, "[chain/end]")} [${crumbs}] [${elapsed(run)}] Exiting Chain run with output: ${tryJsonStringify(run.outputs, "[outputs]")}`);
    }
    /**
     * Method used to log any errors of a chain run.
     * @param run The chain run that has errored.
     * @returns void
     */
    onChainError(run) {
      const crumbs = this.getBreadcrumbs(run);
      console.log(`${wrap(color.red, "[chain/error]")} [${crumbs}] [${elapsed(run)}] Chain run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
    }
    /**
     * Method used to log the start of an LLM run.
     * @param run The LLM run that has started.
     * @returns void
     */
    onLLMStart(run) {
      const crumbs = this.getBreadcrumbs(run);
      const inputs = "prompts" in run.inputs ? { prompts: run.inputs.prompts.map((p) => p.trim()) } : run.inputs;
      console.log(`${wrap(color.green, "[llm/start]")} [${crumbs}] Entering LLM run with input: ${tryJsonStringify(inputs, "[inputs]")}`);
    }
    /**
     * Method used to log the end of an LLM run.
     * @param run The LLM run that has ended.
     * @returns void
     */
    onLLMEnd(run) {
      const crumbs = this.getBreadcrumbs(run);
      console.log(`${wrap(color.cyan, "[llm/end]")} [${crumbs}] [${elapsed(run)}] Exiting LLM run with output: ${tryJsonStringify(run.outputs, "[response]")}`);
    }
    /**
     * Method used to log any errors of an LLM run.
     * @param run The LLM run that has errored.
     * @returns void
     */
    onLLMError(run) {
      const crumbs = this.getBreadcrumbs(run);
      console.log(`${wrap(color.red, "[llm/error]")} [${crumbs}] [${elapsed(run)}] LLM run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
    }
    /**
     * Method used to log the start of a tool run.
     * @param run The tool run that has started.
     * @returns void
     */
    onToolStart(run) {
      const crumbs = this.getBreadcrumbs(run);
      console.log(`${wrap(color.green, "[tool/start]")} [${crumbs}] Entering Tool run with input: "${formatKVMapItem(run.inputs.input)}"`);
    }
    /**
     * Method used to log the end of a tool run.
     * @param run The tool run that has ended.
     * @returns void
     */
    onToolEnd(run) {
      var _a3;
      const crumbs = this.getBreadcrumbs(run);
      console.log(`${wrap(color.cyan, "[tool/end]")} [${crumbs}] [${elapsed(run)}] Exiting Tool run with output: "${formatKVMapItem((_a3 = run.outputs) == null ? void 0 : _a3.output)}"`);
    }
    /**
     * Method used to log any errors of a tool run.
     * @param run The tool run that has errored.
     * @returns void
     */
    onToolError(run) {
      const crumbs = this.getBreadcrumbs(run);
      console.log(`${wrap(color.red, "[tool/error]")} [${crumbs}] [${elapsed(run)}] Tool run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
    }
    /**
     * Method used to log the start of a retriever run.
     * @param run The retriever run that has started.
     * @returns void
     */
    onRetrieverStart(run) {
      const crumbs = this.getBreadcrumbs(run);
      console.log(`${wrap(color.green, "[retriever/start]")} [${crumbs}] Entering Retriever run with input: ${tryJsonStringify(run.inputs, "[inputs]")}`);
    }
    /**
     * Method used to log the end of a retriever run.
     * @param run The retriever run that has ended.
     * @returns void
     */
    onRetrieverEnd(run) {
      const crumbs = this.getBreadcrumbs(run);
      console.log(`${wrap(color.cyan, "[retriever/end]")} [${crumbs}] [${elapsed(run)}] Exiting Retriever run with output: ${tryJsonStringify(run.outputs, "[outputs]")}`);
    }
    /**
     * Method used to log any errors of a retriever run.
     * @param run The retriever run that has errored.
     * @returns void
     */
    onRetrieverError(run) {
      const crumbs = this.getBreadcrumbs(run);
      console.log(`${wrap(color.red, "[retriever/error]")} [${crumbs}] [${elapsed(run)}] Retriever run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
    }
    /**
     * Method used to log the action selected by the agent.
     * @param run The run in which the agent action occurred.
     * @returns void
     */
    onAgentAction(run) {
      const agentRun = run;
      const crumbs = this.getBreadcrumbs(run);
      console.log(`${wrap(color.blue, "[agent/action]")} [${crumbs}] Agent selected action: ${tryJsonStringify(agentRun.actions[agentRun.actions.length - 1], "[action]")}`);
    }
  }
  let client;
  const getDefaultLangChainClientSingleton = () => {
    if (client === void 0) {
      const clientParams = getEnvironmentVariable("LANGCHAIN_CALLBACKS_BACKGROUND") === "false" ? {
        // LangSmith has its own backgrounding system
        blockOnRootRunFinalization: true
      } : {};
      client = new Client(clientParams);
    }
    return client;
  };
  class LangChainTracer extends BaseTracer {
    constructor(fields = {}) {
      super(fields);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "langchain_tracer"
      });
      Object.defineProperty(this, "projectName", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "exampleId", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "client", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      const { exampleId, projectName, client: client2 } = fields;
      this.projectName = projectName ?? getEnvironmentVariable("LANGCHAIN_PROJECT") ?? getEnvironmentVariable("LANGCHAIN_SESSION");
      this.exampleId = exampleId;
      this.client = client2 ?? getDefaultLangChainClientSingleton();
      const traceableTree = LangChainTracer.getTraceableRunTree();
      if (traceableTree) {
        this.updateFromRunTree(traceableTree);
      }
    }
    async _convertToCreate(run, example_id = void 0) {
      return {
        ...run,
        extra: {
          ...run.extra,
          runtime: await getRuntimeEnvironment()
        },
        child_runs: void 0,
        session_name: this.projectName,
        reference_example_id: run.parent_run_id ? void 0 : example_id
      };
    }
    async persistRun(_run) {
    }
    async onRunCreate(run) {
      const persistedRun = await this._convertToCreate(run, this.exampleId);
      await this.client.createRun(persistedRun);
    }
    async onRunUpdate(run) {
      const runUpdate = {
        end_time: run.end_time,
        error: run.error,
        outputs: run.outputs,
        events: run.events,
        inputs: run.inputs,
        trace_id: run.trace_id,
        dotted_order: run.dotted_order,
        parent_run_id: run.parent_run_id,
        extra: run.extra
      };
      await this.client.updateRun(run.id, runUpdate);
    }
    getRun(id) {
      return this.runMap.get(id);
    }
    updateFromRunTree(runTree) {
      let rootRun = runTree;
      const visited = /* @__PURE__ */ new Set();
      while (rootRun.parent_run) {
        if (visited.has(rootRun.id))
          break;
        visited.add(rootRun.id);
        if (!rootRun.parent_run)
          break;
        rootRun = rootRun.parent_run;
      }
      visited.clear();
      const queue2 = [rootRun];
      while (queue2.length > 0) {
        const current = queue2.shift();
        if (!current || visited.has(current.id))
          continue;
        visited.add(current.id);
        this.runMap.set(current.id, current);
        if (current.child_runs) {
          queue2.push(...current.child_runs);
        }
      }
      this.client = runTree.client ?? this.client;
      this.projectName = runTree.project_name ?? this.projectName;
      this.exampleId = runTree.reference_example_id ?? this.exampleId;
    }
    convertToRunTree(id) {
      const runTreeMap = {};
      const runTreeList = [];
      for (const [id2, run] of this.runMap) {
        const runTree = new RunTree({
          ...run,
          child_runs: [],
          parent_run: void 0,
          // inherited properties
          client: this.client,
          project_name: this.projectName,
          reference_example_id: this.exampleId,
          tracingEnabled: true
        });
        runTreeMap[id2] = runTree;
        runTreeList.push([id2, run.dotted_order]);
      }
      runTreeList.sort((a, b) => {
        if (!a[1] || !b[1])
          return 0;
        return a[1].localeCompare(b[1]);
      });
      for (const [id2] of runTreeList) {
        const run = this.runMap.get(id2);
        const runTree = runTreeMap[id2];
        if (!run || !runTree)
          continue;
        if (run.parent_run_id) {
          const parentRunTree = runTreeMap[run.parent_run_id];
          if (parentRunTree) {
            parentRunTree.child_runs.push(runTree);
            runTree.parent_run = parentRunTree;
          }
        }
      }
      return runTreeMap[id];
    }
    static getTraceableRunTree() {
      try {
        return getCurrentRunTree();
      } catch {
        return void 0;
      }
    }
  }
  const TRACING_ALS_KEY = Symbol.for("ls:tracing_async_local_storage");
  const _CONTEXT_VARIABLES_KEY = Symbol.for("lc:context_variables");
  const setGlobalAsyncLocalStorageInstance = (instance) => {
    globalThis[TRACING_ALS_KEY] = instance;
  };
  const getGlobalAsyncLocalStorageInstance = () => {
    return globalThis[TRACING_ALS_KEY];
  };
  let queue;
  function createQueue() {
    const PQueue = "default" in PQueueMod ? PQueueMod.default : PQueueMod;
    return new PQueue({
      autoStart: true,
      concurrency: 1
    });
  }
  function getQueue() {
    if (typeof queue === "undefined") {
      queue = createQueue();
    }
    return queue;
  }
  async function consumeCallback(promiseFn, wait) {
    if (wait === true) {
      const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();
      if (asyncLocalStorageInstance !== void 0) {
        await asyncLocalStorageInstance.run(void 0, async () => promiseFn());
      } else {
        await promiseFn();
      }
    } else {
      queue = getQueue();
      void queue.add(async () => {
        const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();
        if (asyncLocalStorageInstance !== void 0) {
          await asyncLocalStorageInstance.run(void 0, async () => promiseFn());
        } else {
          await promiseFn();
        }
      });
    }
  }
  const isTracingEnabled = (tracingEnabled) => {
    const envVars = [
      "LANGSMITH_TRACING_V2",
      "LANGCHAIN_TRACING_V2",
      "LANGSMITH_TRACING",
      "LANGCHAIN_TRACING"
    ];
    return !!envVars.find((envVar) => getEnvironmentVariable(envVar) === "true");
  };
  function getContextVariable(name) {
    var _a3;
    const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();
    if (asyncLocalStorageInstance === void 0) {
      return void 0;
    }
    const runTree = asyncLocalStorageInstance.getStore();
    return (_a3 = runTree == null ? void 0 : runTree[_CONTEXT_VARIABLES_KEY]) == null ? void 0 : _a3[name];
  }
  const LC_CONFIGURE_HOOKS_KEY = Symbol("lc:configure_hooks");
  const _getConfigureHooks = () => getContextVariable(LC_CONFIGURE_HOOKS_KEY) || [];
  class BaseCallbackManager {
    setHandler(handler) {
      return this.setHandlers([handler]);
    }
  }
  class BaseRunManager {
    constructor(runId, handlers, inheritableHandlers, tags, inheritableTags, metadata, inheritableMetadata, _parentRunId) {
      Object.defineProperty(this, "runId", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: runId
      });
      Object.defineProperty(this, "handlers", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: handlers
      });
      Object.defineProperty(this, "inheritableHandlers", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: inheritableHandlers
      });
      Object.defineProperty(this, "tags", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: tags
      });
      Object.defineProperty(this, "inheritableTags", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: inheritableTags
      });
      Object.defineProperty(this, "metadata", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: metadata
      });
      Object.defineProperty(this, "inheritableMetadata", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: inheritableMetadata
      });
      Object.defineProperty(this, "_parentRunId", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _parentRunId
      });
    }
    get parentRunId() {
      return this._parentRunId;
    }
    async handleText(text) {
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a3;
        try {
          await ((_a3 = handler.handleText) == null ? void 0 : _a3.call(handler, text, this.runId, this._parentRunId, this.tags));
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleText: ${err}`);
          if (handler.raiseError) {
            throw err;
          }
        }
      }, handler.awaitHandlers)));
    }
    async handleCustomEvent(eventName, data, _runId, _tags, _metadata) {
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a3;
        try {
          await ((_a3 = handler.handleCustomEvent) == null ? void 0 : _a3.call(handler, eventName, data, this.runId, this.tags, this.metadata));
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);
          if (handler.raiseError) {
            throw err;
          }
        }
      }, handler.awaitHandlers)));
    }
  }
  class CallbackManagerForRetrieverRun extends BaseRunManager {
    getChild(tag) {
      const manager = new CallbackManager(this.runId);
      manager.setHandlers(this.inheritableHandlers);
      manager.addTags(this.inheritableTags);
      manager.addMetadata(this.inheritableMetadata);
      if (tag) {
        manager.addTags([tag], false);
      }
      return manager;
    }
    async handleRetrieverEnd(documents) {
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a3;
        if (!handler.ignoreRetriever) {
          try {
            await ((_a3 = handler.handleRetrieverEnd) == null ? void 0 : _a3.call(handler, documents, this.runId, this._parentRunId, this.tags));
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleRetriever`);
            if (handler.raiseError) {
              throw err;
            }
          }
        }
      }, handler.awaitHandlers)));
    }
    async handleRetrieverError(err) {
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a3;
        if (!handler.ignoreRetriever) {
          try {
            await ((_a3 = handler.handleRetrieverError) == null ? void 0 : _a3.call(handler, err, this.runId, this._parentRunId, this.tags));
          } catch (error) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverError: ${error}`);
            if (handler.raiseError) {
              throw err;
            }
          }
        }
      }, handler.awaitHandlers)));
    }
  }
  class CallbackManagerForLLMRun extends BaseRunManager {
    async handleLLMNewToken(token, idx, _runId, _parentRunId, _tags, fields) {
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a3;
        if (!handler.ignoreLLM) {
          try {
            await ((_a3 = handler.handleLLMNewToken) == null ? void 0 : _a3.call(handler, token, idx ?? { prompt: 0, completion: 0 }, this.runId, this._parentRunId, this.tags, fields));
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleLLMNewToken: ${err}`);
            if (handler.raiseError) {
              throw err;
            }
          }
        }
      }, handler.awaitHandlers)));
    }
    async handleLLMError(err, _runId, _parentRunId, _tags, extraParams) {
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a3;
        if (!handler.ignoreLLM) {
          try {
            await ((_a3 = handler.handleLLMError) == null ? void 0 : _a3.call(handler, err, this.runId, this._parentRunId, this.tags, extraParams));
          } catch (err2) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleLLMError: ${err2}`);
            if (handler.raiseError) {
              throw err2;
            }
          }
        }
      }, handler.awaitHandlers)));
    }
    async handleLLMEnd(output, _runId, _parentRunId, _tags, extraParams) {
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a3;
        if (!handler.ignoreLLM) {
          try {
            await ((_a3 = handler.handleLLMEnd) == null ? void 0 : _a3.call(handler, output, this.runId, this._parentRunId, this.tags, extraParams));
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleLLMEnd: ${err}`);
            if (handler.raiseError) {
              throw err;
            }
          }
        }
      }, handler.awaitHandlers)));
    }
  }
  class CallbackManagerForChainRun extends BaseRunManager {
    getChild(tag) {
      const manager = new CallbackManager(this.runId);
      manager.setHandlers(this.inheritableHandlers);
      manager.addTags(this.inheritableTags);
      manager.addMetadata(this.inheritableMetadata);
      if (tag) {
        manager.addTags([tag], false);
      }
      return manager;
    }
    async handleChainError(err, _runId, _parentRunId, _tags, kwargs) {
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a3;
        if (!handler.ignoreChain) {
          try {
            await ((_a3 = handler.handleChainError) == null ? void 0 : _a3.call(handler, err, this.runId, this._parentRunId, this.tags, kwargs));
          } catch (err2) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleChainError: ${err2}`);
            if (handler.raiseError) {
              throw err2;
            }
          }
        }
      }, handler.awaitHandlers)));
    }
    async handleChainEnd(output, _runId, _parentRunId, _tags, kwargs) {
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a3;
        if (!handler.ignoreChain) {
          try {
            await ((_a3 = handler.handleChainEnd) == null ? void 0 : _a3.call(handler, output, this.runId, this._parentRunId, this.tags, kwargs));
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleChainEnd: ${err}`);
            if (handler.raiseError) {
              throw err;
            }
          }
        }
      }, handler.awaitHandlers)));
    }
    async handleAgentAction(action) {
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a3;
        if (!handler.ignoreAgent) {
          try {
            await ((_a3 = handler.handleAgentAction) == null ? void 0 : _a3.call(handler, action, this.runId, this._parentRunId, this.tags));
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleAgentAction: ${err}`);
            if (handler.raiseError) {
              throw err;
            }
          }
        }
      }, handler.awaitHandlers)));
    }
    async handleAgentEnd(action) {
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a3;
        if (!handler.ignoreAgent) {
          try {
            await ((_a3 = handler.handleAgentEnd) == null ? void 0 : _a3.call(handler, action, this.runId, this._parentRunId, this.tags));
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleAgentEnd: ${err}`);
            if (handler.raiseError) {
              throw err;
            }
          }
        }
      }, handler.awaitHandlers)));
    }
  }
  class CallbackManagerForToolRun extends BaseRunManager {
    getChild(tag) {
      const manager = new CallbackManager(this.runId);
      manager.setHandlers(this.inheritableHandlers);
      manager.addTags(this.inheritableTags);
      manager.addMetadata(this.inheritableMetadata);
      if (tag) {
        manager.addTags([tag], false);
      }
      return manager;
    }
    async handleToolError(err) {
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a3;
        if (!handler.ignoreAgent) {
          try {
            await ((_a3 = handler.handleToolError) == null ? void 0 : _a3.call(handler, err, this.runId, this._parentRunId, this.tags));
          } catch (err2) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleToolError: ${err2}`);
            if (handler.raiseError) {
              throw err2;
            }
          }
        }
      }, handler.awaitHandlers)));
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async handleToolEnd(output) {
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a3;
        if (!handler.ignoreAgent) {
          try {
            await ((_a3 = handler.handleToolEnd) == null ? void 0 : _a3.call(handler, output, this.runId, this._parentRunId, this.tags));
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleToolEnd: ${err}`);
            if (handler.raiseError) {
              throw err;
            }
          }
        }
      }, handler.awaitHandlers)));
    }
  }
  class CallbackManager extends BaseCallbackManager {
    constructor(parentRunId, options) {
      super();
      Object.defineProperty(this, "handlers", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
      Object.defineProperty(this, "inheritableHandlers", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
      Object.defineProperty(this, "tags", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
      Object.defineProperty(this, "inheritableTags", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
      Object.defineProperty(this, "metadata", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: {}
      });
      Object.defineProperty(this, "inheritableMetadata", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: {}
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "callback_manager"
      });
      Object.defineProperty(this, "_parentRunId", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.handlers = (options == null ? void 0 : options.handlers) ?? this.handlers;
      this.inheritableHandlers = (options == null ? void 0 : options.inheritableHandlers) ?? this.inheritableHandlers;
      this.tags = (options == null ? void 0 : options.tags) ?? this.tags;
      this.inheritableTags = (options == null ? void 0 : options.inheritableTags) ?? this.inheritableTags;
      this.metadata = (options == null ? void 0 : options.metadata) ?? this.metadata;
      this.inheritableMetadata = (options == null ? void 0 : options.inheritableMetadata) ?? this.inheritableMetadata;
      this._parentRunId = parentRunId;
    }
    /**
     * Gets the parent run ID, if any.
     *
     * @returns The parent run ID.
     */
    getParentRunId() {
      return this._parentRunId;
    }
    async handleLLMStart(llm, prompts, runId = void 0, _parentRunId = void 0, extraParams = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
      return Promise.all(prompts.map(async (prompt, idx) => {
        const runId_ = idx === 0 && runId ? runId : v4();
        await Promise.all(this.handlers.map((handler) => {
          if (handler.ignoreLLM) {
            return;
          }
          if (isBaseTracer(handler)) {
            handler._createRunForLLMStart(llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
          }
          return consumeCallback(async () => {
            var _a3;
            try {
              await ((_a3 = handler.handleLLMStart) == null ? void 0 : _a3.call(handler, llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName));
            } catch (err) {
              const logFunction = handler.raiseError ? console.error : console.warn;
              logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);
              if (handler.raiseError) {
                throw err;
              }
            }
          }, handler.awaitHandlers);
        }));
        return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
      }));
    }
    async handleChatModelStart(llm, messages, runId = void 0, _parentRunId = void 0, extraParams = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
      return Promise.all(messages.map(async (messageGroup, idx) => {
        const runId_ = idx === 0 && runId ? runId : v4();
        await Promise.all(this.handlers.map((handler) => {
          if (handler.ignoreLLM) {
            return;
          }
          if (isBaseTracer(handler)) {
            handler._createRunForChatModelStart(llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
          }
          return consumeCallback(async () => {
            var _a3, _b2;
            try {
              if (handler.handleChatModelStart) {
                await ((_a3 = handler.handleChatModelStart) == null ? void 0 : _a3.call(handler, llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName));
              } else if (handler.handleLLMStart) {
                const messageString = getBufferString(messageGroup);
                await ((_b2 = handler.handleLLMStart) == null ? void 0 : _b2.call(handler, llm, [messageString], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName));
              }
            } catch (err) {
              const logFunction = handler.raiseError ? console.error : console.warn;
              logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);
              if (handler.raiseError) {
                throw err;
              }
            }
          }, handler.awaitHandlers);
        }));
        return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
      }));
    }
    async handleChainStart(chain, inputs, runId = v4(), runType = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
      await Promise.all(this.handlers.map((handler) => {
        if (handler.ignoreChain) {
          return;
        }
        if (isBaseTracer(handler)) {
          handler._createRunForChainStart(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName);
        }
        return consumeCallback(async () => {
          var _a3;
          try {
            await ((_a3 = handler.handleChainStart) == null ? void 0 : _a3.call(handler, chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName));
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleChainStart: ${err}`);
            if (handler.raiseError) {
              throw err;
            }
          }
        }, handler.awaitHandlers);
      }));
      return new CallbackManagerForChainRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }
    async handleToolStart(tool, input, runId = v4(), _parentRunId = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
      await Promise.all(this.handlers.map((handler) => {
        if (handler.ignoreAgent) {
          return;
        }
        if (isBaseTracer(handler)) {
          handler._createRunForToolStart(tool, input, runId, this._parentRunId, this.tags, this.metadata, runName);
        }
        return consumeCallback(async () => {
          var _a3;
          try {
            await ((_a3 = handler.handleToolStart) == null ? void 0 : _a3.call(handler, tool, input, runId, this._parentRunId, this.tags, this.metadata, runName));
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleToolStart: ${err}`);
            if (handler.raiseError) {
              throw err;
            }
          }
        }, handler.awaitHandlers);
      }));
      return new CallbackManagerForToolRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }
    async handleRetrieverStart(retriever, query, runId = v4(), _parentRunId = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
      await Promise.all(this.handlers.map((handler) => {
        if (handler.ignoreRetriever) {
          return;
        }
        if (isBaseTracer(handler)) {
          handler._createRunForRetrieverStart(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);
        }
        return consumeCallback(async () => {
          var _a3;
          try {
            await ((_a3 = handler.handleRetrieverStart) == null ? void 0 : _a3.call(handler, retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName));
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverStart: ${err}`);
            if (handler.raiseError) {
              throw err;
            }
          }
        }, handler.awaitHandlers);
      }));
      return new CallbackManagerForRetrieverRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }
    async handleCustomEvent(eventName, data, runId, _tags, _metadata) {
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a3;
        if (!handler.ignoreCustomEvent) {
          try {
            await ((_a3 = handler.handleCustomEvent) == null ? void 0 : _a3.call(handler, eventName, data, runId, this.tags, this.metadata));
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);
            if (handler.raiseError) {
              throw err;
            }
          }
        }
      }, handler.awaitHandlers)));
    }
    addHandler(handler, inherit = true) {
      this.handlers.push(handler);
      if (inherit) {
        this.inheritableHandlers.push(handler);
      }
    }
    removeHandler(handler) {
      this.handlers = this.handlers.filter((_handler) => _handler !== handler);
      this.inheritableHandlers = this.inheritableHandlers.filter((_handler) => _handler !== handler);
    }
    setHandlers(handlers, inherit = true) {
      this.handlers = [];
      this.inheritableHandlers = [];
      for (const handler of handlers) {
        this.addHandler(handler, inherit);
      }
    }
    addTags(tags, inherit = true) {
      this.removeTags(tags);
      this.tags.push(...tags);
      if (inherit) {
        this.inheritableTags.push(...tags);
      }
    }
    removeTags(tags) {
      this.tags = this.tags.filter((tag) => !tags.includes(tag));
      this.inheritableTags = this.inheritableTags.filter((tag) => !tags.includes(tag));
    }
    addMetadata(metadata, inherit = true) {
      this.metadata = { ...this.metadata, ...metadata };
      if (inherit) {
        this.inheritableMetadata = { ...this.inheritableMetadata, ...metadata };
      }
    }
    removeMetadata(metadata) {
      for (const key of Object.keys(metadata)) {
        delete this.metadata[key];
        delete this.inheritableMetadata[key];
      }
    }
    copy(additionalHandlers = [], inherit = true) {
      const manager = new CallbackManager(this._parentRunId);
      for (const handler of this.handlers) {
        const inheritable = this.inheritableHandlers.includes(handler);
        manager.addHandler(handler, inheritable);
      }
      for (const tag of this.tags) {
        const inheritable = this.inheritableTags.includes(tag);
        manager.addTags([tag], inheritable);
      }
      for (const key of Object.keys(this.metadata)) {
        const inheritable = Object.keys(this.inheritableMetadata).includes(key);
        manager.addMetadata({ [key]: this.metadata[key] }, inheritable);
      }
      for (const handler of additionalHandlers) {
        if (
          // Prevent multiple copies of console_callback_handler
          manager.handlers.filter((h) => h.name === "console_callback_handler").some((h) => h.name === handler.name)
        ) {
          continue;
        }
        manager.addHandler(handler, inherit);
      }
      return manager;
    }
    static fromHandlers(handlers) {
      class Handler extends BaseCallbackHandler {
        constructor() {
          super();
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: v4()
          });
          Object.assign(this, handlers);
        }
      }
      const manager = new this();
      manager.addHandler(new Handler());
      return manager;
    }
    static configure(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {
      return this._configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options);
    }
    // TODO: Deprecate async method in favor of this one.
    static _configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {
      var _a3, _b2;
      let callbackManager;
      if (inheritableHandlers || localHandlers) {
        if (Array.isArray(inheritableHandlers) || !inheritableHandlers) {
          callbackManager = new CallbackManager();
          callbackManager.setHandlers((inheritableHandlers == null ? void 0 : inheritableHandlers.map(ensureHandler)) ?? [], true);
        } else {
          callbackManager = inheritableHandlers;
        }
        callbackManager = callbackManager.copy(Array.isArray(localHandlers) ? localHandlers.map(ensureHandler) : localHandlers == null ? void 0 : localHandlers.handlers, false);
      }
      const verboseEnabled = getEnvironmentVariable("LANGCHAIN_VERBOSE") === "true" || (options == null ? void 0 : options.verbose);
      const tracingV2Enabled = ((_a3 = LangChainTracer.getTraceableRunTree()) == null ? void 0 : _a3.tracingEnabled) || isTracingEnabled();
      const tracingEnabled = tracingV2Enabled || (getEnvironmentVariable("LANGCHAIN_TRACING") ?? false);
      if (verboseEnabled || tracingEnabled) {
        if (!callbackManager) {
          callbackManager = new CallbackManager();
        }
        if (verboseEnabled && !callbackManager.handlers.some((handler) => handler.name === ConsoleCallbackHandler.prototype.name)) {
          const consoleHandler = new ConsoleCallbackHandler();
          callbackManager.addHandler(consoleHandler, true);
        }
        if (tracingEnabled && !callbackManager.handlers.some((handler) => handler.name === "langchain_tracer")) {
          if (tracingV2Enabled) {
            const tracerV2 = new LangChainTracer();
            callbackManager.addHandler(tracerV2, true);
            callbackManager._parentRunId = ((_b2 = LangChainTracer.getTraceableRunTree()) == null ? void 0 : _b2.id) ?? callbackManager._parentRunId;
          }
        }
      }
      for (const { contextVar, inheritable = true, handlerClass, envVar } of _getConfigureHooks()) {
        const createIfNotInContext = envVar && getEnvironmentVariable(envVar) === "true" && handlerClass;
        let handler;
        const contextVarValue = contextVar !== void 0 ? getContextVariable(contextVar) : void 0;
        if (contextVarValue && isBaseCallbackHandler(contextVarValue)) {
          handler = contextVarValue;
        } else if (createIfNotInContext) {
          handler = new handlerClass({});
        }
        if (handler !== void 0) {
          if (!callbackManager) {
            callbackManager = new CallbackManager();
          }
          if (!callbackManager.handlers.some((h) => h.name === handler.name)) {
            callbackManager.addHandler(handler, inheritable);
          }
        }
      }
      if (inheritableTags || localTags) {
        if (callbackManager) {
          callbackManager.addTags(inheritableTags ?? []);
          callbackManager.addTags(localTags ?? [], false);
        }
      }
      if (inheritableMetadata || localMetadata) {
        if (callbackManager) {
          callbackManager.addMetadata(inheritableMetadata ?? {});
          callbackManager.addMetadata(localMetadata ?? {}, false);
        }
      }
      return callbackManager;
    }
  }
  function ensureHandler(handler) {
    if ("name" in handler) {
      return handler;
    }
    return BaseCallbackHandler.fromMethods(handler);
  }
  class MockAsyncLocalStorage {
    getStore() {
      return void 0;
    }
    run(_store, callback) {
      return callback();
    }
    enterWith(_store) {
      return void 0;
    }
  }
  const mockAsyncLocalStorage = new MockAsyncLocalStorage();
  const LC_CHILD_KEY = Symbol.for("lc:child_config");
  class AsyncLocalStorageProvider {
    getInstance() {
      return getGlobalAsyncLocalStorageInstance() ?? mockAsyncLocalStorage;
    }
    getRunnableConfig() {
      var _a3, _b2;
      const storage2 = this.getInstance();
      return (_b2 = (_a3 = storage2.getStore()) == null ? void 0 : _a3.extra) == null ? void 0 : _b2[LC_CHILD_KEY];
    }
    runWithConfig(config2, callback, avoidCreatingRootRunTree) {
      var _a3;
      const callbackManager = CallbackManager._configureSync(config2 == null ? void 0 : config2.callbacks, void 0, config2 == null ? void 0 : config2.tags, void 0, config2 == null ? void 0 : config2.metadata);
      const storage2 = this.getInstance();
      const previousValue = storage2.getStore();
      const parentRunId = callbackManager == null ? void 0 : callbackManager.getParentRunId();
      const langChainTracer = (_a3 = callbackManager == null ? void 0 : callbackManager.handlers) == null ? void 0 : _a3.find((handler) => (handler == null ? void 0 : handler.name) === "langchain_tracer");
      let runTree;
      if (langChainTracer && parentRunId) {
        runTree = langChainTracer.convertToRunTree(parentRunId);
      } else if (!avoidCreatingRootRunTree) {
        runTree = new RunTree({
          name: "<runnable_lambda>",
          tracingEnabled: false
        });
      }
      if (runTree) {
        runTree.extra = { ...runTree.extra, [LC_CHILD_KEY]: config2 };
      }
      if (previousValue !== void 0 && previousValue[_CONTEXT_VARIABLES_KEY] !== void 0) {
        if (runTree === void 0) {
          runTree = {};
        }
        runTree[_CONTEXT_VARIABLES_KEY] = previousValue[_CONTEXT_VARIABLES_KEY];
      }
      return storage2.run(runTree, callback);
    }
    initializeGlobalInstance(instance) {
      if (getGlobalAsyncLocalStorageInstance() === void 0) {
        setGlobalAsyncLocalStorageInstance(instance);
      }
    }
  }
  const AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();
  const DEFAULT_RECURSION_LIMIT = 25;
  async function getCallbackManagerForConfig(config2) {
    return CallbackManager._configureSync(config2 == null ? void 0 : config2.callbacks, void 0, config2 == null ? void 0 : config2.tags, void 0, config2 == null ? void 0 : config2.metadata);
  }
  function mergeConfigs(...configs) {
    const copy = {};
    for (const options of configs.filter((c) => !!c)) {
      for (const key of Object.keys(options)) {
        if (key === "metadata") {
          copy[key] = { ...copy[key], ...options[key] };
        } else if (key === "tags") {
          const baseKeys = copy[key] ?? [];
          copy[key] = [...new Set(baseKeys.concat(options[key] ?? []))];
        } else if (key === "configurable") {
          copy[key] = { ...copy[key], ...options[key] };
        } else if (key === "timeout") {
          if (copy.timeout === void 0) {
            copy.timeout = options.timeout;
          } else if (options.timeout !== void 0) {
            copy.timeout = Math.min(copy.timeout, options.timeout);
          }
        } else if (key === "signal") {
          if (copy.signal === void 0) {
            copy.signal = options.signal;
          } else if (options.signal !== void 0) {
            if ("any" in AbortSignal) {
              copy.signal = AbortSignal.any([
                copy.signal,
                options.signal
              ]);
            } else {
              copy.signal = options.signal;
            }
          }
        } else if (key === "callbacks") {
          const baseCallbacks = copy.callbacks;
          const providedCallbacks = options.callbacks;
          if (Array.isArray(providedCallbacks)) {
            if (!baseCallbacks) {
              copy.callbacks = providedCallbacks;
            } else if (Array.isArray(baseCallbacks)) {
              copy.callbacks = baseCallbacks.concat(providedCallbacks);
            } else {
              const manager = baseCallbacks.copy();
              for (const callback of providedCallbacks) {
                manager.addHandler(ensureHandler(callback), true);
              }
              copy.callbacks = manager;
            }
          } else if (providedCallbacks) {
            if (!baseCallbacks) {
              copy.callbacks = providedCallbacks;
            } else if (Array.isArray(baseCallbacks)) {
              const manager = providedCallbacks.copy();
              for (const callback of baseCallbacks) {
                manager.addHandler(ensureHandler(callback), true);
              }
              copy.callbacks = manager;
            } else {
              copy.callbacks = new CallbackManager(providedCallbacks._parentRunId, {
                handlers: baseCallbacks.handlers.concat(providedCallbacks.handlers),
                inheritableHandlers: baseCallbacks.inheritableHandlers.concat(providedCallbacks.inheritableHandlers),
                tags: Array.from(new Set(baseCallbacks.tags.concat(providedCallbacks.tags))),
                inheritableTags: Array.from(new Set(baseCallbacks.inheritableTags.concat(providedCallbacks.inheritableTags))),
                metadata: {
                  ...baseCallbacks.metadata,
                  ...providedCallbacks.metadata
                }
              });
            }
          }
        } else {
          const typedKey = key;
          copy[typedKey] = options[typedKey] ?? copy[typedKey];
        }
      }
    }
    return copy;
  }
  const PRIMITIVES = /* @__PURE__ */ new Set(["string", "number", "boolean"]);
  function ensureConfig(config2) {
    var _a3;
    const implicitConfig = AsyncLocalStorageProviderSingleton.getRunnableConfig();
    let empty = {
      tags: [],
      metadata: {},
      recursionLimit: 25,
      runId: void 0
    };
    if (implicitConfig) {
      const { runId, runName, ...rest } = implicitConfig;
      empty = Object.entries(rest).reduce(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (currentConfig, [key, value]) => {
          if (value !== void 0) {
            currentConfig[key] = value;
          }
          return currentConfig;
        },
        empty
      );
    }
    if (config2) {
      empty = Object.entries(config2).reduce(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (currentConfig, [key, value]) => {
          if (value !== void 0) {
            currentConfig[key] = value;
          }
          return currentConfig;
        },
        empty
      );
    }
    if (empty == null ? void 0 : empty.configurable) {
      for (const key of Object.keys(empty.configurable)) {
        if (PRIMITIVES.has(typeof empty.configurable[key]) && !((_a3 = empty.metadata) == null ? void 0 : _a3[key])) {
          if (!empty.metadata) {
            empty.metadata = {};
          }
          empty.metadata[key] = empty.configurable[key];
        }
      }
    }
    if (empty.timeout !== void 0) {
      if (empty.timeout <= 0) {
        throw new Error("Timeout must be a positive number");
      }
      const timeoutSignal = AbortSignal.timeout(empty.timeout);
      if (empty.signal !== void 0) {
        if ("any" in AbortSignal) {
          empty.signal = AbortSignal.any([empty.signal, timeoutSignal]);
        }
      } else {
        empty.signal = timeoutSignal;
      }
      delete empty.timeout;
    }
    return empty;
  }
  function patchConfig(config2 = {}, { callbacks, maxConcurrency, recursionLimit, runName, configurable, runId } = {}) {
    const newConfig = ensureConfig(config2);
    if (callbacks !== void 0) {
      delete newConfig.runName;
      newConfig.callbacks = callbacks;
    }
    if (recursionLimit !== void 0) {
      newConfig.recursionLimit = recursionLimit;
    }
    if (maxConcurrency !== void 0) {
      newConfig.maxConcurrency = maxConcurrency;
    }
    if (runName !== void 0) {
      newConfig.runName = runName;
    }
    if (configurable !== void 0) {
      newConfig.configurable = { ...newConfig.configurable, ...configurable };
    }
    if (runId !== void 0) {
      delete newConfig.runId;
    }
    return newConfig;
  }
  function pickRunnableConfigKeys(config2) {
    return config2 ? {
      configurable: config2.configurable,
      recursionLimit: config2.recursionLimit,
      callbacks: config2.callbacks,
      tags: config2.tags,
      metadata: config2.metadata,
      maxConcurrency: config2.maxConcurrency,
      timeout: config2.timeout,
      signal: config2.signal
    } : void 0;
  }
  async function raceWithSignal(promise, signal) {
    if (signal === void 0) {
      return promise;
    }
    let listener;
    return Promise.race([
      promise.catch((err) => {
        if (!(signal == null ? void 0 : signal.aborted)) {
          throw err;
        } else {
          return void 0;
        }
      }),
      new Promise((_, reject) => {
        listener = () => {
          reject(new Error("Aborted"));
        };
        signal.addEventListener("abort", listener);
        if (signal.aborted) {
          reject(new Error("Aborted"));
        }
      })
    ]).finally(() => signal.removeEventListener("abort", listener));
  }
  class IterableReadableStream extends ReadableStream {
    constructor() {
      super(...arguments);
      Object.defineProperty(this, "reader", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
    }
    ensureReader() {
      if (!this.reader) {
        this.reader = this.getReader();
      }
    }
    async next() {
      this.ensureReader();
      try {
        const result = await this.reader.read();
        if (result.done) {
          this.reader.releaseLock();
          return {
            done: true,
            value: void 0
          };
        } else {
          return {
            done: false,
            value: result.value
          };
        }
      } catch (e) {
        this.reader.releaseLock();
        throw e;
      }
    }
    async return() {
      this.ensureReader();
      if (this.locked) {
        const cancelPromise = this.reader.cancel();
        this.reader.releaseLock();
        await cancelPromise;
      }
      return { done: true, value: void 0 };
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async throw(e) {
      this.ensureReader();
      if (this.locked) {
        const cancelPromise = this.reader.cancel();
        this.reader.releaseLock();
        await cancelPromise;
      }
      throw e;
    }
    [Symbol.asyncIterator]() {
      return this;
    }
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore Not present in Node 18 types, required in latest Node 22
    async [Symbol.asyncDispose]() {
      await this.return();
    }
    static fromReadableStream(stream) {
      const reader = stream.getReader();
      return new IterableReadableStream({
        start(controller) {
          return pump();
          function pump() {
            return reader.read().then(({ done, value }) => {
              if (done) {
                controller.close();
                return;
              }
              controller.enqueue(value);
              return pump();
            });
          }
        },
        cancel() {
          reader.releaseLock();
        }
      });
    }
    static fromAsyncGenerator(generator) {
      return new IterableReadableStream({
        async pull(controller) {
          const { value, done } = await generator.next();
          if (done) {
            controller.close();
          }
          controller.enqueue(value);
        },
        async cancel(reason) {
          await generator.return(reason);
        }
      });
    }
  }
  function atee(iter, length = 2) {
    const buffers = Array.from({ length }, () => []);
    return buffers.map(async function* makeIter(buffer) {
      while (true) {
        if (buffer.length === 0) {
          const result = await iter.next();
          for (const buffer2 of buffers) {
            buffer2.push(result);
          }
        } else if (buffer[0].done) {
          return;
        } else {
          yield buffer.shift().value;
        }
      }
    });
  }
  function concat(first2, second) {
    if (Array.isArray(first2) && Array.isArray(second)) {
      return first2.concat(second);
    } else if (typeof first2 === "string" && typeof second === "string") {
      return first2 + second;
    } else if (typeof first2 === "number" && typeof second === "number") {
      return first2 + second;
    } else if (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      "concat" in first2 && // eslint-disable-next-line @typescript-eslint/no-explicit-any
      typeof first2.concat === "function"
    ) {
      return first2.concat(second);
    } else if (typeof first2 === "object" && typeof second === "object") {
      const chunk = { ...first2 };
      for (const [key, value] of Object.entries(second)) {
        if (key in chunk && !Array.isArray(chunk[key])) {
          chunk[key] = concat(chunk[key], value);
        } else {
          chunk[key] = value;
        }
      }
      return chunk;
    } else {
      throw new Error(`Cannot concat ${typeof first2} and ${typeof second}`);
    }
  }
  class AsyncGeneratorWithSetup {
    constructor(params) {
      var _a3;
      Object.defineProperty(this, "generator", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "setup", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "config", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "signal", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "firstResult", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "firstResultUsed", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      this.generator = params.generator;
      this.config = params.config;
      this.signal = params.signal ?? ((_a3 = this.config) == null ? void 0 : _a3.signal);
      this.setup = new Promise((resolve, reject) => {
        void AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(params.config), async () => {
          this.firstResult = params.generator.next();
          if (params.startSetup) {
            this.firstResult.then(params.startSetup).then(resolve, reject);
          } else {
            this.firstResult.then((_result2) => resolve(void 0), reject);
          }
        }, true);
      });
    }
    async next(...args) {
      var _a3;
      (_a3 = this.signal) == null ? void 0 : _a3.throwIfAborted();
      if (!this.firstResultUsed) {
        this.firstResultUsed = true;
        return this.firstResult;
      }
      return AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(this.config), this.signal ? async () => {
        return raceWithSignal(this.generator.next(...args), this.signal);
      } : async () => {
        return this.generator.next(...args);
      }, true);
    }
    async return(value) {
      return this.generator.return(value);
    }
    async throw(e) {
      return this.generator.throw(e);
    }
    [Symbol.asyncIterator]() {
      return this;
    }
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore Not present in Node 18 types, required in latest Node 22
    async [Symbol.asyncDispose]() {
      await this.return();
    }
  }
  async function pipeGeneratorWithSetup(to, generator, startSetup, signal, ...args) {
    const gen = new AsyncGeneratorWithSetup({
      generator,
      startSetup,
      signal
    });
    const setup = await gen.setup;
    return { output: to(gen, setup, ...args), setup };
  }
  class RunLogPatch {
    constructor(fields) {
      Object.defineProperty(this, "ops", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.ops = fields.ops ?? [];
    }
    concat(other) {
      const ops = this.ops.concat(other.ops);
      const states = applyPatch({}, ops);
      return new RunLog({
        ops,
        state: states[states.length - 1].newDocument
      });
    }
  }
  class RunLog extends RunLogPatch {
    constructor(fields) {
      super(fields);
      Object.defineProperty(this, "state", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.state = fields.state;
    }
    concat(other) {
      const ops = this.ops.concat(other.ops);
      const states = applyPatch(this.state, other.ops);
      return new RunLog({ ops, state: states[states.length - 1].newDocument });
    }
    static fromRunLogPatch(patch) {
      const states = applyPatch({}, patch.ops);
      return new RunLog({
        ops: patch.ops,
        state: states[states.length - 1].newDocument
      });
    }
  }
  const isLogStreamHandler = (handler) => handler.name === "log_stream_tracer";
  async function _getStandardizedInputs(run, schemaFormat) {
    if (schemaFormat === "original") {
      throw new Error("Do not assign inputs with original schema drop the key for now. When inputs are added to streamLog they should be added with standardized schema for streaming events.");
    }
    const { inputs } = run;
    if (["retriever", "llm", "prompt"].includes(run.run_type)) {
      return inputs;
    }
    if (Object.keys(inputs).length === 1 && (inputs == null ? void 0 : inputs.input) === "") {
      return void 0;
    }
    return inputs.input;
  }
  async function _getStandardizedOutputs(run, schemaFormat) {
    const { outputs } = run;
    if (schemaFormat === "original") {
      return outputs;
    }
    if (["retriever", "llm", "prompt"].includes(run.run_type)) {
      return outputs;
    }
    if (outputs !== void 0 && Object.keys(outputs).length === 1 && (outputs == null ? void 0 : outputs.output) !== void 0) {
      return outputs.output;
    }
    return outputs;
  }
  function isChatGenerationChunk(x) {
    return x !== void 0 && x.message !== void 0;
  }
  class LogStreamCallbackHandler extends BaseTracer {
    constructor(fields) {
      super({ _awaitHandler: true, ...fields });
      Object.defineProperty(this, "autoClose", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "includeNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "includeTypes", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "includeTags", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "excludeNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "excludeTypes", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "excludeTags", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "_schemaFormat", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "original"
      });
      Object.defineProperty(this, "rootId", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "keyMapByRunId", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: {}
      });
      Object.defineProperty(this, "counterMapByRunName", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: {}
      });
      Object.defineProperty(this, "transformStream", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "writer", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "receiveStream", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "log_stream_tracer"
      });
      Object.defineProperty(this, "lc_prefer_streaming", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      this.autoClose = (fields == null ? void 0 : fields.autoClose) ?? true;
      this.includeNames = fields == null ? void 0 : fields.includeNames;
      this.includeTypes = fields == null ? void 0 : fields.includeTypes;
      this.includeTags = fields == null ? void 0 : fields.includeTags;
      this.excludeNames = fields == null ? void 0 : fields.excludeNames;
      this.excludeTypes = fields == null ? void 0 : fields.excludeTypes;
      this.excludeTags = fields == null ? void 0 : fields.excludeTags;
      this._schemaFormat = (fields == null ? void 0 : fields._schemaFormat) ?? this._schemaFormat;
      this.transformStream = new TransformStream();
      this.writer = this.transformStream.writable.getWriter();
      this.receiveStream = IterableReadableStream.fromReadableStream(this.transformStream.readable);
    }
    [Symbol.asyncIterator]() {
      return this.receiveStream;
    }
    async persistRun(_run) {
    }
    _includeRun(run) {
      if (run.id === this.rootId) {
        return false;
      }
      const runTags = run.tags ?? [];
      let include = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
      if (this.includeNames !== void 0) {
        include = include || this.includeNames.includes(run.name);
      }
      if (this.includeTypes !== void 0) {
        include = include || this.includeTypes.includes(run.run_type);
      }
      if (this.includeTags !== void 0) {
        include = include || runTags.find((tag) => {
          var _a3;
          return (_a3 = this.includeTags) == null ? void 0 : _a3.includes(tag);
        }) !== void 0;
      }
      if (this.excludeNames !== void 0) {
        include = include && !this.excludeNames.includes(run.name);
      }
      if (this.excludeTypes !== void 0) {
        include = include && !this.excludeTypes.includes(run.run_type);
      }
      if (this.excludeTags !== void 0) {
        include = include && runTags.every((tag) => {
          var _a3;
          return !((_a3 = this.excludeTags) == null ? void 0 : _a3.includes(tag));
        });
      }
      return include;
    }
    async *tapOutputIterable(runId, output) {
      for await (const chunk of output) {
        if (runId !== this.rootId) {
          const key = this.keyMapByRunId[runId];
          if (key) {
            await this.writer.write(new RunLogPatch({
              ops: [
                {
                  op: "add",
                  path: `/logs/${key}/streamed_output/-`,
                  value: chunk
                }
              ]
            }));
          }
        }
        yield chunk;
      }
    }
    async onRunCreate(run) {
      var _a3;
      if (this.rootId === void 0) {
        this.rootId = run.id;
        await this.writer.write(new RunLogPatch({
          ops: [
            {
              op: "replace",
              path: "",
              value: {
                id: run.id,
                name: run.name,
                type: run.run_type,
                streamed_output: [],
                final_output: void 0,
                logs: {}
              }
            }
          ]
        }));
      }
      if (!this._includeRun(run)) {
        return;
      }
      if (this.counterMapByRunName[run.name] === void 0) {
        this.counterMapByRunName[run.name] = 0;
      }
      this.counterMapByRunName[run.name] += 1;
      const count = this.counterMapByRunName[run.name];
      this.keyMapByRunId[run.id] = count === 1 ? run.name : `${run.name}:${count}`;
      const logEntry = {
        id: run.id,
        name: run.name,
        type: run.run_type,
        tags: run.tags ?? [],
        metadata: ((_a3 = run.extra) == null ? void 0 : _a3.metadata) ?? {},
        start_time: new Date(run.start_time).toISOString(),
        streamed_output: [],
        streamed_output_str: [],
        final_output: void 0,
        end_time: void 0
      };
      if (this._schemaFormat === "streaming_events") {
        logEntry.inputs = await _getStandardizedInputs(run, this._schemaFormat);
      }
      await this.writer.write(new RunLogPatch({
        ops: [
          {
            op: "add",
            path: `/logs/${this.keyMapByRunId[run.id]}`,
            value: logEntry
          }
        ]
      }));
    }
    async onRunUpdate(run) {
      try {
        const runName = this.keyMapByRunId[run.id];
        if (runName === void 0) {
          return;
        }
        const ops = [];
        if (this._schemaFormat === "streaming_events") {
          ops.push({
            op: "replace",
            path: `/logs/${runName}/inputs`,
            value: await _getStandardizedInputs(run, this._schemaFormat)
          });
        }
        ops.push({
          op: "add",
          path: `/logs/${runName}/final_output`,
          value: await _getStandardizedOutputs(run, this._schemaFormat)
        });
        if (run.end_time !== void 0) {
          ops.push({
            op: "add",
            path: `/logs/${runName}/end_time`,
            value: new Date(run.end_time).toISOString()
          });
        }
        const patch = new RunLogPatch({ ops });
        await this.writer.write(patch);
      } finally {
        if (run.id === this.rootId) {
          const patch = new RunLogPatch({
            ops: [
              {
                op: "replace",
                path: "/final_output",
                value: await _getStandardizedOutputs(run, this._schemaFormat)
              }
            ]
          });
          await this.writer.write(patch);
          if (this.autoClose) {
            await this.writer.close();
          }
        }
      }
    }
    async onLLMNewToken(run, token, kwargs) {
      const runName = this.keyMapByRunId[run.id];
      if (runName === void 0) {
        return;
      }
      const isChatModel = run.inputs.messages !== void 0;
      let streamedOutputValue;
      if (isChatModel) {
        if (isChatGenerationChunk(kwargs == null ? void 0 : kwargs.chunk)) {
          streamedOutputValue = kwargs == null ? void 0 : kwargs.chunk;
        } else {
          streamedOutputValue = new AIMessageChunk({
            id: `run-${run.id}`,
            content: token
          });
        }
      } else {
        streamedOutputValue = token;
      }
      const patch = new RunLogPatch({
        ops: [
          {
            op: "add",
            path: `/logs/${runName}/streamed_output_str/-`,
            value: token
          },
          {
            op: "add",
            path: `/logs/${runName}/streamed_output/-`,
            value: streamedOutputValue
          }
        ]
      });
      await this.writer.write(patch);
    }
  }
  const RUN_KEY = "__run";
  class GenerationChunk {
    constructor(fields) {
      Object.defineProperty(this, "text", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "generationInfo", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.text = fields.text;
      this.generationInfo = fields.generationInfo;
    }
    concat(chunk) {
      return new GenerationChunk({
        text: this.text + chunk.text,
        generationInfo: {
          ...this.generationInfo,
          ...chunk.generationInfo
        }
      });
    }
  }
  class ChatGenerationChunk extends GenerationChunk {
    constructor(fields) {
      super(fields);
      Object.defineProperty(this, "message", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.message = fields.message;
    }
    concat(chunk) {
      return new ChatGenerationChunk({
        text: this.text + chunk.text,
        generationInfo: {
          ...this.generationInfo,
          ...chunk.generationInfo
        },
        message: this.message.concat(chunk.message)
      });
    }
  }
  function assignName({ name, serialized }) {
    if (name !== void 0) {
      return name;
    }
    if ((serialized == null ? void 0 : serialized.name) !== void 0) {
      return serialized.name;
    } else if ((serialized == null ? void 0 : serialized.id) !== void 0 && Array.isArray(serialized == null ? void 0 : serialized.id)) {
      return serialized.id[serialized.id.length - 1];
    }
    return "Unnamed";
  }
  const isStreamEventsHandler = (handler) => handler.name === "event_stream_tracer";
  class EventStreamCallbackHandler extends BaseTracer {
    constructor(fields) {
      super({ _awaitHandler: true, ...fields });
      Object.defineProperty(this, "autoClose", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "includeNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "includeTypes", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "includeTags", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "excludeNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "excludeTypes", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "excludeTags", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "runInfoMap", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /* @__PURE__ */ new Map()
      });
      Object.defineProperty(this, "tappedPromises", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /* @__PURE__ */ new Map()
      });
      Object.defineProperty(this, "transformStream", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "writer", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "receiveStream", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "event_stream_tracer"
      });
      Object.defineProperty(this, "lc_prefer_streaming", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      this.autoClose = (fields == null ? void 0 : fields.autoClose) ?? true;
      this.includeNames = fields == null ? void 0 : fields.includeNames;
      this.includeTypes = fields == null ? void 0 : fields.includeTypes;
      this.includeTags = fields == null ? void 0 : fields.includeTags;
      this.excludeNames = fields == null ? void 0 : fields.excludeNames;
      this.excludeTypes = fields == null ? void 0 : fields.excludeTypes;
      this.excludeTags = fields == null ? void 0 : fields.excludeTags;
      this.transformStream = new TransformStream();
      this.writer = this.transformStream.writable.getWriter();
      this.receiveStream = IterableReadableStream.fromReadableStream(this.transformStream.readable);
    }
    [Symbol.asyncIterator]() {
      return this.receiveStream;
    }
    async persistRun(_run) {
    }
    _includeRun(run) {
      const runTags = run.tags ?? [];
      let include = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
      if (this.includeNames !== void 0) {
        include = include || this.includeNames.includes(run.name);
      }
      if (this.includeTypes !== void 0) {
        include = include || this.includeTypes.includes(run.runType);
      }
      if (this.includeTags !== void 0) {
        include = include || runTags.find((tag) => {
          var _a3;
          return (_a3 = this.includeTags) == null ? void 0 : _a3.includes(tag);
        }) !== void 0;
      }
      if (this.excludeNames !== void 0) {
        include = include && !this.excludeNames.includes(run.name);
      }
      if (this.excludeTypes !== void 0) {
        include = include && !this.excludeTypes.includes(run.runType);
      }
      if (this.excludeTags !== void 0) {
        include = include && runTags.every((tag) => {
          var _a3;
          return !((_a3 = this.excludeTags) == null ? void 0 : _a3.includes(tag));
        });
      }
      return include;
    }
    async *tapOutputIterable(runId, outputStream) {
      const firstChunk = await outputStream.next();
      if (firstChunk.done) {
        return;
      }
      const runInfo = this.runInfoMap.get(runId);
      if (runInfo === void 0) {
        yield firstChunk.value;
        return;
      }
      function _formatOutputChunk(eventType, data) {
        if (eventType === "llm" && typeof data === "string") {
          return new GenerationChunk({ text: data });
        }
        return data;
      }
      let tappedPromise = this.tappedPromises.get(runId);
      if (tappedPromise === void 0) {
        let tappedPromiseResolver;
        tappedPromise = new Promise((resolve) => {
          tappedPromiseResolver = resolve;
        });
        this.tappedPromises.set(runId, tappedPromise);
        try {
          const event = {
            event: `on_${runInfo.runType}_stream`,
            run_id: runId,
            name: runInfo.name,
            tags: runInfo.tags,
            metadata: runInfo.metadata,
            data: {}
          };
          await this.send({
            ...event,
            data: {
              chunk: _formatOutputChunk(runInfo.runType, firstChunk.value)
            }
          }, runInfo);
          yield firstChunk.value;
          for await (const chunk of outputStream) {
            if (runInfo.runType !== "tool" && runInfo.runType !== "retriever") {
              await this.send({
                ...event,
                data: {
                  chunk: _formatOutputChunk(runInfo.runType, chunk)
                }
              }, runInfo);
            }
            yield chunk;
          }
        } finally {
          tappedPromiseResolver();
        }
      } else {
        yield firstChunk.value;
        for await (const chunk of outputStream) {
          yield chunk;
        }
      }
    }
    async send(payload, run) {
      if (this._includeRun(run)) {
        await this.writer.write(payload);
      }
    }
    async sendEndEvent(payload, run) {
      const tappedPromise = this.tappedPromises.get(payload.run_id);
      if (tappedPromise !== void 0) {
        void tappedPromise.then(() => {
          void this.send(payload, run);
        });
      } else {
        await this.send(payload, run);
      }
    }
    async onLLMStart(run) {
      var _a3, _b2;
      const runName = assignName(run);
      const runType = run.inputs.messages !== void 0 ? "chat_model" : "llm";
      const runInfo = {
        tags: run.tags ?? [],
        metadata: ((_a3 = run.extra) == null ? void 0 : _a3.metadata) ?? {},
        name: runName,
        runType,
        inputs: run.inputs
      };
      this.runInfoMap.set(run.id, runInfo);
      const eventName = `on_${runType}_start`;
      await this.send({
        event: eventName,
        data: {
          input: run.inputs
        },
        name: runName,
        tags: run.tags ?? [],
        run_id: run.id,
        metadata: ((_b2 = run.extra) == null ? void 0 : _b2.metadata) ?? {}
      }, runInfo);
    }
    async onLLMNewToken(run, token, kwargs) {
      const runInfo = this.runInfoMap.get(run.id);
      let chunk;
      let eventName;
      if (runInfo === void 0) {
        throw new Error(`onLLMNewToken: Run ID ${run.id} not found in run map.`);
      }
      if (this.runInfoMap.size === 1) {
        return;
      }
      if (runInfo.runType === "chat_model") {
        eventName = "on_chat_model_stream";
        if ((kwargs == null ? void 0 : kwargs.chunk) === void 0) {
          chunk = new AIMessageChunk({ content: token, id: `run-${run.id}` });
        } else {
          chunk = kwargs.chunk.message;
        }
      } else if (runInfo.runType === "llm") {
        eventName = "on_llm_stream";
        if ((kwargs == null ? void 0 : kwargs.chunk) === void 0) {
          chunk = new GenerationChunk({ text: token });
        } else {
          chunk = kwargs.chunk;
        }
      } else {
        throw new Error(`Unexpected run type ${runInfo.runType}`);
      }
      await this.send({
        event: eventName,
        data: {
          chunk
        },
        run_id: run.id,
        name: runInfo.name,
        tags: runInfo.tags,
        metadata: runInfo.metadata
      }, runInfo);
    }
    async onLLMEnd(run) {
      var _a3, _b2, _c2;
      const runInfo = this.runInfoMap.get(run.id);
      this.runInfoMap.delete(run.id);
      let eventName;
      if (runInfo === void 0) {
        throw new Error(`onLLMEnd: Run ID ${run.id} not found in run map.`);
      }
      const generations = (_a3 = run.outputs) == null ? void 0 : _a3.generations;
      let output;
      if (runInfo.runType === "chat_model") {
        for (const generation of generations ?? []) {
          if (output !== void 0) {
            break;
          }
          output = (_b2 = generation[0]) == null ? void 0 : _b2.message;
        }
        eventName = "on_chat_model_end";
      } else if (runInfo.runType === "llm") {
        output = {
          generations: generations == null ? void 0 : generations.map((generation) => {
            return generation.map((chunk) => {
              return {
                text: chunk.text,
                generationInfo: chunk.generationInfo
              };
            });
          }),
          llmOutput: ((_c2 = run.outputs) == null ? void 0 : _c2.llmOutput) ?? {}
        };
        eventName = "on_llm_end";
      } else {
        throw new Error(`onLLMEnd: Unexpected run type: ${runInfo.runType}`);
      }
      await this.sendEndEvent({
        event: eventName,
        data: {
          output,
          input: runInfo.inputs
        },
        run_id: run.id,
        name: runInfo.name,
        tags: runInfo.tags,
        metadata: runInfo.metadata
      }, runInfo);
    }
    async onChainStart(run) {
      var _a3, _b2;
      const runName = assignName(run);
      const runType = run.run_type ?? "chain";
      const runInfo = {
        tags: run.tags ?? [],
        metadata: ((_a3 = run.extra) == null ? void 0 : _a3.metadata) ?? {},
        name: runName,
        runType: run.run_type
      };
      let eventData = {};
      if (run.inputs.input === "" && Object.keys(run.inputs).length === 1) {
        eventData = {};
        runInfo.inputs = {};
      } else if (run.inputs.input !== void 0) {
        eventData.input = run.inputs.input;
        runInfo.inputs = run.inputs.input;
      } else {
        eventData.input = run.inputs;
        runInfo.inputs = run.inputs;
      }
      this.runInfoMap.set(run.id, runInfo);
      await this.send({
        event: `on_${runType}_start`,
        data: eventData,
        name: runName,
        tags: run.tags ?? [],
        run_id: run.id,
        metadata: ((_b2 = run.extra) == null ? void 0 : _b2.metadata) ?? {}
      }, runInfo);
    }
    async onChainEnd(run) {
      var _a3;
      const runInfo = this.runInfoMap.get(run.id);
      this.runInfoMap.delete(run.id);
      if (runInfo === void 0) {
        throw new Error(`onChainEnd: Run ID ${run.id} not found in run map.`);
      }
      const eventName = `on_${run.run_type}_end`;
      const inputs = run.inputs ?? runInfo.inputs ?? {};
      const outputs = ((_a3 = run.outputs) == null ? void 0 : _a3.output) ?? run.outputs;
      const data = {
        output: outputs,
        input: inputs
      };
      if (inputs.input && Object.keys(inputs).length === 1) {
        data.input = inputs.input;
        runInfo.inputs = inputs.input;
      }
      await this.sendEndEvent({
        event: eventName,
        data,
        run_id: run.id,
        name: runInfo.name,
        tags: runInfo.tags,
        metadata: runInfo.metadata ?? {}
      }, runInfo);
    }
    async onToolStart(run) {
      var _a3, _b2;
      const runName = assignName(run);
      const runInfo = {
        tags: run.tags ?? [],
        metadata: ((_a3 = run.extra) == null ? void 0 : _a3.metadata) ?? {},
        name: runName,
        runType: "tool",
        inputs: run.inputs ?? {}
      };
      this.runInfoMap.set(run.id, runInfo);
      await this.send({
        event: "on_tool_start",
        data: {
          input: run.inputs ?? {}
        },
        name: runName,
        run_id: run.id,
        tags: run.tags ?? [],
        metadata: ((_b2 = run.extra) == null ? void 0 : _b2.metadata) ?? {}
      }, runInfo);
    }
    async onToolEnd(run) {
      var _a3;
      const runInfo = this.runInfoMap.get(run.id);
      this.runInfoMap.delete(run.id);
      if (runInfo === void 0) {
        throw new Error(`onToolEnd: Run ID ${run.id} not found in run map.`);
      }
      if (runInfo.inputs === void 0) {
        throw new Error(`onToolEnd: Run ID ${run.id} is a tool call, and is expected to have traced inputs.`);
      }
      const output = ((_a3 = run.outputs) == null ? void 0 : _a3.output) === void 0 ? run.outputs : run.outputs.output;
      await this.sendEndEvent({
        event: "on_tool_end",
        data: {
          output,
          input: runInfo.inputs
        },
        run_id: run.id,
        name: runInfo.name,
        tags: runInfo.tags,
        metadata: runInfo.metadata
      }, runInfo);
    }
    async onRetrieverStart(run) {
      var _a3, _b2;
      const runName = assignName(run);
      const runType = "retriever";
      const runInfo = {
        tags: run.tags ?? [],
        metadata: ((_a3 = run.extra) == null ? void 0 : _a3.metadata) ?? {},
        name: runName,
        runType,
        inputs: {
          query: run.inputs.query
        }
      };
      this.runInfoMap.set(run.id, runInfo);
      await this.send({
        event: "on_retriever_start",
        data: {
          input: {
            query: run.inputs.query
          }
        },
        name: runName,
        tags: run.tags ?? [],
        run_id: run.id,
        metadata: ((_b2 = run.extra) == null ? void 0 : _b2.metadata) ?? {}
      }, runInfo);
    }
    async onRetrieverEnd(run) {
      var _a3;
      const runInfo = this.runInfoMap.get(run.id);
      this.runInfoMap.delete(run.id);
      if (runInfo === void 0) {
        throw new Error(`onRetrieverEnd: Run ID ${run.id} not found in run map.`);
      }
      await this.sendEndEvent({
        event: "on_retriever_end",
        data: {
          output: ((_a3 = run.outputs) == null ? void 0 : _a3.documents) ?? run.outputs,
          input: runInfo.inputs
        },
        run_id: run.id,
        name: runInfo.name,
        tags: runInfo.tags,
        metadata: runInfo.metadata
      }, runInfo);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async handleCustomEvent(eventName, data, runId) {
      const runInfo = this.runInfoMap.get(runId);
      if (runInfo === void 0) {
        throw new Error(`handleCustomEvent: Run ID ${runId} not found in run map.`);
      }
      await this.send({
        event: "on_custom_event",
        run_id: runId,
        name: eventName,
        tags: runInfo.tags,
        metadata: runInfo.metadata,
        data
      }, runInfo);
    }
    async finish() {
      const pendingPromises = [...this.tappedPromises.values()];
      void Promise.all(pendingPromises).finally(() => {
        void this.writer.close();
      });
    }
  }
  const STATUS_NO_RETRY = [
    400,
    401,
    402,
    403,
    404,
    405,
    406,
    407,
    409
    // Conflict
  ];
  const defaultFailedAttemptHandler = (error) => {
    var _a3, _b2;
    if (error.message.startsWith("Cancel") || error.message.startsWith("AbortError") || error.name === "AbortError") {
      throw error;
    }
    if ((error == null ? void 0 : error.code) === "ECONNABORTED") {
      throw error;
    }
    const status = (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      ((_a3 = error == null ? void 0 : error.response) == null ? void 0 : _a3.status) ?? (error == null ? void 0 : error.status)
    );
    if (status && STATUS_NO_RETRY.includes(+status)) {
      throw error;
    }
    if (((_b2 = error == null ? void 0 : error.error) == null ? void 0 : _b2.code) === "insufficient_quota") {
      const err = new Error(error == null ? void 0 : error.message);
      err.name = "InsufficientQuotaError";
      throw err;
    }
  };
  class AsyncCaller {
    constructor(params) {
      Object.defineProperty(this, "maxConcurrency", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "maxRetries", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "onFailedAttempt", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "queue", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.maxConcurrency = params.maxConcurrency ?? Infinity;
      this.maxRetries = params.maxRetries ?? 6;
      this.onFailedAttempt = params.onFailedAttempt ?? defaultFailedAttemptHandler;
      const PQueue = "default" in PQueueMod ? PQueueMod.default : PQueueMod;
      this.queue = new PQueue({ concurrency: this.maxConcurrency });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    call(callable, ...args) {
      return this.queue.add(() => pRetry(() => callable(...args).catch((error) => {
        if (error instanceof Error) {
          throw error;
        } else {
          throw new Error(error);
        }
      }), {
        onFailedAttempt: this.onFailedAttempt,
        retries: this.maxRetries,
        randomize: true
        // If needed we can change some of the defaults here,
        // but they're quite sensible.
      }), { throwOnTimeout: true });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    callWithOptions(options, callable, ...args) {
      if (options.signal) {
        return Promise.race([
          this.call(callable, ...args),
          new Promise((_, reject) => {
            var _a3;
            (_a3 = options.signal) == null ? void 0 : _a3.addEventListener("abort", () => {
              reject(new Error("AbortError"));
            });
          })
        ]);
      }
      return this.call(callable, ...args);
    }
    fetch(...args) {
      return this.call(() => fetch(...args).then((res) => res.ok ? res : Promise.reject(res)));
    }
  }
  class RootListenersTracer extends BaseTracer {
    constructor({ config: config2, onStart, onEnd, onError }) {
      super({ _awaitHandler: true });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "RootListenersTracer"
      });
      Object.defineProperty(this, "rootId", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "config", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "argOnStart", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "argOnEnd", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "argOnError", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.config = config2;
      this.argOnStart = onStart;
      this.argOnEnd = onEnd;
      this.argOnError = onError;
    }
    /**
     * This is a legacy method only called once for an entire run tree
     * therefore not useful here
     * @param {Run} _ Not used
     */
    persistRun(_) {
      return Promise.resolve();
    }
    async onRunCreate(run) {
      if (this.rootId) {
        return;
      }
      this.rootId = run.id;
      if (this.argOnStart) {
        await this.argOnStart(run, this.config);
      }
    }
    async onRunUpdate(run) {
      if (run.id !== this.rootId) {
        return;
      }
      if (!run.error) {
        if (this.argOnEnd) {
          await this.argOnEnd(run, this.config);
        }
      } else if (this.argOnError) {
        await this.argOnError(run, this.config);
      }
    }
  }
  function isRunnableInterface(thing) {
    return thing ? thing.lc_runnable : false;
  }
  class _RootEventFilter {
    constructor(fields) {
      Object.defineProperty(this, "includeNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "includeTypes", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "includeTags", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "excludeNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "excludeTypes", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "excludeTags", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.includeNames = fields.includeNames;
      this.includeTypes = fields.includeTypes;
      this.includeTags = fields.includeTags;
      this.excludeNames = fields.excludeNames;
      this.excludeTypes = fields.excludeTypes;
      this.excludeTags = fields.excludeTags;
    }
    includeEvent(event, rootType) {
      let include = this.includeNames === void 0 && this.includeTypes === void 0 && this.includeTags === void 0;
      const eventTags = event.tags ?? [];
      if (this.includeNames !== void 0) {
        include = include || this.includeNames.includes(event.name);
      }
      if (this.includeTypes !== void 0) {
        include = include || this.includeTypes.includes(rootType);
      }
      if (this.includeTags !== void 0) {
        include = include || eventTags.some((tag) => {
          var _a3;
          return (_a3 = this.includeTags) == null ? void 0 : _a3.includes(tag);
        });
      }
      if (this.excludeNames !== void 0) {
        include = include && !this.excludeNames.includes(event.name);
      }
      if (this.excludeTypes !== void 0) {
        include = include && !this.excludeTypes.includes(rootType);
      }
      if (this.excludeTags !== void 0) {
        include = include && eventTags.every((tag) => {
          var _a3;
          return !((_a3 = this.excludeTags) == null ? void 0 : _a3.includes(tag));
        });
      }
      return include;
    }
  }
  const ignoreOverride$3 = Symbol("Let zodToJsonSchema decide on which parser to use");
  const defaultOptions$3 = {
    name: void 0,
    $refStrategy: "root",
    basePath: ["#"],
    effectStrategy: "input",
    pipeStrategy: "all",
    dateStrategy: "format:date-time",
    mapStrategy: "entries",
    removeAdditionalStrategy: "passthrough",
    allowedAdditionalProperties: true,
    rejectedAdditionalProperties: false,
    definitionPath: "definitions",
    target: "jsonSchema7",
    strictUnions: false,
    definitions: {},
    errorMessages: false,
    markdownDescription: false,
    patternStrategy: "escape",
    applyRegexFlags: false,
    emailStrategy: "format:email",
    base64Strategy: "contentEncoding:base64",
    nameStrategy: "ref"
  };
  const getDefaultOptions$3 = (options) => ({
    ...defaultOptions$3,
    ...options
  });
  const getRefs$3 = (options) => {
    const _options = getDefaultOptions$3(options);
    const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
    return {
      ..._options,
      currentPath,
      propertyPath: void 0,
      seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [
        def._def,
        {
          def: def._def,
          path: [..._options.basePath, _options.definitionPath, name],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ]))
    };
  };
  function addErrorMessage$3(res, key, errorMessage, refs) {
    if (!(refs == null ? void 0 : refs.errorMessages))
      return;
    if (errorMessage) {
      res.errorMessage = {
        ...res.errorMessage,
        [key]: errorMessage
      };
    }
  }
  function setResponseValueAndErrors$3(res, key, value, errorMessage, refs) {
    res[key] = value;
    addErrorMessage$3(res, key, errorMessage, refs);
  }
  function parseAnyDef$3() {
    return {};
  }
  function parseArrayDef$3(def, refs) {
    var _a3, _b2, _c2;
    const res = {
      type: "array"
    };
    if (((_a3 = def.type) == null ? void 0 : _a3._def) && ((_c2 = (_b2 = def.type) == null ? void 0 : _b2._def) == null ? void 0 : _c2.typeName) !== ZodFirstPartyTypeKind.ZodAny) {
      res.items = parseDef$3(def.type._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items"]
      });
    }
    if (def.minLength) {
      setResponseValueAndErrors$3(res, "minItems", def.minLength.value, def.minLength.message, refs);
    }
    if (def.maxLength) {
      setResponseValueAndErrors$3(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
    }
    if (def.exactLength) {
      setResponseValueAndErrors$3(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
      setResponseValueAndErrors$3(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
    }
    return res;
  }
  function parseBigintDef$3(def, refs) {
    const res = {
      type: "integer",
      format: "int64"
    };
    if (!def.checks)
      return res;
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          if (refs.target === "jsonSchema7") {
            if (check.inclusive) {
              setResponseValueAndErrors$3(res, "minimum", check.value, check.message, refs);
            } else {
              setResponseValueAndErrors$3(res, "exclusiveMinimum", check.value, check.message, refs);
            }
          } else {
            if (!check.inclusive) {
              res.exclusiveMinimum = true;
            }
            setResponseValueAndErrors$3(res, "minimum", check.value, check.message, refs);
          }
          break;
        case "max":
          if (refs.target === "jsonSchema7") {
            if (check.inclusive) {
              setResponseValueAndErrors$3(res, "maximum", check.value, check.message, refs);
            } else {
              setResponseValueAndErrors$3(res, "exclusiveMaximum", check.value, check.message, refs);
            }
          } else {
            if (!check.inclusive) {
              res.exclusiveMaximum = true;
            }
            setResponseValueAndErrors$3(res, "maximum", check.value, check.message, refs);
          }
          break;
        case "multipleOf":
          setResponseValueAndErrors$3(res, "multipleOf", check.value, check.message, refs);
          break;
      }
    }
    return res;
  }
  function parseBooleanDef$3() {
    return {
      type: "boolean"
    };
  }
  function parseBrandedDef$3(_def, refs) {
    return parseDef$3(_def.type._def, refs);
  }
  const parseCatchDef$3 = (def, refs) => {
    return parseDef$3(def.innerType._def, refs);
  };
  function parseDateDef$3(def, refs, overrideDateStrategy) {
    const strategy = overrideDateStrategy ?? refs.dateStrategy;
    if (Array.isArray(strategy)) {
      return {
        anyOf: strategy.map((item, i2) => parseDateDef$3(def, refs, item))
      };
    }
    switch (strategy) {
      case "string":
      case "format:date-time":
        return {
          type: "string",
          format: "date-time"
        };
      case "format:date":
        return {
          type: "string",
          format: "date"
        };
      case "integer":
        return integerDateParser$3(def, refs);
    }
  }
  const integerDateParser$3 = (def, refs) => {
    const res = {
      type: "integer",
      format: "unix-time"
    };
    if (refs.target === "openApi3") {
      return res;
    }
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors$3(
            res,
            "minimum",
            check.value,
            // This is in milliseconds
            check.message,
            refs
          );
          break;
        case "max":
          setResponseValueAndErrors$3(
            res,
            "maximum",
            check.value,
            // This is in milliseconds
            check.message,
            refs
          );
          break;
      }
    }
    return res;
  };
  function parseDefaultDef$3(_def, refs) {
    return {
      ...parseDef$3(_def.innerType._def, refs),
      default: _def.defaultValue()
    };
  }
  function parseEffectsDef$3(_def, refs) {
    return refs.effectStrategy === "input" ? parseDef$3(_def.schema._def, refs) : {};
  }
  function parseEnumDef$3(def) {
    return {
      type: "string",
      enum: Array.from(def.values)
    };
  }
  const isJsonSchema7AllOfType$3 = (type) => {
    if ("type" in type && type.type === "string")
      return false;
    return "allOf" in type;
  };
  function parseIntersectionDef$3(def, refs) {
    const allOf = [
      parseDef$3(def.left._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", "0"]
      }),
      parseDef$3(def.right._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", "1"]
      })
    ].filter((x) => !!x);
    let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
    const mergedAllOf = [];
    allOf.forEach((schema) => {
      if (isJsonSchema7AllOfType$3(schema)) {
        mergedAllOf.push(...schema.allOf);
        if (schema.unevaluatedProperties === void 0) {
          unevaluatedProperties = void 0;
        }
      } else {
        let nestedSchema = schema;
        if ("additionalProperties" in schema && schema.additionalProperties === false) {
          const { additionalProperties, ...rest } = schema;
          nestedSchema = rest;
        } else {
          unevaluatedProperties = void 0;
        }
        mergedAllOf.push(nestedSchema);
      }
    });
    return mergedAllOf.length ? {
      allOf: mergedAllOf,
      ...unevaluatedProperties
    } : void 0;
  }
  function parseLiteralDef$3(def, refs) {
    const parsedType = typeof def.value;
    if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
      return {
        type: Array.isArray(def.value) ? "array" : "object"
      };
    }
    if (refs.target === "openApi3") {
      return {
        type: parsedType === "bigint" ? "integer" : parsedType,
        enum: [def.value]
      };
    }
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      const: def.value
    };
  }
  let emojiRegex$3 = void 0;
  const zodPatterns$3 = {
    /**
     * `c` was changed to `[cC]` to replicate /i flag
     */
    cuid: /^[cC][^\s-]{8,}$/,
    cuid2: /^[0-9a-z]+$/,
    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
    /**
     * `a-z` was added to replicate /i flag
     */
    email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
    /**
     * Constructed a valid Unicode RegExp
     *
     * Lazily instantiate since this type of regex isn't supported
     * in all envs (e.g. React Native).
     *
     * See:
     * https://github.com/colinhacks/zod/issues/2433
     * Fix in Zod:
     * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
     */
    emoji: () => {
      if (emojiRegex$3 === void 0) {
        emojiRegex$3 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
      }
      return emojiRegex$3;
    },
    /**
     * Unused
     */
    uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
    /**
     * Unused
     */
    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
    /**
     * Unused
     */
    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
    ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
    base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
    nanoid: /^[a-zA-Z0-9_-]{21}$/,
    jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
  };
  function parseStringDef$3(def, refs) {
    const res = {
      type: "string"
    };
    if (def.checks) {
      for (const check of def.checks) {
        switch (check.kind) {
          case "min":
            setResponseValueAndErrors$3(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
            break;
          case "max":
            setResponseValueAndErrors$3(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
            break;
          case "email":
            switch (refs.emailStrategy) {
              case "format:email":
                addFormat$3(res, "email", check.message, refs);
                break;
              case "format:idn-email":
                addFormat$3(res, "idn-email", check.message, refs);
                break;
              case "pattern:zod":
                addPattern$3(res, zodPatterns$3.email, check.message, refs);
                break;
            }
            break;
          case "url":
            addFormat$3(res, "uri", check.message, refs);
            break;
          case "uuid":
            addFormat$3(res, "uuid", check.message, refs);
            break;
          case "regex":
            addPattern$3(res, check.regex, check.message, refs);
            break;
          case "cuid":
            addPattern$3(res, zodPatterns$3.cuid, check.message, refs);
            break;
          case "cuid2":
            addPattern$3(res, zodPatterns$3.cuid2, check.message, refs);
            break;
          case "startsWith":
            addPattern$3(res, RegExp(`^${escapeLiteralCheckValue$1(check.value, refs)}`), check.message, refs);
            break;
          case "endsWith":
            addPattern$3(res, RegExp(`${escapeLiteralCheckValue$1(check.value, refs)}$`), check.message, refs);
            break;
          case "datetime":
            addFormat$3(res, "date-time", check.message, refs);
            break;
          case "date":
            addFormat$3(res, "date", check.message, refs);
            break;
          case "time":
            addFormat$3(res, "time", check.message, refs);
            break;
          case "duration":
            addFormat$3(res, "duration", check.message, refs);
            break;
          case "length":
            setResponseValueAndErrors$3(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
            setResponseValueAndErrors$3(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
            break;
          case "includes": {
            addPattern$3(res, RegExp(escapeLiteralCheckValue$1(check.value, refs)), check.message, refs);
            break;
          }
          case "ip": {
            if (check.version !== "v6") {
              addFormat$3(res, "ipv4", check.message, refs);
            }
            if (check.version !== "v4") {
              addFormat$3(res, "ipv6", check.message, refs);
            }
            break;
          }
          case "base64url":
            addPattern$3(res, zodPatterns$3.base64url, check.message, refs);
            break;
          case "jwt":
            addPattern$3(res, zodPatterns$3.jwt, check.message, refs);
            break;
          case "cidr": {
            if (check.version !== "v6") {
              addPattern$3(res, zodPatterns$3.ipv4Cidr, check.message, refs);
            }
            if (check.version !== "v4") {
              addPattern$3(res, zodPatterns$3.ipv6Cidr, check.message, refs);
            }
            break;
          }
          case "emoji":
            addPattern$3(res, zodPatterns$3.emoji(), check.message, refs);
            break;
          case "ulid": {
            addPattern$3(res, zodPatterns$3.ulid, check.message, refs);
            break;
          }
          case "base64": {
            switch (refs.base64Strategy) {
              case "format:binary": {
                addFormat$3(res, "binary", check.message, refs);
                break;
              }
              case "contentEncoding:base64": {
                setResponseValueAndErrors$3(res, "contentEncoding", "base64", check.message, refs);
                break;
              }
              case "pattern:zod": {
                addPattern$3(res, zodPatterns$3.base64, check.message, refs);
                break;
              }
            }
            break;
          }
          case "nanoid": {
            addPattern$3(res, zodPatterns$3.nanoid, check.message, refs);
          }
        }
      }
    }
    return res;
  }
  function escapeLiteralCheckValue$1(literal, refs) {
    return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric$3(literal) : literal;
  }
  const ALPHA_NUMERIC$1 = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
  function escapeNonAlphaNumeric$3(source2) {
    let result = "";
    for (let i2 = 0; i2 < source2.length; i2++) {
      if (!ALPHA_NUMERIC$1.has(source2[i2])) {
        result += "\\";
      }
      result += source2[i2];
    }
    return result;
  }
  function addFormat$3(schema, value, message, refs) {
    var _a3;
    if (schema.format || ((_a3 = schema.anyOf) == null ? void 0 : _a3.some((x) => x.format))) {
      if (!schema.anyOf) {
        schema.anyOf = [];
      }
      if (schema.format) {
        schema.anyOf.push({
          format: schema.format,
          ...schema.errorMessage && refs.errorMessages && {
            errorMessage: { format: schema.errorMessage.format }
          }
        });
        delete schema.format;
        if (schema.errorMessage) {
          delete schema.errorMessage.format;
          if (Object.keys(schema.errorMessage).length === 0) {
            delete schema.errorMessage;
          }
        }
      }
      schema.anyOf.push({
        format: value,
        ...message && refs.errorMessages && { errorMessage: { format: message } }
      });
    } else {
      setResponseValueAndErrors$3(schema, "format", value, message, refs);
    }
  }
  function addPattern$3(schema, regex, message, refs) {
    var _a3;
    if (schema.pattern || ((_a3 = schema.allOf) == null ? void 0 : _a3.some((x) => x.pattern))) {
      if (!schema.allOf) {
        schema.allOf = [];
      }
      if (schema.pattern) {
        schema.allOf.push({
          pattern: schema.pattern,
          ...schema.errorMessage && refs.errorMessages && {
            errorMessage: { pattern: schema.errorMessage.pattern }
          }
        });
        delete schema.pattern;
        if (schema.errorMessage) {
          delete schema.errorMessage.pattern;
          if (Object.keys(schema.errorMessage).length === 0) {
            delete schema.errorMessage;
          }
        }
      }
      schema.allOf.push({
        pattern: stringifyRegExpWithFlags$1(regex, refs),
        ...message && refs.errorMessages && { errorMessage: { pattern: message } }
      });
    } else {
      setResponseValueAndErrors$3(schema, "pattern", stringifyRegExpWithFlags$1(regex, refs), message, refs);
    }
  }
  function stringifyRegExpWithFlags$1(regex, refs) {
    var _a3;
    if (!refs.applyRegexFlags || !regex.flags) {
      return regex.source;
    }
    const flags = {
      i: regex.flags.includes("i"),
      m: regex.flags.includes("m"),
      s: regex.flags.includes("s")
      // `.` matches newlines
    };
    const source2 = flags.i ? regex.source.toLowerCase() : regex.source;
    let pattern = "";
    let isEscaped = false;
    let inCharGroup = false;
    let inCharRange = false;
    for (let i2 = 0; i2 < source2.length; i2++) {
      if (isEscaped) {
        pattern += source2[i2];
        isEscaped = false;
        continue;
      }
      if (flags.i) {
        if (inCharGroup) {
          if (source2[i2].match(/[a-z]/)) {
            if (inCharRange) {
              pattern += source2[i2];
              pattern += `${source2[i2 - 2]}-${source2[i2]}`.toUpperCase();
              inCharRange = false;
            } else if (source2[i2 + 1] === "-" && ((_a3 = source2[i2 + 2]) == null ? void 0 : _a3.match(/[a-z]/))) {
              pattern += source2[i2];
              inCharRange = true;
            } else {
              pattern += `${source2[i2]}${source2[i2].toUpperCase()}`;
            }
            continue;
          }
        } else if (source2[i2].match(/[a-z]/)) {
          pattern += `[${source2[i2]}${source2[i2].toUpperCase()}]`;
          continue;
        }
      }
      if (flags.m) {
        if (source2[i2] === "^") {
          pattern += `(^|(?<=[\r
]))`;
          continue;
        } else if (source2[i2] === "$") {
          pattern += `($|(?=[\r
]))`;
          continue;
        }
      }
      if (flags.s && source2[i2] === ".") {
        pattern += inCharGroup ? `${source2[i2]}\r
` : `[${source2[i2]}\r
]`;
        continue;
      }
      pattern += source2[i2];
      if (source2[i2] === "\\") {
        isEscaped = true;
      } else if (inCharGroup && source2[i2] === "]") {
        inCharGroup = false;
      } else if (!inCharGroup && source2[i2] === "[") {
        inCharGroup = true;
      }
    }
    try {
      new RegExp(pattern);
    } catch {
      console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
      return regex.source;
    }
    return pattern;
  }
  function parseRecordDef$3(def, refs) {
    var _a3, _b2, _c2, _d2, _e2, _f2;
    if (refs.target === "openAi") {
      console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
    }
    if (refs.target === "openApi3" && ((_a3 = def.keyType) == null ? void 0 : _a3._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {
      return {
        type: "object",
        required: def.keyType._def.values,
        properties: def.keyType._def.values.reduce((acc, key) => ({
          ...acc,
          [key]: parseDef$3(def.valueType._def, {
            ...refs,
            currentPath: [...refs.currentPath, "properties", key]
          }) ?? {}
        }), {}),
        additionalProperties: refs.rejectedAdditionalProperties
      };
    }
    const schema = {
      type: "object",
      additionalProperties: parseDef$3(def.valueType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalProperties"]
      }) ?? refs.allowedAdditionalProperties
    };
    if (refs.target === "openApi3") {
      return schema;
    }
    if (((_b2 = def.keyType) == null ? void 0 : _b2._def.typeName) === ZodFirstPartyTypeKind.ZodString && ((_c2 = def.keyType._def.checks) == null ? void 0 : _c2.length)) {
      const { type, ...keyType } = parseStringDef$3(def.keyType._def, refs);
      return {
        ...schema,
        propertyNames: keyType
      };
    } else if (((_d2 = def.keyType) == null ? void 0 : _d2._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {
      return {
        ...schema,
        propertyNames: {
          enum: def.keyType._def.values
        }
      };
    } else if (((_e2 = def.keyType) == null ? void 0 : _e2._def.typeName) === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && ((_f2 = def.keyType._def.type._def.checks) == null ? void 0 : _f2.length)) {
      const { type, ...keyType } = parseBrandedDef$3(def.keyType._def, refs);
      return {
        ...schema,
        propertyNames: keyType
      };
    }
    return schema;
  }
  function parseMapDef$3(def, refs) {
    if (refs.mapStrategy === "record") {
      return parseRecordDef$3(def, refs);
    }
    const keys = parseDef$3(def.keyType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items", "items", "0"]
    }) || {};
    const values = parseDef$3(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items", "items", "1"]
    }) || {};
    return {
      type: "array",
      maxItems: 125,
      items: {
        type: "array",
        items: [keys, values],
        minItems: 2,
        maxItems: 2
      }
    };
  }
  function parseNativeEnumDef$3(def) {
    const object = def.values;
    const actualKeys = Object.keys(def.values).filter((key) => {
      return typeof object[object[key]] !== "number";
    });
    const actualValues = actualKeys.map((key) => object[key]);
    const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
    return {
      type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
      enum: actualValues
    };
  }
  function parseNeverDef$3() {
    return {
      not: {}
    };
  }
  function parseNullDef$3(refs) {
    return refs.target === "openApi3" ? {
      enum: ["null"],
      nullable: true
    } : {
      type: "null"
    };
  }
  const primitiveMappings$3 = {
    ZodString: "string",
    ZodNumber: "number",
    ZodBigInt: "integer",
    ZodBoolean: "boolean",
    ZodNull: "null"
  };
  function parseUnionDef$3(def, refs) {
    if (refs.target === "openApi3")
      return asAnyOf$3(def, refs);
    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
    if (options.every((x) => x._def.typeName in primitiveMappings$3 && (!x._def.checks || !x._def.checks.length))) {
      const types = options.reduce((types2, x) => {
        const type = primitiveMappings$3[x._def.typeName];
        return type && !types2.includes(type) ? [...types2, type] : types2;
      }, []);
      return {
        type: types.length > 1 ? types : types[0]
      };
    } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
      const types = options.reduce((acc, x) => {
        const type = typeof x._def.value;
        switch (type) {
          case "string":
          case "number":
          case "boolean":
            return [...acc, type];
          case "bigint":
            return [...acc, "integer"];
          case "object":
            if (x._def.value === null)
              return [...acc, "null"];
          case "symbol":
          case "undefined":
          case "function":
          default:
            return acc;
        }
      }, []);
      if (types.length === options.length) {
        const uniqueTypes = types.filter((x, i2, a) => a.indexOf(x) === i2);
        return {
          type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
          enum: options.reduce((acc, x) => {
            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
          }, [])
        };
      }
    } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
      return {
        type: "string",
        enum: options.reduce((acc, x) => [
          ...acc,
          ...x._def.values.filter((x2) => !acc.includes(x2))
        ], [])
      };
    }
    return asAnyOf$3(def, refs);
  }
  const asAnyOf$3 = (def, refs) => {
    const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i2) => parseDef$3(x._def, {
      ...refs,
      currentPath: [...refs.currentPath, "anyOf", `${i2}`]
    })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
    return anyOf.length ? { anyOf } : void 0;
  };
  function parseNullableDef$3(def, refs) {
    if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
      if (refs.target === "openApi3") {
        return {
          type: primitiveMappings$3[def.innerType._def.typeName],
          nullable: true
        };
      }
      return {
        type: [
          primitiveMappings$3[def.innerType._def.typeName],
          "null"
        ]
      };
    }
    if (refs.target === "openApi3") {
      const base2 = parseDef$3(def.innerType._def, {
        ...refs,
        currentPath: [...refs.currentPath]
      });
      if (base2 && "$ref" in base2)
        return { allOf: [base2], nullable: true };
      return base2 && { ...base2, nullable: true };
    }
    const base = parseDef$3(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "anyOf", "0"]
    });
    return base && { anyOf: [base, { type: "null" }] };
  }
  function parseNumberDef$3(def, refs) {
    const res = {
      type: "number"
    };
    if (!def.checks)
      return res;
    for (const check of def.checks) {
      switch (check.kind) {
        case "int":
          res.type = "integer";
          addErrorMessage$3(res, "type", check.message, refs);
          break;
        case "min":
          if (refs.target === "jsonSchema7") {
            if (check.inclusive) {
              setResponseValueAndErrors$3(res, "minimum", check.value, check.message, refs);
            } else {
              setResponseValueAndErrors$3(res, "exclusiveMinimum", check.value, check.message, refs);
            }
          } else {
            if (!check.inclusive) {
              res.exclusiveMinimum = true;
            }
            setResponseValueAndErrors$3(res, "minimum", check.value, check.message, refs);
          }
          break;
        case "max":
          if (refs.target === "jsonSchema7") {
            if (check.inclusive) {
              setResponseValueAndErrors$3(res, "maximum", check.value, check.message, refs);
            } else {
              setResponseValueAndErrors$3(res, "exclusiveMaximum", check.value, check.message, refs);
            }
          } else {
            if (!check.inclusive) {
              res.exclusiveMaximum = true;
            }
            setResponseValueAndErrors$3(res, "maximum", check.value, check.message, refs);
          }
          break;
        case "multipleOf":
          setResponseValueAndErrors$3(res, "multipleOf", check.value, check.message, refs);
          break;
      }
    }
    return res;
  }
  function parseObjectDef$3(def, refs) {
    const forceOptionalIntoNullable = refs.target === "openAi";
    const result = {
      type: "object",
      properties: {}
    };
    const required = [];
    const shape = def.shape();
    for (const propName in shape) {
      let propDef = shape[propName];
      if (propDef === void 0 || propDef._def === void 0) {
        continue;
      }
      let propOptional = safeIsOptional$1(propDef);
      if (propOptional && forceOptionalIntoNullable) {
        if (propDef instanceof ZodOptional) {
          propDef = propDef._def.innerType;
        }
        if (!propDef.isNullable()) {
          propDef = propDef.nullable();
        }
        propOptional = false;
      }
      const parsedDef = parseDef$3(propDef._def, {
        ...refs,
        currentPath: [...refs.currentPath, "properties", propName],
        propertyPath: [...refs.currentPath, "properties", propName]
      });
      if (parsedDef === void 0) {
        continue;
      }
      result.properties[propName] = parsedDef;
      if (!propOptional) {
        required.push(propName);
      }
    }
    if (required.length) {
      result.required = required;
    }
    const additionalProperties = decideAdditionalProperties$3(def, refs);
    if (additionalProperties !== void 0) {
      result.additionalProperties = additionalProperties;
    }
    return result;
  }
  function decideAdditionalProperties$3(def, refs) {
    if (def.catchall._def.typeName !== "ZodNever") {
      return parseDef$3(def.catchall._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalProperties"]
      });
    }
    switch (def.unknownKeys) {
      case "passthrough":
        return refs.allowedAdditionalProperties;
      case "strict":
        return refs.rejectedAdditionalProperties;
      case "strip":
        return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
    }
  }
  function safeIsOptional$1(schema) {
    try {
      return schema.isOptional();
    } catch {
      return true;
    }
  }
  const parseOptionalDef$3 = (def, refs) => {
    var _a3;
    if (refs.currentPath.toString() === ((_a3 = refs.propertyPath) == null ? void 0 : _a3.toString())) {
      return parseDef$3(def.innerType._def, refs);
    }
    const innerSchema = parseDef$3(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "anyOf", "1"]
    });
    return innerSchema ? {
      anyOf: [
        {
          not: {}
        },
        innerSchema
      ]
    } : {};
  };
  const parsePipelineDef$3 = (def, refs) => {
    if (refs.pipeStrategy === "input") {
      return parseDef$3(def.in._def, refs);
    } else if (refs.pipeStrategy === "output") {
      return parseDef$3(def.out._def, refs);
    }
    const a = parseDef$3(def.in._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    });
    const b = parseDef$3(def.out._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
    });
    return {
      allOf: [a, b].filter((x) => x !== void 0)
    };
  };
  function parsePromiseDef$3(def, refs) {
    return parseDef$3(def.type._def, refs);
  }
  function parseSetDef$3(def, refs) {
    const items = parseDef$3(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
    const schema = {
      type: "array",
      uniqueItems: true,
      items
    };
    if (def.minSize) {
      setResponseValueAndErrors$3(schema, "minItems", def.minSize.value, def.minSize.message, refs);
    }
    if (def.maxSize) {
      setResponseValueAndErrors$3(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
    }
    return schema;
  }
  function parseTupleDef$3(def, refs) {
    if (def.rest) {
      return {
        type: "array",
        minItems: def.items.length,
        items: def.items.map((x, i2) => parseDef$3(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i2}`]
        })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
        additionalItems: parseDef$3(def.rest._def, {
          ...refs,
          currentPath: [...refs.currentPath, "additionalItems"]
        })
      };
    } else {
      return {
        type: "array",
        minItems: def.items.length,
        maxItems: def.items.length,
        items: def.items.map((x, i2) => parseDef$3(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i2}`]
        })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
      };
    }
  }
  function parseUndefinedDef$3() {
    return {
      not: {}
    };
  }
  function parseUnknownDef$3() {
    return {};
  }
  const parseReadonlyDef$3 = (def, refs) => {
    return parseDef$3(def.innerType._def, refs);
  };
  const selectParser$3 = (def, typeName, refs) => {
    switch (typeName) {
      case ZodFirstPartyTypeKind.ZodString:
        return parseStringDef$3(def, refs);
      case ZodFirstPartyTypeKind.ZodNumber:
        return parseNumberDef$3(def, refs);
      case ZodFirstPartyTypeKind.ZodObject:
        return parseObjectDef$3(def, refs);
      case ZodFirstPartyTypeKind.ZodBigInt:
        return parseBigintDef$3(def, refs);
      case ZodFirstPartyTypeKind.ZodBoolean:
        return parseBooleanDef$3();
      case ZodFirstPartyTypeKind.ZodDate:
        return parseDateDef$3(def, refs);
      case ZodFirstPartyTypeKind.ZodUndefined:
        return parseUndefinedDef$3();
      case ZodFirstPartyTypeKind.ZodNull:
        return parseNullDef$3(refs);
      case ZodFirstPartyTypeKind.ZodArray:
        return parseArrayDef$3(def, refs);
      case ZodFirstPartyTypeKind.ZodUnion:
      case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
        return parseUnionDef$3(def, refs);
      case ZodFirstPartyTypeKind.ZodIntersection:
        return parseIntersectionDef$3(def, refs);
      case ZodFirstPartyTypeKind.ZodTuple:
        return parseTupleDef$3(def, refs);
      case ZodFirstPartyTypeKind.ZodRecord:
        return parseRecordDef$3(def, refs);
      case ZodFirstPartyTypeKind.ZodLiteral:
        return parseLiteralDef$3(def, refs);
      case ZodFirstPartyTypeKind.ZodEnum:
        return parseEnumDef$3(def);
      case ZodFirstPartyTypeKind.ZodNativeEnum:
        return parseNativeEnumDef$3(def);
      case ZodFirstPartyTypeKind.ZodNullable:
        return parseNullableDef$3(def, refs);
      case ZodFirstPartyTypeKind.ZodOptional:
        return parseOptionalDef$3(def, refs);
      case ZodFirstPartyTypeKind.ZodMap:
        return parseMapDef$3(def, refs);
      case ZodFirstPartyTypeKind.ZodSet:
        return parseSetDef$3(def, refs);
      case ZodFirstPartyTypeKind.ZodLazy:
        return () => def.getter()._def;
      case ZodFirstPartyTypeKind.ZodPromise:
        return parsePromiseDef$3(def, refs);
      case ZodFirstPartyTypeKind.ZodNaN:
      case ZodFirstPartyTypeKind.ZodNever:
        return parseNeverDef$3();
      case ZodFirstPartyTypeKind.ZodEffects:
        return parseEffectsDef$3(def, refs);
      case ZodFirstPartyTypeKind.ZodAny:
        return parseAnyDef$3();
      case ZodFirstPartyTypeKind.ZodUnknown:
        return parseUnknownDef$3();
      case ZodFirstPartyTypeKind.ZodDefault:
        return parseDefaultDef$3(def, refs);
      case ZodFirstPartyTypeKind.ZodBranded:
        return parseBrandedDef$3(def, refs);
      case ZodFirstPartyTypeKind.ZodReadonly:
        return parseReadonlyDef$3(def, refs);
      case ZodFirstPartyTypeKind.ZodCatch:
        return parseCatchDef$3(def, refs);
      case ZodFirstPartyTypeKind.ZodPipeline:
        return parsePipelineDef$3(def, refs);
      case ZodFirstPartyTypeKind.ZodFunction:
      case ZodFirstPartyTypeKind.ZodVoid:
      case ZodFirstPartyTypeKind.ZodSymbol:
        return void 0;
      default:
        return /* @__PURE__ */ ((_) => void 0)();
    }
  };
  function parseDef$3(def, refs, forceResolution = false) {
    var _a3;
    const seenItem = refs.seen.get(def);
    if (refs.override) {
      const overrideResult = (_a3 = refs.override) == null ? void 0 : _a3.call(refs, def, refs, seenItem, forceResolution);
      if (overrideResult !== ignoreOverride$3) {
        return overrideResult;
      }
    }
    if (seenItem && !forceResolution) {
      const seenSchema = get$ref$3(seenItem, refs);
      if (seenSchema !== void 0) {
        return seenSchema;
      }
    }
    const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
    refs.seen.set(def, newItem);
    const jsonSchemaOrGetter = selectParser$3(def, def.typeName, refs);
    const jsonSchema = typeof jsonSchemaOrGetter === "function" ? parseDef$3(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
    if (jsonSchema) {
      addMeta$3(def, refs, jsonSchema);
    }
    if (refs.postProcess) {
      const postProcessResult = refs.postProcess(jsonSchema, def, refs);
      newItem.jsonSchema = jsonSchema;
      return postProcessResult;
    }
    newItem.jsonSchema = jsonSchema;
    return jsonSchema;
  }
  const get$ref$3 = (item, refs) => {
    switch (refs.$refStrategy) {
      case "root":
        return { $ref: item.path.join("/") };
      case "relative":
        return { $ref: getRelativePath$3(refs.currentPath, item.path) };
      case "none":
      case "seen": {
        if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
          console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
          return {};
        }
        return refs.$refStrategy === "seen" ? {} : void 0;
      }
    }
  };
  const getRelativePath$3 = (pathA, pathB) => {
    let i2 = 0;
    for (; i2 < pathA.length && i2 < pathB.length; i2++) {
      if (pathA[i2] !== pathB[i2])
        break;
    }
    return [(pathA.length - i2).toString(), ...pathB.slice(i2)].join("/");
  };
  const addMeta$3 = (def, refs, jsonSchema) => {
    if (def.description) {
      jsonSchema.description = def.description;
      if (refs.markdownDescription) {
        jsonSchema.markdownDescription = def.description;
      }
    }
    return jsonSchema;
  };
  const zodToJsonSchema$5 = (schema, options) => {
    const refs = getRefs$3(options);
    const definitions = void 0;
    const name = options == null ? void 0 : options.name;
    const main = parseDef$3(
      schema._def,
      refs,
      false
    ) ?? {};
    const combined = name === void 0 ? definitions ? {
      ...main,
      [refs.definitionPath]: definitions
    } : main : {
      $ref: [
        ...refs.$refStrategy === "relative" ? [] : refs.basePath,
        refs.definitionPath,
        name
      ].join("/"),
      [refs.definitionPath]: {
        ...definitions,
        [name]: main
      }
    };
    if (refs.target === "jsonSchema7") {
      combined.$schema = "http://json-schema.org/draft-07/schema#";
    } else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") {
      combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
    }
    if (refs.target === "openAi" && ("anyOf" in combined || "oneOf" in combined || "allOf" in combined || "type" in combined && Array.isArray(combined.type))) {
      console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
    }
    return combined;
  };
  function _escapeNodeLabel(nodeLabel) {
    return nodeLabel.replace(/[^a-zA-Z-_0-9]/g, "_");
  }
  const MARKDOWN_SPECIAL_CHARS = ["*", "_", "`"];
  function _generateMermaidGraphStyles(nodeColors) {
    let styles2 = "";
    for (const [className, color2] of Object.entries(nodeColors)) {
      styles2 += `	classDef ${className} ${color2};
`;
    }
    return styles2;
  }
  function drawMermaid(nodes, edges, config2) {
    const { firstNode, lastNode, nodeColors, withStyles = true, curveStyle = "linear", wrapLabelNWords = 9 } = config2 ?? {};
    let mermaidGraph = withStyles ? `%%{init: {'flowchart': {'curve': '${curveStyle}'}}}%%
graph TD;
` : "graph TD;\n";
    if (withStyles) {
      const defaultClassLabel = "default";
      const formatDict = {
        [defaultClassLabel]: "{0}({1})"
      };
      if (firstNode !== void 0) {
        formatDict[firstNode] = "{0}([{1}]):::first";
      }
      if (lastNode !== void 0) {
        formatDict[lastNode] = "{0}([{1}]):::last";
      }
      for (const [key, node] of Object.entries(nodes)) {
        const nodeName = node.name.split(":").pop() ?? "";
        const label = MARKDOWN_SPECIAL_CHARS.some((char) => nodeName.startsWith(char) && nodeName.endsWith(char)) ? `<p>${nodeName}</p>` : nodeName;
        let finalLabel = label;
        if (Object.keys(node.metadata ?? {}).length) {
          finalLabel += `<hr/><small><em>${Object.entries(node.metadata ?? {}).map(([k, v]) => `${k} = ${v}`).join("\n")}</em></small>`;
        }
        const nodeLabel = (formatDict[key] ?? formatDict[defaultClassLabel]).replace("{0}", _escapeNodeLabel(key)).replace("{1}", finalLabel);
        mermaidGraph += `	${nodeLabel}
`;
      }
    }
    const edgeGroups = {};
    for (const edge of edges) {
      const srcParts = edge.source.split(":");
      const tgtParts = edge.target.split(":");
      const commonPrefix = srcParts.filter((src, i2) => src === tgtParts[i2]).join(":");
      if (!edgeGroups[commonPrefix]) {
        edgeGroups[commonPrefix] = [];
      }
      edgeGroups[commonPrefix].push(edge);
    }
    const seenSubgraphs = /* @__PURE__ */ new Set();
    function addSubgraph(edges2, prefix) {
      const selfLoop = edges2.length === 1 && edges2[0].source === edges2[0].target;
      if (prefix && !selfLoop) {
        const subgraph = prefix.split(":").pop();
        if (seenSubgraphs.has(subgraph)) {
          throw new Error(`Found duplicate subgraph '${subgraph}' -- this likely means that you're reusing a subgraph node with the same name. Please adjust your graph to have subgraph nodes with unique names.`);
        }
        seenSubgraphs.add(subgraph);
        mermaidGraph += `	subgraph ${subgraph}
`;
      }
      for (const edge of edges2) {
        const { source: source2, target, data, conditional } = edge;
        let edgeLabel = "";
        if (data !== void 0) {
          let edgeData = data;
          const words = edgeData.split(" ");
          if (words.length > wrapLabelNWords) {
            edgeData = Array.from({ length: Math.ceil(words.length / wrapLabelNWords) }, (_, i2) => words.slice(i2 * wrapLabelNWords, (i2 + 1) * wrapLabelNWords).join(" ")).join("&nbsp;<br>&nbsp;");
          }
          edgeLabel = conditional ? ` -. &nbsp;${edgeData}&nbsp; .-> ` : ` -- &nbsp;${edgeData}&nbsp; --> `;
        } else {
          edgeLabel = conditional ? " -.-> " : " --> ";
        }
        mermaidGraph += `	${_escapeNodeLabel(source2)}${edgeLabel}${_escapeNodeLabel(target)};
`;
      }
      for (const nestedPrefix in edgeGroups) {
        if (nestedPrefix.startsWith(`${prefix}:`) && nestedPrefix !== prefix) {
          addSubgraph(edgeGroups[nestedPrefix], nestedPrefix);
        }
      }
      if (prefix && !selfLoop) {
        mermaidGraph += "	end\n";
      }
    }
    addSubgraph(edgeGroups[""] ?? [], "");
    for (const prefix in edgeGroups) {
      if (!prefix.includes(":") && prefix !== "") {
        addSubgraph(edgeGroups[prefix], prefix);
      }
    }
    if (withStyles) {
      mermaidGraph += _generateMermaidGraphStyles(nodeColors ?? {});
    }
    return mermaidGraph;
  }
  async function drawMermaidPng(mermaidSyntax, config2) {
    let { backgroundColor = "white" } = config2 ?? {};
    const mermaidSyntaxEncoded = btoa(mermaidSyntax);
    if (backgroundColor !== void 0) {
      const hexColorPattern = /^#(?:[0-9a-fA-F]{3}){1,2}$/;
      if (!hexColorPattern.test(backgroundColor)) {
        backgroundColor = `!${backgroundColor}`;
      }
    }
    const imageUrl = `https://mermaid.ink/img/${mermaidSyntaxEncoded}?bgColor=${backgroundColor}`;
    const res = await fetch(imageUrl);
    if (!res.ok) {
      throw new Error([
        `Failed to render the graph using the Mermaid.INK API.`,
        `Status code: ${res.status}`,
        `Status text: ${res.statusText}`
      ].join("\n"));
    }
    const content = await res.blob();
    return content;
  }
  function nodeDataStr(id, data) {
    if (id !== void 0 && !validate$1(id)) {
      return id;
    } else if (isRunnableInterface(data)) {
      try {
        let dataStr = data.getName();
        dataStr = dataStr.startsWith("Runnable") ? dataStr.slice("Runnable".length) : dataStr;
        return dataStr;
      } catch (error) {
        return data.getName();
      }
    } else {
      return data.name ?? "UnknownSchema";
    }
  }
  function nodeDataJson(node) {
    if (isRunnableInterface(node.data)) {
      return {
        type: "runnable",
        data: {
          id: node.data.lc_id,
          name: node.data.getName()
        }
      };
    } else {
      return {
        type: "schema",
        data: { ...zodToJsonSchema$5(node.data.schema), title: node.data.name }
      };
    }
  }
  class Graph {
    constructor(params) {
      Object.defineProperty(this, "nodes", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: {}
      });
      Object.defineProperty(this, "edges", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
      this.nodes = (params == null ? void 0 : params.nodes) ?? this.nodes;
      this.edges = (params == null ? void 0 : params.edges) ?? this.edges;
    }
    // Convert the graph to a JSON-serializable format.
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    toJSON() {
      const stableNodeIds = {};
      Object.values(this.nodes).forEach((node, i2) => {
        stableNodeIds[node.id] = validate$1(node.id) ? i2 : node.id;
      });
      return {
        nodes: Object.values(this.nodes).map((node) => ({
          id: stableNodeIds[node.id],
          ...nodeDataJson(node)
        })),
        edges: this.edges.map((edge) => {
          const item = {
            source: stableNodeIds[edge.source],
            target: stableNodeIds[edge.target]
          };
          if (typeof edge.data !== "undefined") {
            item.data = edge.data;
          }
          if (typeof edge.conditional !== "undefined") {
            item.conditional = edge.conditional;
          }
          return item;
        })
      };
    }
    addNode(data, id, metadata) {
      if (id !== void 0 && this.nodes[id] !== void 0) {
        throw new Error(`Node with id ${id} already exists`);
      }
      const nodeId = id ?? v4();
      const node = {
        id: nodeId,
        data,
        name: nodeDataStr(id, data),
        metadata
      };
      this.nodes[nodeId] = node;
      return node;
    }
    removeNode(node) {
      delete this.nodes[node.id];
      this.edges = this.edges.filter((edge) => edge.source !== node.id && edge.target !== node.id);
    }
    addEdge(source2, target, data, conditional) {
      if (this.nodes[source2.id] === void 0) {
        throw new Error(`Source node ${source2.id} not in graph`);
      }
      if (this.nodes[target.id] === void 0) {
        throw new Error(`Target node ${target.id} not in graph`);
      }
      const edge = {
        source: source2.id,
        target: target.id,
        data,
        conditional
      };
      this.edges.push(edge);
      return edge;
    }
    firstNode() {
      return _firstNode(this);
    }
    lastNode() {
      return _lastNode(this);
    }
    /**
     * Add all nodes and edges from another graph.
     * Note this doesn't check for duplicates, nor does it connect the graphs.
     */
    extend(graph, prefix = "") {
      let finalPrefix = prefix;
      const nodeIds = Object.values(graph.nodes).map((node) => node.id);
      if (nodeIds.every(validate$1)) {
        finalPrefix = "";
      }
      const prefixed = (id) => {
        return finalPrefix ? `${finalPrefix}:${id}` : id;
      };
      Object.entries(graph.nodes).forEach(([key, value]) => {
        this.nodes[prefixed(key)] = { ...value, id: prefixed(key) };
      });
      const newEdges = graph.edges.map((edge) => {
        return {
          ...edge,
          source: prefixed(edge.source),
          target: prefixed(edge.target)
        };
      });
      this.edges = [...this.edges, ...newEdges];
      const first2 = graph.firstNode();
      const last2 = graph.lastNode();
      return [
        first2 ? { id: prefixed(first2.id), data: first2.data } : void 0,
        last2 ? { id: prefixed(last2.id), data: last2.data } : void 0
      ];
    }
    trimFirstNode() {
      const firstNode = this.firstNode();
      if (firstNode && _firstNode(this, [firstNode.id])) {
        this.removeNode(firstNode);
      }
    }
    trimLastNode() {
      const lastNode = this.lastNode();
      if (lastNode && _lastNode(this, [lastNode.id])) {
        this.removeNode(lastNode);
      }
    }
    /**
     * Return a new graph with all nodes re-identified,
     * using their unique, readable names where possible.
     */
    reid() {
      const nodeLabels = Object.fromEntries(Object.values(this.nodes).map((node) => [node.id, node.name]));
      const nodeLabelCounts = /* @__PURE__ */ new Map();
      Object.values(nodeLabels).forEach((label) => {
        nodeLabelCounts.set(label, (nodeLabelCounts.get(label) || 0) + 1);
      });
      const getNodeId = (nodeId) => {
        const label = nodeLabels[nodeId];
        if (validate$1(nodeId) && nodeLabelCounts.get(label) === 1) {
          return label;
        } else {
          return nodeId;
        }
      };
      return new Graph({
        nodes: Object.fromEntries(Object.entries(this.nodes).map(([id, node]) => [
          getNodeId(id),
          { ...node, id: getNodeId(id) }
        ])),
        edges: this.edges.map((edge) => ({
          ...edge,
          source: getNodeId(edge.source),
          target: getNodeId(edge.target)
        }))
      });
    }
    drawMermaid(params) {
      const { withStyles, curveStyle, nodeColors = {
        default: "fill:#f2f0ff,line-height:1.2",
        first: "fill-opacity:0",
        last: "fill:#bfb6fc"
      }, wrapLabelNWords } = params ?? {};
      const graph = this.reid();
      const firstNode = graph.firstNode();
      const lastNode = graph.lastNode();
      return drawMermaid(graph.nodes, graph.edges, {
        firstNode: firstNode == null ? void 0 : firstNode.id,
        lastNode: lastNode == null ? void 0 : lastNode.id,
        withStyles,
        curveStyle,
        nodeColors,
        wrapLabelNWords
      });
    }
    async drawMermaidPng(params) {
      const mermaidSyntax = this.drawMermaid(params);
      return drawMermaidPng(mermaidSyntax, {
        backgroundColor: params == null ? void 0 : params.backgroundColor
      });
    }
  }
  function _firstNode(graph, exclude = []) {
    const targets = new Set(graph.edges.filter((edge) => !exclude.includes(edge.source)).map((edge) => edge.target));
    const found = [];
    for (const node of Object.values(graph.nodes)) {
      if (!exclude.includes(node.id) && !targets.has(node.id)) {
        found.push(node);
      }
    }
    return found.length === 1 ? found[0] : void 0;
  }
  function _lastNode(graph, exclude = []) {
    const sources = new Set(graph.edges.filter((edge) => !exclude.includes(edge.target)).map((edge) => edge.source));
    const found = [];
    for (const node of Object.values(graph.nodes)) {
      if (!exclude.includes(node.id) && !sources.has(node.id)) {
        found.push(node);
      }
    }
    return found.length === 1 ? found[0] : void 0;
  }
  function convertToHttpEventStream(stream) {
    const encoder = new TextEncoder();
    const finalStream = new ReadableStream({
      async start(controller) {
        for await (const chunk of stream) {
          controller.enqueue(encoder.encode(`event: data
data: ${JSON.stringify(chunk)}

`));
        }
        controller.enqueue(encoder.encode("event: end\n\n"));
        controller.close();
      }
    });
    return IterableReadableStream.fromReadableStream(finalStream);
  }
  function isIterableIterator(thing) {
    return typeof thing === "object" && thing !== null && typeof thing[Symbol.iterator] === "function" && // avoid detecting array/set as iterator
    typeof thing.next === "function";
  }
  const isIterator = (x) => x != null && typeof x === "object" && "next" in x && typeof x.next === "function";
  function isAsyncIterable(thing) {
    return typeof thing === "object" && thing !== null && typeof thing[Symbol.asyncIterator] === "function";
  }
  function* consumeIteratorInContext(context, iter) {
    while (true) {
      const { value, done } = AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(context), iter.next.bind(iter), true);
      if (done) {
        break;
      } else {
        yield value;
      }
    }
  }
  async function* consumeAsyncIterableInContext(context, iter) {
    const iterator2 = iter[Symbol.asyncIterator]();
    while (true) {
      const { value, done } = await AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(context), iterator2.next.bind(iter), true);
      if (done) {
        break;
      } else {
        yield value;
      }
    }
  }
  function _coerceToDict(value, defaultKey) {
    return value && !Array.isArray(value) && // eslint-disable-next-line no-instanceof/no-instanceof
    !(value instanceof Date) && typeof value === "object" ? value : { [defaultKey]: value };
  }
  class Runnable extends Serializable {
    constructor() {
      super(...arguments);
      Object.defineProperty(this, "lc_runnable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
    }
    getName(suffix) {
      const name = (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.name ?? this.constructor.lc_name() ?? this.constructor.name
      );
      return suffix ? `${name}${suffix}` : name;
    }
    /**
     * Bind arguments to a Runnable, returning a new Runnable.
     * @param kwargs
     * @returns A new RunnableBinding that, when invoked, will apply the bound args.
     */
    bind(kwargs) {
      return new RunnableBinding({ bound: this, kwargs, config: {} });
    }
    /**
     * Return a new Runnable that maps a list of inputs to a list of outputs,
     * by calling invoke() with each input.
     */
    map() {
      return new RunnableEach({ bound: this });
    }
    /**
     * Add retry logic to an existing runnable.
     * @param kwargs
     * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.
     */
    withRetry(fields) {
      return new RunnableRetry({
        bound: this,
        kwargs: {},
        config: {},
        maxAttemptNumber: fields == null ? void 0 : fields.stopAfterAttempt,
        ...fields
      });
    }
    /**
     * Bind config to a Runnable, returning a new Runnable.
     * @param config New configuration parameters to attach to the new runnable.
     * @returns A new RunnableBinding with a config matching what's passed.
     */
    withConfig(config2) {
      return new RunnableBinding({
        bound: this,
        config: config2,
        kwargs: {}
      });
    }
    /**
     * Create a new runnable from the current one that will try invoking
     * other passed fallback runnables if the initial invocation fails.
     * @param fields.fallbacks Other runnables to call if the runnable errors.
     * @returns A new RunnableWithFallbacks.
     */
    withFallbacks(fields) {
      const fallbacks = Array.isArray(fields) ? fields : fields.fallbacks;
      return new RunnableWithFallbacks({
        runnable: this,
        fallbacks
      });
    }
    _getOptionsList(options, length = 0) {
      if (Array.isArray(options) && options.length !== length) {
        throw new Error(`Passed "options" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`);
      }
      if (Array.isArray(options)) {
        return options.map(ensureConfig);
      }
      if (length > 1 && !Array.isArray(options) && options.runId) {
        console.warn("Provided runId will be used only for the first element of the batch.");
        const subsequent = Object.fromEntries(Object.entries(options).filter(([key]) => key !== "runId"));
        return Array.from({ length }, (_, i2) => ensureConfig(i2 === 0 ? options : subsequent));
      }
      return Array.from({ length }, () => ensureConfig(options));
    }
    async batch(inputs, options, batchOptions) {
      var _a3;
      const configList = this._getOptionsList(options ?? {}, inputs.length);
      const maxConcurrency = ((_a3 = configList[0]) == null ? void 0 : _a3.maxConcurrency) ?? (batchOptions == null ? void 0 : batchOptions.maxConcurrency);
      const caller2 = new AsyncCaller({
        maxConcurrency,
        onFailedAttempt: (e) => {
          throw e;
        }
      });
      const batchCalls = inputs.map((input, i2) => caller2.call(async () => {
        try {
          const result = await this.invoke(input, configList[i2]);
          return result;
        } catch (e) {
          if (batchOptions == null ? void 0 : batchOptions.returnExceptions) {
            return e;
          }
          throw e;
        }
      }));
      return Promise.all(batchCalls);
    }
    /**
     * Default streaming implementation.
     * Subclasses should override this method if they support streaming output.
     * @param input
     * @param options
     */
    async *_streamIterator(input, options) {
      yield this.invoke(input, options);
    }
    /**
     * Stream output in chunks.
     * @param input
     * @param options
     * @returns A readable stream that is also an iterable.
     */
    async stream(input, options) {
      const config2 = ensureConfig(options);
      const wrappedGenerator = new AsyncGeneratorWithSetup({
        generator: this._streamIterator(input, config2),
        config: config2
      });
      await wrappedGenerator.setup;
      return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
    }
    _separateRunnableConfigFromCallOptions(options) {
      let runnableConfig;
      if (options === void 0) {
        runnableConfig = ensureConfig(options);
      } else {
        runnableConfig = ensureConfig({
          callbacks: options.callbacks,
          tags: options.tags,
          metadata: options.metadata,
          runName: options.runName,
          configurable: options.configurable,
          recursionLimit: options.recursionLimit,
          maxConcurrency: options.maxConcurrency,
          runId: options.runId,
          timeout: options.timeout,
          signal: options.signal
        });
      }
      const callOptions = { ...options };
      delete callOptions.callbacks;
      delete callOptions.tags;
      delete callOptions.metadata;
      delete callOptions.runName;
      delete callOptions.configurable;
      delete callOptions.recursionLimit;
      delete callOptions.maxConcurrency;
      delete callOptions.runId;
      delete callOptions.timeout;
      delete callOptions.signal;
      return [runnableConfig, callOptions];
    }
    async _callWithConfig(func, input, options) {
      const config2 = ensureConfig(options);
      const callbackManager_ = await getCallbackManagerForConfig(config2);
      const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict(input, "input"), config2.runId, config2 == null ? void 0 : config2.runType, void 0, void 0, (config2 == null ? void 0 : config2.runName) ?? this.getName()));
      delete config2.runId;
      let output;
      try {
        const promise = func.call(this, input, config2, runManager);
        output = await raceWithSignal(promise, options == null ? void 0 : options.signal);
      } catch (e) {
        await (runManager == null ? void 0 : runManager.handleChainError(e));
        throw e;
      }
      await (runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict(output, "output")));
      return output;
    }
    /**
     * Internal method that handles batching and configuration for a runnable
     * It takes a function, input values, and optional configuration, and
     * returns a promise that resolves to the output values.
     * @param func The function to be executed for each input value.
     * @param input The input values to be processed.
     * @param config Optional configuration for the function execution.
     * @returns A promise that resolves to the output values.
     */
    async _batchWithConfig(func, inputs, options, batchOptions) {
      var _a3;
      const optionsList = this._getOptionsList(options ?? {}, inputs.length);
      const callbackManagers = await Promise.all(optionsList.map(getCallbackManagerForConfig));
      const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i2) => {
        const handleStartRes = await (callbackManager == null ? void 0 : callbackManager.handleChainStart(this.toJSON(), _coerceToDict(inputs[i2], "input"), optionsList[i2].runId, optionsList[i2].runType, void 0, void 0, optionsList[i2].runName ?? this.getName()));
        delete optionsList[i2].runId;
        return handleStartRes;
      }));
      let outputs;
      try {
        const promise = func.call(this, inputs, optionsList, runManagers, batchOptions);
        outputs = await raceWithSignal(promise, (_a3 = optionsList == null ? void 0 : optionsList[0]) == null ? void 0 : _a3.signal);
      } catch (e) {
        await Promise.all(runManagers.map((runManager) => runManager == null ? void 0 : runManager.handleChainError(e)));
        throw e;
      }
      await Promise.all(runManagers.map((runManager) => runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict(outputs, "output"))));
      return outputs;
    }
    /**
     * Helper method to transform an Iterator of Input values into an Iterator of
     * Output values, with callbacks.
     * Use this to implement `stream()` or `transform()` in Runnable subclasses.
     */
    async *_transformStreamWithConfig(inputGenerator, transformer, options) {
      let finalInput;
      let finalInputSupported = true;
      let finalOutput;
      let finalOutputSupported = true;
      const config2 = ensureConfig(options);
      const callbackManager_ = await getCallbackManagerForConfig(config2);
      async function* wrapInputForTracing() {
        for await (const chunk of inputGenerator) {
          if (finalInputSupported) {
            if (finalInput === void 0) {
              finalInput = chunk;
            } else {
              try {
                finalInput = concat(finalInput, chunk);
              } catch {
                finalInput = void 0;
                finalInputSupported = false;
              }
            }
          }
          yield chunk;
        }
      }
      let runManager;
      try {
        const pipe2 = await pipeGeneratorWithSetup(transformer.bind(this), wrapInputForTracing(), async () => callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), { input: "" }, config2.runId, config2.runType, void 0, void 0, config2.runName ?? this.getName()), options == null ? void 0 : options.signal, config2);
        delete config2.runId;
        runManager = pipe2.setup;
        const streamEventsHandler = runManager == null ? void 0 : runManager.handlers.find(isStreamEventsHandler);
        let iterator2 = pipe2.output;
        if (streamEventsHandler !== void 0 && runManager !== void 0) {
          iterator2 = streamEventsHandler.tapOutputIterable(runManager.runId, iterator2);
        }
        const streamLogHandler = runManager == null ? void 0 : runManager.handlers.find(isLogStreamHandler);
        if (streamLogHandler !== void 0 && runManager !== void 0) {
          iterator2 = streamLogHandler.tapOutputIterable(runManager.runId, iterator2);
        }
        for await (const chunk of iterator2) {
          yield chunk;
          if (finalOutputSupported) {
            if (finalOutput === void 0) {
              finalOutput = chunk;
            } else {
              try {
                finalOutput = concat(finalOutput, chunk);
              } catch {
                finalOutput = void 0;
                finalOutputSupported = false;
              }
            }
          }
        }
      } catch (e) {
        await (runManager == null ? void 0 : runManager.handleChainError(e, void 0, void 0, void 0, {
          inputs: _coerceToDict(finalInput, "input")
        }));
        throw e;
      }
      await (runManager == null ? void 0 : runManager.handleChainEnd(finalOutput ?? {}, void 0, void 0, void 0, { inputs: _coerceToDict(finalInput, "input") }));
    }
    getGraph(_) {
      const graph = new Graph();
      const inputNode = graph.addNode({
        name: `${this.getName()}Input`,
        schema: z.any()
      });
      const runnableNode = graph.addNode(this);
      const outputNode = graph.addNode({
        name: `${this.getName()}Output`,
        schema: z.any()
      });
      graph.addEdge(inputNode, runnableNode);
      graph.addEdge(runnableNode, outputNode);
      return graph;
    }
    /**
     * Create a new runnable sequence that runs each individual runnable in series,
     * piping the output of one runnable into another runnable or runnable-like.
     * @param coerceable A runnable, function, or object whose values are functions or runnables.
     * @returns A new runnable sequence.
     */
    pipe(coerceable) {
      return new RunnableSequence({
        first: this,
        last: _coerceToRunnable(coerceable)
      });
    }
    /**
     * Pick keys from the dict output of this runnable. Returns a new runnable.
     */
    pick(keys) {
      return this.pipe(new RunnablePick(keys));
    }
    /**
     * Assigns new fields to the dict output of this runnable. Returns a new runnable.
     */
    assign(mapping) {
      return this.pipe(
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        new RunnableAssign(
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          new RunnableMap({ steps: mapping })
        )
      );
    }
    /**
     * Default implementation of transform, which buffers input and then calls stream.
     * Subclasses should override this method if they can start producing output while
     * input is still being generated.
     * @param generator
     * @param options
     */
    async *transform(generator, options) {
      let finalChunk;
      for await (const chunk of generator) {
        if (finalChunk === void 0) {
          finalChunk = chunk;
        } else {
          finalChunk = concat(finalChunk, chunk);
        }
      }
      yield* this._streamIterator(finalChunk, ensureConfig(options));
    }
    /**
     * Stream all output from a runnable, as reported to the callback system.
     * This includes all inner runs of LLMs, Retrievers, Tools, etc.
     * Output is streamed as Log objects, which include a list of
     * jsonpatch ops that describe how the state of the run has changed in each
     * step, and the final state of the run.
     * The jsonpatch ops can be applied in order to construct state.
     * @param input
     * @param options
     * @param streamOptions
     */
    async *streamLog(input, options, streamOptions) {
      const logStreamCallbackHandler = new LogStreamCallbackHandler({
        ...streamOptions,
        autoClose: false,
        _schemaFormat: "original"
      });
      const config2 = ensureConfig(options);
      yield* this._streamLog(input, logStreamCallbackHandler, config2);
    }
    async *_streamLog(input, logStreamCallbackHandler, config2) {
      const { callbacks } = config2;
      if (callbacks === void 0) {
        config2.callbacks = [logStreamCallbackHandler];
      } else if (Array.isArray(callbacks)) {
        config2.callbacks = callbacks.concat([logStreamCallbackHandler]);
      } else {
        const copiedCallbacks = callbacks.copy();
        copiedCallbacks.addHandler(logStreamCallbackHandler, true);
        config2.callbacks = copiedCallbacks;
      }
      const runnableStreamPromise = this.stream(input, config2);
      async function consumeRunnableStream() {
        try {
          const runnableStream = await runnableStreamPromise;
          for await (const chunk of runnableStream) {
            const patch = new RunLogPatch({
              ops: [
                {
                  op: "add",
                  path: "/streamed_output/-",
                  value: chunk
                }
              ]
            });
            await logStreamCallbackHandler.writer.write(patch);
          }
        } finally {
          await logStreamCallbackHandler.writer.close();
        }
      }
      const runnableStreamConsumePromise = consumeRunnableStream();
      try {
        for await (const log2 of logStreamCallbackHandler) {
          yield log2;
        }
      } finally {
        await runnableStreamConsumePromise;
      }
    }
    streamEvents(input, options, streamOptions) {
      let stream;
      if (options.version === "v1") {
        stream = this._streamEventsV1(input, options, streamOptions);
      } else if (options.version === "v2") {
        stream = this._streamEventsV2(input, options, streamOptions);
      } else {
        throw new Error(`Only versions "v1" and "v2" of the schema are currently supported.`);
      }
      if (options.encoding === "text/event-stream") {
        return convertToHttpEventStream(stream);
      } else {
        return IterableReadableStream.fromAsyncGenerator(stream);
      }
    }
    async *_streamEventsV2(input, options, streamOptions) {
      var _a3;
      const eventStreamer = new EventStreamCallbackHandler({
        ...streamOptions,
        autoClose: false
      });
      const config2 = ensureConfig(options);
      const runId = config2.runId ?? v4();
      config2.runId = runId;
      const callbacks = config2.callbacks;
      if (callbacks === void 0) {
        config2.callbacks = [eventStreamer];
      } else if (Array.isArray(callbacks)) {
        config2.callbacks = callbacks.concat(eventStreamer);
      } else {
        const copiedCallbacks = callbacks.copy();
        copiedCallbacks.addHandler(eventStreamer, true);
        config2.callbacks = copiedCallbacks;
      }
      const abortController = new AbortController();
      const outerThis = this;
      async function consumeRunnableStream() {
        try {
          let signal;
          if (options == null ? void 0 : options.signal) {
            if ("any" in AbortSignal) {
              signal = AbortSignal.any([
                abortController.signal,
                options.signal
              ]);
            } else {
              signal = options.signal;
              options.signal.addEventListener("abort", () => {
                abortController.abort();
              }, { once: true });
            }
          } else {
            signal = abortController.signal;
          }
          const runnableStream = await outerThis.stream(input, {
            ...config2,
            signal
          });
          const tappedStream = eventStreamer.tapOutputIterable(runId, runnableStream);
          for await (const _ of tappedStream) {
            if (abortController.signal.aborted)
              break;
          }
        } finally {
          await eventStreamer.finish();
        }
      }
      const runnableStreamConsumePromise = consumeRunnableStream();
      let firstEventSent = false;
      let firstEventRunId;
      try {
        for await (const event of eventStreamer) {
          if (!firstEventSent) {
            event.data.input = input;
            firstEventSent = true;
            firstEventRunId = event.run_id;
            yield event;
            continue;
          }
          if (event.run_id === firstEventRunId && event.event.endsWith("_end")) {
            if ((_a3 = event.data) == null ? void 0 : _a3.input) {
              delete event.data.input;
            }
          }
          yield event;
        }
      } finally {
        abortController.abort();
        await runnableStreamConsumePromise;
      }
    }
    async *_streamEventsV1(input, options, streamOptions) {
      let runLog;
      let hasEncounteredStartEvent = false;
      const config2 = ensureConfig(options);
      const rootTags = config2.tags ?? [];
      const rootMetadata = config2.metadata ?? {};
      const rootName = config2.runName ?? this.getName();
      const logStreamCallbackHandler = new LogStreamCallbackHandler({
        ...streamOptions,
        autoClose: false,
        _schemaFormat: "streaming_events"
      });
      const rootEventFilter = new _RootEventFilter({
        ...streamOptions
      });
      const logStream = this._streamLog(input, logStreamCallbackHandler, config2);
      for await (const log2 of logStream) {
        if (!runLog) {
          runLog = RunLog.fromRunLogPatch(log2);
        } else {
          runLog = runLog.concat(log2);
        }
        if (runLog.state === void 0) {
          throw new Error(`Internal error: "streamEvents" state is missing. Please open a bug report.`);
        }
        if (!hasEncounteredStartEvent) {
          hasEncounteredStartEvent = true;
          const state3 = { ...runLog.state };
          const event = {
            run_id: state3.id,
            event: `on_${state3.type}_start`,
            name: rootName,
            tags: rootTags,
            metadata: rootMetadata,
            data: {
              input
            }
          };
          if (rootEventFilter.includeEvent(event, state3.type)) {
            yield event;
          }
        }
        const paths = log2.ops.filter((op) => op.path.startsWith("/logs/")).map((op) => op.path.split("/")[2]);
        const dedupedPaths = [...new Set(paths)];
        for (const path of dedupedPaths) {
          let eventType;
          let data = {};
          const logEntry = runLog.state.logs[path];
          if (logEntry.end_time === void 0) {
            if (logEntry.streamed_output.length > 0) {
              eventType = "stream";
            } else {
              eventType = "start";
            }
          } else {
            eventType = "end";
          }
          if (eventType === "start") {
            if (logEntry.inputs !== void 0) {
              data.input = logEntry.inputs;
            }
          } else if (eventType === "end") {
            if (logEntry.inputs !== void 0) {
              data.input = logEntry.inputs;
            }
            data.output = logEntry.final_output;
          } else if (eventType === "stream") {
            const chunkCount = logEntry.streamed_output.length;
            if (chunkCount !== 1) {
              throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: "${logEntry.name}"`);
            }
            data = { chunk: logEntry.streamed_output[0] };
            logEntry.streamed_output = [];
          }
          yield {
            event: `on_${logEntry.type}_${eventType}`,
            name: logEntry.name,
            run_id: logEntry.id,
            tags: logEntry.tags,
            metadata: logEntry.metadata,
            data
          };
        }
        const { state: state2 } = runLog;
        if (state2.streamed_output.length > 0) {
          const chunkCount = state2.streamed_output.length;
          if (chunkCount !== 1) {
            throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: "${state2.name}"`);
          }
          const data = { chunk: state2.streamed_output[0] };
          state2.streamed_output = [];
          const event = {
            event: `on_${state2.type}_stream`,
            run_id: state2.id,
            tags: rootTags,
            metadata: rootMetadata,
            name: rootName,
            data
          };
          if (rootEventFilter.includeEvent(event, state2.type)) {
            yield event;
          }
        }
      }
      const state = runLog == null ? void 0 : runLog.state;
      if (state !== void 0) {
        const event = {
          event: `on_${state.type}_end`,
          name: rootName,
          run_id: state.id,
          tags: rootTags,
          metadata: rootMetadata,
          data: {
            output: state.final_output
          }
        };
        if (rootEventFilter.includeEvent(event, state.type))
          yield event;
      }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static isRunnable(thing) {
      return isRunnableInterface(thing);
    }
    /**
     * Bind lifecycle listeners to a Runnable, returning a new Runnable.
     * The Run object contains information about the run, including its id,
     * type, input, output, error, startTime, endTime, and any tags or metadata
     * added to the run.
     *
     * @param {Object} params - The object containing the callback functions.
     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
     */
    withListeners({ onStart, onEnd, onError }) {
      return new RunnableBinding({
        bound: this,
        config: {},
        configFactories: [
          (config2) => ({
            callbacks: [
              new RootListenersTracer({
                config: config2,
                onStart,
                onEnd,
                onError
              })
            ]
          })
        ]
      });
    }
    /**
     * Convert a runnable to a tool. Return a new instance of `RunnableToolLike`
     * which contains the runnable, name, description and schema.
     *
     * @template {T extends RunInput = RunInput} RunInput - The input type of the runnable. Should be the same as the `RunInput` type of the runnable.
     *
     * @param fields
     * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.
     * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.
     * @param {z.ZodType<T>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.
     * @returns {RunnableToolLike<z.ZodType<T>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.
     */
    asTool(fields) {
      return convertRunnableToTool(this, fields);
    }
  }
  class RunnableBinding extends Runnable {
    static lc_name() {
      return "RunnableBinding";
    }
    constructor(fields) {
      super(fields);
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ["langchain_core", "runnables"]
      });
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "bound", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "config", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "kwargs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "configFactories", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.bound = fields.bound;
      this.kwargs = fields.kwargs;
      this.config = fields.config;
      this.configFactories = fields.configFactories;
    }
    getName(suffix) {
      return this.bound.getName(suffix);
    }
    async _mergeConfig(...options) {
      const config2 = mergeConfigs(this.config, ...options);
      return mergeConfigs(config2, ...this.configFactories ? await Promise.all(this.configFactories.map(async (configFactory) => await configFactory(config2))) : []);
    }
    bind(kwargs) {
      return new this.constructor({
        bound: this.bound,
        kwargs: { ...this.kwargs, ...kwargs },
        config: this.config
      });
    }
    withConfig(config2) {
      return new this.constructor({
        bound: this.bound,
        kwargs: this.kwargs,
        config: { ...this.config, ...config2 }
      });
    }
    withRetry(fields) {
      return new this.constructor({
        bound: this.bound.withRetry(fields),
        kwargs: this.kwargs,
        config: this.config
      });
    }
    async invoke(input, options) {
      return this.bound.invoke(input, await this._mergeConfig(ensureConfig(options), this.kwargs));
    }
    async batch(inputs, options, batchOptions) {
      const mergedOptions = Array.isArray(options) ? await Promise.all(options.map(async (individualOption) => this._mergeConfig(ensureConfig(individualOption), this.kwargs))) : await this._mergeConfig(ensureConfig(options), this.kwargs);
      return this.bound.batch(inputs, mergedOptions, batchOptions);
    }
    async *_streamIterator(input, options) {
      yield* this.bound._streamIterator(input, await this._mergeConfig(ensureConfig(options), this.kwargs));
    }
    async stream(input, options) {
      return this.bound.stream(input, await this._mergeConfig(ensureConfig(options), this.kwargs));
    }
    async *transform(generator, options) {
      yield* this.bound.transform(generator, await this._mergeConfig(ensureConfig(options), this.kwargs));
    }
    streamEvents(input, options, streamOptions) {
      const outerThis = this;
      const generator = async function* () {
        yield* outerThis.bound.streamEvents(input, {
          ...await outerThis._mergeConfig(ensureConfig(options), outerThis.kwargs),
          version: options.version
        }, streamOptions);
      };
      return IterableReadableStream.fromAsyncGenerator(generator());
    }
    static isRunnableBinding(thing) {
      return thing.bound && Runnable.isRunnable(thing.bound);
    }
    /**
     * Bind lifecycle listeners to a Runnable, returning a new Runnable.
     * The Run object contains information about the run, including its id,
     * type, input, output, error, startTime, endTime, and any tags or metadata
     * added to the run.
     *
     * @param {Object} params - The object containing the callback functions.
     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
     */
    withListeners({ onStart, onEnd, onError }) {
      return new RunnableBinding({
        bound: this.bound,
        kwargs: this.kwargs,
        config: this.config,
        configFactories: [
          (config2) => ({
            callbacks: [
              new RootListenersTracer({
                config: config2,
                onStart,
                onEnd,
                onError
              })
            ]
          })
        ]
      });
    }
  }
  class RunnableEach extends Runnable {
    static lc_name() {
      return "RunnableEach";
    }
    constructor(fields) {
      super(fields);
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ["langchain_core", "runnables"]
      });
      Object.defineProperty(this, "bound", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.bound = fields.bound;
    }
    /**
     * Binds the runnable with the specified arguments.
     * @param kwargs The arguments to bind the runnable with.
     * @returns A new instance of the `RunnableEach` class that is bound with the specified arguments.
     */
    bind(kwargs) {
      return new RunnableEach({
        bound: this.bound.bind(kwargs)
      });
    }
    /**
     * Invokes the runnable with the specified input and configuration.
     * @param input The input to invoke the runnable with.
     * @param config The configuration to invoke the runnable with.
     * @returns A promise that resolves to the output of the runnable.
     */
    async invoke(inputs, config2) {
      return this._callWithConfig(this._invoke.bind(this), inputs, config2);
    }
    /**
     * A helper method that is used to invoke the runnable with the specified input and configuration.
     * @param input The input to invoke the runnable with.
     * @param config The configuration to invoke the runnable with.
     * @returns A promise that resolves to the output of the runnable.
     */
    async _invoke(inputs, config2, runManager) {
      return this.bound.batch(inputs, patchConfig(config2, { callbacks: runManager == null ? void 0 : runManager.getChild() }));
    }
    /**
     * Bind lifecycle listeners to a Runnable, returning a new Runnable.
     * The Run object contains information about the run, including its id,
     * type, input, output, error, startTime, endTime, and any tags or metadata
     * added to the run.
     *
     * @param {Object} params - The object containing the callback functions.
     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
     */
    withListeners({ onStart, onEnd, onError }) {
      return new RunnableEach({
        bound: this.bound.withListeners({ onStart, onEnd, onError })
      });
    }
  }
  class RunnableRetry extends RunnableBinding {
    static lc_name() {
      return "RunnableRetry";
    }
    constructor(fields) {
      super(fields);
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ["langchain_core", "runnables"]
      });
      Object.defineProperty(this, "maxAttemptNumber", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 3
      });
      Object.defineProperty(this, "onFailedAttempt", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: () => {
        }
      });
      this.maxAttemptNumber = fields.maxAttemptNumber ?? this.maxAttemptNumber;
      this.onFailedAttempt = fields.onFailedAttempt ?? this.onFailedAttempt;
    }
    _patchConfigForRetry(attempt, config2, runManager) {
      const tag = attempt > 1 ? `retry:attempt:${attempt}` : void 0;
      return patchConfig(config2, { callbacks: runManager == null ? void 0 : runManager.getChild(tag) });
    }
    async _invoke(input, config2, runManager) {
      return pRetry((attemptNumber) => super.invoke(input, this._patchConfigForRetry(attemptNumber, config2, runManager)), {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        onFailedAttempt: (error) => this.onFailedAttempt(error, input),
        retries: Math.max(this.maxAttemptNumber - 1, 0),
        randomize: true
      });
    }
    /**
     * Method that invokes the runnable with the specified input, run manager,
     * and config. It handles the retry logic by catching any errors and
     * recursively invoking itself with the updated config for the next retry
     * attempt.
     * @param input The input for the runnable.
     * @param runManager The run manager for the runnable.
     * @param config The config for the runnable.
     * @returns A promise that resolves to the output of the runnable.
     */
    async invoke(input, config2) {
      return this._callWithConfig(this._invoke.bind(this), input, config2);
    }
    async _batch(inputs, configs, runManagers, batchOptions) {
      const resultsMap = {};
      try {
        await pRetry(async (attemptNumber) => {
          const remainingIndexes = inputs.map((_, i2) => i2).filter((i2) => resultsMap[i2.toString()] === void 0 || // eslint-disable-next-line no-instanceof/no-instanceof
          resultsMap[i2.toString()] instanceof Error);
          const remainingInputs = remainingIndexes.map((i2) => inputs[i2]);
          const patchedConfigs = remainingIndexes.map((i2) => this._patchConfigForRetry(attemptNumber, configs == null ? void 0 : configs[i2], runManagers == null ? void 0 : runManagers[i2]));
          const results = await super.batch(remainingInputs, patchedConfigs, {
            ...batchOptions,
            returnExceptions: true
          });
          let firstException;
          for (let i2 = 0; i2 < results.length; i2 += 1) {
            const result = results[i2];
            const resultMapIndex = remainingIndexes[i2];
            if (result instanceof Error) {
              if (firstException === void 0) {
                firstException = result;
                firstException.input = remainingInputs[i2];
              }
            }
            resultsMap[resultMapIndex.toString()] = result;
          }
          if (firstException) {
            throw firstException;
          }
          return results;
        }, {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          onFailedAttempt: (error) => this.onFailedAttempt(error, error.input),
          retries: Math.max(this.maxAttemptNumber - 1, 0),
          randomize: true
        });
      } catch (e) {
        if ((batchOptions == null ? void 0 : batchOptions.returnExceptions) !== true) {
          throw e;
        }
      }
      return Object.keys(resultsMap).sort((a, b) => parseInt(a, 10) - parseInt(b, 10)).map((key) => resultsMap[parseInt(key, 10)]);
    }
    async batch(inputs, options, batchOptions) {
      return this._batchWithConfig(this._batch.bind(this), inputs, options, batchOptions);
    }
  }
  class RunnableSequence extends Runnable {
    static lc_name() {
      return "RunnableSequence";
    }
    constructor(fields) {
      super(fields);
      Object.defineProperty(this, "first", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "middle", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
      Object.defineProperty(this, "last", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "omitSequenceTags", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ["langchain_core", "runnables"]
      });
      this.first = fields.first;
      this.middle = fields.middle ?? this.middle;
      this.last = fields.last;
      this.name = fields.name;
      this.omitSequenceTags = fields.omitSequenceTags ?? this.omitSequenceTags;
    }
    get steps() {
      return [this.first, ...this.middle, this.last];
    }
    async invoke(input, options) {
      var _a3;
      const config2 = ensureConfig(options);
      const callbackManager_ = await getCallbackManagerForConfig(config2);
      const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict(input, "input"), config2.runId, void 0, void 0, void 0, config2 == null ? void 0 : config2.runName));
      delete config2.runId;
      let nextStepInput = input;
      let finalOutput;
      try {
        const initialSteps = [this.first, ...this.middle];
        for (let i2 = 0; i2 < initialSteps.length; i2 += 1) {
          const step = initialSteps[i2];
          const promise = step.invoke(nextStepInput, patchConfig(config2, {
            callbacks: runManager == null ? void 0 : runManager.getChild(this.omitSequenceTags ? void 0 : `seq:step:${i2 + 1}`)
          }));
          nextStepInput = await raceWithSignal(promise, options == null ? void 0 : options.signal);
        }
        if ((_a3 = options == null ? void 0 : options.signal) == null ? void 0 : _a3.aborted) {
          throw new Error("Aborted");
        }
        finalOutput = await this.last.invoke(nextStepInput, patchConfig(config2, {
          callbacks: runManager == null ? void 0 : runManager.getChild(this.omitSequenceTags ? void 0 : `seq:step:${this.steps.length}`)
        }));
      } catch (e) {
        await (runManager == null ? void 0 : runManager.handleChainError(e));
        throw e;
      }
      await (runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict(finalOutput, "output")));
      return finalOutput;
    }
    async batch(inputs, options, batchOptions) {
      var _a3;
      const configList = this._getOptionsList(options ?? {}, inputs.length);
      const callbackManagers = await Promise.all(configList.map(getCallbackManagerForConfig));
      const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i2) => {
        const handleStartRes = await (callbackManager == null ? void 0 : callbackManager.handleChainStart(this.toJSON(), _coerceToDict(inputs[i2], "input"), configList[i2].runId, void 0, void 0, void 0, configList[i2].runName));
        delete configList[i2].runId;
        return handleStartRes;
      }));
      let nextStepInputs = inputs;
      try {
        for (let i2 = 0; i2 < this.steps.length; i2 += 1) {
          const step = this.steps[i2];
          const promise = step.batch(nextStepInputs, runManagers.map((runManager, j) => {
            const childRunManager = runManager == null ? void 0 : runManager.getChild(this.omitSequenceTags ? void 0 : `seq:step:${i2 + 1}`);
            return patchConfig(configList[j], { callbacks: childRunManager });
          }), batchOptions);
          nextStepInputs = await raceWithSignal(promise, (_a3 = configList[0]) == null ? void 0 : _a3.signal);
        }
      } catch (e) {
        await Promise.all(runManagers.map((runManager) => runManager == null ? void 0 : runManager.handleChainError(e)));
        throw e;
      }
      await Promise.all(runManagers.map((runManager) => runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict(nextStepInputs, "output"))));
      return nextStepInputs;
    }
    async *_streamIterator(input, options) {
      var _a3;
      const callbackManager_ = await getCallbackManagerForConfig(options);
      const { runId, ...otherOptions } = options ?? {};
      const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict(input, "input"), runId, void 0, void 0, void 0, otherOptions == null ? void 0 : otherOptions.runName));
      const steps = [this.first, ...this.middle, this.last];
      let concatSupported = true;
      let finalOutput;
      async function* inputGenerator() {
        yield input;
      }
      try {
        let finalGenerator = steps[0].transform(inputGenerator(), patchConfig(otherOptions, {
          callbacks: runManager == null ? void 0 : runManager.getChild(this.omitSequenceTags ? void 0 : `seq:step:1`)
        }));
        for (let i2 = 1; i2 < steps.length; i2 += 1) {
          const step = steps[i2];
          finalGenerator = await step.transform(finalGenerator, patchConfig(otherOptions, {
            callbacks: runManager == null ? void 0 : runManager.getChild(this.omitSequenceTags ? void 0 : `seq:step:${i2 + 1}`)
          }));
        }
        for await (const chunk of finalGenerator) {
          (_a3 = options == null ? void 0 : options.signal) == null ? void 0 : _a3.throwIfAborted();
          yield chunk;
          if (concatSupported) {
            if (finalOutput === void 0) {
              finalOutput = chunk;
            } else {
              try {
                finalOutput = concat(finalOutput, chunk);
              } catch (e) {
                finalOutput = void 0;
                concatSupported = false;
              }
            }
          }
        }
      } catch (e) {
        await (runManager == null ? void 0 : runManager.handleChainError(e));
        throw e;
      }
      await (runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict(finalOutput, "output")));
    }
    getGraph(config2) {
      const graph = new Graph();
      let currentLastNode = null;
      this.steps.forEach((step, index) => {
        const stepGraph = step.getGraph(config2);
        if (index !== 0) {
          stepGraph.trimFirstNode();
        }
        if (index !== this.steps.length - 1) {
          stepGraph.trimLastNode();
        }
        graph.extend(stepGraph);
        const stepFirstNode = stepGraph.firstNode();
        if (!stepFirstNode) {
          throw new Error(`Runnable ${step} has no first node`);
        }
        if (currentLastNode) {
          graph.addEdge(currentLastNode, stepFirstNode);
        }
        currentLastNode = stepGraph.lastNode();
      });
      return graph;
    }
    pipe(coerceable) {
      if (RunnableSequence.isRunnableSequence(coerceable)) {
        return new RunnableSequence({
          first: this.first,
          middle: this.middle.concat([
            this.last,
            coerceable.first,
            ...coerceable.middle
          ]),
          last: coerceable.last,
          name: this.name ?? coerceable.name
        });
      } else {
        return new RunnableSequence({
          first: this.first,
          middle: [...this.middle, this.last],
          last: _coerceToRunnable(coerceable),
          name: this.name
        });
      }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static isRunnableSequence(thing) {
      return Array.isArray(thing.middle) && Runnable.isRunnable(thing);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static from([first2, ...runnables], nameOrFields) {
      let extra = {};
      if (typeof nameOrFields === "string") {
        extra.name = nameOrFields;
      } else if (nameOrFields !== void 0) {
        extra = nameOrFields;
      }
      return new RunnableSequence({
        ...extra,
        first: _coerceToRunnable(first2),
        middle: runnables.slice(0, -1).map(_coerceToRunnable),
        last: _coerceToRunnable(runnables[runnables.length - 1])
      });
    }
  }
  class RunnableMap extends Runnable {
    static lc_name() {
      return "RunnableMap";
    }
    getStepsKeys() {
      return Object.keys(this.steps);
    }
    constructor(fields) {
      super(fields);
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ["langchain_core", "runnables"]
      });
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "steps", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.steps = {};
      for (const [key, value] of Object.entries(fields.steps)) {
        this.steps[key] = _coerceToRunnable(value);
      }
    }
    static from(steps) {
      return new RunnableMap({ steps });
    }
    async invoke(input, options) {
      const config2 = ensureConfig(options);
      const callbackManager_ = await getCallbackManagerForConfig(config2);
      const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), {
        input
      }, config2.runId, void 0, void 0, void 0, config2 == null ? void 0 : config2.runName));
      delete config2.runId;
      const output = {};
      try {
        const promises = Object.entries(this.steps).map(async ([key, runnable]) => {
          output[key] = await runnable.invoke(input, patchConfig(config2, {
            callbacks: runManager == null ? void 0 : runManager.getChild(`map:key:${key}`)
          }));
        });
        await raceWithSignal(Promise.all(promises), options == null ? void 0 : options.signal);
      } catch (e) {
        await (runManager == null ? void 0 : runManager.handleChainError(e));
        throw e;
      }
      await (runManager == null ? void 0 : runManager.handleChainEnd(output));
      return output;
    }
    async *_transform(generator, runManager, options) {
      const steps = { ...this.steps };
      const inputCopies = atee(generator, Object.keys(steps).length);
      const tasks = new Map(Object.entries(steps).map(([key, runnable], i2) => {
        const gen = runnable.transform(inputCopies[i2], patchConfig(options, {
          callbacks: runManager == null ? void 0 : runManager.getChild(`map:key:${key}`)
        }));
        return [key, gen.next().then((result) => ({ key, gen, result }))];
      }));
      while (tasks.size) {
        const promise = Promise.race(tasks.values());
        const { key, result, gen } = await raceWithSignal(promise, options == null ? void 0 : options.signal);
        tasks.delete(key);
        if (!result.done) {
          yield { [key]: result.value };
          tasks.set(key, gen.next().then((result2) => ({ key, gen, result: result2 })));
        }
      }
    }
    transform(generator, options) {
      return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
    }
    async stream(input, options) {
      async function* generator() {
        yield input;
      }
      const config2 = ensureConfig(options);
      const wrappedGenerator = new AsyncGeneratorWithSetup({
        generator: this.transform(generator(), config2),
        config: config2
      });
      await wrappedGenerator.setup;
      return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
    }
  }
  class RunnableTraceable extends Runnable {
    constructor(fields) {
      super(fields);
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ["langchain_core", "runnables"]
      });
      Object.defineProperty(this, "func", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      if (!isTraceableFunction(fields.func)) {
        throw new Error("RunnableTraceable requires a function that is wrapped in traceable higher-order function");
      }
      this.func = fields.func;
    }
    async invoke(input, options) {
      const [config2] = this._getOptionsList(options ?? {}, 1);
      const callbacks = await getCallbackManagerForConfig(config2);
      const promise = this.func(patchConfig(config2, { callbacks }), input);
      return raceWithSignal(promise, config2 == null ? void 0 : config2.signal);
    }
    async *_streamIterator(input, options) {
      var _a3, _b2;
      const [config2] = this._getOptionsList(options ?? {}, 1);
      const result = await this.invoke(input, options);
      if (isAsyncIterable(result)) {
        for await (const item of result) {
          (_a3 = config2 == null ? void 0 : config2.signal) == null ? void 0 : _a3.throwIfAborted();
          yield item;
        }
        return;
      }
      if (isIterator(result)) {
        while (true) {
          (_b2 = config2 == null ? void 0 : config2.signal) == null ? void 0 : _b2.throwIfAborted();
          const state = result.next();
          if (state.done)
            break;
          yield state.value;
        }
        return;
      }
      yield result;
    }
    static from(func) {
      return new RunnableTraceable({ func });
    }
  }
  function assertNonTraceableFunction(func) {
    if (isTraceableFunction(func)) {
      throw new Error("RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.");
    }
  }
  class RunnableLambda extends Runnable {
    static lc_name() {
      return "RunnableLambda";
    }
    constructor(fields) {
      if (isTraceableFunction(fields.func)) {
        return RunnableTraceable.from(fields.func);
      }
      super(fields);
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ["langchain_core", "runnables"]
      });
      Object.defineProperty(this, "func", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      assertNonTraceableFunction(fields.func);
      this.func = fields.func;
    }
    static from(func) {
      return new RunnableLambda({
        func
      });
    }
    async _invoke(input, config2, runManager) {
      return new Promise((resolve, reject) => {
        const childConfig = patchConfig(config2, {
          callbacks: runManager == null ? void 0 : runManager.getChild(),
          recursionLimit: ((config2 == null ? void 0 : config2.recursionLimit) ?? DEFAULT_RECURSION_LIMIT) - 1
        });
        void AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(childConfig), async () => {
          var _a3, _b2;
          try {
            let output = await this.func(input, {
              ...childConfig
            });
            if (output && Runnable.isRunnable(output)) {
              if ((config2 == null ? void 0 : config2.recursionLimit) === 0) {
                throw new Error("Recursion limit reached.");
              }
              output = await output.invoke(input, {
                ...childConfig,
                recursionLimit: (childConfig.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1
              });
            } else if (isAsyncIterable(output)) {
              let finalOutput;
              for await (const chunk of consumeAsyncIterableInContext(childConfig, output)) {
                (_a3 = config2 == null ? void 0 : config2.signal) == null ? void 0 : _a3.throwIfAborted();
                if (finalOutput === void 0) {
                  finalOutput = chunk;
                } else {
                  try {
                    finalOutput = concat(finalOutput, chunk);
                  } catch (e) {
                    finalOutput = chunk;
                  }
                }
              }
              output = finalOutput;
            } else if (isIterableIterator(output)) {
              let finalOutput;
              for (const chunk of consumeIteratorInContext(childConfig, output)) {
                (_b2 = config2 == null ? void 0 : config2.signal) == null ? void 0 : _b2.throwIfAborted();
                if (finalOutput === void 0) {
                  finalOutput = chunk;
                } else {
                  try {
                    finalOutput = concat(finalOutput, chunk);
                  } catch (e) {
                    finalOutput = chunk;
                  }
                }
              }
              output = finalOutput;
            }
            resolve(output);
          } catch (e) {
            reject(e);
          }
        });
      });
    }
    async invoke(input, options) {
      return this._callWithConfig(this._invoke.bind(this), input, options);
    }
    async *_transform(generator, runManager, config2) {
      var _a3, _b2;
      let finalChunk;
      for await (const chunk of generator) {
        if (finalChunk === void 0) {
          finalChunk = chunk;
        } else {
          try {
            finalChunk = concat(finalChunk, chunk);
          } catch (e) {
            finalChunk = chunk;
          }
        }
      }
      const childConfig = patchConfig(config2, {
        callbacks: runManager == null ? void 0 : runManager.getChild(),
        recursionLimit: ((config2 == null ? void 0 : config2.recursionLimit) ?? DEFAULT_RECURSION_LIMIT) - 1
      });
      const output = await new Promise((resolve, reject) => {
        void AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(childConfig), async () => {
          try {
            const res = await this.func(finalChunk, {
              ...childConfig,
              config: childConfig
            });
            resolve(res);
          } catch (e) {
            reject(e);
          }
        });
      });
      if (output && Runnable.isRunnable(output)) {
        if ((config2 == null ? void 0 : config2.recursionLimit) === 0) {
          throw new Error("Recursion limit reached.");
        }
        const stream = await output.stream(finalChunk, childConfig);
        for await (const chunk of stream) {
          yield chunk;
        }
      } else if (isAsyncIterable(output)) {
        for await (const chunk of consumeAsyncIterableInContext(childConfig, output)) {
          (_a3 = config2 == null ? void 0 : config2.signal) == null ? void 0 : _a3.throwIfAborted();
          yield chunk;
        }
      } else if (isIterableIterator(output)) {
        for (const chunk of consumeIteratorInContext(childConfig, output)) {
          (_b2 = config2 == null ? void 0 : config2.signal) == null ? void 0 : _b2.throwIfAborted();
          yield chunk;
        }
      } else {
        yield output;
      }
    }
    transform(generator, options) {
      return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
    }
    async stream(input, options) {
      async function* generator() {
        yield input;
      }
      const config2 = ensureConfig(options);
      const wrappedGenerator = new AsyncGeneratorWithSetup({
        generator: this.transform(generator(), config2),
        config: config2
      });
      await wrappedGenerator.setup;
      return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
    }
  }
  class RunnableWithFallbacks extends Runnable {
    static lc_name() {
      return "RunnableWithFallbacks";
    }
    constructor(fields) {
      super(fields);
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ["langchain_core", "runnables"]
      });
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "runnable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "fallbacks", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.runnable = fields.runnable;
      this.fallbacks = fields.fallbacks;
    }
    *runnables() {
      yield this.runnable;
      for (const fallback of this.fallbacks) {
        yield fallback;
      }
    }
    async invoke(input, options) {
      const config2 = ensureConfig(options);
      const callbackManager_ = await getCallbackManagerForConfig(config2);
      const { runId, ...otherConfigFields } = config2;
      const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict(input, "input"), runId, void 0, void 0, void 0, otherConfigFields == null ? void 0 : otherConfigFields.runName));
      const childConfig = patchConfig(otherConfigFields, {
        callbacks: runManager == null ? void 0 : runManager.getChild()
      });
      const res = await AsyncLocalStorageProviderSingleton.runWithConfig(childConfig, async () => {
        var _a3;
        let firstError;
        for (const runnable of this.runnables()) {
          (_a3 = config2 == null ? void 0 : config2.signal) == null ? void 0 : _a3.throwIfAborted();
          try {
            const output = await runnable.invoke(input, childConfig);
            await (runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict(output, "output")));
            return output;
          } catch (e) {
            if (firstError === void 0) {
              firstError = e;
            }
          }
        }
        if (firstError === void 0) {
          throw new Error("No error stored at end of fallback.");
        }
        await (runManager == null ? void 0 : runManager.handleChainError(firstError));
        throw firstError;
      });
      return res;
    }
    async *_streamIterator(input, options) {
      var _a3;
      const config2 = ensureConfig(options);
      const callbackManager_ = await getCallbackManagerForConfig(config2);
      const { runId, ...otherConfigFields } = config2;
      const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict(input, "input"), runId, void 0, void 0, void 0, otherConfigFields == null ? void 0 : otherConfigFields.runName));
      let firstError;
      let stream;
      for (const runnable of this.runnables()) {
        (_a3 = config2 == null ? void 0 : config2.signal) == null ? void 0 : _a3.throwIfAborted();
        const childConfig = patchConfig(otherConfigFields, {
          callbacks: runManager == null ? void 0 : runManager.getChild()
        });
        try {
          const originalStream = await runnable.stream(input, childConfig);
          stream = consumeAsyncIterableInContext(childConfig, originalStream);
          break;
        } catch (e) {
          if (firstError === void 0) {
            firstError = e;
          }
        }
      }
      if (stream === void 0) {
        const error = firstError ?? new Error("No error stored at end of fallback.");
        await (runManager == null ? void 0 : runManager.handleChainError(error));
        throw error;
      }
      let output;
      try {
        for await (const chunk of stream) {
          yield chunk;
          try {
            output = output === void 0 ? output : concat(output, chunk);
          } catch (e) {
            output = void 0;
          }
        }
      } catch (e) {
        await (runManager == null ? void 0 : runManager.handleChainError(e));
        throw e;
      }
      await (runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict(output, "output")));
    }
    async batch(inputs, options, batchOptions) {
      var _a3;
      if (batchOptions == null ? void 0 : batchOptions.returnExceptions) {
        throw new Error("Not implemented.");
      }
      const configList = this._getOptionsList(options ?? {}, inputs.length);
      const callbackManagers = await Promise.all(configList.map((config2) => getCallbackManagerForConfig(config2)));
      const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i2) => {
        const handleStartRes = await (callbackManager == null ? void 0 : callbackManager.handleChainStart(this.toJSON(), _coerceToDict(inputs[i2], "input"), configList[i2].runId, void 0, void 0, void 0, configList[i2].runName));
        delete configList[i2].runId;
        return handleStartRes;
      }));
      let firstError;
      for (const runnable of this.runnables()) {
        (_a3 = configList[0].signal) == null ? void 0 : _a3.throwIfAborted();
        try {
          const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => patchConfig(configList[j], {
            callbacks: runManager == null ? void 0 : runManager.getChild()
          })), batchOptions);
          await Promise.all(runManagers.map((runManager, i2) => runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict(outputs[i2], "output"))));
          return outputs;
        } catch (e) {
          if (firstError === void 0) {
            firstError = e;
          }
        }
      }
      if (!firstError) {
        throw new Error("No error stored at end of fallbacks.");
      }
      await Promise.all(runManagers.map((runManager) => runManager == null ? void 0 : runManager.handleChainError(firstError)));
      throw firstError;
    }
  }
  function _coerceToRunnable(coerceable) {
    if (typeof coerceable === "function") {
      return new RunnableLambda({ func: coerceable });
    } else if (Runnable.isRunnable(coerceable)) {
      return coerceable;
    } else if (!Array.isArray(coerceable) && typeof coerceable === "object") {
      const runnables = {};
      for (const [key, value] of Object.entries(coerceable)) {
        runnables[key] = _coerceToRunnable(value);
      }
      return new RunnableMap({
        steps: runnables
      });
    } else {
      throw new Error(`Expected a Runnable, function or object.
Instead got an unsupported type.`);
    }
  }
  class RunnableAssign extends Runnable {
    static lc_name() {
      return "RunnableAssign";
    }
    constructor(fields) {
      if (fields instanceof RunnableMap) {
        fields = { mapper: fields };
      }
      super(fields);
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ["langchain_core", "runnables"]
      });
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "mapper", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.mapper = fields.mapper;
    }
    async invoke(input, options) {
      const mapperResult = await this.mapper.invoke(input, options);
      return {
        ...input,
        ...mapperResult
      };
    }
    async *_transform(generator, runManager, options) {
      const mapperKeys = this.mapper.getStepsKeys();
      const [forPassthrough, forMapper] = atee(generator);
      const mapperOutput = this.mapper.transform(forMapper, patchConfig(options, { callbacks: runManager == null ? void 0 : runManager.getChild() }));
      const firstMapperChunkPromise = mapperOutput.next();
      for await (const chunk of forPassthrough) {
        if (typeof chunk !== "object" || Array.isArray(chunk)) {
          throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof chunk}`);
        }
        const filtered = Object.fromEntries(Object.entries(chunk).filter(([key]) => !mapperKeys.includes(key)));
        if (Object.keys(filtered).length > 0) {
          yield filtered;
        }
      }
      yield (await firstMapperChunkPromise).value;
      for await (const chunk of mapperOutput) {
        yield chunk;
      }
    }
    transform(generator, options) {
      return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
    }
    async stream(input, options) {
      async function* generator() {
        yield input;
      }
      const config2 = ensureConfig(options);
      const wrappedGenerator = new AsyncGeneratorWithSetup({
        generator: this.transform(generator(), config2),
        config: config2
      });
      await wrappedGenerator.setup;
      return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
    }
  }
  class RunnablePick extends Runnable {
    static lc_name() {
      return "RunnablePick";
    }
    constructor(fields) {
      if (typeof fields === "string" || Array.isArray(fields)) {
        fields = { keys: fields };
      }
      super(fields);
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ["langchain_core", "runnables"]
      });
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "keys", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.keys = fields.keys;
    }
    async _pick(input) {
      if (typeof this.keys === "string") {
        return input[this.keys];
      } else {
        const picked = this.keys.map((key) => [key, input[key]]).filter((v) => v[1] !== void 0);
        return picked.length === 0 ? void 0 : Object.fromEntries(picked);
      }
    }
    async invoke(input, options) {
      return this._callWithConfig(this._pick.bind(this), input, options);
    }
    async *_transform(generator) {
      for await (const chunk of generator) {
        const picked = await this._pick(chunk);
        if (picked !== void 0) {
          yield picked;
        }
      }
    }
    transform(generator, options) {
      return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
    }
    async stream(input, options) {
      async function* generator() {
        yield input;
      }
      const config2 = ensureConfig(options);
      const wrappedGenerator = new AsyncGeneratorWithSetup({
        generator: this.transform(generator(), config2),
        config: config2
      });
      await wrappedGenerator.setup;
      return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
    }
  }
  class RunnableToolLike extends RunnableBinding {
    constructor(fields) {
      const sequence = RunnableSequence.from([
        RunnableLambda.from(async (input) => {
          let toolInput;
          if (_isToolCall(input)) {
            try {
              toolInput = await this.schema.parseAsync(input.args);
            } catch (e) {
              throw new ToolInputParsingException(`Received tool input did not match expected schema`, JSON.stringify(input.args));
            }
          } else {
            toolInput = input;
          }
          return toolInput;
        }).withConfig({ runName: `${fields.name}:parse_input` }),
        fields.bound
      ]).withConfig({ runName: fields.name });
      super({
        bound: sequence,
        config: fields.config ?? {}
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "description", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "schema", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.name = fields.name;
      this.description = fields.description;
      this.schema = fields.schema;
    }
    static lc_name() {
      return "RunnableToolLike";
    }
  }
  function convertRunnableToTool(runnable, fields) {
    var _a3;
    const name = fields.name ?? runnable.getName();
    const description = fields.description ?? ((_a3 = fields.schema) == null ? void 0 : _a3.description);
    if (fields.schema.constructor === z.ZodString) {
      return new RunnableToolLike({
        name,
        description,
        schema: z.object({
          input: z.string()
        }).transform((input) => input.input),
        bound: runnable
      });
    }
    return new RunnableToolLike({
      name,
      description,
      schema: fields.schema,
      bound: runnable
    });
  }
  function removeThinkTags(text) {
    const thinkTagsRegex = /<think>[\s\S]*?<\/think>/g;
    let result = text.replace(thinkTagsRegex, "");
    const strayCloseTagRegex = /[\s\S]*?<\/think>/g;
    result = result.replace(strayCloseTagRegex, "");
    return result.trim();
  }
  function extractJsonFromModelOutput(content) {
    try {
      let processedContent = content;
      if (processedContent.includes("```")) {
        const parts = processedContent.split("```");
        processedContent = parts[1];
        if (processedContent.includes("\\n")) {
          const newlineIndex = processedContent.indexOf("\\n");
          processedContent = processedContent.substring(newlineIndex + 1);
        }
      }
      return JSON.parse(processedContent);
    } catch (e) {
      console.warn(`Failed to parse model output: ${content} ${e instanceof Error ? e.message : String(e)}`);
      throw new Error("Could not parse response.");
    }
  }
  function convertInputMessages(inputMessages, modelName) {
    if (modelName === null) {
      return inputMessages;
    }
    if (modelName === "deepseek-reasoner" || modelName.includes("deepseek-r1")) {
      const convertedInputMessages = convertMessagesForNonFunctionCallingModels(inputMessages);
      let mergedInputMessages = mergeSuccessiveMessages(convertedInputMessages, HumanMessage);
      mergedInputMessages = mergeSuccessiveMessages(mergedInputMessages, AIMessage);
      return mergedInputMessages;
    }
    return inputMessages;
  }
  function convertMessagesForNonFunctionCallingModels(inputMessages) {
    const outputMessages = [];
    for (const message of inputMessages) {
      if (message instanceof HumanMessage || message instanceof SystemMessage) {
        outputMessages.push(message);
      } else if (message instanceof ToolMessage) {
        outputMessages.push(new HumanMessage({ content: message.content }));
      } else if (message instanceof AIMessage) {
        if (message.tool_calls) {
          const toolCalls = JSON.stringify(message.tool_calls);
          outputMessages.push(new AIMessage({ content: toolCalls }));
        } else {
          outputMessages.push(message);
        }
      } else {
        throw new Error(`Unknown message type: ${message.constructor.name}`);
      }
    }
    return outputMessages;
  }
  function mergeSuccessiveMessages(messages, classToMerge) {
    const mergedMessages = [];
    let streak = 0;
    for (const message of messages) {
      if (message instanceof classToMerge) {
        streak += 1;
        if (streak > 1) {
          const lastMessage = mergedMessages[mergedMessages.length - 1];
          if (Array.isArray(message.content)) {
            if (typeof lastMessage.content === "string") {
              const textContent = message.content.find(
                (item) => typeof item === "object" && "type" in item && item.type === "text"
              );
              if (textContent && "text" in textContent) {
                lastMessage.content += textContent.text;
              }
            }
          } else {
            if (typeof lastMessage.content === "string" && typeof message.content === "string") {
              lastMessage.content += message.content;
            }
          }
        } else {
          mergedMessages.push(message);
        }
      } else {
        mergedMessages.push(message);
        streak = 0;
      }
    }
    return mergedMessages;
  }
  const logger$7 = createLogger("agent");
  class BaseAgent {
    constructor(modelOutputSchema, options, extraOptions) {
      this.actions = {};
      this.modelOutputSchema = modelOutputSchema;
      this.chatLLM = options.chatLLM;
      this.prompt = options.prompt;
      this.context = options.context;
      this.chatModelLibrary = this.chatLLM.constructor.name;
      this.modelName = this.getModelName();
      this.withStructuredOutput = this.setWithStructuredOutput();
      this.id = (extraOptions == null ? void 0 : extraOptions.id) || "agent";
      this.toolCallingMethod = this.setToolCallingMethod(extraOptions == null ? void 0 : extraOptions.toolCallingMethod);
      this.callOptions = extraOptions == null ? void 0 : extraOptions.callOptions;
      this.modelOutputToolName = `${this.id}_output`;
    }
    // Set the model name
    getModelName() {
      if ("modelName" in this.chatLLM) {
        return this.chatLLM.modelName;
      }
      if ("model_name" in this.chatLLM) {
        return this.chatLLM.model_name;
      }
      if ("model" in this.chatLLM) {
        return this.chatLLM.model;
      }
      return "Unknown";
    }
    // Set the tool calling method
    setToolCallingMethod(toolCallingMethod) {
      if (toolCallingMethod === "auto") {
        switch (this.chatModelLibrary) {
          case "ChatGoogleGenerativeAI":
            return null;
          case "ChatOpenAI":
          case "AzureChatOpenAI":
          case "ChatGroq":
          case "ChatXAI":
            return "function_calling";
          default:
            return null;
        }
      }
      return toolCallingMethod || null;
    }
    // Set whether to use structured output based on the model name
    setWithStructuredOutput() {
      if (this.modelName === "deepseek-reasoner" || this.modelName === "deepseek-r1") {
        return false;
      }
      return true;
    }
    async invoke(inputMessages) {
      if (this.withStructuredOutput) {
        const structuredLlm = this.chatLLM.withStructuredOutput(this.modelOutputSchema, {
          includeRaw: true,
          name: this.modelOutputToolName
        });
        try {
          const response2 = await structuredLlm.invoke(inputMessages, {
            ...this.callOptions
          });
          if (response2.parsed) {
            return response2.parsed;
          }
          logger$7.error("Failed to parse response", response2);
          throw new Error("Could not parse response with structured output");
        } catch (error) {
          const errorMessage2 = `Failed to invoke ${this.modelName} with structured output: ${error}`;
          throw new Error(errorMessage2);
        }
      }
      const convertedInputMessages = convertInputMessages(inputMessages, this.modelName);
      const response = await this.chatLLM.invoke(convertedInputMessages, {
        ...this.callOptions
      });
      if (typeof response.content === "string") {
        response.content = removeThinkTags(response.content);
        try {
          const extractedJson = extractJsonFromModelOutput(response.content);
          const parsed = this.validateModelOutput(extractedJson);
          if (parsed) {
            return parsed;
          }
        } catch (error) {
          const errorMessage2 = `Failed to extract JSON from response: ${error}`;
          throw new Error(errorMessage2);
        }
      }
      const errorMessage = `Failed to parse response: ${response}`;
      logger$7.error(errorMessage);
      throw new Error("Could not parse response");
    }
    // Helper method to validate metadata
    validateModelOutput(data) {
      if (!this.modelOutputSchema || !data) return void 0;
      try {
        return this.modelOutputSchema.parse(data);
      } catch (error) {
        logger$7.error("validateModelOutput", error);
        throw new Error("Could not validate model output");
      }
    }
  }
  const doneActionSchema = {
    name: "done",
    description: "Complete task",
    schema: z$1.object({
      text: z$1.string(),
      success: z$1.boolean()
    })
  };
  const searchGoogleActionSchema = {
    name: "search_google",
    description: "Search Google in the current tab",
    schema: z$1.object({
      intent: z$1.string().optional(),
      query: z$1.string()
    })
  };
  const goToUrlActionSchema = {
    name: "go_to_url",
    description: "Navigate to URL in the current tab",
    schema: z$1.object({
      intent: z$1.string().optional(),
      url: z$1.string()
    })
  };
  const goBackActionSchema = {
    name: "go_back",
    description: "Go back to the previous page",
    schema: z$1.object({
      intent: z$1.string().optional()
    })
  };
  const clickElementActionSchema = {
    name: "click_element",
    description: "Click element by index",
    schema: z$1.object({
      intent: z$1.string().optional(),
      // some small LLM can not generate a intent, so let it be optional (but it's still makred as required in json schema)
      index: z$1.number(),
      xpath: z$1.string().nullable().optional()
    })
  };
  const inputTextActionSchema = {
    name: "input_text",
    description: "Input text into an interactive input element",
    schema: z$1.object({
      intent: z$1.string().optional(),
      index: z$1.number(),
      text: z$1.string(),
      xpath: z$1.string().nullable().optional()
    })
  };
  const switchTabActionSchema = {
    name: "switch_tab",
    description: "Switch to tab by id",
    schema: z$1.object({
      intent: z$1.string().optional(),
      tab_id: z$1.number()
    })
  };
  const openTabActionSchema = {
    name: "open_tab",
    description: "Open URL in new tab",
    schema: z$1.object({
      intent: z$1.string().optional(),
      url: z$1.string()
    })
  };
  const closeTabActionSchema = {
    name: "close_tab",
    description: "Close tab by id",
    schema: z$1.object({
      intent: z$1.string().optional(),
      tab_id: z$1.number()
    })
  };
  const cacheContentActionSchema = {
    name: "cache_content",
    description: "Cache what you have found so far from the current page for future use",
    schema: z$1.object({
      intent: z$1.string().optional(),
      content: z$1.string()
    })
  };
  const scrollDownActionSchema = {
    name: "scroll_down",
    description: "Scroll down the page by pixel amount - if no amount is specified, scroll down one page",
    schema: z$1.object({
      intent: z$1.string().optional(),
      amount: z$1.number().nullable().optional()
    })
  };
  const scrollUpActionSchema = {
    name: "scroll_up",
    description: "Scroll up the page by pixel amount - if no amount is specified, scroll up one page",
    schema: z$1.object({
      intent: z$1.string().optional(),
      amount: z$1.number().nullable().optional()
    })
  };
  const sendKeysActionSchema = {
    name: "send_keys",
    description: "Send strings of special keys like Backspace, Insert, PageDown, Delete, Enter. Shortcuts such as `Control+o`, `Control+Shift+T` are supported as well. This gets used in keyboard press. Be aware of different operating systems and their shortcuts",
    schema: z$1.object({
      intent: z$1.string().optional(),
      keys: z$1.string()
    })
  };
  const scrollToTextActionSchema = {
    name: "scroll_to_text",
    description: "If you dont find something which you want to interact with, scroll to it",
    schema: z$1.object({
      intent: z$1.string().optional(),
      text: z$1.string()
    })
  };
  const getDropdownOptionsActionSchema = {
    name: "get_dropdown_options",
    description: "Get all options from a native dropdown",
    schema: z$1.object({
      intent: z$1.string().optional(),
      index: z$1.number()
    })
  };
  const selectDropdownOptionActionSchema = {
    name: "select_dropdown_option",
    description: "Select dropdown option for interactive element index by the text of the option you want to select",
    schema: z$1.object({
      intent: z$1.string().optional(),
      index: z$1.number(),
      text: z$1.string()
    })
  };
  const waitActionSchema = {
    name: "wait",
    description: "Wait for x seconds default 3",
    schema: z$1.object({
      intent: z$1.string().optional(),
      seconds: z$1.number().nullable().optional()
    })
  };
  const logger$6 = createLogger("Action");
  class InvalidInputError extends Error {
    constructor(message) {
      super(message);
      this.name = "InvalidInputError";
    }
  }
  class Action {
    constructor(handler, schema, hasIndex = false) {
      this.handler = handler;
      this.schema = schema;
      this.hasIndex = hasIndex;
    }
    async call(input) {
      const schema = this.schema.schema;
      const isEmptySchema = schema instanceof z$1.ZodObject && Object.keys(schema.shape || {}).length === 0;
      if (isEmptySchema) {
        return await this.handler({});
      }
      const parsedArgs = this.schema.schema.safeParse(input);
      if (!parsedArgs.success) {
        const errorMessage = parsedArgs.error.message;
        throw new InvalidInputError(errorMessage);
      }
      return await this.handler(parsedArgs.data);
    }
    name() {
      return this.schema.name;
    }
    /**
     * Returns the prompt for the action
     * @returns {string} The prompt for the action
     */
    prompt() {
      const schemaShape = this.schema.schema.shape || {};
      const schemaProperties = Object.entries(schemaShape).map(([key, value]) => {
        const zodValue = value;
        return `'${key}': {'type': '${zodValue.description}', ${zodValue.isOptional() ? "'optional': true" : "'required': true"}}`;
      });
      const schemaStr = schemaProperties.length > 0 ? `{${this.name()}: {${schemaProperties.join(", ")}}}` : `{${this.name()}: {}}`;
      return `${this.schema.description}:
${schemaStr}`;
    }
    /**
     * Get the index argument from the input if this action has an index
     * @param input The input to extract the index from
     * @returns The index value if found, null otherwise
     */
    getIndexArg(input) {
      if (!this.hasIndex) {
        return null;
      }
      if (input && typeof input === "object" && "index" in input) {
        return input.index;
      }
      return null;
    }
  }
  function buildDynamicActionSchema(actions) {
    let schema = z$1.object({});
    for (const action of actions) {
      const actionSchema = action.schema.schema.nullable().describe(action.schema.description);
      schema = schema.extend({
        [action.name()]: actionSchema
      });
    }
    return schema.partial();
  }
  class ActionBuilder {
    constructor(context, extractorLLM) {
      this.context = context;
      this.extractorLLM = extractorLLM;
    }
    buildDefaultActions() {
      const actions = [];
      const done = new Action(async (input) => {
        this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_START, doneActionSchema.name);
        this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_OK, input.text);
        return new ActionResult({
          isDone: true,
          extractedContent: input.text
        });
      }, doneActionSchema);
      actions.push(done);
      const searchGoogle = new Action(async (input) => {
        const context = this.context;
        const intent = input.intent || `Searching for "${input.query}" in Google`;
        context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_START, intent);
        await context.browserContext.navigateTo(`https://www.google.com/search?q=${input.query}`);
        const msg2 = `Searched for "${input.query}" in Google`;
        context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_OK, msg2);
        return new ActionResult({
          extractedContent: msg2,
          includeInMemory: true
        });
      }, searchGoogleActionSchema);
      actions.push(searchGoogle);
      const goToUrl = new Action(async (input) => {
        const intent = input.intent || `Navigating to ${input.url}`;
        this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_START, intent);
        await this.context.browserContext.navigateTo(input.url);
        const msg2 = `Navigated to ${input.url}`;
        this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_OK, msg2);
        return new ActionResult({
          extractedContent: msg2,
          includeInMemory: true
        });
      }, goToUrlActionSchema);
      actions.push(goToUrl);
      const goBack = new Action(async (input) => {
        const intent = input.intent || "Navigating back";
        this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_START, intent);
        const page = await this.context.browserContext.getCurrentPage();
        await page.goBack();
        const msg2 = "Navigated back";
        this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_OK, msg2);
        return new ActionResult({
          extractedContent: msg2,
          includeInMemory: true
        });
      }, goBackActionSchema);
      actions.push(goBack);
      const wait = new Action(async (input) => {
        const seconds = input.seconds || 3;
        const intent = input.intent || `Waiting for ${seconds} seconds`;
        this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_START, intent);
        await new Promise((resolve) => setTimeout(resolve, seconds * 1e3));
        const msg = `${seconds} seconds elapsed`;
        this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_OK, msg);
        return new ActionResult({ extractedContent: msg, includeInMemory: true });
      }, waitActionSchema);
      actions.push(wait);
      const clickElement = new Action(
        async (input) => {
          const intent = input.intent || `Click element with index ${input.index}`;
          this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_START, intent);
          const page = await this.context.browserContext.getCurrentPage();
          const state = await page.getState();
          const elementNode = state == null ? void 0 : state.selectorMap.get(input.index);
          if (!elementNode) {
            throw new Error(`Element with index ${input.index} does not exist - retry or use alternative actions`);
          }
          if (page.isFileUploader(elementNode)) {
            const msg = `Index ${input.index} - has an element which opens file upload dialog. To upload files please use a specific function to upload files`;
            logger$6.info(msg);
            return new ActionResult({
              extractedContent: msg,
              includeInMemory: true
            });
          }
          try {
            const initialTabIds = await this.context.browserContext.getAllTabIds();
            await page.clickElementNode(this.context.options.useVision, elementNode);
            let msg = `Clicked button with index ${input.index}: ${elementNode.getAllTextTillNextClickableElement(2)}`;
            logger$6.info(msg);
            const currentTabIds = await this.context.browserContext.getAllTabIds();
            if (currentTabIds.size > initialTabIds.size) {
              const newTabMsg = "New tab opened - switching to it";
              msg += ` - ${newTabMsg}`;
              logger$6.info(newTabMsg);
              const newTabId = Array.from(currentTabIds).find((id) => !initialTabIds.has(id));
              if (newTabId) {
                await this.context.browserContext.switchTab(newTabId);
              }
            }
            this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_OK, msg);
            return new ActionResult({ extractedContent: msg, includeInMemory: true });
          } catch (error) {
            const msg = `Element no longer available with index ${input.index} - most likely the page changed`;
            this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_FAIL, msg);
            return new ActionResult({
              error: error instanceof Error ? error.message : String(error)
            });
          }
        },
        clickElementActionSchema,
        true
      );
      actions.push(clickElement);
      const inputText = new Action(
        async (input) => {
          const intent = input.intent || `Input text into index ${input.index}`;
          this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_START, intent);
          const page = await this.context.browserContext.getCurrentPage();
          const state = await page.getState();
          const elementNode = state == null ? void 0 : state.selectorMap.get(input.index);
          if (!elementNode) {
            throw new Error(`Element with index ${input.index} does not exist - retry or use alternative actions`);
          }
          await page.inputTextElementNode(this.context.options.useVision, elementNode, input.text);
          const msg = `Input ${input.text} into index ${input.index}`;
          this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_OK, msg);
          return new ActionResult({ extractedContent: msg, includeInMemory: true });
        },
        inputTextActionSchema,
        true
      );
      actions.push(inputText);
      const switchTab = new Action(async (input) => {
        const intent = input.intent || `Switching to tab ${input.tab_id}`;
        this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_START, intent);
        await this.context.browserContext.switchTab(input.tab_id);
        const msg = `Switched to tab ${input.tab_id}`;
        this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_OK, msg);
        return new ActionResult({ extractedContent: msg, includeInMemory: true });
      }, switchTabActionSchema);
      actions.push(switchTab);
      const openTab = new Action(async (input) => {
        const intent = input.intent || `Opening ${input.url} in new tab`;
        this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_START, intent);
        await this.context.browserContext.openTab(input.url);
        const msg = `Opened ${input.url} in new tab`;
        this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_OK, msg);
        return new ActionResult({ extractedContent: msg, includeInMemory: true });
      }, openTabActionSchema);
      actions.push(openTab);
      const closeTab = new Action(async (input) => {
        const intent = input.intent || `Closing tab ${input.tab_id}`;
        this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_START, intent);
        await this.context.browserContext.closeTab(input.tab_id);
        const msg = `Closed tab ${input.tab_id}`;
        this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_OK, msg);
        return new ActionResult({ extractedContent: msg, includeInMemory: true });
      }, closeTabActionSchema);
      actions.push(closeTab);
      const cacheContent = new Action(async (input) => {
        const intent = input.intent || `Caching findings: ${input.content}`;
        this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_START, intent);
        const msg = `Cached findings: ${input.content}`;
        this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_OK, msg);
        return new ActionResult({ extractedContent: msg, includeInMemory: true });
      }, cacheContentActionSchema);
      actions.push(cacheContent);
      const scrollDown = new Action(async (input) => {
        const amount = input.amount !== void 0 && input.amount !== null ? `${input.amount} pixels` : "one page";
        const intent = input.intent || `Scroll down the page by ${amount}`;
        this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_START, intent);
        const page = await this.context.browserContext.getCurrentPage();
        await page.scrollDown(input.amount);
        const msg = `Scrolled down the page by ${amount}`;
        this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_OK, msg);
        return new ActionResult({ extractedContent: msg, includeInMemory: true });
      }, scrollDownActionSchema);
      actions.push(scrollDown);
      const scrollUp = new Action(async (input) => {
        const amount = input.amount !== void 0 && input.amount !== null ? `${input.amount} pixels` : "one page";
        const intent = input.intent || `Scroll up the page by ${amount}`;
        this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_START, intent);
        const page = await this.context.browserContext.getCurrentPage();
        await page.scrollUp(input.amount);
        const msg = `Scrolled up the page by ${amount}`;
        this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_OK, msg);
        return new ActionResult({ extractedContent: msg, includeInMemory: true });
      }, scrollUpActionSchema);
      actions.push(scrollUp);
      const sendKeys = new Action(async (input) => {
        const intent = input.intent || `Send keys: ${input.keys}`;
        this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_START, intent);
        const page = await this.context.browserContext.getCurrentPage();
        await page.sendKeys(input.keys);
        const msg = `Sent keys: ${input.keys}`;
        this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_OK, msg);
        return new ActionResult({ extractedContent: msg, includeInMemory: true });
      }, sendKeysActionSchema);
      actions.push(sendKeys);
      const scrollToText = new Action(async (input) => {
        const intent = input.intent || `Scroll to text: ${input.text}`;
        this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_START, intent);
        const page = await this.context.browserContext.getCurrentPage();
        try {
          const scrolled = await page.scrollToText(input.text);
          const msg = scrolled ? `Scrolled to text: ${input.text}` : `Text '${input.text}' not found or not visible on page`;
          this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_OK, msg);
          return new ActionResult({ extractedContent: msg, includeInMemory: true });
        } catch (error) {
          const msg = `Failed to scroll to text: ${error instanceof Error ? error.message : String(error)}`;
          this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_FAIL, msg);
          return new ActionResult({ error: msg, includeInMemory: true });
        }
      }, scrollToTextActionSchema);
      actions.push(scrollToText);
      const getDropdownOptions = new Action(
        async (input) => {
          const intent = input.intent || `Getting options from dropdown with index ${input.index}`;
          this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_START, intent);
          const page = await this.context.browserContext.getCurrentPage();
          const state = await page.getState();
          const elementNode = state == null ? void 0 : state.selectorMap.get(input.index);
          if (!elementNode) {
            const errorMsg = `Element with index ${input.index} does not exist - retry or use alternative actions`;
            logger$6.error(errorMsg);
            this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_FAIL, errorMsg);
            return new ActionResult({
              error: errorMsg,
              includeInMemory: true
            });
          }
          try {
            const options = await page.getDropdownOptions(input.index);
            if (options && options.length > 0) {
              const formattedOptions = options.map((opt) => {
                const encodedText = JSON.stringify(opt.text);
                return `${opt.index}: text=${encodedText}`;
              });
              let msg2 = formattedOptions.join("\n");
              msg2 += "\nUse the exact text string in select_dropdown_option";
              logger$6.info(msg2);
              this.context.emitEvent(
                Actors.NAVIGATOR,
                ExecutionState.ACT_OK,
                `Got ${options.length} options from dropdown`
              );
              return new ActionResult({
                extractedContent: msg2,
                includeInMemory: true
              });
            }
            const msg = "No options found in dropdown";
            logger$6.info(msg);
            this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_OK, msg);
            return new ActionResult({
              extractedContent: msg,
              includeInMemory: true
            });
          } catch (error) {
            const errorMsg = `Failed to get dropdown options: ${error instanceof Error ? error.message : String(error)}`;
            logger$6.error(errorMsg);
            this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_FAIL, errorMsg);
            return new ActionResult({
              error: errorMsg,
              includeInMemory: true
            });
          }
        },
        getDropdownOptionsActionSchema,
        true
      );
      actions.push(getDropdownOptions);
      const selectDropdownOption = new Action(
        async (input) => {
          const intent = input.intent || `Select option "${input.text}" from dropdown with index ${input.index}`;
          this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_START, intent);
          const page = await this.context.browserContext.getCurrentPage();
          const state = await page.getState();
          const elementNode = state == null ? void 0 : state.selectorMap.get(input.index);
          if (!elementNode) {
            const errorMsg = `Element with index ${input.index} does not exist - retry or use alternative actions`;
            this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_FAIL, errorMsg);
            return new ActionResult({
              error: errorMsg,
              includeInMemory: true
            });
          }
          if (!elementNode.tagName || elementNode.tagName.toLowerCase() !== "select") {
            const errorMsg = `Cannot select option: Element with index ${input.index} is a ${elementNode.tagName || "unknown"}, not a SELECT`;
            logger$6.error(errorMsg);
            this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_FAIL, errorMsg);
            return new ActionResult({
              error: errorMsg,
              includeInMemory: true
            });
          }
          logger$6.debug(`Attempting to select '${input.text}' using xpath: ${elementNode.xpath}`);
          logger$6.debug(`Element attributes: ${JSON.stringify(elementNode.attributes)}`);
          logger$6.debug(`Element tag: ${elementNode.tagName}`);
          try {
            const result = await page.selectDropdownOption(input.index, input.text);
            const msg = `Selected option "${input.text}" from dropdown with index ${input.index}`;
            logger$6.info(msg);
            this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_OK, msg);
            return new ActionResult({
              extractedContent: result,
              includeInMemory: true
            });
          } catch (error) {
            const errorMsg = `Failed to select option: ${error instanceof Error ? error.message : String(error)}`;
            logger$6.error(errorMsg);
            this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_FAIL, errorMsg);
            return new ActionResult({
              error: errorMsg,
              includeInMemory: true
            });
          }
        },
        selectDropdownOptionActionSchema,
        true
      );
      actions.push(selectDropdownOption);
      return actions;
    }
  }
  class ChatModelAuthError extends Error {
    /**
     * Creates a new ChatModelAuthError
     *
     * @param message - The error message
     * @param cause - The original error that caused this error
     */
    constructor(message, cause) {
      super(message);
      this.cause = cause;
      this.name = "ChatModelAuthError";
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, ChatModelAuthError);
      }
    }
    /**
     * Returns a string representation of the error
     */
    toString() {
      return `${this.name}: ${this.message}${this.cause ? ` (Caused by: ${this.cause})` : ""}`;
    }
  }
  class ChatModelForbiddenError extends Error {
    constructor(message, cause) {
      super(message);
      this.cause = cause;
      this.name = "ChatModelForbiddenError";
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, ChatModelForbiddenError);
      }
    }
    /**
     * Returns a string representation of the error
     */
    toString() {
      return `${this.name}: ${this.message}${this.cause ? ` (Caused by: ${this.cause})` : ""}`;
    }
  }
  const LLM_FORBIDDEN_ERROR_MESSAGE = "Access denied (403 Forbidden). Please check:\n\n1. Your API key has the required permissions\n\n2. For Ollama: Set OLLAMA_ORIGINS=chrome-extension://* \nsee https://github.com/ollama/ollama/blob/main/docs/faq.md";
  function isAuthenticationError(error) {
    var _a3;
    if (!(error instanceof Error)) return false;
    const errorMessage = error.message || "";
    let errorName = error.name || "";
    const constructorName = (_a3 = error.constructor) == null ? void 0 : _a3.name;
    if (constructorName && constructorName !== "Error") {
      errorName = constructorName;
    }
    if (errorName === "AuthenticationError") {
      return true;
    }
    return errorMessage.toLowerCase().includes("authentication") || errorMessage.includes(" 401") || errorMessage.toLowerCase().includes("api key");
  }
  function isForbiddenError(error) {
    if (!(error instanceof Error)) return false;
    return error.message.includes(" 403") && error.message.includes("Forbidden");
  }
  const jsonNavigatorOutputSchema = {
    properties: {
      current_state: {
        description: "Current state of the agent",
        properties: {
          evaluation_previous_goal: {
            title: "Evaluation of previous goal",
            type: "string"
          },
          memory: {
            title: "Memory",
            type: "string"
          },
          next_goal: {
            title: "Next Goal",
            type: "string"
          }
        },
        required: ["evaluation_previous_goal", "memory", "next_goal"],
        title: "AgentBrain",
        type: "object"
      },
      action: {
        items: {
          properties: {
            done: {
              description: "Complete task",
              properties: {
                text: {
                  title: "Text",
                  type: "string"
                },
                success: {
                  title: "Success",
                  type: "boolean"
                }
              },
              required: ["text", "success"],
              title: "DoneAction",
              type: "object",
              nullable: true
            },
            search_google: {
              description: "Search the query in Google in the current tab, the query should be a search query like humans search in Google, concrete and not vague or super long. More the single most important items. ",
              properties: {
                intent: {
                  title: "Intent",
                  type: "string",
                  description: "purpose of this action"
                },
                query: {
                  title: "Query",
                  type: "string"
                }
              },
              required: ["intent", "query"],
              title: "SearchGoogleAction",
              type: "object",
              nullable: true
            },
            go_to_url: {
              description: "Navigate to URL in the current tab",
              properties: {
                intent: {
                  title: "Intent",
                  type: "string",
                  description: "purpose of this action"
                },
                url: {
                  title: "Url",
                  type: "string"
                }
              },
              required: ["intent", "url"],
              title: "GoToUrlAction",
              type: "object",
              nullable: true
            },
            go_back: {
              description: "Go back to previous page",
              properties: {
                intent: {
                  title: "Intent",
                  type: "string",
                  description: "purpose of this action"
                }
              },
              required: ["intent"],
              title: "GoBackAction",
              type: "object",
              nullable: true
            },
            wait: {
              description: "Wait for x seconds default 3",
              properties: {
                intent: {
                  title: "Intent",
                  type: "string",
                  description: "purpose of this action"
                },
                seconds: {
                  title: "Seconds",
                  type: "integer",
                  default: 3
                }
              },
              required: ["intent", "seconds"],
              title: "WaitAction",
              type: "object",
              nullable: true
            },
            click_element: {
              description: "Click element by index",
              properties: {
                intent: {
                  title: "Intent",
                  type: "string",
                  description: "purpose of this action"
                },
                index: {
                  title: "Index",
                  type: "integer"
                },
                xpath: {
                  title: "Xpath",
                  type: "string",
                  nullable: true
                }
              },
              required: ["intent", "index"],
              title: "ClickElementAction",
              type: "object",
              nullable: true
            },
            input_text: {
              description: "Input text into an interactive input element",
              properties: {
                intent: {
                  title: "Intent",
                  type: "string",
                  description: "purpose of this action"
                },
                index: {
                  title: "Index",
                  type: "integer"
                },
                text: {
                  title: "Text",
                  type: "string"
                },
                xpath: {
                  title: "Xpath",
                  type: "string",
                  nullable: true
                }
              },
              required: ["intent", "index", "text"],
              title: "InputTextAction",
              type: "object",
              nullable: true
            },
            switch_tab: {
              description: "Switch tab",
              properties: {
                intent: {
                  title: "Intent",
                  type: "string",
                  description: "purpose of this action"
                },
                tab_id: {
                  title: "Tab Id",
                  type: "integer"
                }
              },
              required: ["intent", "tab_id"],
              title: "SwitchTabAction",
              type: "object",
              nullable: true
            },
            open_tab: {
              description: "Open url in new tab",
              properties: {
                intent: {
                  title: "Intent",
                  type: "string",
                  description: "purpose of this action"
                },
                url: {
                  title: "Url",
                  type: "string"
                }
              },
              required: ["intent", "url"],
              title: "OpenTabAction",
              type: "object",
              nullable: true
            },
            close_tab: {
              description: "Close tab by tab_id",
              properties: {
                intent: {
                  title: "Intent",
                  type: "string",
                  description: "purpose of this action"
                },
                tab_id: {
                  title: "Tab Id",
                  type: "integer"
                }
              },
              required: ["intent", "tab_id"],
              title: "CloseTabAction",
              type: "object",
              nullable: true
            },
            cache_content: {
              description: "Cache what you have found so far from the current page for future use",
              properties: {
                intent: {
                  title: "Intent",
                  type: "string",
                  description: "purpose of this action"
                },
                content: {
                  title: "Content",
                  type: "string"
                }
              },
              required: ["intent", "content"],
              title: "cache_content_parameters",
              type: "object",
              nullable: true
            },
            scroll_down: {
              description: "Scroll down the page by pixel amount - if no amount is specified, scroll down one page",
              properties: {
                intent: {
                  title: "Intent",
                  type: "string",
                  description: "purpose of this action"
                },
                amount: {
                  title: "Amount",
                  type: "integer",
                  nullable: true
                }
              },
              required: ["intent", "amount"],
              title: "ScrollAction",
              type: "object",
              nullable: true
            },
            scroll_up: {
              description: "Scroll up the page by pixel amount - if no amount is specified, scroll up one page",
              properties: {
                intent: {
                  title: "Intent",
                  type: "string",
                  description: "purpose of this action"
                },
                amount: {
                  title: "Amount",
                  type: "integer",
                  nullable: true
                }
              },
              required: ["intent", "amount"],
              title: "ScrollAction",
              type: "object",
              nullable: true
            },
            send_keys: {
              description: "Send strings of special keys like Escape, Backspace, Insert, PageDown, Delete, Enter, Shortcuts such as `Control+o`, `Control+Shift+T` are supported as well. This gets used in keyboard.press.",
              properties: {
                intent: {
                  title: "Intent",
                  type: "string",
                  description: "purpose of this action"
                },
                keys: {
                  title: "Keys",
                  type: "string"
                }
              },
              required: ["intent", "keys"],
              title: "SendKeysAction",
              type: "object",
              nullable: true
            },
            scroll_to_text: {
              description: "If you dont find something which you want to interact with, scroll to it",
              properties: {
                intent: {
                  title: "Intent",
                  type: "string",
                  description: "purpose of this action"
                },
                text: {
                  title: "Text",
                  type: "string"
                }
              },
              required: ["intent", "text"],
              title: "scroll_to_text_parameters",
              type: "object",
              nullable: true
            },
            get_dropdown_options: {
              description: "Get all options from a native dropdown",
              properties: {
                intent: {
                  title: "Intent",
                  type: "string",
                  description: "purpose of this action"
                },
                index: {
                  title: "Index",
                  type: "integer"
                }
              },
              required: ["intent", "index"],
              title: "get_dropdown_options_parameters",
              type: "object",
              nullable: true
            },
            select_dropdown_option: {
              description: "Select dropdown option for interactive element index by the text of the option you want to select",
              properties: {
                intent: {
                  title: "Intent",
                  type: "string",
                  description: "purpose of this action"
                },
                index: {
                  title: "Index",
                  type: "integer"
                },
                text: {
                  title: "Text",
                  type: "string"
                }
              },
              required: ["intent", "index", "text"],
              title: "select_dropdown_option_parameters",
              type: "object",
              nullable: true
            }
          },
          title: "ActionModel",
          type: "object"
        },
        title: "Action",
        type: "array"
      }
    },
    required: ["current_state", "action"],
    title: "AgentOutput",
    type: "object"
  };
  const geminiNavigatorOutputSchema = {
    type: "object",
    properties: {
      current_state: {
        type: "object",
        description: "Current state of the agent",
        properties: {
          evaluation_previous_goal: {
            type: "string"
          },
          memory: {
            type: "string"
          },
          next_goal: {
            type: "string"
          }
        },
        required: ["evaluation_previous_goal", "memory", "next_goal"]
      },
      action: {
        type: "array",
        items: {
          type: "object",
          properties: {
            done: {
              type: "object",
              description: "Complete task",
              nullable: true,
              properties: {
                text: {
                  type: "string"
                },
                success: {
                  type: "boolean"
                }
              },
              required: ["text", "success"]
            },
            search_google: {
              type: "object",
              description: "Search the query in Google in the current tab, the query should be a search query like humans search in Google, concrete and not vague or super long. More the single most important items. ",
              nullable: true,
              properties: {
                intent: {
                  type: "string",
                  description: "purpose of this action"
                },
                query: {
                  type: "string"
                }
              },
              required: ["intent", "query"]
            },
            go_to_url: {
              type: "object",
              description: "Navigate to URL in the current tab",
              nullable: true,
              properties: {
                intent: {
                  type: "string",
                  description: "purpose of this action"
                },
                url: {
                  type: "string"
                }
              },
              required: ["intent", "url"]
            },
            go_back: {
              type: "object",
              description: "Go back to previous page",
              nullable: true,
              properties: {
                intent: {
                  type: "string",
                  description: "purpose of this action"
                }
              },
              required: ["intent"]
            },
            wait: {
              type: "object",
              description: "Wait for x seconds default 3",
              nullable: true,
              properties: {
                intent: {
                  type: "string",
                  description: "purpose of this action"
                },
                seconds: {
                  type: "integer"
                }
              },
              required: ["intent", "seconds"]
            },
            click_element: {
              type: "object",
              description: "Click element by index",
              nullable: true,
              properties: {
                intent: {
                  type: "string",
                  description: "purpose of this action"
                },
                index: {
                  type: "integer"
                },
                xpath: {
                  type: "string",
                  nullable: true
                }
              },
              required: ["intent", "index"]
            },
            input_text: {
              type: "object",
              description: "Input text into an interactive input element",
              nullable: true,
              properties: {
                intent: {
                  type: "string",
                  description: "purpose of this action"
                },
                index: {
                  type: "integer"
                },
                text: {
                  type: "string"
                },
                xpath: {
                  type: "string",
                  nullable: true
                }
              },
              required: ["intent", "index", "text"]
            },
            switch_tab: {
              type: "object",
              description: "Switch tab",
              nullable: true,
              properties: {
                intent: {
                  type: "string",
                  description: "purpose of this action"
                },
                tab_id: {
                  type: "integer"
                }
              },
              required: ["intent", "tab_id"]
            },
            open_tab: {
              type: "object",
              description: "Open url in new tab",
              nullable: true,
              properties: {
                intent: {
                  type: "string",
                  description: "purpose of this action"
                },
                url: {
                  type: "string"
                }
              },
              required: ["intent", "url"]
            },
            close_tab: {
              type: "object",
              description: "Close tab by tab_id",
              nullable: true,
              properties: {
                intent: {
                  type: "string",
                  description: "purpose of this action"
                },
                tab_id: {
                  type: "integer"
                }
              },
              required: ["intent", "tab_id"]
            },
            cache_content: {
              type: "object",
              description: "Cache what you have found so far from the current page for future use",
              nullable: true,
              properties: {
                intent: {
                  type: "string",
                  description: "purpose of this action"
                },
                content: {
                  type: "string"
                }
              },
              required: ["intent", "content"]
            },
            scroll_down: {
              type: "object",
              description: "Scroll down the page by pixel amount - if no amount is specified, scroll down one page",
              nullable: true,
              properties: {
                intent: {
                  type: "string",
                  description: "purpose of this action"
                },
                amount: {
                  type: "integer",
                  nullable: true
                }
              },
              required: ["intent", "amount"]
            },
            scroll_up: {
              type: "object",
              description: "Scroll up the page by pixel amount - if no amount is specified, scroll up one page",
              nullable: true,
              properties: {
                intent: {
                  type: "string",
                  description: "purpose of this action"
                },
                amount: {
                  type: "integer",
                  nullable: true
                }
              },
              required: ["intent", "amount"]
            },
            send_keys: {
              type: "object",
              description: "Send strings of special keys like Escape, Backspace, Insert, PageDown, Delete, Enter, Shortcuts such as `Control+o`, `Control+Shift+T` are supported as well. This gets used in keyboard.press.",
              nullable: true,
              properties: {
                intent: {
                  type: "string",
                  description: "purpose of this action"
                },
                keys: {
                  type: "string"
                }
              },
              required: ["intent", "keys"]
            },
            scroll_to_text: {
              type: "object",
              description: "If you dont find something which you want to interact with, scroll to it",
              nullable: true,
              properties: {
                intent: {
                  type: "string",
                  description: "purpose of this action"
                },
                text: {
                  type: "string"
                }
              },
              required: ["intent", "text"]
            },
            get_dropdown_options: {
              type: "object",
              description: "Get all options from a native dropdown",
              nullable: true,
              properties: {
                intent: {
                  type: "string",
                  description: "purpose of this action"
                },
                index: {
                  type: "integer"
                }
              },
              required: ["intent", "index"]
            },
            select_dropdown_option: {
              type: "object",
              description: "Select dropdown option for interactive element index by the text of the option you want to select",
              nullable: true,
              properties: {
                intent: {
                  type: "string",
                  description: "purpose of this action"
                },
                index: {
                  type: "integer"
                },
                text: {
                  type: "string"
                }
              },
              required: ["intent", "index", "text"]
            }
          }
        }
      }
    },
    required: ["current_state", "action"]
  };
  const logger$5 = createLogger("NavigatorAgent");
  class NavigatorActionRegistry {
    constructor(actions) {
      this.actions = {};
      for (const action of actions) {
        this.registerAction(action);
      }
    }
    registerAction(action) {
      this.actions[action.name()] = action;
    }
    unregisterAction(name) {
      delete this.actions[name];
    }
    getAction(name) {
      return this.actions[name];
    }
    setupModelOutputSchema() {
      const actionSchema = buildDynamicActionSchema(Object.values(this.actions));
      return z$1.object({
        current_state: agentBrainSchema,
        action: z$1.array(actionSchema)
      });
    }
  }
  class NavigatorAgent extends BaseAgent {
    constructor(actionRegistry, options, extraOptions) {
      super(actionRegistry.setupModelOutputSchema(), options, { ...extraOptions, id: "navigator" });
      this.actionRegistry = actionRegistry;
      this.jsonSchema = this.modelName.startsWith("gemini") ? geminiNavigatorOutputSchema : jsonNavigatorOutputSchema;
    }
    async invoke(inputMessages) {
      if (this.withStructuredOutput) {
        const structuredLlm = this.chatLLM.withStructuredOutput(this.jsonSchema, {
          includeRaw: true,
          name: this.modelOutputToolName
        });
        let response = void 0;
        try {
          response = await structuredLlm.invoke(inputMessages, {
            ...this.callOptions
          });
          if (response.parsed) {
            return response.parsed;
          }
        } catch (error) {
          const errorMessage = `Failed to invoke ${this.modelName} with structured output: ${error}`;
          throw new Error(errorMessage);
        }
        const rawResponse = response.raw;
        if (rawResponse.tool_calls && rawResponse.tool_calls.length > 0) {
          logger$5.info("Navigator structuredLlm tool call with empty content", rawResponse.tool_calls);
          const toolCall = rawResponse.tool_calls[0];
          return {
            current_state: toolCall.args.currentState,
            action: [...toolCall.args.action]
          };
        }
        throw new Error("Could not parse response");
      }
      throw new Error("Navigator needs to work with LLM that supports tool calling");
    }
    async execute() {
      const agentOutput = {
        id: this.id
      };
      let cancelled = false;
      try {
        this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.STEP_START, "Navigating...");
        const messageManager = this.context.messageManager;
        await this.addStateMessageToMemory();
        if (this.context.paused || this.context.stopped) {
          cancelled = true;
          return agentOutput;
        }
        const inputMessages = messageManager.getMessages();
        const modelOutput = await this.invoke(inputMessages);
        if (this.context.paused || this.context.stopped) {
          cancelled = true;
          return agentOutput;
        }
        this.removeLastStateMessageFromMemory();
        this.addModelOutputToMemory(modelOutput);
        const actionResults = await this.doMultiAction(modelOutput);
        this.context.actionResults = actionResults;
        if (this.context.paused || this.context.stopped) {
          cancelled = true;
          return agentOutput;
        }
        this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.STEP_OK, "Navigation done");
        let done = false;
        if (actionResults.length > 0 && actionResults[actionResults.length - 1].isDone) {
          done = true;
        }
        agentOutput.result = { done };
        return agentOutput;
      } catch (error) {
        this.removeLastStateMessageFromMemory();
        if (isAuthenticationError(error)) {
          throw new ChatModelAuthError("Navigator API Authentication failed. Please verify your API key", error);
        }
        if (isForbiddenError(error)) {
          throw new ChatModelForbiddenError(LLM_FORBIDDEN_ERROR_MESSAGE, error);
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        const errorString = `Navigation failed: ${errorMessage}`;
        logger$5.error(errorString);
        this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.STEP_FAIL, errorString);
        agentOutput.error = errorMessage;
        return agentOutput;
      } finally {
        if (cancelled) {
          this.removeLastStateMessageFromMemory();
          this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.STEP_CANCEL, "Navigation cancelled");
        }
      }
    }
    /**
     * Add the state message to the memory
     */
    async addStateMessageToMemory() {
      if (this.context.stateMessageAdded) {
        return;
      }
      const messageManager = this.context.messageManager;
      if (this.context.actionResults.length > 0) {
        let index = 0;
        for (const r of this.context.actionResults) {
          if (r.includeInMemory) {
            if (r.extractedContent) {
              const msg = new HumanMessage(`Action result: ${r.extractedContent}`);
              messageManager.addMessageWithTokens(msg);
            }
            if (r.error) {
              const errorText = r.error.toString().trim();
              const lastLine = errorText.split("\n").pop() || "";
              const msg = new HumanMessage(`Action error: ${lastLine}`);
              logger$5.info("Adding action error to memory", msg.content);
              messageManager.addMessageWithTokens(msg);
            }
            this.context.actionResults[index] = new ActionResult();
          }
          index++;
        }
      }
      const state = await this.prompt.getUserMessage(this.context);
      messageManager.addStateMessage(state);
      this.context.stateMessageAdded = true;
    }
    /**
     * Remove the last state message from the memory
     */
    async removeLastStateMessageFromMemory() {
      if (!this.context.stateMessageAdded) return;
      const messageManager = this.context.messageManager;
      messageManager.removeLastStateMessage();
      this.context.stateMessageAdded = false;
    }
    async addModelOutputToMemory(modelOutput) {
      const messageManager = this.context.messageManager;
      messageManager.addModelOutput(modelOutput);
    }
    async doMultiAction(response) {
      const results = [];
      let errCount = 0;
      logger$5.info("Actions", response.action);
      let actions = [];
      if (Array.isArray(response.action)) {
        actions = response.action.filter((item) => item !== null);
        if (actions.length === 0) {
          logger$5.warning("No valid actions found", response.action);
        }
      } else if (typeof response.action === "string") {
        try {
          logger$5.warning("Unexpected action format", response.action);
          actions = JSON.parse(response.action);
        } catch (error) {
          logger$5.error("Invalid action format", response.action);
          throw new Error("Invalid action output format");
        }
      } else {
        actions = [response.action];
      }
      const browserContext2 = this.context.browserContext;
      const browserState = await browserContext2.getState();
      const cachedPathHashes = await calcBranchPathHashSet(browserState);
      await browserContext2.removeHighlight();
      for (const [i2, action] of actions.entries()) {
        const actionName = Object.keys(action)[0];
        const actionArgs = action[actionName];
        try {
          if (this.context.paused || this.context.stopped) {
            return results;
          }
          const actionInstance = this.actionRegistry.getAction(actionName);
          if (actionInstance === void 0) {
            throw new Error(`Action ${actionName} not exists`);
          }
          const indexArg = actionInstance.getIndexArg(actionArgs);
          if (i2 > 0 && indexArg !== null) {
            const newState = await browserContext2.getState();
            const newPathHashes = await calcBranchPathHashSet(newState);
            if (!newPathHashes.isSubsetOf(cachedPathHashes)) {
              const msg = `Something new appeared after action ${i2} / ${actions.length}`;
              logger$5.info(msg);
              results.push(
                new ActionResult({
                  extractedContent: msg,
                  includeInMemory: true
                })
              );
              break;
            }
          }
          const result = await actionInstance.call(actionArgs);
          if (result === void 0) {
            throw new Error(`Action ${actionName} returned undefined`);
          }
          results.push(result);
          if (this.context.paused || this.context.stopped) {
            return results;
          }
          await new Promise((resolve) => setTimeout(resolve, 1e3));
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          logger$5.error("doAction error", actionName, actionArgs, errorMessage);
          this.context.emitEvent(Actors.NAVIGATOR, ExecutionState.ACT_FAIL, errorMessage);
          errCount++;
          if (errCount > 3) {
            throw new Error("Too many errors in actions");
          }
          results.push(
            new ActionResult({
              error: errorMessage,
              isDone: false,
              includeInMemory: true
            })
          );
        }
      }
      return results;
    }
  }
  const plannerOutputSchema = z$1.object({
    observation: z$1.string(),
    challenges: z$1.string(),
    done: z$1.union([
      z$1.boolean(),
      z$1.string().transform((val) => {
        if (val.toLowerCase() === "true") return true;
        if (val.toLowerCase() === "false") return false;
        throw new Error("Invalid boolean string");
      })
    ]),
    next_steps: z$1.string(),
    reasoning: z$1.string(),
    web_task: z$1.union([
      z$1.boolean(),
      z$1.string().transform((val) => {
        if (val.toLowerCase() === "true") return true;
        if (val.toLowerCase() === "false") return false;
        throw new Error("Invalid boolean string");
      })
    ])
  });
  class PlannerAgent extends BaseAgent {
    constructor(options, extraOptions) {
      super(plannerOutputSchema, options, { ...extraOptions, id: "planner" });
    }
    async execute() {
      try {
        this.context.emitEvent(Actors.PLANNER, ExecutionState.STEP_START, "Planning...");
        const messages = this.context.messageManager.getMessages();
        const plannerMessages = [this.prompt.getSystemMessage(), ...messages.slice(1)];
        if (!this.context.options.useVisionForPlanner && this.context.options.useVision) {
          const lastStateMessage = plannerMessages[plannerMessages.length - 1];
          let newMsg = "";
          if (Array.isArray(lastStateMessage.content)) {
            for (const msg of lastStateMessage.content) {
              if (msg.type === "text") {
                newMsg += msg.text;
              }
            }
          } else {
            newMsg = lastStateMessage.content;
          }
          plannerMessages[plannerMessages.length - 1] = new HumanMessage(newMsg);
        }
        const modelOutput = await this.invoke(plannerMessages);
        if (!modelOutput) {
          throw new Error("Failed to validate planner output");
        }
        this.context.emitEvent(Actors.PLANNER, ExecutionState.STEP_OK, modelOutput.next_steps);
        return {
          id: this.id,
          result: modelOutput
        };
      } catch (error) {
        if (isAuthenticationError(error)) {
          throw new ChatModelAuthError("Planner API Authentication failed. Please verify your API key", error);
        }
        if (isForbiddenError(error)) {
          throw new ChatModelForbiddenError(LLM_FORBIDDEN_ERROR_MESSAGE, error);
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        this.context.emitEvent(Actors.PLANNER, ExecutionState.STEP_FAIL, `Planning failed: ${errorMessage}`);
        return {
          id: this.id,
          error: errorMessage
        };
      }
    }
  }
  const logger$4 = createLogger("ValidatorAgent");
  const validatorOutputSchema = z$1.object({
    is_valid: z$1.union([
      z$1.boolean(),
      z$1.string().transform((val) => {
        if (val.toLowerCase() === "true") return true;
        if (val.toLowerCase() === "false") return false;
        throw new Error("Invalid boolean string");
      })
    ]),
    // indicates if the output is correct
    reason: z$1.string(),
    // explains why it is valid or not
    answer: z$1.string()
    // the final answer to the task if it is valid
  });
  class ValidatorAgent extends BaseAgent {
    constructor(options, extraOptions) {
      super(validatorOutputSchema, options, { ...extraOptions, id: "validator" });
      this.plan = null;
    }
    /**
     * Set the plan for the validator agent
     * @param plan - The plan to set
     */
    setPlan(plan) {
      this.plan = plan;
    }
    /**
     * Executes the validator agent
     * @returns AgentOutput<ValidatorOutput>
     */
    async execute() {
      try {
        this.context.emitEvent(Actors.VALIDATOR, ExecutionState.STEP_START, "Validating...");
        let stateMessage = await this.prompt.getUserMessage(this.context);
        if (this.plan) {
          const mergedMessage = new HumanMessage(`${stateMessage.content}

The current plan is: 
${this.plan}`);
          stateMessage = mergedMessage;
        }
        const systemMessage = this.prompt.getSystemMessage();
        const inputMessages = [systemMessage, stateMessage];
        const modelOutput = await this.invoke(inputMessages);
        if (!modelOutput) {
          throw new Error("Failed to validate task result");
        }
        logger$4.info("validator output", JSON.stringify(modelOutput, null, 2));
        if (!modelOutput.is_valid) {
          const msg = `The answer is not yet correct. ${modelOutput.reason}.`;
          this.context.emitEvent(Actors.VALIDATOR, ExecutionState.STEP_FAIL, msg);
          this.context.actionResults = [new ActionResult({ extractedContent: msg, includeInMemory: true })];
        } else {
          this.context.emitEvent(Actors.VALIDATOR, ExecutionState.STEP_OK, modelOutput.answer);
        }
        return {
          id: this.id,
          result: modelOutput
        };
      } catch (error) {
        if (isAuthenticationError(error)) {
          throw new ChatModelAuthError("Validator API Authentication failed. Please verify your API key", error);
        }
        if (isForbiddenError(error)) {
          throw new ChatModelForbiddenError(LLM_FORBIDDEN_ERROR_MESSAGE, error);
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        logger$4.error(`Validation failed: ${errorMessage}`);
        this.context.emitEvent(Actors.VALIDATOR, ExecutionState.STEP_FAIL, `Validation failed: ${errorMessage}`);
        return {
          id: this.id,
          error: `Validation failed: ${errorMessage}`
        };
      }
    }
  }
  class BasePrompt {
    /**
     * Builds the user message containing the browser state
     * @param context - The agent context
     * @returns HumanMessage from LangChain
     */
    async buildBrowserStateUserMessage(context) {
      const browserState = await context.browserContext.getState();
      const elementsText = browserState.elementTree.clickableElementsToString(context.options.includeAttributes);
      const hasContentAbove = (browserState.pixelsAbove || 0) > 0;
      const hasContentBelow = (browserState.pixelsBelow || 0) > 0;
      let formattedElementsText = "";
      if (elementsText !== "") {
        if (hasContentAbove) {
          formattedElementsText = `... ${browserState.pixelsAbove} pixels above - scroll up to see more ...
${elementsText}`;
        } else {
          formattedElementsText = `[Start of page]
${elementsText}`;
        }
        if (hasContentBelow) {
          formattedElementsText = `${formattedElementsText}
... ${browserState.pixelsBelow} pixels below - scroll down to see more ...`;
        } else {
          formattedElementsText = `${formattedElementsText}
[End of page]`;
        }
      } else {
        formattedElementsText = "empty page";
      }
      let stepInfoDescription = "";
      if (context.stepInfo) {
        stepInfoDescription = `Current step: ${context.stepInfo.stepNumber + 1}/${context.stepInfo.maxSteps}`;
      }
      const timeStr = (/* @__PURE__ */ new Date()).toISOString().slice(0, 16).replace("T", " ");
      stepInfoDescription += `Current date and time: ${timeStr}`;
      let actionResultsDescription = "";
      if (context.actionResults.length > 0) {
        for (let i2 = 0; i2 < context.actionResults.length; i2++) {
          const result = context.actionResults[i2];
          if (result.extractedContent) {
            actionResultsDescription += `
Action result ${i2 + 1}/${context.actionResults.length}: ${result.extractedContent}`;
          }
          if (result.error) {
            const error = result.error.split("\n").pop();
            actionResultsDescription += `
Action error ${i2 + 1}/${context.actionResults.length}: ...${error}`;
          }
        }
      }
      const currentTab = `{id: ${browserState.tabId}, url: ${browserState.url}, title: ${browserState.title}}`;
      const otherTabs = browserState.tabs.filter((tab) => tab.id !== browserState.tabId).map((tab) => `- {id: ${tab.id}, url: ${tab.url}, title: ${tab.title}}`);
      const stateDescription = `
[Task history memory ends]
[Current state starts here]
The following is one-time information - if you need to remember it write it to memory:
Current tab: ${currentTab}
Other available tabs:
  ${otherTabs.join("\n")}
Interactive elements from top layer of the current page inside the viewport:
${formattedElementsText}
${stepInfoDescription}
${actionResultsDescription}
`;
      if (browserState.screenshot && context.options.useVision) {
        return new HumanMessage({
          content: [
            { type: "text", text: stateDescription },
            {
              type: "image_url",
              image_url: { url: `data:image/jpeg;base64,${browserState.screenshot}` }
            }
          ]
        });
      }
      return new HumanMessage(stateDescription);
    }
  }
  const navigatorSystemPromptTemplate = `
You are an AI agent designed to automate browser tasks. Your goal is to accomplish the ultimate task following the rules.

# Input Format

Task
Previous steps
Current Tab
Open Tabs
Interactive Elements
[index]<type>text</type>

- index: Numeric identifier for interaction
- type: HTML element type (button, input, etc.)
- text: Element description
  Example:
  [33]<div>User form</div>
  \\t*[35]*<button aria-label='Submit form'>Submit</button>

- Only elements with numeric indexes in [] are interactive
- (stacked) indentation (with \\t) is important and means that the element is a (html) child of the element above (with a lower index)
- Elements with * are new elements that were added after the previous step (if url has not changed)

# Response Rules

1. RESPONSE FORMAT: You must ALWAYS respond with valid JSON in this exact format:
   {"current_state": {"evaluation_previous_goal": "Success|Failed|Unknown - Analyze the current elements and the image to check if the previous goals/actions are successful like intended by the task. Mention if something unexpected happened. Shortly state why/why not",
   "memory": "Description of what has been done and what you need to remember. Be very specific. Count here ALWAYS how many times you have done something and how many remain. E.g. 0 out of 10 websites analyzed. Continue with abc and xyz",
   "next_goal": "What needs to be done with the next immediate action"},
   "action":[{"one_action_name": {// action-specific parameter}}, // ... more actions in sequence]}

2. ACTIONS: You can specify multiple actions in the list to be executed in sequence. But always specify only one action name per item. Use maximum {{max_actions}} actions per sequence.
Common action sequences:

- Form filling: [{"input_text": {"intent": "Fill title", "index": 1, "text": "username"}}, {"input_text": {"intent": "Fill title", "index": 2, "text": "password"}}, {"click_element": {"intent": "Click submit button", "index": 3}}]
- Navigation: [{"go_to_url": {"intent": "Go to url", "url": "https://example.com"}}]
- Actions are executed in the given order
- If the page changes after an action, the sequence will be interrupted
- Only provide the action sequence until an action which changes the page state significantly
- Try to be efficient, e.g. fill forms at once, or chain actions where nothing changes on the page
- only use multiple actions if it makes sense

3. ELEMENT INTERACTION:

- Only use indexes of the interactive elements

4. NAVIGATION & ERROR HANDLING:

- If no suitable elements exist, use other functions to complete the task
- If stuck, try alternative approaches - like going back to a previous page, new search, new tab etc.
- Handle popups/cookies by accepting or closing them
- Use scroll to find elements you are looking for
- If you want to research something, open a new tab instead of using the current tab
- If captcha pops up, try to solve it if a screenshot image is provided - else try a different approach
- If the page is not fully loaded, use wait action

5. TASK COMPLETION:

- Use the done action as the last action as soon as the ultimate task is complete
- Dont use "done" before you are done with everything the user asked you, except you reach the last step of max_steps.
- If you reach your last step, use the done action even if the task is not fully finished. Provide all the information you have gathered so far. If the ultimate task is completely finished set success to true. If not everything the user asked for is completed set success in done to false!
- If you have to do something repeatedly for example the task says for "each", or "for all", or "x times", count always inside "memory" how many times you have done it and how many remain. Don't stop until you have completed like the task asked you. Only call done after the last step.
- Don't hallucinate actions
- Make sure you include everything you found out for the ultimate task in the done text parameter. Do not just say you are done, but include the requested information of the task.
- Include exact relevant urls if available, but do NOT make up any urls

6. VISUAL CONTEXT:

- When an image is provided, use it to understand the page layout
- Bounding boxes with labels on their top right corner correspond to element indexes

7. Form filling:

- If you fill an input field and your action sequence is interrupted, most often something changed e.g. suggestions popped up under the field.

8. Long tasks:

- Keep track of the status and subresults in the memory.
- You are provided with procedural memory summaries that condense previous task history (every N steps). Use these summaries to maintain context about completed actions, current progress, and next steps. The summaries appear in chronological order and contain key information about navigation history, findings, errors encountered, and current state. Refer to these summaries to avoid repeating actions and to ensure consistent progress toward the task goal.

9. Extraction:

- Extraction process for research tasks or searching for information:
  1. ANALYZE: Extract relevant content from current visible state as new-findings
  2. EVALUATE: Check if information is sufficient taking into account the new-findings and the cached-findings in memory
     - If SUFFICIENT → Complete task using all findings
     - If INSUFFICIENT → Follow these steps in order:
       a) CACHE: First of all, use cache_content action to store new-findings
       b) SCROLL: Move EXACTLY ONE PAGE using scroll_down/scroll_up
       c) REPEAT: Continue analyze-evaluate loop until either:
          • Information becomes sufficient
          • Maximum 8 page scrolls completed
  3. FINALIZE:
     - Combine all cached-findings with new-findings from current visible state
     - Verify all required information is collected
     - Present complete findings in done action

- Critical guidelines:d
  • Be thorough and specific in extraction
  • Always cache findings BEFORE scrolling
  • Verify source information before caching
  • Scroll EXACTLY ONE PAGE each time
  • NEVER scroll more than one page at once, as this will cause loss of information
  • NEVER scroll less than half a page, as this is inefficient and you will get stuck in a loop
  • Stop after maximum 8 page scrolls

10. Login & Authentication:

- If the webpage is asking for login credentials or asking users to sign in, NEVER try to fill it by yourself. Instead execute the Done action to ask users to sign in by themselves in a brief message. 
- Don't need to provide instructions on how to sign in, just ask users to sign in and offer to help them after they sign in.

11. Plan:

- Plan is a json string wrapped by the <plan> tag
- If a plan is provided, follow the instructions in the next_steps exactly first
- If no plan is provided, just continue with the task
`;
  class NavigatorPrompt extends BasePrompt {
    constructor(maxActionsPerStep = 10) {
      super();
      this.maxActionsPerStep = maxActionsPerStep;
      const promptTemplate = navigatorSystemPromptTemplate;
      const formattedPrompt = promptTemplate.replace("{{max_actions}}", this.maxActionsPerStep.toString()).trim();
      this.systemMessage = new SystemMessage(formattedPrompt);
    }
    getSystemMessage() {
      return this.systemMessage;
    }
    async getUserMessage(context) {
      return await this.buildBrowserStateUserMessage(context);
    }
  }
  class PlannerPrompt extends BasePrompt {
    getSystemMessage() {
      return new SystemMessage(`You are a helpful assistant.

RESPONSIBILITIES:
1. Judge whether the ultimate task is related to web browsing or not and set the "web_task" field.
2. If web_task is false, then just answer the task directly as a helpful assistant
  - Output the answer into "next_steps" field in the JSON object. 
  - Set "done" field to true
  - Set these fields in the JSON object to empty string: "observation", "challenges", "reasoning"
  - Be kind and helpful when answering the task
  - Do NOT offer anything that users don't explicitly ask for.
  - Do NOT make up anything, if you don't know the answer, just say "I don't know"

3. If web_task is true, then helps break down tasks into smaller steps and reason about the current state
  - Analyze the current state and history
  - Evaluate progress towards the ultimate goal
  - Identify potential challenges or roadblocks
  - Suggest the next high-level steps to take
  - If you know the direct URL, use it directly instead of searching for it (e.g. github.com, www.espn.com). Search it if you don't know the direct URL.
  - Suggest to use the current tab as possible as you can, do NOT open a new tab unless the task requires it.
  - IMPORTANT: 
    - Always prioritize working with content visible in the current viewport first:
    - Focus on elements that are immediately visible without scrolling
    - Only suggest scrolling if the required content is confirmed to not be in the current view
    - Scrolling is your LAST resort unless you are explicitly required to do so by the task
    - NEVER suggest scrolling through the entire page, only scroll ONE PAGE at a time.
4. Once web_task is set to either true or false, its value The value must never change from its first set state in the conversation.

RESPONSE FORMAT: Your must always respond with a valid JSON object with the following fields:
{
    "observation": "[string type], brief analysis of the current state and what has been done so far",
    "done": "[boolean type], whether further steps are needed to complete the ultimate task",
    "challenges": "[string type], list any potential challenges or roadblocks",
    "next_steps": "[string type], list 2-3 high-level next steps to take, each step should start with a new line",
    "reasoning": "[string type], explain your reasoning for the suggested next steps",
    "web_task": "[boolean type], whether the ultimate task is related to browsing the web"
}

NOTE:
  - Inside the messages you receive, there will be other AI messages from other agents with different formats.
  - Ignore the output structures of other AI messages.

REMEMBER:
  - Keep your responses concise and focused on actionable insights.`);
    }
    async getUserMessage(context) {
      return new HumanMessage("");
    }
  }
  class ValidatorPrompt extends BasePrompt {
    constructor(task) {
      super();
      this.tasks = [];
      this.tasks.push(task);
    }
    tasksToValidate() {
      if (this.tasks.length === 1) {
        return this.tasks[0];
      }
      const lastTask = this.tasks[this.tasks.length - 1];
      const previousTasks = this.tasks.slice(0, -1).map((task, index) => `${index + 1}. ${task}`).join("\n");
      const tasksString = `
${lastTask}

The above task is a follow up task of the following tasks, please take the previous context into account when validating the task.

Previous tasks:
${previousTasks}
`;
      return tasksString;
    }
    getSystemMessage() {
      return new SystemMessage(`You are a validator of an agent who interacts with a browser.
YOUR ROLE:
1. Validate if the agent's last action matches the user's request and if the task is completed.
2. Determine if the task is fully completed
3. Answer the task based on the provided context if the task is completed

RULES of ANSWERING THE TASK:
  - Read the task description carefully, neither miss any detailed requirements nor make up any requirements
  - Compile the final answer from provided context, do NOT make up any information not provided in the context
  - Make answers concise and easy to read
  - Include relevant numerical data when available, but do NOT make up any numbers
  - Include exact urls when available, but do NOT make up any urls
  - Format the final answer in a user-friendly way

SPECIAL CASES:
1. If the task is unclear defined, you can let it pass. But if something is missing or the image does not show what was requested, do NOT let it pass
2. If the task is required to consolidate information from multiple pages, focus on the last Action Result. The current page is not important for validation but the last Action Result is.
3. Try to understand the page and help the model with suggestions like scroll, do x, ... to get the solution right
4. If the webpage is asking for username or password, you should respond with:
  - is_valid: true
  - reason: describe the reason why it is valid although the task is not completed yet
  - answer: ask the user to sign in by themselves
5. If the output is correct and the task is completed, you should respond with 
  - is_valid: true
  - reason: "Task completed"
  - answer: The final answer to the task

RESPONSE FORMAT: You must ALWAYS respond with valid JSON in this exact format:
{
  "is_valid": true or false,  // Boolean value (not a string) indicating if task is completed correctly
  "reason": string,           // clear explanation of validation result
  "answer": string            // empty string if is_valid is false; human-readable final answer and should not be empty if is_valid is true
}

ANSWER FORMATTING GUIDELINES:
- Start with an emoji "✅" if is_valid is true
- Use markdown formatting if required by the task description
- By default use plain text
- Use bullet points for multiple items if needed
- Use line breaks for better readability
- Use indentations for nested lists

<example_output>
{
  "is_valid": false, 
  "reason": "The user wanted to search for \\"cat photos\\", but the agent searched for \\"dog photos\\" instead.",
  "answer": ""
}
</example_output>

<example_output>
{
  "is_valid": true, 
  "reason": "The task is completed",
  "answer": "✅ Successfully followed @nanobrowser_ai on X."
}
</example_output>

TASK TO VALIDATE: 
${this.tasksToValidate()}`);
    }
    /**
     * Get the user message for the validator prompt
     * @param context - The agent context
     * @returns The user message
     */
    async getUserMessage(context) {
      return await this.buildBrowserStateUserMessage(context);
    }
    addFollowUpTask(task) {
      this.tasks.push(task);
    }
  }
  class MessageMetadata {
    constructor(tokens, message_type) {
      this.message_type = null;
      this.tokens = tokens;
      this.message_type = message_type ?? null;
    }
  }
  class MessageHistory {
    constructor() {
      this.messages = [];
      this.totalTokens = 0;
    }
    addMessage(message, metadata, position) {
      const managedMessage = {
        message,
        metadata
      };
      if (position === void 0) {
        this.messages.push(managedMessage);
      } else {
        this.messages.splice(position, 0, managedMessage);
      }
      this.totalTokens += metadata.tokens;
    }
    removeMessage(index = -1) {
      if (this.messages.length > 0) {
        const msg = this.messages.splice(index, 1)[0];
        this.totalTokens -= msg.metadata.tokens;
      }
    }
    /**
     * Removes the last message from the history if it is a human message.
     * This is used to remove the state message from the history.
     */
    removeLastStateMessage() {
      if (this.messages.length > 2 && this.messages[this.messages.length - 1].message instanceof HumanMessage) {
        const msg = this.messages.pop();
        if (msg) {
          this.totalTokens -= msg.metadata.tokens;
        }
      }
    }
    /**
     * Get all messages
     */
    getMessages() {
      return this.messages.map((m) => m.message);
    }
    /**
     * Get total tokens in history
     */
    getTotalTokens() {
      return this.totalTokens;
    }
    /**
     * Remove oldest non-system message
     */
    removeOldestMessage() {
      for (let i2 = 0; i2 < this.messages.length; i2++) {
        if (!(this.messages[i2].message instanceof SystemMessage)) {
          const msg = this.messages.splice(i2, 1)[0];
          this.totalTokens -= msg.metadata.tokens;
          break;
        }
      }
    }
  }
  const logger$3 = createLogger("MessageManager");
  class MessageManagerSettings {
    constructor(options = {}) {
      this.maxInputTokens = 128e3;
      this.estimatedCharactersPerToken = 3;
      this.imageTokens = 800;
      this.includeAttributes = [];
      if (options.maxInputTokens !== void 0) this.maxInputTokens = options.maxInputTokens;
      if (options.estimatedCharactersPerToken !== void 0)
        this.estimatedCharactersPerToken = options.estimatedCharactersPerToken;
      if (options.imageTokens !== void 0) this.imageTokens = options.imageTokens;
      if (options.includeAttributes !== void 0) this.includeAttributes = options.includeAttributes;
      if (options.messageContext !== void 0) this.messageContext = options.messageContext;
      if (options.sensitiveData !== void 0) this.sensitiveData = options.sensitiveData;
      if (options.availableFilePaths !== void 0) this.availableFilePaths = options.availableFilePaths;
    }
  }
  class MessageManager {
    constructor(settings = new MessageManagerSettings()) {
      this.settings = settings;
      this.history = new MessageHistory();
      this.toolId = 1;
    }
    initTaskMessages(systemMessage, task, messageContext) {
      this.addMessageWithTokens(systemMessage, "init");
      if (messageContext && messageContext.length > 0) {
        const contextMessage = new HumanMessage({
          content: `Context for the task: ${messageContext}`
        });
        this.addMessageWithTokens(contextMessage, "init");
      }
      const taskMessage = MessageManager.taskInstructions(task);
      this.addMessageWithTokens(taskMessage, "init");
      if (this.settings.sensitiveData) {
        const info = `Here are placeholders for sensitive data: ${Object.keys(this.settings.sensitiveData)}`;
        const infoMessage = new HumanMessage({
          content: `${info}
To use them, write <secret>the placeholder name</secret>`
        });
        this.addMessageWithTokens(infoMessage, "init");
      }
      const placeholderMessage = new HumanMessage({
        content: "Example output:"
      });
      this.addMessageWithTokens(placeholderMessage, "init");
      const toolCallId = this.nextToolId();
      const toolCalls = [
        {
          name: "AgentOutput",
          args: {
            current_state: {
              evaluation_previous_goal: `Success - I successfully clicked on the 'Apple' link from the Google Search results page, 
              which directed me to the 'Apple' company homepage. This is a good start toward finding 
              the best place to buy a new iPhone as the Apple website often list iPhones for sale.`.trim(),
              memory: `I searched for 'iPhone retailers' on Google. From the Google Search results page, 
              I used the 'click_element' tool to click on a element labelled 'Best Buy' but calling 
              the tool did not direct me to a new page. I then used the 'click_element' tool to click 
              on a element labelled 'Apple' which redirected me to the 'Apple' company homepage. 
              Currently at step 3/15.`.trim(),
              next_goal: `Looking at reported structure of the current page, I can see the item '[127]<h3 iPhone/>' 
              in the content. I think this button will lead to more information and potentially prices 
              for iPhones. I'll click on the link to 'iPhone' at index [127] using the 'click_element' 
              tool and hope to see prices on the next page.`.trim()
            },
            action: [{ click_element: { index: 127 } }]
          },
          id: String(toolCallId),
          type: "tool_call"
        }
      ];
      const exampleToolCall = new AIMessage({
        content: "",
        tool_calls: toolCalls
      });
      this.addMessageWithTokens(exampleToolCall, "init");
      this.addToolMessage("Browser started", toolCallId, "init");
      const historyStartMessage = new HumanMessage({
        content: "[Your task history memory starts here]"
      });
      this.addMessageWithTokens(historyStartMessage);
      if (this.settings.availableFilePaths && this.settings.availableFilePaths.length > 0) {
        const filepathsMsg = new HumanMessage({
          content: `Here are file paths you can use: ${this.settings.availableFilePaths}`
        });
        this.addMessageWithTokens(filepathsMsg, "init");
      }
    }
    nextToolId() {
      const id = this.toolId;
      this.toolId += 1;
      return id;
    }
    /**
     * Createthe task instructions
     * @param task - The raw description of the task
     * @returns A HumanMessage object containing the task instructions
     */
    static taskInstructions(task) {
      const content = `Your ultimate task is: """${task}""". If you achieved your ultimate task, stop everything and use the done action in the next step to complete the task. If not, continue as usual.`;
      return new HumanMessage({ content });
    }
    /**
     * Returns the number of messages in the history
     * @returns The number of messages in the history
     */
    length() {
      return this.history.messages.length;
    }
    /**
     * Adds a new task to execute, it will be executed based on the history
     * @param newTask - The raw description of the new task
     */
    addNewTask(newTask) {
      const content = `Your new ultimate task is: """${newTask}""". Take the previous context into account and finish your new ultimate task. `;
      const msg = new HumanMessage({ content });
      this.addMessageWithTokens(msg);
    }
    /**
     * Adds a plan message to the history
     * @param plan - The raw description of the plan
     * @param position - The position to add the plan
     */
    addPlan(plan, position) {
      if (plan) {
        const msg = new AIMessage({ content: `<plan>${plan}</plan>` });
        this.addMessageWithTokens(msg, null, position);
      }
    }
    /**
     * Adds a state message to the history
     * @param stateMessage - The HumanMessage object containing the state
     */
    addStateMessage(stateMessage) {
      this.addMessageWithTokens(stateMessage);
    }
    /**
     * Adds a model output message to the history
     * @param modelOutput - The model output
     */
    addModelOutput(modelOutput) {
      const toolCallId = this.nextToolId();
      const toolCalls = [
        {
          name: "AgentOutput",
          args: modelOutput,
          id: String(toolCallId),
          type: "tool_call"
        }
      ];
      const msg = new AIMessage({
        content: "tool call",
        tool_calls: toolCalls
      });
      this.addMessageWithTokens(msg);
      this.addToolMessage("tool call response placeholder", toolCallId);
    }
    /**
     * Removes the last state message from the history
     */
    removeLastStateMessage() {
      this.history.removeLastStateMessage();
    }
    getMessages() {
      const messages = this.history.messages.map((m) => m.message);
      let totalInputTokens = 0;
      logger$3.debug(`Messages in history: ${this.history.messages.length}:`);
      for (const m of this.history.messages) {
        totalInputTokens += m.metadata.tokens;
        logger$3.debug(`${m.message.constructor.name} - Token count: ${m.metadata.tokens}`);
      }
      return messages;
    }
    /**
     * Adds a message to the history with the token count metadata
     * @param message - The BaseMessage object to add
     * @param messageType - The type of the message (optional)
     * @param position - The optional position to add the message, if not provided, the message will be added to the end of the history
     */
    addMessageWithTokens(message, messageType, position) {
      let filteredMessage = message;
      if (this.settings.sensitiveData) {
        filteredMessage = this._filterSensitiveData(message);
      }
      const tokenCount = this._countTokens(filteredMessage);
      const metadata = new MessageMetadata(tokenCount, messageType);
      this.history.addMessage(filteredMessage, metadata, position);
    }
    /**
     * Filters out sensitive data from the message
     * @param message - The BaseMessage object to filter
     * @returns The filtered BaseMessage object
     */
    _filterSensitiveData(message) {
      const replaceSensitive = (value) => {
        let filteredValue = value;
        if (!this.settings.sensitiveData) return filteredValue;
        for (const [key, val] of Object.entries(this.settings.sensitiveData)) {
          if (!val) continue;
          filteredValue = filteredValue.replace(val, `<secret>${key}</secret>`);
        }
        return filteredValue;
      };
      if (typeof message.content === "string") {
        message.content = replaceSensitive(message.content);
      } else if (Array.isArray(message.content)) {
        message.content = message.content.map((item) => {
          if (typeof item === "object" && item !== null && "text" in item) {
            return { ...item, text: replaceSensitive(item.text) };
          }
          return item;
        });
      }
      return message;
    }
    /**
     * Counts the tokens in the message
     * @param message - The BaseMessage object to count the tokens
     * @returns The number of tokens in the message
     */
    _countTokens(message) {
      let tokens = 0;
      if (Array.isArray(message.content)) {
        for (const item of message.content) {
          if ("image_url" in item) {
            tokens += this.settings.imageTokens;
          } else if (typeof item === "object" && "text" in item) {
            tokens += this._countTextTokens(item.text);
          }
        }
      } else {
        let msg = message.content;
        if ("tool_calls" in message) {
          msg += JSON.stringify(message.tool_calls);
        }
        tokens += this._countTextTokens(msg);
      }
      return tokens;
    }
    /**
     * Counts the tokens in the text
     * Rough estimate, no tokenizer provided for now
     * @param text - The text to count the tokens
     * @returns The number of tokens in the text
     */
    _countTextTokens(text) {
      return Math.floor(text.length / this.settings.estimatedCharactersPerToken);
    }
    /**
     * Cuts the last message if the total tokens exceed the max input tokens
     *
     * Get current message list, potentially trimmed to max tokens
     */
    cutMessages() {
      let diff = this.history.totalTokens - this.settings.maxInputTokens;
      if (diff <= 0) return;
      const lastMsg = this.history.messages[this.history.messages.length - 1];
      if (Array.isArray(lastMsg.message.content)) {
        let text = "";
        lastMsg.message.content = lastMsg.message.content.filter((item) => {
          if ("image_url" in item) {
            diff -= this.settings.imageTokens;
            lastMsg.metadata.tokens -= this.settings.imageTokens;
            this.history.totalTokens -= this.settings.imageTokens;
            logger$3.debug(
              `Removed image with ${this.settings.imageTokens} tokens - total tokens now: ${this.history.totalTokens}/${this.settings.maxInputTokens}`
            );
            return false;
          }
          if ("text" in item) {
            text += item.text;
          }
          return true;
        });
        lastMsg.message.content = text;
        this.history.messages[this.history.messages.length - 1] = lastMsg;
      }
      if (diff <= 0) return;
      const proportionToRemove = diff / lastMsg.metadata.tokens;
      if (proportionToRemove > 0.99) {
        throw new Error(
          `Max token limit reached - history is too long - reduce the system prompt or task. proportion_to_remove: ${proportionToRemove}`
        );
      }
      logger$3.debug(
        `Removing ${(proportionToRemove * 100).toFixed(2)}% of the last message (${(proportionToRemove * lastMsg.metadata.tokens).toFixed(2)} / ${lastMsg.metadata.tokens.toFixed(2)} tokens)`
      );
      const content = lastMsg.message.content;
      const charactersToRemove = Math.floor(content.length * proportionToRemove);
      const newContent = content.slice(0, -charactersToRemove);
      this.history.removeLastStateMessage();
      const msg = new HumanMessage({ content: newContent });
      this.addMessageWithTokens(msg);
      const finalMsg = this.history.messages[this.history.messages.length - 1];
      logger$3.debug(
        `Added message with ${finalMsg.metadata.tokens} tokens - total tokens now: ${this.history.totalTokens}/${this.settings.maxInputTokens} - total messages: ${this.history.messages.length}`
      );
    }
    /**
     * Adds a tool message to the history
     * @param content - The content of the tool message
     * @param toolCallId - The tool call id of the tool message, if not provided, a new tool call id will be generated
     * @param messageType - The type of the tool message
     */
    addToolMessage(content, toolCallId, messageType) {
      const id = toolCallId ?? this.nextToolId();
      const msg = new ToolMessage({ content, tool_call_id: String(id) });
      this.addMessageWithTokens(msg, messageType);
    }
  }
  const logger$2 = createLogger("event-manager");
  let EventManager$1 = class EventManager {
    constructor() {
      this._subscribers = /* @__PURE__ */ new Map();
    }
    subscribe(eventType, callback) {
      if (!this._subscribers.has(eventType)) {
        this._subscribers.set(eventType, []);
      }
      const callbacks = this._subscribers.get(eventType);
      if (callbacks && !callbacks.includes(callback)) {
        callbacks.push(callback);
      }
    }
    unsubscribe(eventType, callback) {
      if (this._subscribers.has(eventType)) {
        const callbacks = this._subscribers.get(eventType);
        if (callbacks) {
          this._subscribers.set(
            eventType,
            callbacks.filter((cb) => cb !== callback)
          );
        }
      }
    }
    clearSubscribers(eventType) {
      if (this._subscribers.has(eventType)) {
        this._subscribers.set(eventType, []);
      }
    }
    async emit(event) {
      const callbacks = this._subscribers.get(event.type);
      if (callbacks) {
        try {
          await Promise.all(callbacks.map(async (callback) => await callback(event)));
        } catch (error) {
          logger$2.error("Error executing event callbacks:", error);
        }
      }
    }
  };
  const logger$1 = createLogger("Executor");
  class Executor {
    constructor(task, taskId, browserContext2, navigatorLLM, extraArgs) {
      this.tasks = [];
      const messageManager = new MessageManager({});
      const plannerLLM = (extraArgs == null ? void 0 : extraArgs.plannerLLM) ?? navigatorLLM;
      const validatorLLM = (extraArgs == null ? void 0 : extraArgs.validatorLLM) ?? navigatorLLM;
      const extractorLLM = (extraArgs == null ? void 0 : extraArgs.extractorLLM) ?? navigatorLLM;
      const eventManager = new EventManager$1();
      const context = new AgentContext(
        taskId,
        browserContext2,
        messageManager,
        eventManager,
        (extraArgs == null ? void 0 : extraArgs.agentOptions) ?? {}
      );
      this.tasks.push(task);
      this.navigatorPrompt = new NavigatorPrompt(context.options.maxActionsPerStep);
      this.plannerPrompt = new PlannerPrompt();
      this.validatorPrompt = new ValidatorPrompt(task);
      const actionBuilder = new ActionBuilder(context, extractorLLM);
      const navigatorActionRegistry = new NavigatorActionRegistry(actionBuilder.buildDefaultActions());
      this.navigator = new NavigatorAgent(navigatorActionRegistry, {
        chatLLM: navigatorLLM,
        context,
        prompt: this.navigatorPrompt
      });
      this.planner = new PlannerAgent({
        chatLLM: plannerLLM,
        context,
        prompt: this.plannerPrompt
      });
      this.validator = new ValidatorAgent({
        chatLLM: validatorLLM,
        context,
        prompt: this.validatorPrompt
      });
      this.context = context;
      this.context.messageManager.initTaskMessages(this.navigatorPrompt.getSystemMessage(), task);
    }
    subscribeExecutionEvents(callback) {
      this.context.eventManager.subscribe(EventType.EXECUTION, callback);
    }
    clearExecutionEvents() {
      this.context.eventManager.clearSubscribers(EventType.EXECUTION);
    }
    addFollowUpTask(task) {
      this.tasks.push(task);
      this.context.messageManager.addNewTask(task);
      this.validatorPrompt.addFollowUpTask(task);
      this.context.actionResults = this.context.actionResults.filter((result) => result.includeInMemory);
    }
    /**
     * Execute the task
     *
     * @returns {Promise<void>}
     */
    async execute() {
      var _a3;
      logger$1.info(`🚀 Executing task: ${this.tasks[this.tasks.length - 1]}`);
      const context = this.context;
      context.nSteps = 0;
      const allowedMaxSteps = this.context.options.maxSteps;
      try {
        this.context.emitEvent(Actors.SYSTEM, ExecutionState.TASK_START, this.context.taskId);
        let done = false;
        let step = 0;
        let validatorFailed = false;
        for (step = 0; step < allowedMaxSteps; step++) {
          context.stepInfo = {
            stepNumber: context.nSteps,
            maxSteps: context.options.maxSteps
          };
          logger$1.info(`🔄 Step ${step + 1} / ${allowedMaxSteps}`);
          if (await this.shouldStop()) {
            break;
          }
          if (this.planner && (context.nSteps % context.options.planningInterval === 0 || validatorFailed)) {
            validatorFailed = false;
            let positionForPlan = 0;
            if (this.tasks.length > 1 || step > 0) {
              await this.navigator.addStateMessageToMemory();
              positionForPlan = this.context.messageManager.length() - 1;
            } else {
              positionForPlan = this.context.messageManager.length();
            }
            const planOutput = await this.planner.execute();
            if (planOutput.result) {
              logger$1.info(`🔄 Planner output: ${JSON.stringify(planOutput.result, null, 2)}`);
              this.context.messageManager.addPlan(JSON.stringify(planOutput.result), positionForPlan);
              if (planOutput.result.done) {
                done = true;
                this.validator.setPlan(planOutput.result.next_steps);
              } else {
                this.validator.setPlan(null);
                done = false;
              }
              if (!planOutput.result.web_task && planOutput.result.done) {
                break;
              }
            }
          }
          if (!done) {
            done = await this.navigate();
          }
          if (done && this.context.options.validateOutput && !this.context.stopped && !this.context.paused) {
            const validatorOutput = await this.validator.execute();
            if ((_a3 = validatorOutput.result) == null ? void 0 : _a3.is_valid) {
              logger$1.info("✅ Task completed successfully");
              break;
            }
            validatorFailed = true;
            context.consecutiveValidatorFailures++;
            if (context.consecutiveValidatorFailures >= context.options.maxValidatorFailures) {
              logger$1.error(`Stopping due to ${context.options.maxValidatorFailures} consecutive validator failures`);
              throw new Error("Too many failures of validation");
            }
          }
        }
        if (done) {
          this.context.emitEvent(Actors.SYSTEM, ExecutionState.TASK_OK, this.context.taskId);
        } else if (step >= allowedMaxSteps) {
          logger$1.info("❌ Task failed: Max steps reached");
          this.context.emitEvent(Actors.SYSTEM, ExecutionState.TASK_FAIL, "Task failed: Max steps reached");
        } else if (this.context.stopped) {
          this.context.emitEvent(Actors.SYSTEM, ExecutionState.TASK_CANCEL, "Task cancelled");
        } else {
          this.context.emitEvent(Actors.SYSTEM, ExecutionState.TASK_PAUSE, "Task paused");
        }
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        this.context.emitEvent(Actors.SYSTEM, ExecutionState.TASK_FAIL, `Task failed: ${errorMessage}`);
      }
    }
    async navigate() {
      var _a3;
      const context = this.context;
      try {
        if (context.paused || context.stopped) {
          return false;
        }
        const navOutput = await this.navigator.execute();
        if (context.paused || context.stopped) {
          return false;
        }
        context.nSteps++;
        if (navOutput.error) {
          throw new Error(navOutput.error);
        }
        context.consecutiveFailures = 0;
        if ((_a3 = navOutput.result) == null ? void 0 : _a3.done) {
          return true;
        }
      } catch (error) {
        if (error instanceof ChatModelAuthError || error instanceof ChatModelForbiddenError) {
          throw error;
        }
        context.consecutiveFailures++;
        logger$1.error(`Failed to execute step: ${error}`);
        if (context.consecutiveFailures >= context.options.maxFailures) {
          throw new Error("Max failures reached");
        }
      }
      return false;
    }
    async shouldStop() {
      if (this.context.stopped) {
        logger$1.info("Agent stopped");
        return true;
      }
      while (this.context.paused) {
        await new Promise((resolve) => setTimeout(resolve, 200));
        if (this.context.stopped) {
          return true;
        }
      }
      if (this.context.consecutiveFailures >= this.context.options.maxFailures) {
        logger$1.error(`Stopping due to ${this.context.options.maxFailures} consecutive failures`);
        return true;
      }
      return false;
    }
    async cancel() {
      this.context.stop();
    }
    async resume() {
      this.context.resume();
    }
    async pause() {
      this.context.pause();
    }
    async cleanup() {
      try {
        await this.context.browserContext.cleanup();
      } catch (error) {
        logger$1.error(`Failed to cleanup browser context: ${error}`);
      }
    }
    async getCurrentTaskId() {
      return this.context.taskId;
    }
  }
  const default_format$1 = "RFC3986";
  const formatters$1 = {
    RFC1738: (v) => String(v).replace(/%20/g, "+"),
    RFC3986: (v) => String(v)
  };
  const RFC1738$1 = "RFC1738";
  const is_array$3 = Array.isArray;
  const hex_table$1 = (() => {
    const array = [];
    for (let i2 = 0; i2 < 256; ++i2) {
      array.push("%" + ((i2 < 16 ? "0" : "") + i2.toString(16)).toUpperCase());
    }
    return array;
  })();
  const limit$1 = 1024;
  const encode$1 = (str2, _defaultEncoder, charset, _kind, format) => {
    if (str2.length === 0) {
      return str2;
    }
    let string = str2;
    if (typeof str2 === "symbol") {
      string = Symbol.prototype.toString.call(str2);
    } else if (typeof str2 !== "string") {
      string = String(str2);
    }
    if (charset === "iso-8859-1") {
      return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
        return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
      });
    }
    let out = "";
    for (let j = 0; j < string.length; j += limit$1) {
      const segment = string.length >= limit$1 ? string.slice(j, j + limit$1) : string;
      const arr2 = [];
      for (let i2 = 0; i2 < segment.length; ++i2) {
        let c = segment.charCodeAt(i2);
        if (c === 45 || // -
        c === 46 || // .
        c === 95 || // _
        c === 126 || // ~
        c >= 48 && c <= 57 || // 0-9
        c >= 65 && c <= 90 || // a-z
        c >= 97 && c <= 122 || // A-Z
        format === RFC1738$1 && (c === 40 || c === 41)) {
          arr2[arr2.length] = segment.charAt(i2);
          continue;
        }
        if (c < 128) {
          arr2[arr2.length] = hex_table$1[c];
          continue;
        }
        if (c < 2048) {
          arr2[arr2.length] = hex_table$1[192 | c >> 6] + hex_table$1[128 | c & 63];
          continue;
        }
        if (c < 55296 || c >= 57344) {
          arr2[arr2.length] = hex_table$1[224 | c >> 12] + hex_table$1[128 | c >> 6 & 63] + hex_table$1[128 | c & 63];
          continue;
        }
        i2 += 1;
        c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i2) & 1023);
        arr2[arr2.length] = hex_table$1[240 | c >> 18] + hex_table$1[128 | c >> 12 & 63] + hex_table$1[128 | c >> 6 & 63] + hex_table$1[128 | c & 63];
      }
      out += arr2.join("");
    }
    return out;
  };
  function is_buffer$1(obj) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
  }
  function maybe_map$1(val, fn) {
    if (is_array$3(val)) {
      const mapped = [];
      for (let i2 = 0; i2 < val.length; i2 += 1) {
        mapped.push(fn(val[i2]));
      }
      return mapped;
    }
    return fn(val);
  }
  const has$1 = Object.prototype.hasOwnProperty;
  const array_prefix_generators$1 = {
    brackets(prefix) {
      return String(prefix) + "[]";
    },
    comma: "comma",
    indices(prefix, key) {
      return String(prefix) + "[" + key + "]";
    },
    repeat(prefix) {
      return String(prefix);
    }
  };
  const is_array$2 = Array.isArray;
  const push$1 = Array.prototype.push;
  const push_to_array$1 = function(arr2, value_or_array) {
    push$1.apply(arr2, is_array$2(value_or_array) ? value_or_array : [value_or_array]);
  };
  const to_ISO$1 = Date.prototype.toISOString;
  const defaults$1 = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: "indices",
    charset: "utf-8",
    charsetSentinel: false,
    delimiter: "&",
    encode: true,
    encodeDotInKeys: false,
    encoder: encode$1,
    encodeValuesOnly: false,
    format: default_format$1,
    formatter: formatters$1[default_format$1],
    /** @deprecated */
    indices: false,
    serializeDate(date) {
      return to_ISO$1.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
  };
  function is_non_nullish_primitive$1(v) {
    return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
  }
  const sentinel$1 = {};
  function inner_stringify$1(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter2, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
    let obj = object;
    let tmp_sc = sideChannel;
    let step = 0;
    let find_flag = false;
    while ((tmp_sc = tmp_sc.get(sentinel$1)) !== void 0 && !find_flag) {
      const pos = tmp_sc.get(object);
      step += 1;
      if (typeof pos !== "undefined") {
        if (pos === step) {
          throw new RangeError("Cyclic object value");
        } else {
          find_flag = true;
        }
      }
      if (typeof tmp_sc.get(sentinel$1) === "undefined") {
        step = 0;
      }
    }
    if (typeof filter2 === "function") {
      obj = filter2(prefix, obj);
    } else if (obj instanceof Date) {
      obj = serializeDate == null ? void 0 : serializeDate(obj);
    } else if (generateArrayPrefix === "comma" && is_array$2(obj)) {
      obj = maybe_map$1(obj, function(value) {
        if (value instanceof Date) {
          return serializeDate == null ? void 0 : serializeDate(value);
        }
        return value;
      });
    }
    if (obj === null) {
      if (strictNullHandling) {
        return encoder && !encodeValuesOnly ? (
          // @ts-expect-error
          encoder(prefix, defaults$1.encoder, charset, "key", format)
        ) : prefix;
      }
      obj = "";
    }
    if (is_non_nullish_primitive$1(obj) || is_buffer$1(obj)) {
      if (encoder) {
        const key_value = encodeValuesOnly ? prefix : encoder(prefix, defaults$1.encoder, charset, "key", format);
        return [
          (formatter == null ? void 0 : formatter(key_value)) + "=" + // @ts-expect-error
          (formatter == null ? void 0 : formatter(encoder(obj, defaults$1.encoder, charset, "value", format)))
        ];
      }
      return [(formatter == null ? void 0 : formatter(prefix)) + "=" + (formatter == null ? void 0 : formatter(String(obj)))];
    }
    const values = [];
    if (typeof obj === "undefined") {
      return values;
    }
    let obj_keys;
    if (generateArrayPrefix === "comma" && is_array$2(obj)) {
      if (encodeValuesOnly && encoder) {
        obj = maybe_map$1(obj, encoder);
      }
      obj_keys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
    } else if (is_array$2(filter2)) {
      obj_keys = filter2;
    } else {
      const keys = Object.keys(obj);
      obj_keys = sort ? keys.sort(sort) : keys;
    }
    const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
    const adjusted_prefix = commaRoundTrip && is_array$2(obj) && obj.length === 1 ? encoded_prefix + "[]" : encoded_prefix;
    if (allowEmptyArrays && is_array$2(obj) && obj.length === 0) {
      return adjusted_prefix + "[]";
    }
    for (let j = 0; j < obj_keys.length; ++j) {
      const key = obj_keys[j];
      const value = (
        // @ts-ignore
        typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key]
      );
      if (skipNulls && value === null) {
        continue;
      }
      const encoded_key = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
      const key_prefix = is_array$2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjusted_prefix, encoded_key) : adjusted_prefix : adjusted_prefix + (allowDots ? "." + encoded_key : "[" + encoded_key + "]");
      sideChannel.set(object, step);
      const valueSideChannel = /* @__PURE__ */ new WeakMap();
      valueSideChannel.set(sentinel$1, sideChannel);
      push_to_array$1(values, inner_stringify$1(
        value,
        key_prefix,
        generateArrayPrefix,
        commaRoundTrip,
        allowEmptyArrays,
        strictNullHandling,
        skipNulls,
        encodeDotInKeys,
        // @ts-ignore
        generateArrayPrefix === "comma" && encodeValuesOnly && is_array$2(obj) ? null : encoder,
        filter2,
        sort,
        allowDots,
        serializeDate,
        format,
        formatter,
        encodeValuesOnly,
        charset,
        valueSideChannel
      ));
    }
    return values;
  }
  function normalize_stringify_options$1(opts = defaults$1) {
    if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    }
    if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
      throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
    }
    if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
      throw new TypeError("Encoder has to be a function.");
    }
    const charset = opts.charset || defaults$1.charset;
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    let format = default_format$1;
    if (typeof opts.format !== "undefined") {
      if (!has$1.call(formatters$1, opts.format)) {
        throw new TypeError("Unknown format option provided.");
      }
      format = opts.format;
    }
    const formatter = formatters$1[format];
    let filter2 = defaults$1.filter;
    if (typeof opts.filter === "function" || is_array$2(opts.filter)) {
      filter2 = opts.filter;
    }
    let arrayFormat;
    if (opts.arrayFormat && opts.arrayFormat in array_prefix_generators$1) {
      arrayFormat = opts.arrayFormat;
    } else if ("indices" in opts) {
      arrayFormat = opts.indices ? "indices" : "repeat";
    } else {
      arrayFormat = defaults$1.arrayFormat;
    }
    if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
      throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    }
    const allowDots = typeof opts.allowDots === "undefined" ? !!opts.encodeDotInKeys === true ? true : defaults$1.allowDots : !!opts.allowDots;
    return {
      addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults$1.addQueryPrefix,
      // @ts-ignore
      allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults$1.allowEmptyArrays,
      arrayFormat,
      charset,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$1.charsetSentinel,
      commaRoundTrip: !!opts.commaRoundTrip,
      delimiter: typeof opts.delimiter === "undefined" ? defaults$1.delimiter : opts.delimiter,
      encode: typeof opts.encode === "boolean" ? opts.encode : defaults$1.encode,
      encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults$1.encodeDotInKeys,
      encoder: typeof opts.encoder === "function" ? opts.encoder : defaults$1.encoder,
      encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults$1.encodeValuesOnly,
      filter: filter2,
      format,
      formatter,
      serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults$1.serializeDate,
      skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults$1.skipNulls,
      // @ts-ignore
      sort: typeof opts.sort === "function" ? opts.sort : null,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$1.strictNullHandling
    };
  }
  function stringify$1(object, opts = {}) {
    let obj = object;
    const options = normalize_stringify_options$1(opts);
    let obj_keys;
    let filter2;
    if (typeof options.filter === "function") {
      filter2 = options.filter;
      obj = filter2("", obj);
    } else if (is_array$2(options.filter)) {
      filter2 = options.filter;
      obj_keys = filter2;
    }
    const keys = [];
    if (typeof obj !== "object" || obj === null) {
      return "";
    }
    const generateArrayPrefix = array_prefix_generators$1[options.arrayFormat];
    const commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
    if (!obj_keys) {
      obj_keys = Object.keys(obj);
    }
    if (options.sort) {
      obj_keys.sort(options.sort);
    }
    const sideChannel = /* @__PURE__ */ new WeakMap();
    for (let i2 = 0; i2 < obj_keys.length; ++i2) {
      const key = obj_keys[i2];
      if (options.skipNulls && obj[key] === null) {
        continue;
      }
      push_to_array$1(keys, inner_stringify$1(
        obj[key],
        key,
        // @ts-expect-error
        generateArrayPrefix,
        commaRoundTrip,
        options.allowEmptyArrays,
        options.strictNullHandling,
        options.skipNulls,
        options.encodeDotInKeys,
        options.encode ? options.encoder : null,
        options.filter,
        options.sort,
        options.allowDots,
        options.serializeDate,
        options.format,
        options.formatter,
        options.encodeValuesOnly,
        options.charset,
        sideChannel
      ));
    }
    const joined = keys.join(options.delimiter);
    let prefix = options.addQueryPrefix === true ? "?" : "";
    if (options.charsetSentinel) {
      if (options.charset === "iso-8859-1") {
        prefix += "utf8=%26%2310003%3B&";
      } else {
        prefix += "utf8=%E2%9C%93&";
      }
    }
    return joined.length > 0 ? prefix + joined : "";
  }
  const VERSION$2 = "4.82.0";
  let auto$2 = false;
  let kind$2 = void 0;
  let fetch$4 = void 0;
  let FormData$2 = void 0;
  let File$3 = void 0;
  let ReadableStream$3 = void 0;
  let getMultipartRequestOptions$1 = void 0;
  let getDefaultAgent$2 = void 0;
  let fileFromPath$2 = void 0;
  let isFsReadStream$1 = void 0;
  function setShims$2(shims, options = { auto: false }) {
    if (auto$2) {
      throw new Error(`you must \`import 'openai/shims/${shims.kind}'\` before importing anything else from openai`);
    }
    if (kind$2) {
      throw new Error(`can't \`import 'openai/shims/${shims.kind}'\` after \`import 'openai/shims/${kind$2}'\``);
    }
    auto$2 = options.auto;
    kind$2 = shims.kind;
    fetch$4 = shims.fetch;
    FormData$2 = shims.FormData;
    File$3 = shims.File;
    ReadableStream$3 = shims.ReadableStream;
    getMultipartRequestOptions$1 = shims.getMultipartRequestOptions;
    getDefaultAgent$2 = shims.getDefaultAgent;
    fileFromPath$2 = shims.fileFromPath;
    isFsReadStream$1 = shims.isFsReadStream;
  }
  let MultipartBody$2 = class MultipartBody {
    constructor(body) {
      this.body = body;
    }
    get [Symbol.toStringTag]() {
      return "MultipartBody";
    }
  };
  function getRuntime$2({ manuallyImported } = {}) {
    const recommendation = manuallyImported ? `You may need to use polyfills` : `Add one of these imports before your first \`import … from 'openai'\`:
- \`import 'openai/shims/node'\` (if you're running on Node)
- \`import 'openai/shims/web'\` (otherwise)
`;
    let _fetch, _Request, _Response, _Headers;
    try {
      _fetch = fetch;
      _Request = Request;
      _Response = Response;
      _Headers = Headers;
    } catch (error) {
      throw new Error(`this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`);
    }
    return {
      kind: "web",
      fetch: _fetch,
      Request: _Request,
      Response: _Response,
      Headers: _Headers,
      FormData: (
        // @ts-ignore
        typeof FormData !== "undefined" ? FormData : class FormData {
          // @ts-ignore
          constructor() {
            throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);
          }
        }
      ),
      Blob: typeof Blob !== "undefined" ? Blob : class Blob {
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);
        }
      },
      File: (
        // @ts-ignore
        typeof File !== "undefined" ? File : class File {
          // @ts-ignore
          constructor() {
            throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);
          }
        }
      ),
      ReadableStream: (
        // @ts-ignore
        typeof ReadableStream !== "undefined" ? ReadableStream : class ReadableStream {
          // @ts-ignore
          constructor() {
            throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`);
          }
        }
      ),
      getMultipartRequestOptions: async (form, opts) => ({
        ...opts,
        body: new MultipartBody$2(form)
      }),
      getDefaultAgent: (url) => void 0,
      fileFromPath: () => {
        throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads");
      },
      isFsReadStream: (value) => false
    };
  }
  if (!kind$2) setShims$2(getRuntime$2(), { auto: true });
  let OpenAIError$1 = class OpenAIError extends Error {
  };
  let APIError$2 = class APIError2 extends OpenAIError$1 {
    constructor(status, error, message, headers) {
      super(`${APIError2.makeMessage(status, error, message)}`);
      this.status = status;
      this.headers = headers;
      this.request_id = headers == null ? void 0 : headers["x-request-id"];
      this.error = error;
      const data = error;
      this.code = data == null ? void 0 : data["code"];
      this.param = data == null ? void 0 : data["param"];
      this.type = data == null ? void 0 : data["type"];
    }
    static makeMessage(status, error, message) {
      const msg = (error == null ? void 0 : error.message) ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
      if (status && msg) {
        return `${status} ${msg}`;
      }
      if (status) {
        return `${status} status code (no body)`;
      }
      if (msg) {
        return msg;
      }
      return "(no status code or body)";
    }
    static generate(status, errorResponse, message, headers) {
      if (!status || !headers) {
        return new APIConnectionError$2({ message, cause: castToError$2(errorResponse) });
      }
      const error = errorResponse == null ? void 0 : errorResponse["error"];
      if (status === 400) {
        return new BadRequestError$2(status, error, message, headers);
      }
      if (status === 401) {
        return new AuthenticationError$2(status, error, message, headers);
      }
      if (status === 403) {
        return new PermissionDeniedError$2(status, error, message, headers);
      }
      if (status === 404) {
        return new NotFoundError$2(status, error, message, headers);
      }
      if (status === 409) {
        return new ConflictError$2(status, error, message, headers);
      }
      if (status === 422) {
        return new UnprocessableEntityError$2(status, error, message, headers);
      }
      if (status === 429) {
        return new RateLimitError$2(status, error, message, headers);
      }
      if (status >= 500) {
        return new InternalServerError$2(status, error, message, headers);
      }
      return new APIError2(status, error, message, headers);
    }
  };
  let APIUserAbortError$2 = class APIUserAbortError extends APIError$2 {
    constructor({ message } = {}) {
      super(void 0, void 0, message || "Request was aborted.", void 0);
    }
  };
  let APIConnectionError$2 = class APIConnectionError extends APIError$2 {
    constructor({ message, cause }) {
      super(void 0, void 0, message || "Connection error.", void 0);
      if (cause)
        this.cause = cause;
    }
  };
  let APIConnectionTimeoutError$2 = class APIConnectionTimeoutError extends APIConnectionError$2 {
    constructor({ message } = {}) {
      super({ message: message ?? "Request timed out." });
    }
  };
  let BadRequestError$2 = class BadRequestError extends APIError$2 {
  };
  let AuthenticationError$2 = class AuthenticationError extends APIError$2 {
  };
  let PermissionDeniedError$2 = class PermissionDeniedError extends APIError$2 {
  };
  let NotFoundError$2 = class NotFoundError extends APIError$2 {
  };
  let ConflictError$2 = class ConflictError extends APIError$2 {
  };
  let UnprocessableEntityError$2 = class UnprocessableEntityError extends APIError$2 {
  };
  let RateLimitError$2 = class RateLimitError extends APIError$2 {
  };
  let InternalServerError$2 = class InternalServerError extends APIError$2 {
  };
  let LengthFinishReasonError$1 = class LengthFinishReasonError extends OpenAIError$1 {
    constructor() {
      super(`Could not parse response content as the length limit was reached`);
    }
  };
  let ContentFilterFinishReasonError$1 = class ContentFilterFinishReasonError extends OpenAIError$1 {
    constructor() {
      super(`Could not parse response content as the request was rejected by the content filter`);
    }
  };
  let LineDecoder$2 = class LineDecoder2 {
    constructor() {
      this.buffer = [];
      this.trailingCR = false;
    }
    decode(chunk) {
      let text = this.decodeText(chunk);
      if (this.trailingCR) {
        text = "\r" + text;
        this.trailingCR = false;
      }
      if (text.endsWith("\r")) {
        this.trailingCR = true;
        text = text.slice(0, -1);
      }
      if (!text) {
        return [];
      }
      const trailingNewline = LineDecoder2.NEWLINE_CHARS.has(text[text.length - 1] || "");
      let lines = text.split(LineDecoder2.NEWLINE_REGEXP);
      if (trailingNewline) {
        lines.pop();
      }
      if (lines.length === 1 && !trailingNewline) {
        this.buffer.push(lines[0]);
        return [];
      }
      if (this.buffer.length > 0) {
        lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
        this.buffer = [];
      }
      if (!trailingNewline) {
        this.buffer = [lines.pop() || ""];
      }
      return lines;
    }
    decodeText(bytes) {
      if (bytes == null)
        return "";
      if (typeof bytes === "string")
        return bytes;
      if (typeof Buffer !== "undefined") {
        if (bytes instanceof Buffer) {
          return bytes.toString();
        }
        if (bytes instanceof Uint8Array) {
          return Buffer.from(bytes).toString();
        }
        throw new OpenAIError$1(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
      }
      if (typeof TextDecoder !== "undefined") {
        if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
          this.textDecoder ?? (this.textDecoder = new TextDecoder("utf8"));
          return this.textDecoder.decode(bytes);
        }
        throw new OpenAIError$1(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
      }
      throw new OpenAIError$1(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
    }
    flush() {
      if (!this.buffer.length && !this.trailingCR) {
        return [];
      }
      const lines = [this.buffer.join("")];
      this.buffer = [];
      this.trailingCR = false;
      return lines;
    }
  };
  LineDecoder$2.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
  LineDecoder$2.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
  function ReadableStreamToAsyncIterable$1(stream) {
    if (stream[Symbol.asyncIterator])
      return stream;
    const reader = stream.getReader();
    return {
      async next() {
        try {
          const result = await reader.read();
          if (result == null ? void 0 : result.done)
            reader.releaseLock();
          return result;
        } catch (e) {
          reader.releaseLock();
          throw e;
        }
      },
      async return() {
        const cancelPromise = reader.cancel();
        reader.releaseLock();
        await cancelPromise;
        return { done: true, value: void 0 };
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  let Stream$2 = class Stream2 {
    constructor(iterator2, controller) {
      this.iterator = iterator2;
      this.controller = controller;
    }
    static fromSSEResponse(response, controller) {
      let consumed2 = false;
      async function* iterator2() {
        if (consumed2) {
          throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
        }
        consumed2 = true;
        let done = false;
        try {
          for await (const sse of _iterSSEMessages$2(response, controller)) {
            if (done)
              continue;
            if (sse.data.startsWith("[DONE]")) {
              done = true;
              continue;
            }
            if (sse.event === null) {
              let data;
              try {
                data = JSON.parse(sse.data);
              } catch (e) {
                console.error(`Could not parse message into JSON:`, sse.data);
                console.error(`From chunk:`, sse.raw);
                throw e;
              }
              if (data && data.error) {
                throw new APIError$2(void 0, data.error, void 0, void 0);
              }
              yield data;
            } else {
              let data;
              try {
                data = JSON.parse(sse.data);
              } catch (e) {
                console.error(`Could not parse message into JSON:`, sse.data);
                console.error(`From chunk:`, sse.raw);
                throw e;
              }
              if (sse.event == "error") {
                throw new APIError$2(void 0, data.error, data.message, void 0);
              }
              yield { event: sse.event, data };
            }
          }
          done = true;
        } catch (e) {
          if (e instanceof Error && e.name === "AbortError")
            return;
          throw e;
        } finally {
          if (!done)
            controller.abort();
        }
      }
      return new Stream2(iterator2, controller);
    }
    /**
     * Generates a Stream from a newline-separated ReadableStream
     * where each item is a JSON value.
     */
    static fromReadableStream(readableStream, controller) {
      let consumed2 = false;
      async function* iterLines() {
        const lineDecoder = new LineDecoder$2();
        const iter = ReadableStreamToAsyncIterable$1(readableStream);
        for await (const chunk of iter) {
          for (const line of lineDecoder.decode(chunk)) {
            yield line;
          }
        }
        for (const line of lineDecoder.flush()) {
          yield line;
        }
      }
      async function* iterator2() {
        if (consumed2) {
          throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
        }
        consumed2 = true;
        let done = false;
        try {
          for await (const line of iterLines()) {
            if (done)
              continue;
            if (line)
              yield JSON.parse(line);
          }
          done = true;
        } catch (e) {
          if (e instanceof Error && e.name === "AbortError")
            return;
          throw e;
        } finally {
          if (!done)
            controller.abort();
        }
      }
      return new Stream2(iterator2, controller);
    }
    [Symbol.asyncIterator]() {
      return this.iterator();
    }
    /**
     * Splits the stream into two streams which can be
     * independently read from at different speeds.
     */
    tee() {
      const left = [];
      const right = [];
      const iterator2 = this.iterator();
      const teeIterator = (queue2) => {
        return {
          next: () => {
            if (queue2.length === 0) {
              const result = iterator2.next();
              left.push(result);
              right.push(result);
            }
            return queue2.shift();
          }
        };
      };
      return [
        new Stream2(() => teeIterator(left), this.controller),
        new Stream2(() => teeIterator(right), this.controller)
      ];
    }
    /**
     * Converts this stream to a newline-separated ReadableStream of
     * JSON stringified values in the stream
     * which can be turned back into a Stream with `Stream.fromReadableStream()`.
     */
    toReadableStream() {
      const self2 = this;
      let iter;
      const encoder = new TextEncoder();
      return new ReadableStream$3({
        async start() {
          iter = self2[Symbol.asyncIterator]();
        },
        async pull(ctrl) {
          try {
            const { value, done } = await iter.next();
            if (done)
              return ctrl.close();
            const bytes = encoder.encode(JSON.stringify(value) + "\n");
            ctrl.enqueue(bytes);
          } catch (err) {
            ctrl.error(err);
          }
        },
        async cancel() {
          var _a3;
          await ((_a3 = iter.return) == null ? void 0 : _a3.call(iter));
        }
      });
    }
  };
  async function* _iterSSEMessages$2(response, controller) {
    if (!response.body) {
      controller.abort();
      throw new OpenAIError$1(`Attempted to iterate over a response with no body`);
    }
    const sseDecoder = new SSEDecoder$2();
    const lineDecoder = new LineDecoder$2();
    const iter = ReadableStreamToAsyncIterable$1(response.body);
    for await (const sseChunk of iterSSEChunks$2(iter)) {
      for (const line of lineDecoder.decode(sseChunk)) {
        const sse = sseDecoder.decode(line);
        if (sse)
          yield sse;
      }
    }
    for (const line of lineDecoder.flush()) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  async function* iterSSEChunks$2(iterator2) {
    let data = new Uint8Array();
    for await (const chunk of iterator2) {
      if (chunk == null) {
        continue;
      }
      const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
      let newData = new Uint8Array(data.length + binaryChunk.length);
      newData.set(data);
      newData.set(binaryChunk, data.length);
      data = newData;
      let patternIndex;
      while ((patternIndex = findDoubleNewlineIndex$2(data)) !== -1) {
        yield data.slice(0, patternIndex);
        data = data.slice(patternIndex);
      }
    }
    if (data.length > 0) {
      yield data;
    }
  }
  function findDoubleNewlineIndex$2(buffer) {
    const newline = 10;
    const carriage = 13;
    for (let i2 = 0; i2 < buffer.length - 2; i2++) {
      if (buffer[i2] === newline && buffer[i2 + 1] === newline) {
        return i2 + 2;
      }
      if (buffer[i2] === carriage && buffer[i2 + 1] === carriage) {
        return i2 + 2;
      }
      if (buffer[i2] === carriage && buffer[i2 + 1] === newline && i2 + 3 < buffer.length && buffer[i2 + 2] === carriage && buffer[i2 + 3] === newline) {
        return i2 + 4;
      }
    }
    return -1;
  }
  let SSEDecoder$2 = class SSEDecoder {
    constructor() {
      this.event = null;
      this.data = [];
      this.chunks = [];
    }
    decode(line) {
      if (line.endsWith("\r")) {
        line = line.substring(0, line.length - 1);
      }
      if (!line) {
        if (!this.event && !this.data.length)
          return null;
        const sse = {
          event: this.event,
          data: this.data.join("\n"),
          raw: this.chunks
        };
        this.event = null;
        this.data = [];
        this.chunks = [];
        return sse;
      }
      this.chunks.push(line);
      if (line.startsWith(":")) {
        return null;
      }
      let [fieldname, _, value] = partition$2(line, ":");
      if (value.startsWith(" ")) {
        value = value.substring(1);
      }
      if (fieldname === "event") {
        this.event = value;
      } else if (fieldname === "data") {
        this.data.push(value);
      }
      return null;
    }
  };
  function partition$2(str2, delimiter) {
    const index = str2.indexOf(delimiter);
    if (index !== -1) {
      return [str2.substring(0, index), delimiter, str2.substring(index + delimiter.length)];
    }
    return [str2, "", ""];
  }
  const isResponseLike$2 = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
  const isFileLike$2 = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike$2(value);
  const isBlobLike$2 = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
  const isUploadable$1 = (value) => {
    return isFileLike$2(value) || isResponseLike$2(value) || isFsReadStream$1(value);
  };
  async function toFile$2(value, name, options) {
    var _a3;
    value = await value;
    if (isFileLike$2(value)) {
      return value;
    }
    if (isResponseLike$2(value)) {
      const blob = await value.blob();
      name || (name = new URL(value.url).pathname.split(/[\\/]/).pop() ?? "unknown_file");
      const data = isBlobLike$2(blob) ? [await blob.arrayBuffer()] : [blob];
      return new File$3(data, name, options);
    }
    const bits = await getBytes$2(value);
    name || (name = getName$2(value) ?? "unknown_file");
    if (!(options == null ? void 0 : options.type)) {
      const type = (_a3 = bits[0]) == null ? void 0 : _a3.type;
      if (typeof type === "string") {
        options = { ...options, type };
      }
    }
    return new File$3(bits, name, options);
  }
  async function getBytes$2(value) {
    var _a3;
    let parts = [];
    if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
    value instanceof ArrayBuffer) {
      parts.push(value);
    } else if (isBlobLike$2(value)) {
      parts.push(await value.arrayBuffer());
    } else if (isAsyncIterableIterator$2(value)) {
      for await (const chunk of value) {
        parts.push(chunk);
      }
    } else {
      throw new Error(`Unexpected data type: ${typeof value}; constructor: ${(_a3 = value == null ? void 0 : value.constructor) == null ? void 0 : _a3.name}; props: ${propsForError$2(value)}`);
    }
    return parts;
  }
  function propsForError$2(value) {
    const props = Object.getOwnPropertyNames(value);
    return `[${props.map((p) => `"${p}"`).join(", ")}]`;
  }
  function getName$2(value) {
    var _a3;
    return getStringFromMaybeBuffer$2(value.name) || getStringFromMaybeBuffer$2(value.filename) || // For fs.ReadStream
    ((_a3 = getStringFromMaybeBuffer$2(value.path)) == null ? void 0 : _a3.split(/[\\/]/).pop());
  }
  const getStringFromMaybeBuffer$2 = (x) => {
    if (typeof x === "string")
      return x;
    if (typeof Buffer !== "undefined" && x instanceof Buffer)
      return String(x);
    return void 0;
  };
  const isAsyncIterableIterator$2 = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
  const isMultipartBody$2 = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";
  const multipartFormRequestOptions$1 = async (opts) => {
    const form = await createForm$1(opts.body);
    return getMultipartRequestOptions$1(form, opts);
  };
  const createForm$1 = async (body) => {
    const form = new FormData$2();
    await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue$1(form, key, value)));
    return form;
  };
  const addFormValue$1 = async (form, key, value) => {
    if (value === void 0)
      return;
    if (value == null) {
      throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
    }
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      form.append(key, String(value));
    } else if (isUploadable$1(value)) {
      const file = await toFile$2(value);
      form.append(key, file);
    } else if (Array.isArray(value)) {
      await Promise.all(value.map((entry) => addFormValue$1(form, key + "[]", entry)));
    } else if (typeof value === "object") {
      await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue$1(form, `${key}[${name}]`, prop)));
    } else {
      throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
    }
  };
  var __classPrivateFieldSet$a = function(receiver, state, value, kind2, f) {
    if (kind2 === "m") throw new TypeError("Private method is not writable");
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet$c = function(receiver, state, kind2, f) {
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _AbstractPage_client$2;
  async function defaultParseResponse$2(props) {
    const { response } = props;
    if (props.options.stream) {
      debug$2("response", response.status, response.url, response.headers, response.body);
      if (props.options.__streamClass) {
        return props.options.__streamClass.fromSSEResponse(response, props.controller);
      }
      return Stream$2.fromSSEResponse(response, props.controller);
    }
    if (response.status === 204) {
      return null;
    }
    if (props.options.__binaryResponse) {
      return response;
    }
    const contentType = response.headers.get("content-type");
    const isJSON = (contentType == null ? void 0 : contentType.includes("application/json")) || (contentType == null ? void 0 : contentType.includes("application/vnd.api+json"));
    if (isJSON) {
      const json = await response.json();
      debug$2("response", response.status, response.url, response.headers, json);
      return _addRequestID$1(json, response);
    }
    const text = await response.text();
    debug$2("response", response.status, response.url, response.headers, text);
    return text;
  }
  function _addRequestID$1(value, response) {
    if (!value || typeof value !== "object" || Array.isArray(value)) {
      return value;
    }
    return Object.defineProperty(value, "_request_id", {
      value: response.headers.get("x-request-id"),
      enumerable: false
    });
  }
  let APIPromise$2 = class APIPromise2 extends Promise {
    constructor(responsePromise, parseResponse = defaultParseResponse$2) {
      super((resolve) => {
        resolve(null);
      });
      this.responsePromise = responsePromise;
      this.parseResponse = parseResponse;
    }
    _thenUnwrap(transform) {
      return new APIPromise2(this.responsePromise, async (props) => _addRequestID$1(transform(await this.parseResponse(props), props), props.response));
    }
    /**
     * Gets the raw `Response` instance instead of parsing the response
     * data.
     *
     * If you want to parse the response body but still get the `Response`
     * instance, you can use {@link withResponse()}.
     *
     * 👋 Getting the wrong TypeScript type for `Response`?
     * Try setting `"moduleResolution": "NodeNext"` if you can,
     * or add one of these imports before your first `import … from 'openai'`:
     * - `import 'openai/shims/node'` (if you're running on Node)
     * - `import 'openai/shims/web'` (otherwise)
     */
    asResponse() {
      return this.responsePromise.then((p) => p.response);
    }
    /**
     * Gets the parsed response data, the raw `Response` instance and the ID of the request,
     * returned via the X-Request-ID header which is useful for debugging requests and reporting
     * issues to OpenAI.
     *
     * If you just want to get the raw `Response` instance without parsing it,
     * you can use {@link asResponse()}.
     *
     *
     * 👋 Getting the wrong TypeScript type for `Response`?
     * Try setting `"moduleResolution": "NodeNext"` if you can,
     * or add one of these imports before your first `import … from 'openai'`:
     * - `import 'openai/shims/node'` (if you're running on Node)
     * - `import 'openai/shims/web'` (otherwise)
     */
    async withResponse() {
      const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
      return { data, response, request_id: response.headers.get("x-request-id") };
    }
    parse() {
      if (!this.parsedPromise) {
        this.parsedPromise = this.responsePromise.then(this.parseResponse);
      }
      return this.parsedPromise;
    }
    then(onfulfilled, onrejected) {
      return this.parse().then(onfulfilled, onrejected);
    }
    catch(onrejected) {
      return this.parse().catch(onrejected);
    }
    finally(onfinally) {
      return this.parse().finally(onfinally);
    }
  };
  let APIClient$2 = class APIClient {
    constructor({
      baseURL,
      maxRetries = 2,
      timeout: timeout2 = 6e5,
      // 10 minutes
      httpAgent,
      fetch: overriddenFetch
    }) {
      this.baseURL = baseURL;
      this.maxRetries = validatePositiveInteger$2("maxRetries", maxRetries);
      this.timeout = validatePositiveInteger$2("timeout", timeout2);
      this.httpAgent = httpAgent;
      this.fetch = overriddenFetch ?? fetch$4;
    }
    authHeaders(opts) {
      return {};
    }
    /**
     * Override this to add your own default headers, for example:
     *
     *  {
     *    ...super.defaultHeaders(),
     *    Authorization: 'Bearer 123',
     *  }
     */
    defaultHeaders(opts) {
      return {
        Accept: "application/json",
        "Content-Type": "application/json",
        "User-Agent": this.getUserAgent(),
        ...getPlatformHeaders$2(),
        ...this.authHeaders(opts)
      };
    }
    /**
     * Override this to add your own headers validation:
     */
    validateHeaders(headers, customHeaders) {
    }
    defaultIdempotencyKey() {
      return `stainless-node-retry-${uuid4$2()}`;
    }
    get(path, opts) {
      return this.methodRequest("get", path, opts);
    }
    post(path, opts) {
      return this.methodRequest("post", path, opts);
    }
    patch(path, opts) {
      return this.methodRequest("patch", path, opts);
    }
    put(path, opts) {
      return this.methodRequest("put", path, opts);
    }
    delete(path, opts) {
      return this.methodRequest("delete", path, opts);
    }
    methodRequest(method, path, opts) {
      return this.request(Promise.resolve(opts).then(async (opts2) => {
        const body = opts2 && isBlobLike$2(opts2 == null ? void 0 : opts2.body) ? new DataView(await opts2.body.arrayBuffer()) : (opts2 == null ? void 0 : opts2.body) instanceof DataView ? opts2.body : (opts2 == null ? void 0 : opts2.body) instanceof ArrayBuffer ? new DataView(opts2.body) : opts2 && ArrayBuffer.isView(opts2 == null ? void 0 : opts2.body) ? new DataView(opts2.body.buffer) : opts2 == null ? void 0 : opts2.body;
        return { method, path, ...opts2, body };
      }));
    }
    getAPIList(path, Page2, opts) {
      return this.requestAPIList(Page2, { method: "get", path, ...opts });
    }
    calculateContentLength(body) {
      if (typeof body === "string") {
        if (typeof Buffer !== "undefined") {
          return Buffer.byteLength(body, "utf8").toString();
        }
        if (typeof TextEncoder !== "undefined") {
          const encoder = new TextEncoder();
          const encoded = encoder.encode(body);
          return encoded.length.toString();
        }
      } else if (ArrayBuffer.isView(body)) {
        return body.byteLength.toString();
      }
      return null;
    }
    buildRequest(options, { retryCount = 0 } = {}) {
      var _a3;
      const { method, path, query, headers = {} } = options;
      const body = ArrayBuffer.isView(options.body) || options.__binaryRequest && typeof options.body === "string" ? options.body : isMultipartBody$2(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
      const contentLength = this.calculateContentLength(body);
      const url = this.buildURL(path, query);
      if ("timeout" in options)
        validatePositiveInteger$2("timeout", options.timeout);
      const timeout2 = options.timeout ?? this.timeout;
      const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent$2(url);
      const minAgentTimeout = timeout2 + 1e3;
      if (typeof ((_a3 = httpAgent == null ? void 0 : httpAgent.options) == null ? void 0 : _a3.timeout) === "number" && minAgentTimeout > (httpAgent.options.timeout ?? 0)) {
        httpAgent.options.timeout = minAgentTimeout;
      }
      if (this.idempotencyHeader && method !== "get") {
        if (!options.idempotencyKey)
          options.idempotencyKey = this.defaultIdempotencyKey();
        headers[this.idempotencyHeader] = options.idempotencyKey;
      }
      const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });
      const req = {
        method,
        ...body && { body },
        headers: reqHeaders,
        ...httpAgent && { agent: httpAgent },
        // @ts-ignore node-fetch uses a custom AbortSignal type that is
        // not compatible with standard web types
        signal: options.signal ?? null
      };
      return { req, url, timeout: timeout2 };
    }
    buildHeaders({ options, headers, contentLength, retryCount }) {
      const reqHeaders = {};
      if (contentLength) {
        reqHeaders["content-length"] = contentLength;
      }
      const defaultHeaders = this.defaultHeaders(options);
      applyHeadersMut$2(reqHeaders, defaultHeaders);
      applyHeadersMut$2(reqHeaders, headers);
      if (isMultipartBody$2(options.body) && kind$2 !== "node") {
        delete reqHeaders["content-type"];
      }
      if (getHeader$2(defaultHeaders, "x-stainless-retry-count") === void 0 && getHeader$2(headers, "x-stainless-retry-count") === void 0) {
        reqHeaders["x-stainless-retry-count"] = String(retryCount);
      }
      this.validateHeaders(reqHeaders, headers);
      return reqHeaders;
    }
    /**
     * Used as a callback for mutating the given `FinalRequestOptions` object.
     */
    async prepareOptions(options) {
    }
    /**
     * Used as a callback for mutating the given `RequestInit` object.
     *
     * This is useful for cases where you want to add certain headers based off of
     * the request properties, e.g. `method` or `url`.
     */
    async prepareRequest(request, { url, options }) {
    }
    parseHeaders(headers) {
      return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
    }
    makeStatusError(status, error, message, headers) {
      return APIError$2.generate(status, error, message, headers);
    }
    request(options, remainingRetries = null) {
      return new APIPromise$2(this.makeRequest(options, remainingRetries));
    }
    async makeRequest(optionsInput, retriesRemaining) {
      var _a3, _b2;
      const options = await optionsInput;
      const maxRetries = options.maxRetries ?? this.maxRetries;
      if (retriesRemaining == null) {
        retriesRemaining = maxRetries;
      }
      await this.prepareOptions(options);
      const { req, url, timeout: timeout2 } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });
      await this.prepareRequest(req, { url, options });
      debug$2("request", url, options, req.headers);
      if ((_a3 = options.signal) == null ? void 0 : _a3.aborted) {
        throw new APIUserAbortError$2();
      }
      const controller = new AbortController();
      const response = await this.fetchWithTimeout(url, req, timeout2, controller).catch(castToError$2);
      if (response instanceof Error) {
        if ((_b2 = options.signal) == null ? void 0 : _b2.aborted) {
          throw new APIUserAbortError$2();
        }
        if (retriesRemaining) {
          return this.retryRequest(options, retriesRemaining);
        }
        if (response.name === "AbortError") {
          throw new APIConnectionTimeoutError$2();
        }
        throw new APIConnectionError$2({ cause: response });
      }
      const responseHeaders = createResponseHeaders$2(response.headers);
      if (!response.ok) {
        if (retriesRemaining && this.shouldRetry(response)) {
          const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
          debug$2(`response (error; ${retryMessage2})`, response.status, url, responseHeaders);
          return this.retryRequest(options, retriesRemaining, responseHeaders);
        }
        const errText = await response.text().catch((e) => castToError$2(e).message);
        const errJSON = safeJSON$2(errText);
        const errMessage = errJSON ? void 0 : errText;
        const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;
        debug$2(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);
        const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
        throw err;
      }
      return { response, options, controller };
    }
    requestAPIList(Page2, options) {
      const request = this.makeRequest(options, null);
      return new PagePromise$2(this, request, Page2);
    }
    buildURL(path, query) {
      const url = isAbsoluteURL$2(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path.startsWith("/") ? path.slice(1) : path));
      const defaultQuery = this.defaultQuery();
      if (!isEmptyObj$4(defaultQuery)) {
        query = { ...defaultQuery, ...query };
      }
      if (typeof query === "object" && query && !Array.isArray(query)) {
        url.search = this.stringifyQuery(query);
      }
      return url.toString();
    }
    stringifyQuery(query) {
      return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
        if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
          return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
        }
        if (value === null) {
          return `${encodeURIComponent(key)}=`;
        }
        throw new OpenAIError$1(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
      }).join("&");
    }
    async fetchWithTimeout(url, init, ms2, controller) {
      const { signal, ...options } = init || {};
      if (signal)
        signal.addEventListener("abort", () => controller.abort());
      const timeout2 = setTimeout(() => controller.abort(), ms2);
      const fetchOptions = {
        signal: controller.signal,
        ...options
      };
      if (fetchOptions.method) {
        fetchOptions.method = fetchOptions.method.toUpperCase();
      }
      return (
        // use undefined this binding; fetch errors if bound to something else in browser/cloudflare
        this.fetch.call(void 0, url, fetchOptions).finally(() => {
          clearTimeout(timeout2);
        })
      );
    }
    shouldRetry(response) {
      const shouldRetryHeader = response.headers.get("x-should-retry");
      if (shouldRetryHeader === "true")
        return true;
      if (shouldRetryHeader === "false")
        return false;
      if (response.status === 408)
        return true;
      if (response.status === 409)
        return true;
      if (response.status === 429)
        return true;
      if (response.status >= 500)
        return true;
      return false;
    }
    async retryRequest(options, retriesRemaining, responseHeaders) {
      let timeoutMillis;
      const retryAfterMillisHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after-ms"];
      if (retryAfterMillisHeader) {
        const timeoutMs = parseFloat(retryAfterMillisHeader);
        if (!Number.isNaN(timeoutMs)) {
          timeoutMillis = timeoutMs;
        }
      }
      const retryAfterHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after"];
      if (retryAfterHeader && !timeoutMillis) {
        const timeoutSeconds = parseFloat(retryAfterHeader);
        if (!Number.isNaN(timeoutSeconds)) {
          timeoutMillis = timeoutSeconds * 1e3;
        } else {
          timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
        }
      }
      if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
        const maxRetries = options.maxRetries ?? this.maxRetries;
        timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
      }
      await sleep$2(timeoutMillis);
      return this.makeRequest(options, retriesRemaining - 1);
    }
    calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
      const initialRetryDelay = 0.5;
      const maxRetryDelay = 8;
      const numRetries = maxRetries - retriesRemaining;
      const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
      const jitter = 1 - Math.random() * 0.25;
      return sleepSeconds * jitter * 1e3;
    }
    getUserAgent() {
      return `${this.constructor.name}/JS ${VERSION$2}`;
    }
  };
  let AbstractPage$2 = class AbstractPage {
    constructor(client2, response, body, options) {
      _AbstractPage_client$2.set(this, void 0);
      __classPrivateFieldSet$a(this, _AbstractPage_client$2, client2, "f");
      this.options = options;
      this.response = response;
      this.body = body;
    }
    hasNextPage() {
      const items = this.getPaginatedItems();
      if (!items.length)
        return false;
      return this.nextPageInfo() != null;
    }
    async getNextPage() {
      const nextInfo = this.nextPageInfo();
      if (!nextInfo) {
        throw new OpenAIError$1("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
      }
      const nextOptions = { ...this.options };
      if ("params" in nextInfo && typeof nextOptions.query === "object") {
        nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
      } else if ("url" in nextInfo) {
        const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
        for (const [key, value] of params) {
          nextInfo.url.searchParams.set(key, value);
        }
        nextOptions.query = void 0;
        nextOptions.path = nextInfo.url.toString();
      }
      return await __classPrivateFieldGet$c(this, _AbstractPage_client$2, "f").requestAPIList(this.constructor, nextOptions);
    }
    async *iterPages() {
      let page = this;
      yield page;
      while (page.hasNextPage()) {
        page = await page.getNextPage();
        yield page;
      }
    }
    async *[(_AbstractPage_client$2 = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
      for await (const page of this.iterPages()) {
        for (const item of page.getPaginatedItems()) {
          yield item;
        }
      }
    }
  };
  let PagePromise$2 = class PagePromise extends APIPromise$2 {
    constructor(client2, request, Page2) {
      super(request, async (props) => new Page2(client2, props.response, await defaultParseResponse$2(props), props.options));
    }
    /**
     * Allow auto-paginating iteration on an unawaited list call, eg:
     *
     *    for await (const item of client.items.list()) {
     *      console.log(item)
     *    }
     */
    async *[Symbol.asyncIterator]() {
      const page = await this;
      for await (const item of page) {
        yield item;
      }
    }
  };
  const createResponseHeaders$2 = (headers) => {
    return new Proxy(Object.fromEntries(
      // @ts-ignore
      headers.entries()
    ), {
      get(target, name) {
        const key = name.toString();
        return target[key.toLowerCase()] || target[key];
      }
    });
  };
  const requestOptionsKeys$2 = {
    method: true,
    path: true,
    query: true,
    body: true,
    headers: true,
    maxRetries: true,
    stream: true,
    timeout: true,
    httpAgent: true,
    signal: true,
    idempotencyKey: true,
    __binaryRequest: true,
    __binaryResponse: true,
    __streamClass: true
  };
  const isRequestOptions$2 = (obj) => {
    return typeof obj === "object" && obj !== null && !isEmptyObj$4(obj) && Object.keys(obj).every((k) => hasOwn$2(requestOptionsKeys$2, k));
  };
  const getPlatformProperties$2 = () => {
    var _a3;
    if (typeof Deno !== "undefined" && Deno.build != null) {
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION$2,
        "X-Stainless-OS": normalizePlatform$2(Deno.build.os),
        "X-Stainless-Arch": normalizeArch$2(Deno.build.arch),
        "X-Stainless-Runtime": "deno",
        "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : ((_a3 = Deno.version) == null ? void 0 : _a3.deno) ?? "unknown"
      };
    }
    if (typeof EdgeRuntime !== "undefined") {
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION$2,
        "X-Stainless-OS": "Unknown",
        "X-Stainless-Arch": `other:${EdgeRuntime}`,
        "X-Stainless-Runtime": "edge",
        "X-Stainless-Runtime-Version": process.version
      };
    }
    if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION$2,
        "X-Stainless-OS": normalizePlatform$2(process.platform),
        "X-Stainless-Arch": normalizeArch$2(process.arch),
        "X-Stainless-Runtime": "node",
        "X-Stainless-Runtime-Version": process.version
      };
    }
    const browserInfo = getBrowserInfo$2();
    if (browserInfo) {
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION$2,
        "X-Stainless-OS": "Unknown",
        "X-Stainless-Arch": "unknown",
        "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
        "X-Stainless-Runtime-Version": browserInfo.version
      };
    }
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION$2,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": "unknown",
      "X-Stainless-Runtime-Version": "unknown"
    };
  };
  function getBrowserInfo$2() {
    if (typeof navigator === "undefined" || !navigator) {
      return null;
    }
    const browserPatterns = [
      { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
    ];
    for (const { key, pattern } of browserPatterns) {
      const match = pattern.exec(navigator.userAgent);
      if (match) {
        const major = match[1] || 0;
        const minor = match[2] || 0;
        const patch = match[3] || 0;
        return { browser: key, version: `${major}.${minor}.${patch}` };
      }
    }
    return null;
  }
  const normalizeArch$2 = (arch) => {
    if (arch === "x32")
      return "x32";
    if (arch === "x86_64" || arch === "x64")
      return "x64";
    if (arch === "arm")
      return "arm";
    if (arch === "aarch64" || arch === "arm64")
      return "arm64";
    if (arch)
      return `other:${arch}`;
    return "unknown";
  };
  const normalizePlatform$2 = (platform) => {
    platform = platform.toLowerCase();
    if (platform.includes("ios"))
      return "iOS";
    if (platform === "android")
      return "Android";
    if (platform === "darwin")
      return "MacOS";
    if (platform === "win32")
      return "Windows";
    if (platform === "freebsd")
      return "FreeBSD";
    if (platform === "openbsd")
      return "OpenBSD";
    if (platform === "linux")
      return "Linux";
    if (platform)
      return `Other:${platform}`;
    return "Unknown";
  };
  let _platformHeaders$2;
  const getPlatformHeaders$2 = () => {
    return _platformHeaders$2 ?? (_platformHeaders$2 = getPlatformProperties$2());
  };
  const safeJSON$2 = (text) => {
    try {
      return JSON.parse(text);
    } catch (err) {
      return void 0;
    }
  };
  const startsWithSchemeRegexp$2 = /^[a-z][a-z0-9+.-]*:/i;
  const isAbsoluteURL$2 = (url) => {
    return startsWithSchemeRegexp$2.test(url);
  };
  const sleep$2 = (ms2) => new Promise((resolve) => setTimeout(resolve, ms2));
  const validatePositiveInteger$2 = (name, n) => {
    if (typeof n !== "number" || !Number.isInteger(n)) {
      throw new OpenAIError$1(`${name} must be an integer`);
    }
    if (n < 0) {
      throw new OpenAIError$1(`${name} must be a positive integer`);
    }
    return n;
  };
  const castToError$2 = (err) => {
    if (err instanceof Error)
      return err;
    if (typeof err === "object" && err !== null) {
      try {
        return new Error(JSON.stringify(err));
      } catch {
      }
    }
    return new Error(err);
  };
  const readEnv$2 = (env) => {
    var _a3, _b2, _c2, _d2, _e2;
    if (typeof process !== "undefined") {
      return ((_b2 = (_a3 = process.env) == null ? void 0 : _a3[env]) == null ? void 0 : _b2.trim()) ?? void 0;
    }
    if (typeof Deno !== "undefined") {
      return (_e2 = (_d2 = (_c2 = Deno.env) == null ? void 0 : _c2.get) == null ? void 0 : _d2.call(_c2, env)) == null ? void 0 : _e2.trim();
    }
    return void 0;
  };
  function isEmptyObj$4(obj) {
    if (!obj)
      return true;
    for (const _k2 in obj)
      return false;
    return true;
  }
  function hasOwn$2(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  function applyHeadersMut$2(targetHeaders, newHeaders) {
    for (const k in newHeaders) {
      if (!hasOwn$2(newHeaders, k))
        continue;
      const lowerKey = k.toLowerCase();
      if (!lowerKey)
        continue;
      const val = newHeaders[k];
      if (val === null) {
        delete targetHeaders[lowerKey];
      } else if (val !== void 0) {
        targetHeaders[lowerKey] = val;
      }
    }
  }
  const SENSITIVE_HEADERS$1 = /* @__PURE__ */ new Set(["authorization", "api-key"]);
  function debug$2(action, ...args) {
    var _a3;
    if (typeof process !== "undefined" && ((_a3 = process == null ? void 0 : process.env) == null ? void 0 : _a3["DEBUG"]) === "true") {
      const modifiedArgs = args.map((arg) => {
        if (!arg) {
          return arg;
        }
        if (arg["headers"]) {
          const modifiedArg2 = { ...arg, headers: { ...arg["headers"] } };
          for (const header in arg["headers"]) {
            if (SENSITIVE_HEADERS$1.has(header.toLowerCase())) {
              modifiedArg2["headers"][header] = "REDACTED";
            }
          }
          return modifiedArg2;
        }
        let modifiedArg = null;
        for (const header in arg) {
          if (SENSITIVE_HEADERS$1.has(header.toLowerCase())) {
            modifiedArg ?? (modifiedArg = { ...arg });
            modifiedArg[header] = "REDACTED";
          }
        }
        return modifiedArg ?? arg;
      });
      console.log(`OpenAI:DEBUG:${action}`, ...modifiedArgs);
    }
  }
  const uuid4$2 = () => {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  };
  const isRunningInBrowser$2 = () => {
    return (
      // @ts-ignore
      typeof window !== "undefined" && // @ts-ignore
      typeof window.document !== "undefined" && // @ts-ignore
      typeof navigator !== "undefined"
    );
  };
  const isHeadersProtocol$2 = (headers) => {
    return typeof (headers == null ? void 0 : headers.get) === "function";
  };
  const getHeader$2 = (headers, header) => {
    var _a3;
    const lowerCasedHeader = header.toLowerCase();
    if (isHeadersProtocol$2(headers)) {
      const intercapsHeader = ((_a3 = header[0]) == null ? void 0 : _a3.toUpperCase()) + header.substring(1).replace(/([^\w])(\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());
      for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {
        const value = headers.get(key);
        if (value) {
          return value;
        }
      }
    }
    for (const [key, value] of Object.entries(headers)) {
      if (key.toLowerCase() === lowerCasedHeader) {
        if (Array.isArray(value)) {
          if (value.length <= 1)
            return value[0];
          console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);
          return value[0];
        }
        return value;
      }
    }
    return void 0;
  };
  function isObj$1(obj) {
    return obj != null && typeof obj === "object" && !Array.isArray(obj);
  }
  let Page$2 = class Page extends AbstractPage$2 {
    constructor(client2, response, body, options) {
      super(client2, response, body, options);
      this.data = body.data || [];
      this.object = body.object;
    }
    getPaginatedItems() {
      return this.data ?? [];
    }
    // @deprecated Please use `nextPageInfo()` instead
    /**
     * This page represents a response that isn't actually paginated at the API level
     * so there will never be any next page params.
     */
    nextPageParams() {
      return null;
    }
    nextPageInfo() {
      return null;
    }
  };
  let CursorPage$1 = class CursorPage extends AbstractPage$2 {
    constructor(client2, response, body, options) {
      super(client2, response, body, options);
      this.data = body.data || [];
    }
    getPaginatedItems() {
      return this.data ?? [];
    }
    // @deprecated Please use `nextPageInfo()` instead
    nextPageParams() {
      const info = this.nextPageInfo();
      if (!info)
        return null;
      if ("params" in info)
        return info.params;
      const params = Object.fromEntries(info.url.searchParams);
      if (!Object.keys(params).length)
        return null;
      return params;
    }
    nextPageInfo() {
      var _a3;
      const data = this.getPaginatedItems();
      if (!data.length) {
        return null;
      }
      const id = (_a3 = data[data.length - 1]) == null ? void 0 : _a3.id;
      if (!id) {
        return null;
      }
      return { params: { after: id } };
    }
  };
  let APIResource$2 = class APIResource {
    constructor(client2) {
      this._client = client2;
    }
  };
  let Completions$6 = class Completions extends APIResource$2 {
    create(body, options) {
      return this._client.post("/chat/completions", { body, ...options, stream: body.stream ?? false });
    }
  };
  let Chat$3 = class Chat extends APIResource$2 {
    constructor() {
      super(...arguments);
      this.completions = new Completions$6(this._client);
    }
  };
  Chat$3.Completions = Completions$6;
  let Speech$1 = class Speech extends APIResource$2 {
    /**
     * Generates audio from the input text.
     */
    create(body, options) {
      return this._client.post("/audio/speech", {
        body,
        ...options,
        headers: { Accept: "application/octet-stream", ...options == null ? void 0 : options.headers },
        __binaryResponse: true
      });
    }
  };
  let Transcriptions$1 = class Transcriptions extends APIResource$2 {
    create(body, options) {
      return this._client.post("/audio/transcriptions", multipartFormRequestOptions$1({ body, ...options }));
    }
  };
  let Translations$1 = class Translations extends APIResource$2 {
    create(body, options) {
      return this._client.post("/audio/translations", multipartFormRequestOptions$1({ body, ...options }));
    }
  };
  let Audio$1 = class Audio extends APIResource$2 {
    constructor() {
      super(...arguments);
      this.transcriptions = new Transcriptions$1(this._client);
      this.translations = new Translations$1(this._client);
      this.speech = new Speech$1(this._client);
    }
  };
  Audio$1.Transcriptions = Transcriptions$1;
  Audio$1.Translations = Translations$1;
  Audio$1.Speech = Speech$1;
  let Batches$2 = class Batches extends APIResource$2 {
    /**
     * Creates and executes a batch from an uploaded file of requests
     */
    create(body, options) {
      return this._client.post("/batches", { body, ...options });
    }
    /**
     * Retrieves a batch.
     */
    retrieve(batchId, options) {
      return this._client.get(`/batches/${batchId}`, options);
    }
    list(query = {}, options) {
      if (isRequestOptions$2(query)) {
        return this.list({}, query);
      }
      return this._client.getAPIList("/batches", BatchesPage$1, { query, ...options });
    }
    /**
     * Cancels an in-progress batch. The batch will be in status `cancelling` for up to
     * 10 minutes, before changing to `cancelled`, where it will have partial results
     * (if any) available in the output file.
     */
    cancel(batchId, options) {
      return this._client.post(`/batches/${batchId}/cancel`, options);
    }
  };
  let BatchesPage$1 = class BatchesPage extends CursorPage$1 {
  };
  Batches$2.BatchesPage = BatchesPage$1;
  let Assistants$1 = class Assistants extends APIResource$2 {
    /**
     * Create an assistant with a model and instructions.
     */
    create(body, options) {
      return this._client.post("/assistants", {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Retrieves an assistant.
     */
    retrieve(assistantId, options) {
      return this._client.get(`/assistants/${assistantId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Modifies an assistant.
     */
    update(assistantId, body, options) {
      return this._client.post(`/assistants/${assistantId}`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    list(query = {}, options) {
      if (isRequestOptions$2(query)) {
        return this.list({}, query);
      }
      return this._client.getAPIList("/assistants", AssistantsPage$1, {
        query,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Delete an assistant.
     */
    del(assistantId, options) {
      return this._client.delete(`/assistants/${assistantId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
  };
  let AssistantsPage$1 = class AssistantsPage extends CursorPage$1 {
  };
  Assistants$1.AssistantsPage = AssistantsPage$1;
  function isRunnableFunctionWithParse$1(fn) {
    return typeof fn.parse === "function";
  }
  const isAssistantMessage$1 = (message) => {
    return (message == null ? void 0 : message.role) === "assistant";
  };
  const isFunctionMessage$1 = (message) => {
    return (message == null ? void 0 : message.role) === "function";
  };
  const isToolMessage$1 = (message) => {
    return (message == null ? void 0 : message.role) === "tool";
  };
  var __classPrivateFieldSet$9 = function(receiver, state, value, kind2, f) {
    if (kind2 === "m") throw new TypeError("Private method is not writable");
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet$b = function(receiver, state, kind2, f) {
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _EventStream_instances$1, _EventStream_connectedPromise$1, _EventStream_resolveConnectedPromise$1, _EventStream_rejectConnectedPromise$1, _EventStream_endPromise$1, _EventStream_resolveEndPromise$1, _EventStream_rejectEndPromise$1, _EventStream_listeners$1, _EventStream_ended$1, _EventStream_errored$1, _EventStream_aborted$1, _EventStream_catchingPromiseCreated$1, _EventStream_handleError$1;
  let EventStream$1 = class EventStream {
    constructor() {
      _EventStream_instances$1.add(this);
      this.controller = new AbortController();
      _EventStream_connectedPromise$1.set(this, void 0);
      _EventStream_resolveConnectedPromise$1.set(this, () => {
      });
      _EventStream_rejectConnectedPromise$1.set(this, () => {
      });
      _EventStream_endPromise$1.set(this, void 0);
      _EventStream_resolveEndPromise$1.set(this, () => {
      });
      _EventStream_rejectEndPromise$1.set(this, () => {
      });
      _EventStream_listeners$1.set(this, {});
      _EventStream_ended$1.set(this, false);
      _EventStream_errored$1.set(this, false);
      _EventStream_aborted$1.set(this, false);
      _EventStream_catchingPromiseCreated$1.set(this, false);
      __classPrivateFieldSet$9(this, _EventStream_connectedPromise$1, new Promise((resolve, reject) => {
        __classPrivateFieldSet$9(this, _EventStream_resolveConnectedPromise$1, resolve, "f");
        __classPrivateFieldSet$9(this, _EventStream_rejectConnectedPromise$1, reject, "f");
      }), "f");
      __classPrivateFieldSet$9(this, _EventStream_endPromise$1, new Promise((resolve, reject) => {
        __classPrivateFieldSet$9(this, _EventStream_resolveEndPromise$1, resolve, "f");
        __classPrivateFieldSet$9(this, _EventStream_rejectEndPromise$1, reject, "f");
      }), "f");
      __classPrivateFieldGet$b(this, _EventStream_connectedPromise$1, "f").catch(() => {
      });
      __classPrivateFieldGet$b(this, _EventStream_endPromise$1, "f").catch(() => {
      });
    }
    _run(executor) {
      setTimeout(() => {
        executor().then(() => {
          this._emitFinal();
          this._emit("end");
        }, __classPrivateFieldGet$b(this, _EventStream_instances$1, "m", _EventStream_handleError$1).bind(this));
      }, 0);
    }
    _connected() {
      if (this.ended)
        return;
      __classPrivateFieldGet$b(this, _EventStream_resolveConnectedPromise$1, "f").call(this);
      this._emit("connect");
    }
    get ended() {
      return __classPrivateFieldGet$b(this, _EventStream_ended$1, "f");
    }
    get errored() {
      return __classPrivateFieldGet$b(this, _EventStream_errored$1, "f");
    }
    get aborted() {
      return __classPrivateFieldGet$b(this, _EventStream_aborted$1, "f");
    }
    abort() {
      this.controller.abort();
    }
    /**
     * Adds the listener function to the end of the listeners array for the event.
     * No checks are made to see if the listener has already been added. Multiple calls passing
     * the same combination of event and listener will result in the listener being added, and
     * called, multiple times.
     * @returns this ChatCompletionStream, so that calls can be chained
     */
    on(event, listener) {
      const listeners = __classPrivateFieldGet$b(this, _EventStream_listeners$1, "f")[event] || (__classPrivateFieldGet$b(this, _EventStream_listeners$1, "f")[event] = []);
      listeners.push({ listener });
      return this;
    }
    /**
     * Removes the specified listener from the listener array for the event.
     * off() will remove, at most, one instance of a listener from the listener array. If any single
     * listener has been added multiple times to the listener array for the specified event, then
     * off() must be called multiple times to remove each instance.
     * @returns this ChatCompletionStream, so that calls can be chained
     */
    off(event, listener) {
      const listeners = __classPrivateFieldGet$b(this, _EventStream_listeners$1, "f")[event];
      if (!listeners)
        return this;
      const index = listeners.findIndex((l) => l.listener === listener);
      if (index >= 0)
        listeners.splice(index, 1);
      return this;
    }
    /**
     * Adds a one-time listener function for the event. The next time the event is triggered,
     * this listener is removed and then invoked.
     * @returns this ChatCompletionStream, so that calls can be chained
     */
    once(event, listener) {
      const listeners = __classPrivateFieldGet$b(this, _EventStream_listeners$1, "f")[event] || (__classPrivateFieldGet$b(this, _EventStream_listeners$1, "f")[event] = []);
      listeners.push({ listener, once: true });
      return this;
    }
    /**
     * This is similar to `.once()`, but returns a Promise that resolves the next time
     * the event is triggered, instead of calling a listener callback.
     * @returns a Promise that resolves the next time given event is triggered,
     * or rejects if an error is emitted.  (If you request the 'error' event,
     * returns a promise that resolves with the error).
     *
     * Example:
     *
     *   const message = await stream.emitted('message') // rejects if the stream errors
     */
    emitted(event) {
      return new Promise((resolve, reject) => {
        __classPrivateFieldSet$9(this, _EventStream_catchingPromiseCreated$1, true, "f");
        if (event !== "error")
          this.once("error", reject);
        this.once(event, resolve);
      });
    }
    async done() {
      __classPrivateFieldSet$9(this, _EventStream_catchingPromiseCreated$1, true, "f");
      await __classPrivateFieldGet$b(this, _EventStream_endPromise$1, "f");
    }
    _emit(event, ...args) {
      if (__classPrivateFieldGet$b(this, _EventStream_ended$1, "f")) {
        return;
      }
      if (event === "end") {
        __classPrivateFieldSet$9(this, _EventStream_ended$1, true, "f");
        __classPrivateFieldGet$b(this, _EventStream_resolveEndPromise$1, "f").call(this);
      }
      const listeners = __classPrivateFieldGet$b(this, _EventStream_listeners$1, "f")[event];
      if (listeners) {
        __classPrivateFieldGet$b(this, _EventStream_listeners$1, "f")[event] = listeners.filter((l) => !l.once);
        listeners.forEach(({ listener }) => listener(...args));
      }
      if (event === "abort") {
        const error = args[0];
        if (!__classPrivateFieldGet$b(this, _EventStream_catchingPromiseCreated$1, "f") && !(listeners == null ? void 0 : listeners.length)) {
          Promise.reject(error);
        }
        __classPrivateFieldGet$b(this, _EventStream_rejectConnectedPromise$1, "f").call(this, error);
        __classPrivateFieldGet$b(this, _EventStream_rejectEndPromise$1, "f").call(this, error);
        this._emit("end");
        return;
      }
      if (event === "error") {
        const error = args[0];
        if (!__classPrivateFieldGet$b(this, _EventStream_catchingPromiseCreated$1, "f") && !(listeners == null ? void 0 : listeners.length)) {
          Promise.reject(error);
        }
        __classPrivateFieldGet$b(this, _EventStream_rejectConnectedPromise$1, "f").call(this, error);
        __classPrivateFieldGet$b(this, _EventStream_rejectEndPromise$1, "f").call(this, error);
        this._emit("end");
      }
    }
    _emitFinal() {
    }
  };
  _EventStream_connectedPromise$1 = /* @__PURE__ */ new WeakMap(), _EventStream_resolveConnectedPromise$1 = /* @__PURE__ */ new WeakMap(), _EventStream_rejectConnectedPromise$1 = /* @__PURE__ */ new WeakMap(), _EventStream_endPromise$1 = /* @__PURE__ */ new WeakMap(), _EventStream_resolveEndPromise$1 = /* @__PURE__ */ new WeakMap(), _EventStream_rejectEndPromise$1 = /* @__PURE__ */ new WeakMap(), _EventStream_listeners$1 = /* @__PURE__ */ new WeakMap(), _EventStream_ended$1 = /* @__PURE__ */ new WeakMap(), _EventStream_errored$1 = /* @__PURE__ */ new WeakMap(), _EventStream_aborted$1 = /* @__PURE__ */ new WeakMap(), _EventStream_catchingPromiseCreated$1 = /* @__PURE__ */ new WeakMap(), _EventStream_instances$1 = /* @__PURE__ */ new WeakSet(), _EventStream_handleError$1 = function _EventStream_handleError2(error) {
    __classPrivateFieldSet$9(this, _EventStream_errored$1, true, "f");
    if (error instanceof Error && error.name === "AbortError") {
      error = new APIUserAbortError$2();
    }
    if (error instanceof APIUserAbortError$2) {
      __classPrivateFieldSet$9(this, _EventStream_aborted$1, true, "f");
      return this._emit("abort", error);
    }
    if (error instanceof OpenAIError$1) {
      return this._emit("error", error);
    }
    if (error instanceof Error) {
      const openAIError = new OpenAIError$1(error.message);
      openAIError.cause = error;
      return this._emit("error", openAIError);
    }
    return this._emit("error", new OpenAIError$1(String(error)));
  };
  function makeParseableResponseFormat$1(response_format, parser) {
    const obj = { ...response_format };
    Object.defineProperties(obj, {
      $brand: {
        value: "auto-parseable-response-format",
        enumerable: false
      },
      $parseRaw: {
        value: parser,
        enumerable: false
      }
    });
    return obj;
  }
  function isAutoParsableResponseFormat$1(response_format) {
    return (response_format == null ? void 0 : response_format["$brand"]) === "auto-parseable-response-format";
  }
  function makeParseableTool$1(tool, { parser, callback }) {
    const obj = { ...tool };
    Object.defineProperties(obj, {
      $brand: {
        value: "auto-parseable-tool",
        enumerable: false
      },
      $parseRaw: {
        value: parser,
        enumerable: false
      },
      $callback: {
        value: callback,
        enumerable: false
      }
    });
    return obj;
  }
  function isAutoParsableTool$1(tool) {
    return (tool == null ? void 0 : tool["$brand"]) === "auto-parseable-tool";
  }
  function maybeParseChatCompletion$1(completion, params) {
    if (!params || !hasAutoParseableInput$1(params)) {
      return {
        ...completion,
        choices: completion.choices.map((choice) => ({
          ...choice,
          message: { ...choice.message, parsed: null, tool_calls: choice.message.tool_calls ?? [] }
        }))
      };
    }
    return parseChatCompletion$1(completion, params);
  }
  function parseChatCompletion$1(completion, params) {
    const choices = completion.choices.map((choice) => {
      var _a3;
      if (choice.finish_reason === "length") {
        throw new LengthFinishReasonError$1();
      }
      if (choice.finish_reason === "content_filter") {
        throw new ContentFilterFinishReasonError$1();
      }
      return {
        ...choice,
        message: {
          ...choice.message,
          tool_calls: ((_a3 = choice.message.tool_calls) == null ? void 0 : _a3.map((toolCall) => parseToolCall$2(params, toolCall))) ?? [],
          parsed: choice.message.content && !choice.message.refusal ? parseResponseFormat$1(params, choice.message.content) : null
        }
      };
    });
    return { ...completion, choices };
  }
  function parseResponseFormat$1(params, content) {
    var _a3, _b2;
    if (((_a3 = params.response_format) == null ? void 0 : _a3.type) !== "json_schema") {
      return null;
    }
    if (((_b2 = params.response_format) == null ? void 0 : _b2.type) === "json_schema") {
      if ("$parseRaw" in params.response_format) {
        const response_format = params.response_format;
        return response_format.$parseRaw(content);
      }
      return JSON.parse(content);
    }
    return null;
  }
  function parseToolCall$2(params, toolCall) {
    var _a3;
    const inputTool = (_a3 = params.tools) == null ? void 0 : _a3.find((inputTool2) => {
      var _a4;
      return ((_a4 = inputTool2.function) == null ? void 0 : _a4.name) === toolCall.function.name;
    });
    return {
      ...toolCall,
      function: {
        ...toolCall.function,
        parsed_arguments: isAutoParsableTool$1(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments) : (inputTool == null ? void 0 : inputTool.function.strict) ? JSON.parse(toolCall.function.arguments) : null
      }
    };
  }
  function shouldParseToolCall$1(params, toolCall) {
    var _a3;
    if (!params) {
      return false;
    }
    const inputTool = (_a3 = params.tools) == null ? void 0 : _a3.find((inputTool2) => {
      var _a4;
      return ((_a4 = inputTool2.function) == null ? void 0 : _a4.name) === toolCall.function.name;
    });
    return isAutoParsableTool$1(inputTool) || (inputTool == null ? void 0 : inputTool.function.strict) || false;
  }
  function hasAutoParseableInput$1(params) {
    var _a3;
    if (isAutoParsableResponseFormat$1(params.response_format)) {
      return true;
    }
    return ((_a3 = params.tools) == null ? void 0 : _a3.some((t) => isAutoParsableTool$1(t) || t.type === "function" && t.function.strict === true)) ?? false;
  }
  function validateInputTools$1(tools) {
    for (const tool of tools ?? []) {
      if (tool.type !== "function") {
        throw new OpenAIError$1(`Currently only \`function\` tool types support auto-parsing; Received \`${tool.type}\``);
      }
      if (tool.function.strict !== true) {
        throw new OpenAIError$1(`The \`${tool.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
      }
    }
  }
  var __classPrivateFieldGet$a = function(receiver, state, kind2, f) {
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _AbstractChatCompletionRunner_instances$1, _AbstractChatCompletionRunner_getFinalContent$1, _AbstractChatCompletionRunner_getFinalMessage$1, _AbstractChatCompletionRunner_getFinalFunctionCall$1, _AbstractChatCompletionRunner_getFinalFunctionCallResult$1, _AbstractChatCompletionRunner_calculateTotalUsage$1, _AbstractChatCompletionRunner_validateParams$1, _AbstractChatCompletionRunner_stringifyFunctionCallResult$1;
  const DEFAULT_MAX_CHAT_COMPLETIONS$1 = 10;
  let AbstractChatCompletionRunner$1 = class AbstractChatCompletionRunner extends EventStream$1 {
    constructor() {
      super(...arguments);
      _AbstractChatCompletionRunner_instances$1.add(this);
      this._chatCompletions = [];
      this.messages = [];
    }
    _addChatCompletion(chatCompletion) {
      var _a3;
      this._chatCompletions.push(chatCompletion);
      this._emit("chatCompletion", chatCompletion);
      const message = (_a3 = chatCompletion.choices[0]) == null ? void 0 : _a3.message;
      if (message)
        this._addMessage(message);
      return chatCompletion;
    }
    _addMessage(message, emit = true) {
      if (!("content" in message))
        message.content = null;
      this.messages.push(message);
      if (emit) {
        this._emit("message", message);
        if ((isFunctionMessage$1(message) || isToolMessage$1(message)) && message.content) {
          this._emit("functionCallResult", message.content);
        } else if (isAssistantMessage$1(message) && message.function_call) {
          this._emit("functionCall", message.function_call);
        } else if (isAssistantMessage$1(message) && message.tool_calls) {
          for (const tool_call of message.tool_calls) {
            if (tool_call.type === "function") {
              this._emit("functionCall", tool_call.function);
            }
          }
        }
      }
    }
    /**
     * @returns a promise that resolves with the final ChatCompletion, or rejects
     * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
     */
    async finalChatCompletion() {
      await this.done();
      const completion = this._chatCompletions[this._chatCompletions.length - 1];
      if (!completion)
        throw new OpenAIError$1("stream ended without producing a ChatCompletion");
      return completion;
    }
    /**
     * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
     * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
     */
    async finalContent() {
      await this.done();
      return __classPrivateFieldGet$a(this, _AbstractChatCompletionRunner_instances$1, "m", _AbstractChatCompletionRunner_getFinalContent$1).call(this);
    }
    /**
     * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
     * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
     */
    async finalMessage() {
      await this.done();
      return __classPrivateFieldGet$a(this, _AbstractChatCompletionRunner_instances$1, "m", _AbstractChatCompletionRunner_getFinalMessage$1).call(this);
    }
    /**
     * @returns a promise that resolves with the content of the final FunctionCall, or rejects
     * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
     */
    async finalFunctionCall() {
      await this.done();
      return __classPrivateFieldGet$a(this, _AbstractChatCompletionRunner_instances$1, "m", _AbstractChatCompletionRunner_getFinalFunctionCall$1).call(this);
    }
    async finalFunctionCallResult() {
      await this.done();
      return __classPrivateFieldGet$a(this, _AbstractChatCompletionRunner_instances$1, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult$1).call(this);
    }
    async totalUsage() {
      await this.done();
      return __classPrivateFieldGet$a(this, _AbstractChatCompletionRunner_instances$1, "m", _AbstractChatCompletionRunner_calculateTotalUsage$1).call(this);
    }
    allChatCompletions() {
      return [...this._chatCompletions];
    }
    _emitFinal() {
      const completion = this._chatCompletions[this._chatCompletions.length - 1];
      if (completion)
        this._emit("finalChatCompletion", completion);
      const finalMessage = __classPrivateFieldGet$a(this, _AbstractChatCompletionRunner_instances$1, "m", _AbstractChatCompletionRunner_getFinalMessage$1).call(this);
      if (finalMessage)
        this._emit("finalMessage", finalMessage);
      const finalContent = __classPrivateFieldGet$a(this, _AbstractChatCompletionRunner_instances$1, "m", _AbstractChatCompletionRunner_getFinalContent$1).call(this);
      if (finalContent)
        this._emit("finalContent", finalContent);
      const finalFunctionCall = __classPrivateFieldGet$a(this, _AbstractChatCompletionRunner_instances$1, "m", _AbstractChatCompletionRunner_getFinalFunctionCall$1).call(this);
      if (finalFunctionCall)
        this._emit("finalFunctionCall", finalFunctionCall);
      const finalFunctionCallResult = __classPrivateFieldGet$a(this, _AbstractChatCompletionRunner_instances$1, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult$1).call(this);
      if (finalFunctionCallResult != null)
        this._emit("finalFunctionCallResult", finalFunctionCallResult);
      if (this._chatCompletions.some((c) => c.usage)) {
        this._emit("totalUsage", __classPrivateFieldGet$a(this, _AbstractChatCompletionRunner_instances$1, "m", _AbstractChatCompletionRunner_calculateTotalUsage$1).call(this));
      }
    }
    async _createChatCompletion(client2, params, options) {
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      __classPrivateFieldGet$a(this, _AbstractChatCompletionRunner_instances$1, "m", _AbstractChatCompletionRunner_validateParams$1).call(this, params);
      const chatCompletion = await client2.chat.completions.create({ ...params, stream: false }, { ...options, signal: this.controller.signal });
      this._connected();
      return this._addChatCompletion(parseChatCompletion$1(chatCompletion, params));
    }
    async _runChatCompletion(client2, params, options) {
      for (const message of params.messages) {
        this._addMessage(message, false);
      }
      return await this._createChatCompletion(client2, params, options);
    }
    async _runFunctions(client2, params, options) {
      var _a3;
      const role = "function";
      const { function_call = "auto", stream, ...restParams } = params;
      const singleFunctionToCall = typeof function_call !== "string" && (function_call == null ? void 0 : function_call.name);
      const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS$1 } = options || {};
      const functionsByName = {};
      for (const f of params.functions) {
        functionsByName[f.name || f.function.name] = f;
      }
      const functions = params.functions.map((f) => ({
        name: f.name || f.function.name,
        parameters: f.parameters,
        description: f.description
      }));
      for (const message of params.messages) {
        this._addMessage(message, false);
      }
      for (let i2 = 0; i2 < maxChatCompletions; ++i2) {
        const chatCompletion = await this._createChatCompletion(client2, {
          ...restParams,
          function_call,
          functions,
          messages: [...this.messages]
        }, options);
        const message = (_a3 = chatCompletion.choices[0]) == null ? void 0 : _a3.message;
        if (!message) {
          throw new OpenAIError$1(`missing message in ChatCompletion response`);
        }
        if (!message.function_call)
          return;
        const { name, arguments: args } = message.function_call;
        const fn = functionsByName[name];
        if (!fn) {
          const content2 = `Invalid function_call: ${JSON.stringify(name)}. Available options are: ${functions.map((f) => JSON.stringify(f.name)).join(", ")}. Please try again`;
          this._addMessage({ role, name, content: content2 });
          continue;
        } else if (singleFunctionToCall && singleFunctionToCall !== name) {
          const content2 = `Invalid function_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
          this._addMessage({ role, name, content: content2 });
          continue;
        }
        let parsed;
        try {
          parsed = isRunnableFunctionWithParse$1(fn) ? await fn.parse(args) : args;
        } catch (error) {
          this._addMessage({
            role,
            name,
            content: error instanceof Error ? error.message : String(error)
          });
          continue;
        }
        const rawContent = await fn.function(parsed, this);
        const content = __classPrivateFieldGet$a(this, _AbstractChatCompletionRunner_instances$1, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult$1).call(this, rawContent);
        this._addMessage({ role, name, content });
        if (singleFunctionToCall)
          return;
      }
    }
    async _runTools(client2, params, options) {
      var _a3, _b2, _c2;
      const role = "tool";
      const { tool_choice = "auto", stream, ...restParams } = params;
      const singleFunctionToCall = typeof tool_choice !== "string" && ((_a3 = tool_choice == null ? void 0 : tool_choice.function) == null ? void 0 : _a3.name);
      const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS$1 } = options || {};
      const inputTools = params.tools.map((tool) => {
        if (isAutoParsableTool$1(tool)) {
          if (!tool.$callback) {
            throw new OpenAIError$1("Tool given to `.runTools()` that does not have an associated function");
          }
          return {
            type: "function",
            function: {
              function: tool.$callback,
              name: tool.function.name,
              description: tool.function.description || "",
              parameters: tool.function.parameters,
              parse: tool.$parseRaw,
              strict: true
            }
          };
        }
        return tool;
      });
      const functionsByName = {};
      for (const f of inputTools) {
        if (f.type === "function") {
          functionsByName[f.function.name || f.function.function.name] = f.function;
        }
      }
      const tools = "tools" in params ? inputTools.map((t) => t.type === "function" ? {
        type: "function",
        function: {
          name: t.function.name || t.function.function.name,
          parameters: t.function.parameters,
          description: t.function.description,
          strict: t.function.strict
        }
      } : t) : void 0;
      for (const message of params.messages) {
        this._addMessage(message, false);
      }
      for (let i2 = 0; i2 < maxChatCompletions; ++i2) {
        const chatCompletion = await this._createChatCompletion(client2, {
          ...restParams,
          tool_choice,
          tools,
          messages: [...this.messages]
        }, options);
        const message = (_b2 = chatCompletion.choices[0]) == null ? void 0 : _b2.message;
        if (!message) {
          throw new OpenAIError$1(`missing message in ChatCompletion response`);
        }
        if (!((_c2 = message.tool_calls) == null ? void 0 : _c2.length)) {
          return;
        }
        for (const tool_call of message.tool_calls) {
          if (tool_call.type !== "function")
            continue;
          const tool_call_id = tool_call.id;
          const { name, arguments: args } = tool_call.function;
          const fn = functionsByName[name];
          if (!fn) {
            const content2 = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName).map((name2) => JSON.stringify(name2)).join(", ")}. Please try again`;
            this._addMessage({ role, tool_call_id, content: content2 });
            continue;
          } else if (singleFunctionToCall && singleFunctionToCall !== name) {
            const content2 = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
            this._addMessage({ role, tool_call_id, content: content2 });
            continue;
          }
          let parsed;
          try {
            parsed = isRunnableFunctionWithParse$1(fn) ? await fn.parse(args) : args;
          } catch (error) {
            const content2 = error instanceof Error ? error.message : String(error);
            this._addMessage({ role, tool_call_id, content: content2 });
            continue;
          }
          const rawContent = await fn.function(parsed, this);
          const content = __classPrivateFieldGet$a(this, _AbstractChatCompletionRunner_instances$1, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult$1).call(this, rawContent);
          this._addMessage({ role, tool_call_id, content });
          if (singleFunctionToCall) {
            return;
          }
        }
      }
      return;
    }
  };
  _AbstractChatCompletionRunner_instances$1 = /* @__PURE__ */ new WeakSet(), _AbstractChatCompletionRunner_getFinalContent$1 = function _AbstractChatCompletionRunner_getFinalContent2() {
    return __classPrivateFieldGet$a(this, _AbstractChatCompletionRunner_instances$1, "m", _AbstractChatCompletionRunner_getFinalMessage$1).call(this).content ?? null;
  }, _AbstractChatCompletionRunner_getFinalMessage$1 = function _AbstractChatCompletionRunner_getFinalMessage2() {
    let i2 = this.messages.length;
    while (i2-- > 0) {
      const message = this.messages[i2];
      if (isAssistantMessage$1(message)) {
        const { function_call, ...rest } = message;
        const ret = {
          ...rest,
          content: message.content ?? null,
          refusal: message.refusal ?? null
        };
        if (function_call) {
          ret.function_call = function_call;
        }
        return ret;
      }
    }
    throw new OpenAIError$1("stream ended without producing a ChatCompletionMessage with role=assistant");
  }, _AbstractChatCompletionRunner_getFinalFunctionCall$1 = function _AbstractChatCompletionRunner_getFinalFunctionCall2() {
    var _a3, _b2;
    for (let i2 = this.messages.length - 1; i2 >= 0; i2--) {
      const message = this.messages[i2];
      if (isAssistantMessage$1(message) && (message == null ? void 0 : message.function_call)) {
        return message.function_call;
      }
      if (isAssistantMessage$1(message) && ((_a3 = message == null ? void 0 : message.tool_calls) == null ? void 0 : _a3.length)) {
        return (_b2 = message.tool_calls.at(-1)) == null ? void 0 : _b2.function;
      }
    }
    return;
  }, _AbstractChatCompletionRunner_getFinalFunctionCallResult$1 = function _AbstractChatCompletionRunner_getFinalFunctionCallResult2() {
    for (let i2 = this.messages.length - 1; i2 >= 0; i2--) {
      const message = this.messages[i2];
      if (isFunctionMessage$1(message) && message.content != null) {
        return message.content;
      }
      if (isToolMessage$1(message) && message.content != null && typeof message.content === "string" && this.messages.some((x) => {
        var _a3;
        return x.role === "assistant" && ((_a3 = x.tool_calls) == null ? void 0 : _a3.some((y) => y.type === "function" && y.id === message.tool_call_id));
      })) {
        return message.content;
      }
    }
    return;
  }, _AbstractChatCompletionRunner_calculateTotalUsage$1 = function _AbstractChatCompletionRunner_calculateTotalUsage2() {
    const total = {
      completion_tokens: 0,
      prompt_tokens: 0,
      total_tokens: 0
    };
    for (const { usage } of this._chatCompletions) {
      if (usage) {
        total.completion_tokens += usage.completion_tokens;
        total.prompt_tokens += usage.prompt_tokens;
        total.total_tokens += usage.total_tokens;
      }
    }
    return total;
  }, _AbstractChatCompletionRunner_validateParams$1 = function _AbstractChatCompletionRunner_validateParams2(params) {
    if (params.n != null && params.n > 1) {
      throw new OpenAIError$1("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
    }
  }, _AbstractChatCompletionRunner_stringifyFunctionCallResult$1 = function _AbstractChatCompletionRunner_stringifyFunctionCallResult2(rawContent) {
    return typeof rawContent === "string" ? rawContent : rawContent === void 0 ? "undefined" : JSON.stringify(rawContent);
  };
  let ChatCompletionRunner$1 = class ChatCompletionRunner2 extends AbstractChatCompletionRunner$1 {
    /** @deprecated - please use `runTools` instead. */
    static runFunctions(client2, params, options) {
      const runner = new ChatCompletionRunner2();
      const opts = {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runFunctions" }
      };
      runner._run(() => runner._runFunctions(client2, params, opts));
      return runner;
    }
    static runTools(client2, params, options) {
      const runner = new ChatCompletionRunner2();
      const opts = {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runTools" }
      };
      runner._run(() => runner._runTools(client2, params, opts));
      return runner;
    }
    _addMessage(message, emit = true) {
      super._addMessage(message, emit);
      if (isAssistantMessage$1(message) && message.content) {
        this._emit("content", message.content);
      }
    }
  };
  const STR$1 = 1;
  const NUM$1 = 2;
  const ARR$1 = 4;
  const OBJ$1 = 8;
  const NULL$1 = 16;
  const BOOL$1 = 32;
  const NAN$1 = 64;
  const INFINITY$1 = 128;
  const MINUS_INFINITY$1 = 256;
  const INF$1 = INFINITY$1 | MINUS_INFINITY$1;
  const SPECIAL$1 = NULL$1 | BOOL$1 | INF$1 | NAN$1;
  const ATOM$1 = STR$1 | NUM$1 | SPECIAL$1;
  const COLLECTION$1 = ARR$1 | OBJ$1;
  const ALL$1 = ATOM$1 | COLLECTION$1;
  const Allow$1 = {
    STR: STR$1,
    NUM: NUM$1,
    ARR: ARR$1,
    OBJ: OBJ$1,
    NULL: NULL$1,
    BOOL: BOOL$1,
    NAN: NAN$1,
    INFINITY: INFINITY$1,
    MINUS_INFINITY: MINUS_INFINITY$1,
    INF: INF$1,
    SPECIAL: SPECIAL$1,
    ATOM: ATOM$1,
    COLLECTION: COLLECTION$1,
    ALL: ALL$1
  };
  let PartialJSON$1 = class PartialJSON extends Error {
  };
  let MalformedJSON$1 = class MalformedJSON extends Error {
  };
  function parseJSON$2(jsonString, allowPartial = Allow$1.ALL) {
    if (typeof jsonString !== "string") {
      throw new TypeError(`expecting str, got ${typeof jsonString}`);
    }
    if (!jsonString.trim()) {
      throw new Error(`${jsonString} is empty`);
    }
    return _parseJSON$1(jsonString.trim(), allowPartial);
  }
  const _parseJSON$1 = (jsonString, allow) => {
    const length = jsonString.length;
    let index = 0;
    const markPartialJSON = (msg) => {
      throw new PartialJSON$1(`${msg} at position ${index}`);
    };
    const throwMalformedError = (msg) => {
      throw new MalformedJSON$1(`${msg} at position ${index}`);
    };
    const parseAny = () => {
      skipBlank();
      if (index >= length)
        markPartialJSON("Unexpected end of input");
      if (jsonString[index] === '"')
        return parseStr();
      if (jsonString[index] === "{")
        return parseObj();
      if (jsonString[index] === "[")
        return parseArr();
      if (jsonString.substring(index, index + 4) === "null" || Allow$1.NULL & allow && length - index < 4 && "null".startsWith(jsonString.substring(index))) {
        index += 4;
        return null;
      }
      if (jsonString.substring(index, index + 4) === "true" || Allow$1.BOOL & allow && length - index < 4 && "true".startsWith(jsonString.substring(index))) {
        index += 4;
        return true;
      }
      if (jsonString.substring(index, index + 5) === "false" || Allow$1.BOOL & allow && length - index < 5 && "false".startsWith(jsonString.substring(index))) {
        index += 5;
        return false;
      }
      if (jsonString.substring(index, index + 8) === "Infinity" || Allow$1.INFINITY & allow && length - index < 8 && "Infinity".startsWith(jsonString.substring(index))) {
        index += 8;
        return Infinity;
      }
      if (jsonString.substring(index, index + 9) === "-Infinity" || Allow$1.MINUS_INFINITY & allow && 1 < length - index && length - index < 9 && "-Infinity".startsWith(jsonString.substring(index))) {
        index += 9;
        return -Infinity;
      }
      if (jsonString.substring(index, index + 3) === "NaN" || Allow$1.NAN & allow && length - index < 3 && "NaN".startsWith(jsonString.substring(index))) {
        index += 3;
        return NaN;
      }
      return parseNum();
    };
    const parseStr = () => {
      const start = index;
      let escape2 = false;
      index++;
      while (index < length && (jsonString[index] !== '"' || escape2 && jsonString[index - 1] === "\\")) {
        escape2 = jsonString[index] === "\\" ? !escape2 : false;
        index++;
      }
      if (jsonString.charAt(index) == '"') {
        try {
          return JSON.parse(jsonString.substring(start, ++index - Number(escape2)));
        } catch (e) {
          throwMalformedError(String(e));
        }
      } else if (Allow$1.STR & allow) {
        try {
          return JSON.parse(jsonString.substring(start, index - Number(escape2)) + '"');
        } catch (e) {
          return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("\\")) + '"');
        }
      }
      markPartialJSON("Unterminated string literal");
    };
    const parseObj = () => {
      index++;
      skipBlank();
      const obj = {};
      try {
        while (jsonString[index] !== "}") {
          skipBlank();
          if (index >= length && Allow$1.OBJ & allow)
            return obj;
          const key = parseStr();
          skipBlank();
          index++;
          try {
            const value = parseAny();
            Object.defineProperty(obj, key, { value, writable: true, enumerable: true, configurable: true });
          } catch (e) {
            if (Allow$1.OBJ & allow)
              return obj;
            else
              throw e;
          }
          skipBlank();
          if (jsonString[index] === ",")
            index++;
        }
      } catch (e) {
        if (Allow$1.OBJ & allow)
          return obj;
        else
          markPartialJSON("Expected '}' at end of object");
      }
      index++;
      return obj;
    };
    const parseArr = () => {
      index++;
      const arr2 = [];
      try {
        while (jsonString[index] !== "]") {
          arr2.push(parseAny());
          skipBlank();
          if (jsonString[index] === ",") {
            index++;
          }
        }
      } catch (e) {
        if (Allow$1.ARR & allow) {
          return arr2;
        }
        markPartialJSON("Expected ']' at end of array");
      }
      index++;
      return arr2;
    };
    const parseNum = () => {
      if (index === 0) {
        if (jsonString === "-" && Allow$1.NUM & allow)
          markPartialJSON("Not sure what '-' is");
        try {
          return JSON.parse(jsonString);
        } catch (e) {
          if (Allow$1.NUM & allow) {
            try {
              if ("." === jsonString[jsonString.length - 1])
                return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf(".")));
              return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf("e")));
            } catch (e2) {
            }
          }
          throwMalformedError(String(e));
        }
      }
      const start = index;
      if (jsonString[index] === "-")
        index++;
      while (jsonString[index] && !",]}".includes(jsonString[index]))
        index++;
      if (index == length && !(Allow$1.NUM & allow))
        markPartialJSON("Unterminated number literal");
      try {
        return JSON.parse(jsonString.substring(start, index));
      } catch (e) {
        if (jsonString.substring(start, index) === "-" && Allow$1.NUM & allow)
          markPartialJSON("Not sure what '-' is");
        try {
          return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("e")));
        } catch (e2) {
          throwMalformedError(String(e2));
        }
      }
    };
    const skipBlank = () => {
      while (index < length && " \n\r	".includes(jsonString[index])) {
        index++;
      }
    };
    return parseAny();
  };
  const partialParse$2 = (input) => parseJSON$2(input, Allow$1.ALL ^ Allow$1.NUM);
  var __classPrivateFieldSet$8 = function(receiver, state, value, kind2, f) {
    if (kind2 === "m") throw new TypeError("Private method is not writable");
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet$9 = function(receiver, state, kind2, f) {
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _ChatCompletionStream_instances$1, _ChatCompletionStream_params$1, _ChatCompletionStream_choiceEventStates$1, _ChatCompletionStream_currentChatCompletionSnapshot$1, _ChatCompletionStream_beginRequest$1, _ChatCompletionStream_getChoiceEventState$1, _ChatCompletionStream_addChunk$1, _ChatCompletionStream_emitToolCallDoneEvent$1, _ChatCompletionStream_emitContentDoneEvents$1, _ChatCompletionStream_endRequest$1, _ChatCompletionStream_getAutoParseableResponseFormat$1, _ChatCompletionStream_accumulateChatCompletion$1;
  let ChatCompletionStream$1 = class ChatCompletionStream2 extends AbstractChatCompletionRunner$1 {
    constructor(params) {
      super();
      _ChatCompletionStream_instances$1.add(this);
      _ChatCompletionStream_params$1.set(this, void 0);
      _ChatCompletionStream_choiceEventStates$1.set(this, void 0);
      _ChatCompletionStream_currentChatCompletionSnapshot$1.set(this, void 0);
      __classPrivateFieldSet$8(this, _ChatCompletionStream_params$1, params, "f");
      __classPrivateFieldSet$8(this, _ChatCompletionStream_choiceEventStates$1, [], "f");
    }
    get currentChatCompletionSnapshot() {
      return __classPrivateFieldGet$9(this, _ChatCompletionStream_currentChatCompletionSnapshot$1, "f");
    }
    /**
     * Intended for use on the frontend, consuming a stream produced with
     * `.toReadableStream()` on the backend.
     *
     * Note that messages sent to the model do not appear in `.on('message')`
     * in this context.
     */
    static fromReadableStream(stream) {
      const runner = new ChatCompletionStream2(null);
      runner._run(() => runner._fromReadableStream(stream));
      return runner;
    }
    static createChatCompletion(client2, params, options) {
      const runner = new ChatCompletionStream2(params);
      runner._run(() => runner._runChatCompletion(client2, { ...params, stream: true }, { ...options, headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" } }));
      return runner;
    }
    async _createChatCompletion(client2, params, options) {
      var _a3;
      super._createChatCompletion;
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      __classPrivateFieldGet$9(this, _ChatCompletionStream_instances$1, "m", _ChatCompletionStream_beginRequest$1).call(this);
      const stream = await client2.chat.completions.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
      this._connected();
      for await (const chunk of stream) {
        __classPrivateFieldGet$9(this, _ChatCompletionStream_instances$1, "m", _ChatCompletionStream_addChunk$1).call(this, chunk);
      }
      if ((_a3 = stream.controller.signal) == null ? void 0 : _a3.aborted) {
        throw new APIUserAbortError$2();
      }
      return this._addChatCompletion(__classPrivateFieldGet$9(this, _ChatCompletionStream_instances$1, "m", _ChatCompletionStream_endRequest$1).call(this));
    }
    async _fromReadableStream(readableStream, options) {
      var _a3;
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      __classPrivateFieldGet$9(this, _ChatCompletionStream_instances$1, "m", _ChatCompletionStream_beginRequest$1).call(this);
      this._connected();
      const stream = Stream$2.fromReadableStream(readableStream, this.controller);
      let chatId;
      for await (const chunk of stream) {
        if (chatId && chatId !== chunk.id) {
          this._addChatCompletion(__classPrivateFieldGet$9(this, _ChatCompletionStream_instances$1, "m", _ChatCompletionStream_endRequest$1).call(this));
        }
        __classPrivateFieldGet$9(this, _ChatCompletionStream_instances$1, "m", _ChatCompletionStream_addChunk$1).call(this, chunk);
        chatId = chunk.id;
      }
      if ((_a3 = stream.controller.signal) == null ? void 0 : _a3.aborted) {
        throw new APIUserAbortError$2();
      }
      return this._addChatCompletion(__classPrivateFieldGet$9(this, _ChatCompletionStream_instances$1, "m", _ChatCompletionStream_endRequest$1).call(this));
    }
    [(_ChatCompletionStream_params$1 = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_choiceEventStates$1 = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_currentChatCompletionSnapshot$1 = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_instances$1 = /* @__PURE__ */ new WeakSet(), _ChatCompletionStream_beginRequest$1 = function _ChatCompletionStream_beginRequest2() {
      if (this.ended)
        return;
      __classPrivateFieldSet$8(this, _ChatCompletionStream_currentChatCompletionSnapshot$1, void 0, "f");
    }, _ChatCompletionStream_getChoiceEventState$1 = function _ChatCompletionStream_getChoiceEventState2(choice) {
      let state = __classPrivateFieldGet$9(this, _ChatCompletionStream_choiceEventStates$1, "f")[choice.index];
      if (state) {
        return state;
      }
      state = {
        content_done: false,
        refusal_done: false,
        logprobs_content_done: false,
        logprobs_refusal_done: false,
        done_tool_calls: /* @__PURE__ */ new Set(),
        current_tool_call_index: null
      };
      __classPrivateFieldGet$9(this, _ChatCompletionStream_choiceEventStates$1, "f")[choice.index] = state;
      return state;
    }, _ChatCompletionStream_addChunk$1 = function _ChatCompletionStream_addChunk2(chunk) {
      var _a3, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2, _k2, _l, _m, _n, _o;
      if (this.ended)
        return;
      const completion = __classPrivateFieldGet$9(this, _ChatCompletionStream_instances$1, "m", _ChatCompletionStream_accumulateChatCompletion$1).call(this, chunk);
      this._emit("chunk", chunk, completion);
      for (const choice of chunk.choices) {
        const choiceSnapshot = completion.choices[choice.index];
        if (choice.delta.content != null && ((_a3 = choiceSnapshot.message) == null ? void 0 : _a3.role) === "assistant" && ((_b2 = choiceSnapshot.message) == null ? void 0 : _b2.content)) {
          this._emit("content", choice.delta.content, choiceSnapshot.message.content);
          this._emit("content.delta", {
            delta: choice.delta.content,
            snapshot: choiceSnapshot.message.content,
            parsed: choiceSnapshot.message.parsed
          });
        }
        if (choice.delta.refusal != null && ((_c2 = choiceSnapshot.message) == null ? void 0 : _c2.role) === "assistant" && ((_d2 = choiceSnapshot.message) == null ? void 0 : _d2.refusal)) {
          this._emit("refusal.delta", {
            delta: choice.delta.refusal,
            snapshot: choiceSnapshot.message.refusal
          });
        }
        if (((_e2 = choice.logprobs) == null ? void 0 : _e2.content) != null && ((_f2 = choiceSnapshot.message) == null ? void 0 : _f2.role) === "assistant") {
          this._emit("logprobs.content.delta", {
            content: (_g2 = choice.logprobs) == null ? void 0 : _g2.content,
            snapshot: ((_h2 = choiceSnapshot.logprobs) == null ? void 0 : _h2.content) ?? []
          });
        }
        if (((_i2 = choice.logprobs) == null ? void 0 : _i2.refusal) != null && ((_j2 = choiceSnapshot.message) == null ? void 0 : _j2.role) === "assistant") {
          this._emit("logprobs.refusal.delta", {
            refusal: (_k2 = choice.logprobs) == null ? void 0 : _k2.refusal,
            snapshot: ((_l = choiceSnapshot.logprobs) == null ? void 0 : _l.refusal) ?? []
          });
        }
        const state = __classPrivateFieldGet$9(this, _ChatCompletionStream_instances$1, "m", _ChatCompletionStream_getChoiceEventState$1).call(this, choiceSnapshot);
        if (choiceSnapshot.finish_reason) {
          __classPrivateFieldGet$9(this, _ChatCompletionStream_instances$1, "m", _ChatCompletionStream_emitContentDoneEvents$1).call(this, choiceSnapshot);
          if (state.current_tool_call_index != null) {
            __classPrivateFieldGet$9(this, _ChatCompletionStream_instances$1, "m", _ChatCompletionStream_emitToolCallDoneEvent$1).call(this, choiceSnapshot, state.current_tool_call_index);
          }
        }
        for (const toolCall of choice.delta.tool_calls ?? []) {
          if (state.current_tool_call_index !== toolCall.index) {
            __classPrivateFieldGet$9(this, _ChatCompletionStream_instances$1, "m", _ChatCompletionStream_emitContentDoneEvents$1).call(this, choiceSnapshot);
            if (state.current_tool_call_index != null) {
              __classPrivateFieldGet$9(this, _ChatCompletionStream_instances$1, "m", _ChatCompletionStream_emitToolCallDoneEvent$1).call(this, choiceSnapshot, state.current_tool_call_index);
            }
          }
          state.current_tool_call_index = toolCall.index;
        }
        for (const toolCallDelta of choice.delta.tool_calls ?? []) {
          const toolCallSnapshot = (_m = choiceSnapshot.message.tool_calls) == null ? void 0 : _m[toolCallDelta.index];
          if (!(toolCallSnapshot == null ? void 0 : toolCallSnapshot.type)) {
            continue;
          }
          if ((toolCallSnapshot == null ? void 0 : toolCallSnapshot.type) === "function") {
            this._emit("tool_calls.function.arguments.delta", {
              name: (_n = toolCallSnapshot.function) == null ? void 0 : _n.name,
              index: toolCallDelta.index,
              arguments: toolCallSnapshot.function.arguments,
              parsed_arguments: toolCallSnapshot.function.parsed_arguments,
              arguments_delta: ((_o = toolCallDelta.function) == null ? void 0 : _o.arguments) ?? ""
            });
          } else {
            assertNever$1(toolCallSnapshot == null ? void 0 : toolCallSnapshot.type);
          }
        }
      }
    }, _ChatCompletionStream_emitToolCallDoneEvent$1 = function _ChatCompletionStream_emitToolCallDoneEvent2(choiceSnapshot, toolCallIndex) {
      var _a3, _b2, _c2;
      const state = __classPrivateFieldGet$9(this, _ChatCompletionStream_instances$1, "m", _ChatCompletionStream_getChoiceEventState$1).call(this, choiceSnapshot);
      if (state.done_tool_calls.has(toolCallIndex)) {
        return;
      }
      const toolCallSnapshot = (_a3 = choiceSnapshot.message.tool_calls) == null ? void 0 : _a3[toolCallIndex];
      if (!toolCallSnapshot) {
        throw new Error("no tool call snapshot");
      }
      if (!toolCallSnapshot.type) {
        throw new Error("tool call snapshot missing `type`");
      }
      if (toolCallSnapshot.type === "function") {
        const inputTool = (_c2 = (_b2 = __classPrivateFieldGet$9(this, _ChatCompletionStream_params$1, "f")) == null ? void 0 : _b2.tools) == null ? void 0 : _c2.find((tool) => tool.type === "function" && tool.function.name === toolCallSnapshot.function.name);
        this._emit("tool_calls.function.arguments.done", {
          name: toolCallSnapshot.function.name,
          index: toolCallIndex,
          arguments: toolCallSnapshot.function.arguments,
          parsed_arguments: isAutoParsableTool$1(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments) : (inputTool == null ? void 0 : inputTool.function.strict) ? JSON.parse(toolCallSnapshot.function.arguments) : null
        });
      } else {
        assertNever$1(toolCallSnapshot.type);
      }
    }, _ChatCompletionStream_emitContentDoneEvents$1 = function _ChatCompletionStream_emitContentDoneEvents2(choiceSnapshot) {
      var _a3, _b2;
      const state = __classPrivateFieldGet$9(this, _ChatCompletionStream_instances$1, "m", _ChatCompletionStream_getChoiceEventState$1).call(this, choiceSnapshot);
      if (choiceSnapshot.message.content && !state.content_done) {
        state.content_done = true;
        const responseFormat = __classPrivateFieldGet$9(this, _ChatCompletionStream_instances$1, "m", _ChatCompletionStream_getAutoParseableResponseFormat$1).call(this);
        this._emit("content.done", {
          content: choiceSnapshot.message.content,
          parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null
        });
      }
      if (choiceSnapshot.message.refusal && !state.refusal_done) {
        state.refusal_done = true;
        this._emit("refusal.done", { refusal: choiceSnapshot.message.refusal });
      }
      if (((_a3 = choiceSnapshot.logprobs) == null ? void 0 : _a3.content) && !state.logprobs_content_done) {
        state.logprobs_content_done = true;
        this._emit("logprobs.content.done", { content: choiceSnapshot.logprobs.content });
      }
      if (((_b2 = choiceSnapshot.logprobs) == null ? void 0 : _b2.refusal) && !state.logprobs_refusal_done) {
        state.logprobs_refusal_done = true;
        this._emit("logprobs.refusal.done", { refusal: choiceSnapshot.logprobs.refusal });
      }
    }, _ChatCompletionStream_endRequest$1 = function _ChatCompletionStream_endRequest2() {
      if (this.ended) {
        throw new OpenAIError$1(`stream has ended, this shouldn't happen`);
      }
      const snapshot = __classPrivateFieldGet$9(this, _ChatCompletionStream_currentChatCompletionSnapshot$1, "f");
      if (!snapshot) {
        throw new OpenAIError$1(`request ended without sending any chunks`);
      }
      __classPrivateFieldSet$8(this, _ChatCompletionStream_currentChatCompletionSnapshot$1, void 0, "f");
      __classPrivateFieldSet$8(this, _ChatCompletionStream_choiceEventStates$1, [], "f");
      return finalizeChatCompletion$1(snapshot, __classPrivateFieldGet$9(this, _ChatCompletionStream_params$1, "f"));
    }, _ChatCompletionStream_getAutoParseableResponseFormat$1 = function _ChatCompletionStream_getAutoParseableResponseFormat2() {
      var _a3;
      const responseFormat = (_a3 = __classPrivateFieldGet$9(this, _ChatCompletionStream_params$1, "f")) == null ? void 0 : _a3.response_format;
      if (isAutoParsableResponseFormat$1(responseFormat)) {
        return responseFormat;
      }
      return null;
    }, _ChatCompletionStream_accumulateChatCompletion$1 = function _ChatCompletionStream_accumulateChatCompletion2(chunk) {
      var _a3, _b2, _c2, _d2;
      let snapshot = __classPrivateFieldGet$9(this, _ChatCompletionStream_currentChatCompletionSnapshot$1, "f");
      const { choices, ...rest } = chunk;
      if (!snapshot) {
        snapshot = __classPrivateFieldSet$8(this, _ChatCompletionStream_currentChatCompletionSnapshot$1, {
          ...rest,
          choices: []
        }, "f");
      } else {
        Object.assign(snapshot, rest);
      }
      for (const { delta, finish_reason, index, logprobs = null, ...other } of chunk.choices) {
        let choice = snapshot.choices[index];
        if (!choice) {
          choice = snapshot.choices[index] = { finish_reason, index, message: {}, logprobs, ...other };
        }
        if (logprobs) {
          if (!choice.logprobs) {
            choice.logprobs = Object.assign({}, logprobs);
          } else {
            const { content: content2, refusal: refusal2, ...rest3 } = logprobs;
            Object.assign(choice.logprobs, rest3);
            if (content2) {
              (_a3 = choice.logprobs).content ?? (_a3.content = []);
              choice.logprobs.content.push(...content2);
            }
            if (refusal2) {
              (_b2 = choice.logprobs).refusal ?? (_b2.refusal = []);
              choice.logprobs.refusal.push(...refusal2);
            }
          }
        }
        if (finish_reason) {
          choice.finish_reason = finish_reason;
          if (__classPrivateFieldGet$9(this, _ChatCompletionStream_params$1, "f") && hasAutoParseableInput$1(__classPrivateFieldGet$9(this, _ChatCompletionStream_params$1, "f"))) {
            if (finish_reason === "length") {
              throw new LengthFinishReasonError$1();
            }
            if (finish_reason === "content_filter") {
              throw new ContentFilterFinishReasonError$1();
            }
          }
        }
        Object.assign(choice, other);
        if (!delta)
          continue;
        const { content, refusal, function_call, role, tool_calls, ...rest2 } = delta;
        Object.assign(choice.message, rest2);
        if (refusal) {
          choice.message.refusal = (choice.message.refusal || "") + refusal;
        }
        if (role)
          choice.message.role = role;
        if (function_call) {
          if (!choice.message.function_call) {
            choice.message.function_call = function_call;
          } else {
            if (function_call.name)
              choice.message.function_call.name = function_call.name;
            if (function_call.arguments) {
              (_c2 = choice.message.function_call).arguments ?? (_c2.arguments = "");
              choice.message.function_call.arguments += function_call.arguments;
            }
          }
        }
        if (content) {
          choice.message.content = (choice.message.content || "") + content;
          if (!choice.message.refusal && __classPrivateFieldGet$9(this, _ChatCompletionStream_instances$1, "m", _ChatCompletionStream_getAutoParseableResponseFormat$1).call(this)) {
            choice.message.parsed = partialParse$2(choice.message.content);
          }
        }
        if (tool_calls) {
          if (!choice.message.tool_calls)
            choice.message.tool_calls = [];
          for (const { index: index2, id, type, function: fn, ...rest3 } of tool_calls) {
            const tool_call = (_d2 = choice.message.tool_calls)[index2] ?? (_d2[index2] = {});
            Object.assign(tool_call, rest3);
            if (id)
              tool_call.id = id;
            if (type)
              tool_call.type = type;
            if (fn)
              tool_call.function ?? (tool_call.function = { name: fn.name ?? "", arguments: "" });
            if (fn == null ? void 0 : fn.name)
              tool_call.function.name = fn.name;
            if (fn == null ? void 0 : fn.arguments) {
              tool_call.function.arguments += fn.arguments;
              if (shouldParseToolCall$1(__classPrivateFieldGet$9(this, _ChatCompletionStream_params$1, "f"), tool_call)) {
                tool_call.function.parsed_arguments = partialParse$2(tool_call.function.arguments);
              }
            }
          }
        }
      }
      return snapshot;
    }, Symbol.asyncIterator)]() {
      const pushQueue = [];
      const readQueue = [];
      let done = false;
      this.on("chunk", (chunk) => {
        const reader = readQueue.shift();
        if (reader) {
          reader.resolve(chunk);
        } else {
          pushQueue.push(chunk);
        }
      });
      this.on("end", () => {
        done = true;
        for (const reader of readQueue) {
          reader.resolve(void 0);
        }
        readQueue.length = 0;
      });
      this.on("abort", (err) => {
        done = true;
        for (const reader of readQueue) {
          reader.reject(err);
        }
        readQueue.length = 0;
      });
      this.on("error", (err) => {
        done = true;
        for (const reader of readQueue) {
          reader.reject(err);
        }
        readQueue.length = 0;
      });
      return {
        next: async () => {
          if (!pushQueue.length) {
            if (done) {
              return { value: void 0, done: true };
            }
            return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
          }
          const chunk = pushQueue.shift();
          return { value: chunk, done: false };
        },
        return: async () => {
          this.abort();
          return { value: void 0, done: true };
        }
      };
    }
    toReadableStream() {
      const stream = new Stream$2(this[Symbol.asyncIterator].bind(this), this.controller);
      return stream.toReadableStream();
    }
  };
  function finalizeChatCompletion$1(snapshot, params) {
    const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;
    const completion = {
      ...rest,
      id,
      choices: choices.map(({ message, finish_reason, index, logprobs, ...choiceRest }) => {
        if (!finish_reason) {
          throw new OpenAIError$1(`missing finish_reason for choice ${index}`);
        }
        const { content = null, function_call, tool_calls, ...messageRest } = message;
        const role = message.role;
        if (!role) {
          throw new OpenAIError$1(`missing role for choice ${index}`);
        }
        if (function_call) {
          const { arguments: args, name } = function_call;
          if (args == null) {
            throw new OpenAIError$1(`missing function_call.arguments for choice ${index}`);
          }
          if (!name) {
            throw new OpenAIError$1(`missing function_call.name for choice ${index}`);
          }
          return {
            ...choiceRest,
            message: {
              content,
              function_call: { arguments: args, name },
              role,
              refusal: message.refusal ?? null
            },
            finish_reason,
            index,
            logprobs
          };
        }
        if (tool_calls) {
          return {
            ...choiceRest,
            index,
            finish_reason,
            logprobs,
            message: {
              ...messageRest,
              role,
              content,
              refusal: message.refusal ?? null,
              tool_calls: tool_calls.map((tool_call, i2) => {
                const { function: fn, type, id: id2, ...toolRest } = tool_call;
                const { arguments: args, name, ...fnRest } = fn || {};
                if (id2 == null) {
                  throw new OpenAIError$1(`missing choices[${index}].tool_calls[${i2}].id
${str$1(snapshot)}`);
                }
                if (type == null) {
                  throw new OpenAIError$1(`missing choices[${index}].tool_calls[${i2}].type
${str$1(snapshot)}`);
                }
                if (name == null) {
                  throw new OpenAIError$1(`missing choices[${index}].tool_calls[${i2}].function.name
${str$1(snapshot)}`);
                }
                if (args == null) {
                  throw new OpenAIError$1(`missing choices[${index}].tool_calls[${i2}].function.arguments
${str$1(snapshot)}`);
                }
                return { ...toolRest, id: id2, type, function: { ...fnRest, name, arguments: args } };
              })
            }
          };
        }
        return {
          ...choiceRest,
          message: { ...messageRest, content, role, refusal: message.refusal ?? null },
          finish_reason,
          index,
          logprobs
        };
      }),
      created,
      model,
      object: "chat.completion",
      ...system_fingerprint ? { system_fingerprint } : {}
    };
    return maybeParseChatCompletion$1(completion, params);
  }
  function str$1(x) {
    return JSON.stringify(x);
  }
  function assertNever$1(_x2) {
  }
  let ChatCompletionStreamingRunner$1 = class ChatCompletionStreamingRunner2 extends ChatCompletionStream$1 {
    static fromReadableStream(stream) {
      const runner = new ChatCompletionStreamingRunner2(null);
      runner._run(() => runner._fromReadableStream(stream));
      return runner;
    }
    /** @deprecated - please use `runTools` instead. */
    static runFunctions(client2, params, options) {
      const runner = new ChatCompletionStreamingRunner2(null);
      const opts = {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runFunctions" }
      };
      runner._run(() => runner._runFunctions(client2, params, opts));
      return runner;
    }
    static runTools(client2, params, options) {
      const runner = new ChatCompletionStreamingRunner2(
        // @ts-expect-error TODO these types are incompatible
        params
      );
      const opts = {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runTools" }
      };
      runner._run(() => runner._runTools(client2, params, opts));
      return runner;
    }
  };
  let Completions$5 = class Completions extends APIResource$2 {
    parse(body, options) {
      validateInputTools$1(body.tools);
      return this._client.chat.completions.create(body, {
        ...options,
        headers: {
          ...options == null ? void 0 : options.headers,
          "X-Stainless-Helper-Method": "beta.chat.completions.parse"
        }
      })._thenUnwrap((completion) => parseChatCompletion$1(completion, body));
    }
    runFunctions(body, options) {
      if (body.stream) {
        return ChatCompletionStreamingRunner$1.runFunctions(this._client, body, options);
      }
      return ChatCompletionRunner$1.runFunctions(this._client, body, options);
    }
    runTools(body, options) {
      if (body.stream) {
        return ChatCompletionStreamingRunner$1.runTools(this._client, body, options);
      }
      return ChatCompletionRunner$1.runTools(this._client, body, options);
    }
    /**
     * Creates a chat completion stream
     */
    stream(body, options) {
      return ChatCompletionStream$1.createChatCompletion(this._client, body, options);
    }
  };
  let Chat$2 = class Chat extends APIResource$2 {
    constructor() {
      super(...arguments);
      this.completions = new Completions$5(this._client);
    }
  };
  (function(Chat2) {
    Chat2.Completions = Completions$5;
  })(Chat$2 || (Chat$2 = {}));
  let Sessions$1 = class Sessions extends APIResource$2 {
    /**
     * Create an ephemeral API token for use in client-side applications with the
     * Realtime API. Can be configured with the same session parameters as the
     * `session.update` client event.
     *
     * It responds with a session object, plus a `client_secret` key which contains a
     * usable ephemeral API token that can be used to authenticate browser clients for
     * the Realtime API.
     */
    create(body, options) {
      return this._client.post("/realtime/sessions", {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
  };
  let Realtime$1 = class Realtime extends APIResource$2 {
    constructor() {
      super(...arguments);
      this.sessions = new Sessions$1(this._client);
    }
  };
  Realtime$1.Sessions = Sessions$1;
  var __classPrivateFieldGet$8 = function(receiver, state, kind2, f) {
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __classPrivateFieldSet$7 = function(receiver, state, value, kind2, f) {
    if (kind2 === "m") throw new TypeError("Private method is not writable");
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var _AssistantStream_instances$1, _AssistantStream_events$1, _AssistantStream_runStepSnapshots$1, _AssistantStream_messageSnapshots$1, _AssistantStream_messageSnapshot$1, _AssistantStream_finalRun$1, _AssistantStream_currentContentIndex$1, _AssistantStream_currentContent$1, _AssistantStream_currentToolCallIndex$1, _AssistantStream_currentToolCall$1, _AssistantStream_currentEvent$1, _AssistantStream_currentRunSnapshot$1, _AssistantStream_currentRunStepSnapshot$1, _AssistantStream_addEvent$1, _AssistantStream_endRequest$1, _AssistantStream_handleMessage$1, _AssistantStream_handleRunStep$1, _AssistantStream_handleEvent$1, _AssistantStream_accumulateRunStep$1, _AssistantStream_accumulateMessage$1, _AssistantStream_accumulateContent$1, _AssistantStream_handleRun$1;
  let AssistantStream$1 = class AssistantStream2 extends EventStream$1 {
    constructor() {
      super(...arguments);
      _AssistantStream_instances$1.add(this);
      _AssistantStream_events$1.set(this, []);
      _AssistantStream_runStepSnapshots$1.set(this, {});
      _AssistantStream_messageSnapshots$1.set(this, {});
      _AssistantStream_messageSnapshot$1.set(this, void 0);
      _AssistantStream_finalRun$1.set(this, void 0);
      _AssistantStream_currentContentIndex$1.set(this, void 0);
      _AssistantStream_currentContent$1.set(this, void 0);
      _AssistantStream_currentToolCallIndex$1.set(this, void 0);
      _AssistantStream_currentToolCall$1.set(this, void 0);
      _AssistantStream_currentEvent$1.set(this, void 0);
      _AssistantStream_currentRunSnapshot$1.set(this, void 0);
      _AssistantStream_currentRunStepSnapshot$1.set(this, void 0);
    }
    [(_AssistantStream_events$1 = /* @__PURE__ */ new WeakMap(), _AssistantStream_runStepSnapshots$1 = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshots$1 = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshot$1 = /* @__PURE__ */ new WeakMap(), _AssistantStream_finalRun$1 = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContentIndex$1 = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContent$1 = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCallIndex$1 = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCall$1 = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentEvent$1 = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunSnapshot$1 = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunStepSnapshot$1 = /* @__PURE__ */ new WeakMap(), _AssistantStream_instances$1 = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
      const pushQueue = [];
      const readQueue = [];
      let done = false;
      this.on("event", (event) => {
        const reader = readQueue.shift();
        if (reader) {
          reader.resolve(event);
        } else {
          pushQueue.push(event);
        }
      });
      this.on("end", () => {
        done = true;
        for (const reader of readQueue) {
          reader.resolve(void 0);
        }
        readQueue.length = 0;
      });
      this.on("abort", (err) => {
        done = true;
        for (const reader of readQueue) {
          reader.reject(err);
        }
        readQueue.length = 0;
      });
      this.on("error", (err) => {
        done = true;
        for (const reader of readQueue) {
          reader.reject(err);
        }
        readQueue.length = 0;
      });
      return {
        next: async () => {
          if (!pushQueue.length) {
            if (done) {
              return { value: void 0, done: true };
            }
            return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
          }
          const chunk = pushQueue.shift();
          return { value: chunk, done: false };
        },
        return: async () => {
          this.abort();
          return { value: void 0, done: true };
        }
      };
    }
    static fromReadableStream(stream) {
      const runner = new AssistantStream2();
      runner._run(() => runner._fromReadableStream(stream));
      return runner;
    }
    async _fromReadableStream(readableStream, options) {
      var _a3;
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      this._connected();
      const stream = Stream$2.fromReadableStream(readableStream, this.controller);
      for await (const event of stream) {
        __classPrivateFieldGet$8(this, _AssistantStream_instances$1, "m", _AssistantStream_addEvent$1).call(this, event);
      }
      if ((_a3 = stream.controller.signal) == null ? void 0 : _a3.aborted) {
        throw new APIUserAbortError$2();
      }
      return this._addRun(__classPrivateFieldGet$8(this, _AssistantStream_instances$1, "m", _AssistantStream_endRequest$1).call(this));
    }
    toReadableStream() {
      const stream = new Stream$2(this[Symbol.asyncIterator].bind(this), this.controller);
      return stream.toReadableStream();
    }
    static createToolAssistantStream(threadId, runId, runs, params, options) {
      const runner = new AssistantStream2();
      runner._run(() => runner._runToolAssistantStream(threadId, runId, runs, params, {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
      }));
      return runner;
    }
    async _createToolAssistantStream(run, threadId, runId, params, options) {
      var _a3;
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      const body = { ...params, stream: true };
      const stream = await run.submitToolOutputs(threadId, runId, body, {
        ...options,
        signal: this.controller.signal
      });
      this._connected();
      for await (const event of stream) {
        __classPrivateFieldGet$8(this, _AssistantStream_instances$1, "m", _AssistantStream_addEvent$1).call(this, event);
      }
      if ((_a3 = stream.controller.signal) == null ? void 0 : _a3.aborted) {
        throw new APIUserAbortError$2();
      }
      return this._addRun(__classPrivateFieldGet$8(this, _AssistantStream_instances$1, "m", _AssistantStream_endRequest$1).call(this));
    }
    static createThreadAssistantStream(params, thread, options) {
      const runner = new AssistantStream2();
      runner._run(() => runner._threadAssistantStream(params, thread, {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
      }));
      return runner;
    }
    static createAssistantStream(threadId, runs, params, options) {
      const runner = new AssistantStream2();
      runner._run(() => runner._runAssistantStream(threadId, runs, params, {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
      }));
      return runner;
    }
    currentEvent() {
      return __classPrivateFieldGet$8(this, _AssistantStream_currentEvent$1, "f");
    }
    currentRun() {
      return __classPrivateFieldGet$8(this, _AssistantStream_currentRunSnapshot$1, "f");
    }
    currentMessageSnapshot() {
      return __classPrivateFieldGet$8(this, _AssistantStream_messageSnapshot$1, "f");
    }
    currentRunStepSnapshot() {
      return __classPrivateFieldGet$8(this, _AssistantStream_currentRunStepSnapshot$1, "f");
    }
    async finalRunSteps() {
      await this.done();
      return Object.values(__classPrivateFieldGet$8(this, _AssistantStream_runStepSnapshots$1, "f"));
    }
    async finalMessages() {
      await this.done();
      return Object.values(__classPrivateFieldGet$8(this, _AssistantStream_messageSnapshots$1, "f"));
    }
    async finalRun() {
      await this.done();
      if (!__classPrivateFieldGet$8(this, _AssistantStream_finalRun$1, "f"))
        throw Error("Final run was not received.");
      return __classPrivateFieldGet$8(this, _AssistantStream_finalRun$1, "f");
    }
    async _createThreadAssistantStream(thread, params, options) {
      var _a3;
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      const body = { ...params, stream: true };
      const stream = await thread.createAndRun(body, { ...options, signal: this.controller.signal });
      this._connected();
      for await (const event of stream) {
        __classPrivateFieldGet$8(this, _AssistantStream_instances$1, "m", _AssistantStream_addEvent$1).call(this, event);
      }
      if ((_a3 = stream.controller.signal) == null ? void 0 : _a3.aborted) {
        throw new APIUserAbortError$2();
      }
      return this._addRun(__classPrivateFieldGet$8(this, _AssistantStream_instances$1, "m", _AssistantStream_endRequest$1).call(this));
    }
    async _createAssistantStream(run, threadId, params, options) {
      var _a3;
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      const body = { ...params, stream: true };
      const stream = await run.create(threadId, body, { ...options, signal: this.controller.signal });
      this._connected();
      for await (const event of stream) {
        __classPrivateFieldGet$8(this, _AssistantStream_instances$1, "m", _AssistantStream_addEvent$1).call(this, event);
      }
      if ((_a3 = stream.controller.signal) == null ? void 0 : _a3.aborted) {
        throw new APIUserAbortError$2();
      }
      return this._addRun(__classPrivateFieldGet$8(this, _AssistantStream_instances$1, "m", _AssistantStream_endRequest$1).call(this));
    }
    static accumulateDelta(acc, delta) {
      for (const [key, deltaValue] of Object.entries(delta)) {
        if (!acc.hasOwnProperty(key)) {
          acc[key] = deltaValue;
          continue;
        }
        let accValue = acc[key];
        if (accValue === null || accValue === void 0) {
          acc[key] = deltaValue;
          continue;
        }
        if (key === "index" || key === "type") {
          acc[key] = deltaValue;
          continue;
        }
        if (typeof accValue === "string" && typeof deltaValue === "string") {
          accValue += deltaValue;
        } else if (typeof accValue === "number" && typeof deltaValue === "number") {
          accValue += deltaValue;
        } else if (isObj$1(accValue) && isObj$1(deltaValue)) {
          accValue = this.accumulateDelta(accValue, deltaValue);
        } else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {
          if (accValue.every((x) => typeof x === "string" || typeof x === "number")) {
            accValue.push(...deltaValue);
            continue;
          }
          for (const deltaEntry of deltaValue) {
            if (!isObj$1(deltaEntry)) {
              throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);
            }
            const index = deltaEntry["index"];
            if (index == null) {
              console.error(deltaEntry);
              throw new Error("Expected array delta entry to have an `index` property");
            }
            if (typeof index !== "number") {
              throw new Error(`Expected array delta entry \`index\` property to be a number but got ${index}`);
            }
            const accEntry = accValue[index];
            if (accEntry == null) {
              accValue.push(deltaEntry);
            } else {
              accValue[index] = this.accumulateDelta(accEntry, deltaEntry);
            }
          }
          continue;
        } else {
          throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);
        }
        acc[key] = accValue;
      }
      return acc;
    }
    _addRun(run) {
      return run;
    }
    async _threadAssistantStream(params, thread, options) {
      return await this._createThreadAssistantStream(thread, params, options);
    }
    async _runAssistantStream(threadId, runs, params, options) {
      return await this._createAssistantStream(runs, threadId, params, options);
    }
    async _runToolAssistantStream(threadId, runId, runs, params, options) {
      return await this._createToolAssistantStream(runs, threadId, runId, params, options);
    }
  };
  _AssistantStream_addEvent$1 = function _AssistantStream_addEvent2(event) {
    if (this.ended)
      return;
    __classPrivateFieldSet$7(this, _AssistantStream_currentEvent$1, event, "f");
    __classPrivateFieldGet$8(this, _AssistantStream_instances$1, "m", _AssistantStream_handleEvent$1).call(this, event);
    switch (event.event) {
      case "thread.created":
        break;
      case "thread.run.created":
      case "thread.run.queued":
      case "thread.run.in_progress":
      case "thread.run.requires_action":
      case "thread.run.completed":
      case "thread.run.failed":
      case "thread.run.cancelling":
      case "thread.run.cancelled":
      case "thread.run.expired":
        __classPrivateFieldGet$8(this, _AssistantStream_instances$1, "m", _AssistantStream_handleRun$1).call(this, event);
        break;
      case "thread.run.step.created":
      case "thread.run.step.in_progress":
      case "thread.run.step.delta":
      case "thread.run.step.completed":
      case "thread.run.step.failed":
      case "thread.run.step.cancelled":
      case "thread.run.step.expired":
        __classPrivateFieldGet$8(this, _AssistantStream_instances$1, "m", _AssistantStream_handleRunStep$1).call(this, event);
        break;
      case "thread.message.created":
      case "thread.message.in_progress":
      case "thread.message.delta":
      case "thread.message.completed":
      case "thread.message.incomplete":
        __classPrivateFieldGet$8(this, _AssistantStream_instances$1, "m", _AssistantStream_handleMessage$1).call(this, event);
        break;
      case "error":
        throw new Error("Encountered an error event in event processing - errors should be processed earlier");
    }
  }, _AssistantStream_endRequest$1 = function _AssistantStream_endRequest2() {
    if (this.ended) {
      throw new OpenAIError$1(`stream has ended, this shouldn't happen`);
    }
    if (!__classPrivateFieldGet$8(this, _AssistantStream_finalRun$1, "f"))
      throw Error("Final run has not been received");
    return __classPrivateFieldGet$8(this, _AssistantStream_finalRun$1, "f");
  }, _AssistantStream_handleMessage$1 = function _AssistantStream_handleMessage2(event) {
    const [accumulatedMessage, newContent] = __classPrivateFieldGet$8(this, _AssistantStream_instances$1, "m", _AssistantStream_accumulateMessage$1).call(this, event, __classPrivateFieldGet$8(this, _AssistantStream_messageSnapshot$1, "f"));
    __classPrivateFieldSet$7(this, _AssistantStream_messageSnapshot$1, accumulatedMessage, "f");
    __classPrivateFieldGet$8(this, _AssistantStream_messageSnapshots$1, "f")[accumulatedMessage.id] = accumulatedMessage;
    for (const content of newContent) {
      const snapshotContent = accumulatedMessage.content[content.index];
      if ((snapshotContent == null ? void 0 : snapshotContent.type) == "text") {
        this._emit("textCreated", snapshotContent.text);
      }
    }
    switch (event.event) {
      case "thread.message.created":
        this._emit("messageCreated", event.data);
        break;
      case "thread.message.in_progress":
        break;
      case "thread.message.delta":
        this._emit("messageDelta", event.data.delta, accumulatedMessage);
        if (event.data.delta.content) {
          for (const content of event.data.delta.content) {
            if (content.type == "text" && content.text) {
              let textDelta = content.text;
              let snapshot = accumulatedMessage.content[content.index];
              if (snapshot && snapshot.type == "text") {
                this._emit("textDelta", textDelta, snapshot.text);
              } else {
                throw Error("The snapshot associated with this text delta is not text or missing");
              }
            }
            if (content.index != __classPrivateFieldGet$8(this, _AssistantStream_currentContentIndex$1, "f")) {
              if (__classPrivateFieldGet$8(this, _AssistantStream_currentContent$1, "f")) {
                switch (__classPrivateFieldGet$8(this, _AssistantStream_currentContent$1, "f").type) {
                  case "text":
                    this._emit("textDone", __classPrivateFieldGet$8(this, _AssistantStream_currentContent$1, "f").text, __classPrivateFieldGet$8(this, _AssistantStream_messageSnapshot$1, "f"));
                    break;
                  case "image_file":
                    this._emit("imageFileDone", __classPrivateFieldGet$8(this, _AssistantStream_currentContent$1, "f").image_file, __classPrivateFieldGet$8(this, _AssistantStream_messageSnapshot$1, "f"));
                    break;
                }
              }
              __classPrivateFieldSet$7(this, _AssistantStream_currentContentIndex$1, content.index, "f");
            }
            __classPrivateFieldSet$7(this, _AssistantStream_currentContent$1, accumulatedMessage.content[content.index], "f");
          }
        }
        break;
      case "thread.message.completed":
      case "thread.message.incomplete":
        if (__classPrivateFieldGet$8(this, _AssistantStream_currentContentIndex$1, "f") !== void 0) {
          const currentContent = event.data.content[__classPrivateFieldGet$8(this, _AssistantStream_currentContentIndex$1, "f")];
          if (currentContent) {
            switch (currentContent.type) {
              case "image_file":
                this._emit("imageFileDone", currentContent.image_file, __classPrivateFieldGet$8(this, _AssistantStream_messageSnapshot$1, "f"));
                break;
              case "text":
                this._emit("textDone", currentContent.text, __classPrivateFieldGet$8(this, _AssistantStream_messageSnapshot$1, "f"));
                break;
            }
          }
        }
        if (__classPrivateFieldGet$8(this, _AssistantStream_messageSnapshot$1, "f")) {
          this._emit("messageDone", event.data);
        }
        __classPrivateFieldSet$7(this, _AssistantStream_messageSnapshot$1, void 0, "f");
    }
  }, _AssistantStream_handleRunStep$1 = function _AssistantStream_handleRunStep2(event) {
    const accumulatedRunStep = __classPrivateFieldGet$8(this, _AssistantStream_instances$1, "m", _AssistantStream_accumulateRunStep$1).call(this, event);
    __classPrivateFieldSet$7(this, _AssistantStream_currentRunStepSnapshot$1, accumulatedRunStep, "f");
    switch (event.event) {
      case "thread.run.step.created":
        this._emit("runStepCreated", event.data);
        break;
      case "thread.run.step.delta":
        const delta = event.data.delta;
        if (delta.step_details && delta.step_details.type == "tool_calls" && delta.step_details.tool_calls && accumulatedRunStep.step_details.type == "tool_calls") {
          for (const toolCall of delta.step_details.tool_calls) {
            if (toolCall.index == __classPrivateFieldGet$8(this, _AssistantStream_currentToolCallIndex$1, "f")) {
              this._emit("toolCallDelta", toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);
            } else {
              if (__classPrivateFieldGet$8(this, _AssistantStream_currentToolCall$1, "f")) {
                this._emit("toolCallDone", __classPrivateFieldGet$8(this, _AssistantStream_currentToolCall$1, "f"));
              }
              __classPrivateFieldSet$7(this, _AssistantStream_currentToolCallIndex$1, toolCall.index, "f");
              __classPrivateFieldSet$7(this, _AssistantStream_currentToolCall$1, accumulatedRunStep.step_details.tool_calls[toolCall.index], "f");
              if (__classPrivateFieldGet$8(this, _AssistantStream_currentToolCall$1, "f"))
                this._emit("toolCallCreated", __classPrivateFieldGet$8(this, _AssistantStream_currentToolCall$1, "f"));
            }
          }
        }
        this._emit("runStepDelta", event.data.delta, accumulatedRunStep);
        break;
      case "thread.run.step.completed":
      case "thread.run.step.failed":
      case "thread.run.step.cancelled":
      case "thread.run.step.expired":
        __classPrivateFieldSet$7(this, _AssistantStream_currentRunStepSnapshot$1, void 0, "f");
        const details = event.data.step_details;
        if (details.type == "tool_calls") {
          if (__classPrivateFieldGet$8(this, _AssistantStream_currentToolCall$1, "f")) {
            this._emit("toolCallDone", __classPrivateFieldGet$8(this, _AssistantStream_currentToolCall$1, "f"));
            __classPrivateFieldSet$7(this, _AssistantStream_currentToolCall$1, void 0, "f");
          }
        }
        this._emit("runStepDone", event.data, accumulatedRunStep);
        break;
    }
  }, _AssistantStream_handleEvent$1 = function _AssistantStream_handleEvent2(event) {
    __classPrivateFieldGet$8(this, _AssistantStream_events$1, "f").push(event);
    this._emit("event", event);
  }, _AssistantStream_accumulateRunStep$1 = function _AssistantStream_accumulateRunStep2(event) {
    switch (event.event) {
      case "thread.run.step.created":
        __classPrivateFieldGet$8(this, _AssistantStream_runStepSnapshots$1, "f")[event.data.id] = event.data;
        return event.data;
      case "thread.run.step.delta":
        let snapshot = __classPrivateFieldGet$8(this, _AssistantStream_runStepSnapshots$1, "f")[event.data.id];
        if (!snapshot) {
          throw Error("Received a RunStepDelta before creation of a snapshot");
        }
        let data = event.data;
        if (data.delta) {
          const accumulated = AssistantStream$1.accumulateDelta(snapshot, data.delta);
          __classPrivateFieldGet$8(this, _AssistantStream_runStepSnapshots$1, "f")[event.data.id] = accumulated;
        }
        return __classPrivateFieldGet$8(this, _AssistantStream_runStepSnapshots$1, "f")[event.data.id];
      case "thread.run.step.completed":
      case "thread.run.step.failed":
      case "thread.run.step.cancelled":
      case "thread.run.step.expired":
      case "thread.run.step.in_progress":
        __classPrivateFieldGet$8(this, _AssistantStream_runStepSnapshots$1, "f")[event.data.id] = event.data;
        break;
    }
    if (__classPrivateFieldGet$8(this, _AssistantStream_runStepSnapshots$1, "f")[event.data.id])
      return __classPrivateFieldGet$8(this, _AssistantStream_runStepSnapshots$1, "f")[event.data.id];
    throw new Error("No snapshot available");
  }, _AssistantStream_accumulateMessage$1 = function _AssistantStream_accumulateMessage2(event, snapshot) {
    let newContent = [];
    switch (event.event) {
      case "thread.message.created":
        return [event.data, newContent];
      case "thread.message.delta":
        if (!snapshot) {
          throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
        }
        let data = event.data;
        if (data.delta.content) {
          for (const contentElement of data.delta.content) {
            if (contentElement.index in snapshot.content) {
              let currentContent = snapshot.content[contentElement.index];
              snapshot.content[contentElement.index] = __classPrivateFieldGet$8(this, _AssistantStream_instances$1, "m", _AssistantStream_accumulateContent$1).call(this, contentElement, currentContent);
            } else {
              snapshot.content[contentElement.index] = contentElement;
              newContent.push(contentElement);
            }
          }
        }
        return [snapshot, newContent];
      case "thread.message.in_progress":
      case "thread.message.completed":
      case "thread.message.incomplete":
        if (snapshot) {
          return [snapshot, newContent];
        } else {
          throw Error("Received thread message event with no existing snapshot");
        }
    }
    throw Error("Tried to accumulate a non-message event");
  }, _AssistantStream_accumulateContent$1 = function _AssistantStream_accumulateContent2(contentElement, currentContent) {
    return AssistantStream$1.accumulateDelta(currentContent, contentElement);
  }, _AssistantStream_handleRun$1 = function _AssistantStream_handleRun2(event) {
    __classPrivateFieldSet$7(this, _AssistantStream_currentRunSnapshot$1, event.data, "f");
    switch (event.event) {
      case "thread.run.created":
        break;
      case "thread.run.queued":
        break;
      case "thread.run.in_progress":
        break;
      case "thread.run.requires_action":
      case "thread.run.cancelled":
      case "thread.run.failed":
      case "thread.run.completed":
      case "thread.run.expired":
        __classPrivateFieldSet$7(this, _AssistantStream_finalRun$1, event.data, "f");
        if (__classPrivateFieldGet$8(this, _AssistantStream_currentToolCall$1, "f")) {
          this._emit("toolCallDone", __classPrivateFieldGet$8(this, _AssistantStream_currentToolCall$1, "f"));
          __classPrivateFieldSet$7(this, _AssistantStream_currentToolCall$1, void 0, "f");
        }
        break;
    }
  };
  let Messages$4 = class Messages extends APIResource$2 {
    /**
     * Create a message.
     */
    create(threadId, body, options) {
      return this._client.post(`/threads/${threadId}/messages`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Retrieve a message.
     */
    retrieve(threadId, messageId, options) {
      return this._client.get(`/threads/${threadId}/messages/${messageId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Modifies a message.
     */
    update(threadId, messageId, body, options) {
      return this._client.post(`/threads/${threadId}/messages/${messageId}`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    list(threadId, query = {}, options) {
      if (isRequestOptions$2(query)) {
        return this.list(threadId, {}, query);
      }
      return this._client.getAPIList(`/threads/${threadId}/messages`, MessagesPage$1, {
        query,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Deletes a message.
     */
    del(threadId, messageId, options) {
      return this._client.delete(`/threads/${threadId}/messages/${messageId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
  };
  let MessagesPage$1 = class MessagesPage extends CursorPage$1 {
  };
  Messages$4.MessagesPage = MessagesPage$1;
  let Steps$1 = class Steps extends APIResource$2 {
    retrieve(threadId, runId, stepId, query = {}, options) {
      if (isRequestOptions$2(query)) {
        return this.retrieve(threadId, runId, stepId, {}, query);
      }
      return this._client.get(`/threads/${threadId}/runs/${runId}/steps/${stepId}`, {
        query,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    list(threadId, runId, query = {}, options) {
      if (isRequestOptions$2(query)) {
        return this.list(threadId, runId, {}, query);
      }
      return this._client.getAPIList(`/threads/${threadId}/runs/${runId}/steps`, RunStepsPage$1, {
        query,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
  };
  let RunStepsPage$1 = class RunStepsPage extends CursorPage$1 {
  };
  Steps$1.RunStepsPage = RunStepsPage$1;
  let Runs$1 = class Runs extends APIResource$2 {
    constructor() {
      super(...arguments);
      this.steps = new Steps$1(this._client);
    }
    create(threadId, params, options) {
      const { include, ...body } = params;
      return this._client.post(`/threads/${threadId}/runs`, {
        query: { include },
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers },
        stream: params.stream ?? false
      });
    }
    /**
     * Retrieves a run.
     */
    retrieve(threadId, runId, options) {
      return this._client.get(`/threads/${threadId}/runs/${runId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Modifies a run.
     */
    update(threadId, runId, body, options) {
      return this._client.post(`/threads/${threadId}/runs/${runId}`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    list(threadId, query = {}, options) {
      if (isRequestOptions$2(query)) {
        return this.list(threadId, {}, query);
      }
      return this._client.getAPIList(`/threads/${threadId}/runs`, RunsPage$1, {
        query,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Cancels a run that is `in_progress`.
     */
    cancel(threadId, runId, options) {
      return this._client.post(`/threads/${threadId}/runs/${runId}/cancel`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * A helper to create a run an poll for a terminal state. More information on Run
     * lifecycles can be found here:
     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
     */
    async createAndPoll(threadId, body, options) {
      const run = await this.create(threadId, body, options);
      return await this.poll(threadId, run.id, options);
    }
    /**
     * Create a Run stream
     *
     * @deprecated use `stream` instead
     */
    createAndStream(threadId, body, options) {
      return AssistantStream$1.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
    }
    /**
     * A helper to poll a run status until it reaches a terminal state. More
     * information on Run lifecycles can be found here:
     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
     */
    async poll(threadId, runId, options) {
      const headers = { ...options == null ? void 0 : options.headers, "X-Stainless-Poll-Helper": "true" };
      if (options == null ? void 0 : options.pollIntervalMs) {
        headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
      }
      while (true) {
        const { data: run, response } = await this.retrieve(threadId, runId, {
          ...options,
          headers: { ...options == null ? void 0 : options.headers, ...headers }
        }).withResponse();
        switch (run.status) {
          //If we are in any sort of intermediate state we poll
          case "queued":
          case "in_progress":
          case "cancelling":
            let sleepInterval = 5e3;
            if (options == null ? void 0 : options.pollIntervalMs) {
              sleepInterval = options.pollIntervalMs;
            } else {
              const headerInterval = response.headers.get("openai-poll-after-ms");
              if (headerInterval) {
                const headerIntervalMs = parseInt(headerInterval);
                if (!isNaN(headerIntervalMs)) {
                  sleepInterval = headerIntervalMs;
                }
              }
            }
            await sleep$2(sleepInterval);
            break;
          //We return the run in any terminal state.
          case "requires_action":
          case "incomplete":
          case "cancelled":
          case "completed":
          case "failed":
          case "expired":
            return run;
        }
      }
    }
    /**
     * Create a Run stream
     */
    stream(threadId, body, options) {
      return AssistantStream$1.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
    }
    submitToolOutputs(threadId, runId, body, options) {
      return this._client.post(`/threads/${threadId}/runs/${runId}/submit_tool_outputs`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers },
        stream: body.stream ?? false
      });
    }
    /**
     * A helper to submit a tool output to a run and poll for a terminal run state.
     * More information on Run lifecycles can be found here:
     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
     */
    async submitToolOutputsAndPoll(threadId, runId, body, options) {
      const run = await this.submitToolOutputs(threadId, runId, body, options);
      return await this.poll(threadId, run.id, options);
    }
    /**
     * Submit the tool outputs from a previous run and stream the run to a terminal
     * state. More information on Run lifecycles can be found here:
     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
     */
    submitToolOutputsStream(threadId, runId, body, options) {
      return AssistantStream$1.createToolAssistantStream(threadId, runId, this._client.beta.threads.runs, body, options);
    }
  };
  let RunsPage$1 = class RunsPage extends CursorPage$1 {
  };
  Runs$1.RunsPage = RunsPage$1;
  Runs$1.Steps = Steps$1;
  Runs$1.RunStepsPage = RunStepsPage$1;
  let Threads$1 = class Threads extends APIResource$2 {
    constructor() {
      super(...arguments);
      this.runs = new Runs$1(this._client);
      this.messages = new Messages$4(this._client);
    }
    create(body = {}, options) {
      if (isRequestOptions$2(body)) {
        return this.create({}, body);
      }
      return this._client.post("/threads", {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Retrieves a thread.
     */
    retrieve(threadId, options) {
      return this._client.get(`/threads/${threadId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Modifies a thread.
     */
    update(threadId, body, options) {
      return this._client.post(`/threads/${threadId}`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Delete a thread.
     */
    del(threadId, options) {
      return this._client.delete(`/threads/${threadId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    createAndRun(body, options) {
      return this._client.post("/threads/runs", {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers },
        stream: body.stream ?? false
      });
    }
    /**
     * A helper to create a thread, start a run and then poll for a terminal state.
     * More information on Run lifecycles can be found here:
     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
     */
    async createAndRunPoll(body, options) {
      const run = await this.createAndRun(body, options);
      return await this.runs.poll(run.thread_id, run.id, options);
    }
    /**
     * Create a thread and stream the run back
     */
    createAndRunStream(body, options) {
      return AssistantStream$1.createThreadAssistantStream(body, this._client.beta.threads, options);
    }
  };
  Threads$1.Runs = Runs$1;
  Threads$1.RunsPage = RunsPage$1;
  Threads$1.Messages = Messages$4;
  Threads$1.MessagesPage = MessagesPage$1;
  const allSettledWithThrow$1 = async (promises) => {
    const results = await Promise.allSettled(promises);
    const rejected = results.filter((result) => result.status === "rejected");
    if (rejected.length) {
      for (const result of rejected) {
        console.error(result.reason);
      }
      throw new Error(`${rejected.length} promise(s) failed - see the above errors`);
    }
    const values = [];
    for (const result of results) {
      if (result.status === "fulfilled") {
        values.push(result.value);
      }
    }
    return values;
  };
  let Files$3 = class Files extends APIResource$2 {
    /**
     * Create a vector store file by attaching a
     * [File](https://platform.openai.com/docs/api-reference/files) to a
     * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
     */
    create(vectorStoreId, body, options) {
      return this._client.post(`/vector_stores/${vectorStoreId}/files`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Retrieves a vector store file.
     */
    retrieve(vectorStoreId, fileId, options) {
      return this._client.get(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    list(vectorStoreId, query = {}, options) {
      if (isRequestOptions$2(query)) {
        return this.list(vectorStoreId, {}, query);
      }
      return this._client.getAPIList(`/vector_stores/${vectorStoreId}/files`, VectorStoreFilesPage$1, {
        query,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Delete a vector store file. This will remove the file from the vector store but
     * the file itself will not be deleted. To delete the file, use the
     * [delete file](https://platform.openai.com/docs/api-reference/files/delete)
     * endpoint.
     */
    del(vectorStoreId, fileId, options) {
      return this._client.delete(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Attach a file to the given vector store and wait for it to be processed.
     */
    async createAndPoll(vectorStoreId, body, options) {
      const file = await this.create(vectorStoreId, body, options);
      return await this.poll(vectorStoreId, file.id, options);
    }
    /**
     * Wait for the vector store file to finish processing.
     *
     * Note: this will return even if the file failed to process, you need to check
     * file.last_error and file.status to handle these cases
     */
    async poll(vectorStoreId, fileId, options) {
      const headers = { ...options == null ? void 0 : options.headers, "X-Stainless-Poll-Helper": "true" };
      if (options == null ? void 0 : options.pollIntervalMs) {
        headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
      }
      while (true) {
        const fileResponse = await this.retrieve(vectorStoreId, fileId, {
          ...options,
          headers
        }).withResponse();
        const file = fileResponse.data;
        switch (file.status) {
          case "in_progress":
            let sleepInterval = 5e3;
            if (options == null ? void 0 : options.pollIntervalMs) {
              sleepInterval = options.pollIntervalMs;
            } else {
              const headerInterval = fileResponse.response.headers.get("openai-poll-after-ms");
              if (headerInterval) {
                const headerIntervalMs = parseInt(headerInterval);
                if (!isNaN(headerIntervalMs)) {
                  sleepInterval = headerIntervalMs;
                }
              }
            }
            await sleep$2(sleepInterval);
            break;
          case "failed":
          case "completed":
            return file;
        }
      }
    }
    /**
     * Upload a file to the `files` API and then attach it to the given vector store.
     *
     * Note the file will be asynchronously processed (you can use the alternative
     * polling helper method to wait for processing to complete).
     */
    async upload(vectorStoreId, file, options) {
      const fileInfo = await this._client.files.create({ file, purpose: "assistants" }, options);
      return this.create(vectorStoreId, { file_id: fileInfo.id }, options);
    }
    /**
     * Add a file to a vector store and poll until processing is complete.
     */
    async uploadAndPoll(vectorStoreId, file, options) {
      const fileInfo = await this.upload(vectorStoreId, file, options);
      return await this.poll(vectorStoreId, fileInfo.id, options);
    }
  };
  let VectorStoreFilesPage$1 = class VectorStoreFilesPage extends CursorPage$1 {
  };
  Files$3.VectorStoreFilesPage = VectorStoreFilesPage$1;
  let FileBatches$1 = class FileBatches extends APIResource$2 {
    /**
     * Create a vector store file batch.
     */
    create(vectorStoreId, body, options) {
      return this._client.post(`/vector_stores/${vectorStoreId}/file_batches`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Retrieves a vector store file batch.
     */
    retrieve(vectorStoreId, batchId, options) {
      return this._client.get(`/vector_stores/${vectorStoreId}/file_batches/${batchId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Cancel a vector store file batch. This attempts to cancel the processing of
     * files in this batch as soon as possible.
     */
    cancel(vectorStoreId, batchId, options) {
      return this._client.post(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/cancel`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Create a vector store batch and poll until all files have been processed.
     */
    async createAndPoll(vectorStoreId, body, options) {
      const batch = await this.create(vectorStoreId, body);
      return await this.poll(vectorStoreId, batch.id, options);
    }
    listFiles(vectorStoreId, batchId, query = {}, options) {
      if (isRequestOptions$2(query)) {
        return this.listFiles(vectorStoreId, batchId, {}, query);
      }
      return this._client.getAPIList(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/files`, VectorStoreFilesPage$1, { query, ...options, headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers } });
    }
    /**
     * Wait for the given file batch to be processed.
     *
     * Note: this will return even if one of the files failed to process, you need to
     * check batch.file_counts.failed_count to handle this case.
     */
    async poll(vectorStoreId, batchId, options) {
      const headers = { ...options == null ? void 0 : options.headers, "X-Stainless-Poll-Helper": "true" };
      if (options == null ? void 0 : options.pollIntervalMs) {
        headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
      }
      while (true) {
        const { data: batch, response } = await this.retrieve(vectorStoreId, batchId, {
          ...options,
          headers
        }).withResponse();
        switch (batch.status) {
          case "in_progress":
            let sleepInterval = 5e3;
            if (options == null ? void 0 : options.pollIntervalMs) {
              sleepInterval = options.pollIntervalMs;
            } else {
              const headerInterval = response.headers.get("openai-poll-after-ms");
              if (headerInterval) {
                const headerIntervalMs = parseInt(headerInterval);
                if (!isNaN(headerIntervalMs)) {
                  sleepInterval = headerIntervalMs;
                }
              }
            }
            await sleep$2(sleepInterval);
            break;
          case "failed":
          case "cancelled":
          case "completed":
            return batch;
        }
      }
    }
    /**
     * Uploads the given files concurrently and then creates a vector store file batch.
     *
     * The concurrency limit is configurable using the `maxConcurrency` parameter.
     */
    async uploadAndPoll(vectorStoreId, { files, fileIds = [] }, options) {
      if (files == null || files.length == 0) {
        throw new Error(`No \`files\` provided to process. If you've already uploaded files you should use \`.createAndPoll()\` instead`);
      }
      const configuredConcurrency = (options == null ? void 0 : options.maxConcurrency) ?? 5;
      const concurrencyLimit = Math.min(configuredConcurrency, files.length);
      const client2 = this._client;
      const fileIterator = files.values();
      const allFileIds = [...fileIds];
      async function processFiles(iterator2) {
        for (let item of iterator2) {
          const fileObj = await client2.files.create({ file: item, purpose: "assistants" }, options);
          allFileIds.push(fileObj.id);
        }
      }
      const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);
      await allSettledWithThrow$1(workers);
      return await this.createAndPoll(vectorStoreId, {
        file_ids: allFileIds
      });
    }
  };
  let VectorStores$1 = class VectorStores extends APIResource$2 {
    constructor() {
      super(...arguments);
      this.files = new Files$3(this._client);
      this.fileBatches = new FileBatches$1(this._client);
    }
    /**
     * Create a vector store.
     */
    create(body, options) {
      return this._client.post("/vector_stores", {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Retrieves a vector store.
     */
    retrieve(vectorStoreId, options) {
      return this._client.get(`/vector_stores/${vectorStoreId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Modifies a vector store.
     */
    update(vectorStoreId, body, options) {
      return this._client.post(`/vector_stores/${vectorStoreId}`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    list(query = {}, options) {
      if (isRequestOptions$2(query)) {
        return this.list({}, query);
      }
      return this._client.getAPIList("/vector_stores", VectorStoresPage$1, {
        query,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Delete a vector store.
     */
    del(vectorStoreId, options) {
      return this._client.delete(`/vector_stores/${vectorStoreId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
  };
  let VectorStoresPage$1 = class VectorStoresPage extends CursorPage$1 {
  };
  VectorStores$1.VectorStoresPage = VectorStoresPage$1;
  VectorStores$1.Files = Files$3;
  VectorStores$1.VectorStoreFilesPage = VectorStoreFilesPage$1;
  VectorStores$1.FileBatches = FileBatches$1;
  let Beta$2 = class Beta extends APIResource$2 {
    constructor() {
      super(...arguments);
      this.realtime = new Realtime$1(this._client);
      this.vectorStores = new VectorStores$1(this._client);
      this.chat = new Chat$2(this._client);
      this.assistants = new Assistants$1(this._client);
      this.threads = new Threads$1(this._client);
    }
  };
  Beta$2.Realtime = Realtime$1;
  Beta$2.VectorStores = VectorStores$1;
  Beta$2.VectorStoresPage = VectorStoresPage$1;
  Beta$2.Assistants = Assistants$1;
  Beta$2.AssistantsPage = AssistantsPage$1;
  Beta$2.Threads = Threads$1;
  let Completions$4 = class Completions extends APIResource$2 {
    create(body, options) {
      return this._client.post("/completions", { body, ...options, stream: body.stream ?? false });
    }
  };
  let Embeddings$1 = class Embeddings extends APIResource$2 {
    /**
     * Creates an embedding vector representing the input text.
     */
    create(body, options) {
      return this._client.post("/embeddings", { body, ...options });
    }
  };
  let Files$2 = class Files extends APIResource$2 {
    /**
     * Upload a file that can be used across various endpoints. Individual files can be
     * up to 512 MB, and the size of all files uploaded by one organization can be up
     * to 100 GB.
     *
     * The Assistants API supports files up to 2 million tokens and of specific file
     * types. See the
     * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) for
     * details.
     *
     * The Fine-tuning API only supports `.jsonl` files. The input also has certain
     * required formats for fine-tuning
     * [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or
     * [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
     * models.
     *
     * The Batch API only supports `.jsonl` files up to 200 MB in size. The input also
     * has a specific required
     * [format](https://platform.openai.com/docs/api-reference/batch/request-input).
     *
     * Please [contact us](https://help.openai.com/) if you need to increase these
     * storage limits.
     */
    create(body, options) {
      return this._client.post("/files", multipartFormRequestOptions$1({ body, ...options }));
    }
    /**
     * Returns information about a specific file.
     */
    retrieve(fileId, options) {
      return this._client.get(`/files/${fileId}`, options);
    }
    list(query = {}, options) {
      if (isRequestOptions$2(query)) {
        return this.list({}, query);
      }
      return this._client.getAPIList("/files", FileObjectsPage$1, { query, ...options });
    }
    /**
     * Delete a file.
     */
    del(fileId, options) {
      return this._client.delete(`/files/${fileId}`, options);
    }
    /**
     * Returns the contents of the specified file.
     */
    content(fileId, options) {
      return this._client.get(`/files/${fileId}/content`, {
        ...options,
        headers: { Accept: "application/binary", ...options == null ? void 0 : options.headers },
        __binaryResponse: true
      });
    }
    /**
     * Returns the contents of the specified file.
     *
     * @deprecated The `.content()` method should be used instead
     */
    retrieveContent(fileId, options) {
      return this._client.get(`/files/${fileId}/content`, options);
    }
    /**
     * Waits for the given file to be processed, default timeout is 30 mins.
     */
    async waitForProcessing(id, { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}) {
      const TERMINAL_STATES = /* @__PURE__ */ new Set(["processed", "error", "deleted"]);
      const start = Date.now();
      let file = await this.retrieve(id);
      while (!file.status || !TERMINAL_STATES.has(file.status)) {
        await sleep$2(pollInterval);
        file = await this.retrieve(id);
        if (Date.now() - start > maxWait) {
          throw new APIConnectionTimeoutError$2({
            message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
          });
        }
      }
      return file;
    }
  };
  let FileObjectsPage$1 = class FileObjectsPage extends CursorPage$1 {
  };
  Files$2.FileObjectsPage = FileObjectsPage$1;
  let Checkpoints$1 = class Checkpoints extends APIResource$2 {
    list(fineTuningJobId, query = {}, options) {
      if (isRequestOptions$2(query)) {
        return this.list(fineTuningJobId, {}, query);
      }
      return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/checkpoints`, FineTuningJobCheckpointsPage$1, { query, ...options });
    }
  };
  let FineTuningJobCheckpointsPage$1 = class FineTuningJobCheckpointsPage extends CursorPage$1 {
  };
  Checkpoints$1.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage$1;
  let Jobs$1 = class Jobs extends APIResource$2 {
    constructor() {
      super(...arguments);
      this.checkpoints = new Checkpoints$1(this._client);
    }
    /**
     * Creates a fine-tuning job which begins the process of creating a new model from
     * a given dataset.
     *
     * Response includes details of the enqueued job including job status and the name
     * of the fine-tuned models once complete.
     *
     * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
     */
    create(body, options) {
      return this._client.post("/fine_tuning/jobs", { body, ...options });
    }
    /**
     * Get info about a fine-tuning job.
     *
     * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
     */
    retrieve(fineTuningJobId, options) {
      return this._client.get(`/fine_tuning/jobs/${fineTuningJobId}`, options);
    }
    list(query = {}, options) {
      if (isRequestOptions$2(query)) {
        return this.list({}, query);
      }
      return this._client.getAPIList("/fine_tuning/jobs", FineTuningJobsPage$1, { query, ...options });
    }
    /**
     * Immediately cancel a fine-tune job.
     */
    cancel(fineTuningJobId, options) {
      return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`, options);
    }
    listEvents(fineTuningJobId, query = {}, options) {
      if (isRequestOptions$2(query)) {
        return this.listEvents(fineTuningJobId, {}, query);
      }
      return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/events`, FineTuningJobEventsPage$1, {
        query,
        ...options
      });
    }
  };
  let FineTuningJobsPage$1 = class FineTuningJobsPage extends CursorPage$1 {
  };
  let FineTuningJobEventsPage$1 = class FineTuningJobEventsPage extends CursorPage$1 {
  };
  Jobs$1.FineTuningJobsPage = FineTuningJobsPage$1;
  Jobs$1.FineTuningJobEventsPage = FineTuningJobEventsPage$1;
  Jobs$1.Checkpoints = Checkpoints$1;
  Jobs$1.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage$1;
  let FineTuning$1 = class FineTuning extends APIResource$2 {
    constructor() {
      super(...arguments);
      this.jobs = new Jobs$1(this._client);
    }
  };
  FineTuning$1.Jobs = Jobs$1;
  FineTuning$1.FineTuningJobsPage = FineTuningJobsPage$1;
  FineTuning$1.FineTuningJobEventsPage = FineTuningJobEventsPage$1;
  let Images$1 = class Images extends APIResource$2 {
    /**
     * Creates a variation of a given image.
     */
    createVariation(body, options) {
      return this._client.post("/images/variations", multipartFormRequestOptions$1({ body, ...options }));
    }
    /**
     * Creates an edited or extended image given an original image and a prompt.
     */
    edit(body, options) {
      return this._client.post("/images/edits", multipartFormRequestOptions$1({ body, ...options }));
    }
    /**
     * Creates an image given a prompt.
     */
    generate(body, options) {
      return this._client.post("/images/generations", { body, ...options });
    }
  };
  let Models$1 = class Models extends APIResource$2 {
    /**
     * Retrieves a model instance, providing basic information about the model such as
     * the owner and permissioning.
     */
    retrieve(model, options) {
      return this._client.get(`/models/${model}`, options);
    }
    /**
     * Lists the currently available models, and provides basic information about each
     * one such as the owner and availability.
     */
    list(options) {
      return this._client.getAPIList("/models", ModelsPage$1, options);
    }
    /**
     * Delete a fine-tuned model. You must have the Owner role in your organization to
     * delete a model.
     */
    del(model, options) {
      return this._client.delete(`/models/${model}`, options);
    }
  };
  let ModelsPage$1 = class ModelsPage extends Page$2 {
  };
  Models$1.ModelsPage = ModelsPage$1;
  let Moderations$1 = class Moderations extends APIResource$2 {
    /**
     * Classifies if text and/or image inputs are potentially harmful. Learn more in
     * the [moderation guide](https://platform.openai.com/docs/guides/moderation).
     */
    create(body, options) {
      return this._client.post("/moderations", { body, ...options });
    }
  };
  let Parts$1 = class Parts extends APIResource$2 {
    /**
     * Adds a
     * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an
     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.
     * A Part represents a chunk of bytes from the file you are trying to upload.
     *
     * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload
     * maximum of 8 GB.
     *
     * It is possible to add multiple Parts in parallel. You can decide the intended
     * order of the Parts when you
     * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).
     */
    create(uploadId, body, options) {
      return this._client.post(`/uploads/${uploadId}/parts`, multipartFormRequestOptions$1({ body, ...options }));
    }
  };
  let Uploads$1 = class Uploads extends APIResource$2 {
    constructor() {
      super(...arguments);
      this.parts = new Parts$1(this._client);
    }
    /**
     * Creates an intermediate
     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object
     * that you can add
     * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.
     * Currently, an Upload can accept at most 8 GB in total and expires after an hour
     * after you create it.
     *
     * Once you complete the Upload, we will create a
     * [File](https://platform.openai.com/docs/api-reference/files/object) object that
     * contains all the parts you uploaded. This File is usable in the rest of our
     * platform as a regular File object.
     *
     * For certain `purpose`s, the correct `mime_type` must be specified. Please refer
     * to documentation for the supported MIME types for your use case:
     *
     * - [Assistants](https://platform.openai.com/docs/assistants/tools/file-search#supported-files)
     *
     * For guidance on the proper filename extensions for each purpose, please follow
     * the documentation on
     * [creating a File](https://platform.openai.com/docs/api-reference/files/create).
     */
    create(body, options) {
      return this._client.post("/uploads", { body, ...options });
    }
    /**
     * Cancels the Upload. No Parts may be added after an Upload is cancelled.
     */
    cancel(uploadId, options) {
      return this._client.post(`/uploads/${uploadId}/cancel`, options);
    }
    /**
     * Completes the
     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).
     *
     * Within the returned Upload object, there is a nested
     * [File](https://platform.openai.com/docs/api-reference/files/object) object that
     * is ready to use in the rest of the platform.
     *
     * You can specify the order of the Parts by passing in an ordered list of the Part
     * IDs.
     *
     * The number of bytes uploaded upon completion must match the number of bytes
     * initially specified when creating the Upload object. No Parts may be added after
     * an Upload is completed.
     */
    complete(uploadId, body, options) {
      return this._client.post(`/uploads/${uploadId}/complete`, { body, ...options });
    }
  };
  Uploads$1.Parts = Parts$1;
  var _a$4;
  let OpenAI$2 = class OpenAI extends APIClient$2 {
    /**
     * API Client for interfacing with the OpenAI API.
     *
     * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
     * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
     * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]
     * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
     * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
     * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
     * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
     * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
     * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
     * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
     * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
     */
    constructor({ baseURL = readEnv$2("OPENAI_BASE_URL"), apiKey = readEnv$2("OPENAI_API_KEY"), organization = readEnv$2("OPENAI_ORG_ID") ?? null, project = readEnv$2("OPENAI_PROJECT_ID") ?? null, ...opts } = {}) {
      if (apiKey === void 0) {
        throw new OpenAIError$1("The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).");
      }
      const options = {
        apiKey,
        organization,
        project,
        ...opts,
        baseURL: baseURL || `https://api.openai.com/v1`
      };
      if (!options.dangerouslyAllowBrowser && isRunningInBrowser$2()) {
        throw new OpenAIError$1("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n");
      }
      super({
        baseURL: options.baseURL,
        timeout: options.timeout ?? 6e5,
        httpAgent: options.httpAgent,
        maxRetries: options.maxRetries,
        fetch: options.fetch
      });
      this.completions = new Completions$4(this);
      this.chat = new Chat$3(this);
      this.embeddings = new Embeddings$1(this);
      this.files = new Files$2(this);
      this.images = new Images$1(this);
      this.audio = new Audio$1(this);
      this.moderations = new Moderations$1(this);
      this.models = new Models$1(this);
      this.fineTuning = new FineTuning$1(this);
      this.beta = new Beta$2(this);
      this.batches = new Batches$2(this);
      this.uploads = new Uploads$1(this);
      this._options = options;
      this.apiKey = apiKey;
      this.organization = organization;
      this.project = project;
    }
    defaultQuery() {
      return this._options.defaultQuery;
    }
    defaultHeaders(opts) {
      return {
        ...super.defaultHeaders(opts),
        "OpenAI-Organization": this.organization,
        "OpenAI-Project": this.project,
        ...this._options.defaultHeaders
      };
    }
    authHeaders(opts) {
      return { Authorization: `Bearer ${this.apiKey}` };
    }
    stringifyQuery(query) {
      return stringify$1(query, { arrayFormat: "brackets" });
    }
  };
  _a$4 = OpenAI$2;
  OpenAI$2.OpenAI = _a$4;
  OpenAI$2.DEFAULT_TIMEOUT = 6e5;
  OpenAI$2.OpenAIError = OpenAIError$1;
  OpenAI$2.APIError = APIError$2;
  OpenAI$2.APIConnectionError = APIConnectionError$2;
  OpenAI$2.APIConnectionTimeoutError = APIConnectionTimeoutError$2;
  OpenAI$2.APIUserAbortError = APIUserAbortError$2;
  OpenAI$2.NotFoundError = NotFoundError$2;
  OpenAI$2.ConflictError = ConflictError$2;
  OpenAI$2.RateLimitError = RateLimitError$2;
  OpenAI$2.BadRequestError = BadRequestError$2;
  OpenAI$2.AuthenticationError = AuthenticationError$2;
  OpenAI$2.InternalServerError = InternalServerError$2;
  OpenAI$2.PermissionDeniedError = PermissionDeniedError$2;
  OpenAI$2.UnprocessableEntityError = UnprocessableEntityError$2;
  OpenAI$2.toFile = toFile$2;
  OpenAI$2.fileFromPath = fileFromPath$2;
  OpenAI$2.Completions = Completions$4;
  OpenAI$2.Chat = Chat$3;
  OpenAI$2.Embeddings = Embeddings$1;
  OpenAI$2.Files = Files$2;
  OpenAI$2.FileObjectsPage = FileObjectsPage$1;
  OpenAI$2.Images = Images$1;
  OpenAI$2.Audio = Audio$1;
  OpenAI$2.Moderations = Moderations$1;
  OpenAI$2.Models = Models$1;
  OpenAI$2.ModelsPage = ModelsPage$1;
  OpenAI$2.FineTuning = FineTuning$1;
  OpenAI$2.Beta = Beta$2;
  OpenAI$2.Batches = Batches$2;
  OpenAI$2.BatchesPage = BatchesPage$1;
  OpenAI$2.Uploads = Uploads$1;
  let AzureOpenAI$1 = class AzureOpenAI extends OpenAI$2 {
    /**
     * API Client for interfacing with the Azure OpenAI API.
     *
     * @param {string | undefined} [opts.apiVersion=process.env['OPENAI_API_VERSION'] ?? undefined]
     * @param {string | undefined} [opts.endpoint=process.env['AZURE_OPENAI_ENDPOINT'] ?? undefined] - Your Azure endpoint, including the resource, e.g. `https://example-resource.azure.openai.com/`
     * @param {string | undefined} [opts.apiKey=process.env['AZURE_OPENAI_API_KEY'] ?? undefined]
     * @param {string | undefined} opts.deployment - A model deployment, if given, sets the base client URL to include `/deployments/{deployment}`.
     * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
     * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL']] - Sets the base URL for the API, e.g. `https://example-resource.azure.openai.com/openai/`.
     * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
     * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
     * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
     * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
     * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
     * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
     * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
     */
    constructor({ baseURL = readEnv$2("OPENAI_BASE_URL"), apiKey = readEnv$2("AZURE_OPENAI_API_KEY"), apiVersion = readEnv$2("OPENAI_API_VERSION"), endpoint, deployment, azureADTokenProvider, dangerouslyAllowBrowser, ...opts } = {}) {
      if (!apiVersion) {
        throw new OpenAIError$1("The OPENAI_API_VERSION environment variable is missing or empty; either provide it, or instantiate the AzureOpenAI client with an apiVersion option, like new AzureOpenAI({ apiVersion: 'My API Version' }).");
      }
      if (typeof azureADTokenProvider === "function") {
        dangerouslyAllowBrowser = true;
      }
      if (!azureADTokenProvider && !apiKey) {
        throw new OpenAIError$1("Missing credentials. Please pass one of `apiKey` and `azureADTokenProvider`, or set the `AZURE_OPENAI_API_KEY` environment variable.");
      }
      if (azureADTokenProvider && apiKey) {
        throw new OpenAIError$1("The `apiKey` and `azureADTokenProvider` arguments are mutually exclusive; only one can be passed at a time.");
      }
      apiKey ?? (apiKey = API_KEY_SENTINEL);
      opts.defaultQuery = { ...opts.defaultQuery, "api-version": apiVersion };
      if (!baseURL) {
        if (!endpoint) {
          endpoint = process.env["AZURE_OPENAI_ENDPOINT"];
        }
        if (!endpoint) {
          throw new OpenAIError$1("Must provide one of the `baseURL` or `endpoint` arguments, or the `AZURE_OPENAI_ENDPOINT` environment variable");
        }
        baseURL = `${endpoint}/openai`;
      } else {
        if (endpoint) {
          throw new OpenAIError$1("baseURL and endpoint are mutually exclusive");
        }
      }
      super({
        apiKey,
        baseURL,
        ...opts,
        ...dangerouslyAllowBrowser !== void 0 ? { dangerouslyAllowBrowser } : {}
      });
      this.apiVersion = "";
      this._azureADTokenProvider = azureADTokenProvider;
      this.apiVersion = apiVersion;
      this.deploymentName = deployment;
    }
    buildRequest(options, props = {}) {
      if (_deployments_endpoints.has(options.path) && options.method === "post" && options.body !== void 0) {
        if (!isObj$1(options.body)) {
          throw new Error("Expected request body to be an object");
        }
        const model = this.deploymentName || options.body["model"];
        if (model !== void 0 && !this.baseURL.includes("/deployments")) {
          options.path = `/deployments/${model}${options.path}`;
        }
      }
      return super.buildRequest(options, props);
    }
    async _getAzureADToken() {
      if (typeof this._azureADTokenProvider === "function") {
        const token = await this._azureADTokenProvider();
        if (!token || typeof token !== "string") {
          throw new OpenAIError$1(`Expected 'azureADTokenProvider' argument to return a string but it returned ${token}`);
        }
        return token;
      }
      return void 0;
    }
    authHeaders(opts) {
      return {};
    }
    async prepareOptions(opts) {
      var _a3;
      if ((_a3 = opts.headers) == null ? void 0 : _a3["api-key"]) {
        return super.prepareOptions(opts);
      }
      const token = await this._getAzureADToken();
      opts.headers ?? (opts.headers = {});
      if (token) {
        opts.headers["Authorization"] = `Bearer ${token}`;
      } else if (this.apiKey !== API_KEY_SENTINEL) {
        opts.headers["api-key"] = this.apiKey;
      } else {
        throw new OpenAIError$1("Unable to handle auth");
      }
      return super.prepareOptions(opts);
    }
  };
  const _deployments_endpoints = /* @__PURE__ */ new Set([
    "/completions",
    "/chat/completions",
    "/embeddings",
    "/audio/transcriptions",
    "/audio/translations",
    "/audio/speech",
    "/images/generations"
  ]);
  const API_KEY_SENTINEL = "<Missing Key>";
  /*
   * [js-sha1]{@link https://github.com/emn178/js-sha1}
   *
   * @version 0.6.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2017
   * @license MIT
   */
  var root = typeof window === "object" ? window : {};
  var HEX_CHARS = "0123456789abcdef".split("");
  var EXTRA = [-2147483648, 8388608, 32768, 128];
  var SHIFT = [24, 16, 8, 0];
  var blocks = [];
  function Sha1(sharedMemory) {
    if (sharedMemory) {
      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      this.blocks = blocks;
    } else {
      this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    }
    this.h0 = 1732584193;
    this.h1 = 4023233417;
    this.h2 = 2562383102;
    this.h3 = 271733878;
    this.h4 = 3285377520;
    this.block = this.start = this.bytes = this.hBytes = 0;
    this.finalized = this.hashed = false;
    this.first = true;
  }
  Sha1.prototype.update = function(message) {
    if (this.finalized) {
      return;
    }
    var notString = typeof message !== "string";
    if (notString && message.constructor === root.ArrayBuffer) {
      message = new Uint8Array(message);
    }
    var code, index = 0, i2, length = message.length || 0, blocks2 = this.blocks;
    while (index < length) {
      if (this.hashed) {
        this.hashed = false;
        blocks2[0] = this.block;
        blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
      }
      if (notString) {
        for (i2 = this.start; index < length && i2 < 64; ++index) {
          blocks2[i2 >> 2] |= message[index] << SHIFT[i2++ & 3];
        }
      } else {
        for (i2 = this.start; index < length && i2 < 64; ++index) {
          code = message.charCodeAt(index);
          if (code < 128) {
            blocks2[i2 >> 2] |= code << SHIFT[i2++ & 3];
          } else if (code < 2048) {
            blocks2[i2 >> 2] |= (192 | code >> 6) << SHIFT[i2++ & 3];
            blocks2[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
          } else if (code < 55296 || code >= 57344) {
            blocks2[i2 >> 2] |= (224 | code >> 12) << SHIFT[i2++ & 3];
            blocks2[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
            blocks2[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
          } else {
            code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
            blocks2[i2 >> 2] |= (240 | code >> 18) << SHIFT[i2++ & 3];
            blocks2[i2 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i2++ & 3];
            blocks2[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
            blocks2[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
          }
        }
      }
      this.lastByteIndex = i2;
      this.bytes += i2 - this.start;
      if (i2 >= 64) {
        this.block = blocks2[16];
        this.start = i2 - 64;
        this.hash();
        this.hashed = true;
      } else {
        this.start = i2;
      }
    }
    if (this.bytes > 4294967295) {
      this.hBytes += this.bytes / 4294967296 << 0;
      this.bytes = this.bytes % 4294967296;
    }
    return this;
  };
  Sha1.prototype.finalize = function() {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks2 = this.blocks, i2 = this.lastByteIndex;
    blocks2[16] = this.block;
    blocks2[i2 >> 2] |= EXTRA[i2 & 3];
    this.block = blocks2[16];
    if (i2 >= 56) {
      if (!this.hashed) {
        this.hash();
      }
      blocks2[0] = this.block;
      blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
    }
    blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
    blocks2[15] = this.bytes << 3;
    this.hash();
  };
  Sha1.prototype.hash = function() {
    var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4;
    var f, j, t, blocks2 = this.blocks;
    for (j = 16; j < 80; ++j) {
      t = blocks2[j - 3] ^ blocks2[j - 8] ^ blocks2[j - 14] ^ blocks2[j - 16];
      blocks2[j] = t << 1 | t >>> 31;
    }
    for (j = 0; j < 20; j += 5) {
      f = b & c | ~b & d;
      t = a << 5 | a >>> 27;
      e = t + f + e + 1518500249 + blocks2[j] << 0;
      b = b << 30 | b >>> 2;
      f = a & b | ~a & c;
      t = e << 5 | e >>> 27;
      d = t + f + d + 1518500249 + blocks2[j + 1] << 0;
      a = a << 30 | a >>> 2;
      f = e & a | ~e & b;
      t = d << 5 | d >>> 27;
      c = t + f + c + 1518500249 + blocks2[j + 2] << 0;
      e = e << 30 | e >>> 2;
      f = d & e | ~d & a;
      t = c << 5 | c >>> 27;
      b = t + f + b + 1518500249 + blocks2[j + 3] << 0;
      d = d << 30 | d >>> 2;
      f = c & d | ~c & e;
      t = b << 5 | b >>> 27;
      a = t + f + a + 1518500249 + blocks2[j + 4] << 0;
      c = c << 30 | c >>> 2;
    }
    for (; j < 40; j += 5) {
      f = b ^ c ^ d;
      t = a << 5 | a >>> 27;
      e = t + f + e + 1859775393 + blocks2[j] << 0;
      b = b << 30 | b >>> 2;
      f = a ^ b ^ c;
      t = e << 5 | e >>> 27;
      d = t + f + d + 1859775393 + blocks2[j + 1] << 0;
      a = a << 30 | a >>> 2;
      f = e ^ a ^ b;
      t = d << 5 | d >>> 27;
      c = t + f + c + 1859775393 + blocks2[j + 2] << 0;
      e = e << 30 | e >>> 2;
      f = d ^ e ^ a;
      t = c << 5 | c >>> 27;
      b = t + f + b + 1859775393 + blocks2[j + 3] << 0;
      d = d << 30 | d >>> 2;
      f = c ^ d ^ e;
      t = b << 5 | b >>> 27;
      a = t + f + a + 1859775393 + blocks2[j + 4] << 0;
      c = c << 30 | c >>> 2;
    }
    for (; j < 60; j += 5) {
      f = b & c | b & d | c & d;
      t = a << 5 | a >>> 27;
      e = t + f + e - 1894007588 + blocks2[j] << 0;
      b = b << 30 | b >>> 2;
      f = a & b | a & c | b & c;
      t = e << 5 | e >>> 27;
      d = t + f + d - 1894007588 + blocks2[j + 1] << 0;
      a = a << 30 | a >>> 2;
      f = e & a | e & b | a & b;
      t = d << 5 | d >>> 27;
      c = t + f + c - 1894007588 + blocks2[j + 2] << 0;
      e = e << 30 | e >>> 2;
      f = d & e | d & a | e & a;
      t = c << 5 | c >>> 27;
      b = t + f + b - 1894007588 + blocks2[j + 3] << 0;
      d = d << 30 | d >>> 2;
      f = c & d | c & e | d & e;
      t = b << 5 | b >>> 27;
      a = t + f + a - 1894007588 + blocks2[j + 4] << 0;
      c = c << 30 | c >>> 2;
    }
    for (; j < 80; j += 5) {
      f = b ^ c ^ d;
      t = a << 5 | a >>> 27;
      e = t + f + e - 899497514 + blocks2[j] << 0;
      b = b << 30 | b >>> 2;
      f = a ^ b ^ c;
      t = e << 5 | e >>> 27;
      d = t + f + d - 899497514 + blocks2[j + 1] << 0;
      a = a << 30 | a >>> 2;
      f = e ^ a ^ b;
      t = d << 5 | d >>> 27;
      c = t + f + c - 899497514 + blocks2[j + 2] << 0;
      e = e << 30 | e >>> 2;
      f = d ^ e ^ a;
      t = c << 5 | c >>> 27;
      b = t + f + b - 899497514 + blocks2[j + 3] << 0;
      d = d << 30 | d >>> 2;
      f = c ^ d ^ e;
      t = b << 5 | b >>> 27;
      a = t + f + a - 899497514 + blocks2[j + 4] << 0;
      c = c << 30 | c >>> 2;
    }
    this.h0 = this.h0 + a << 0;
    this.h1 = this.h1 + b << 0;
    this.h2 = this.h2 + c << 0;
    this.h3 = this.h3 + d << 0;
    this.h4 = this.h4 + e << 0;
  };
  Sha1.prototype.hex = function() {
    this.finalize();
    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4;
    return HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15];
  };
  Sha1.prototype.toString = Sha1.prototype.hex;
  Sha1.prototype.digest = function() {
    this.finalize();
    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4;
    return [
      h0 >> 24 & 255,
      h0 >> 16 & 255,
      h0 >> 8 & 255,
      h0 & 255,
      h1 >> 24 & 255,
      h1 >> 16 & 255,
      h1 >> 8 & 255,
      h1 & 255,
      h2 >> 24 & 255,
      h2 >> 16 & 255,
      h2 >> 8 & 255,
      h2 & 255,
      h3 >> 24 & 255,
      h3 >> 16 & 255,
      h3 >> 8 & 255,
      h3 & 255,
      h4 >> 24 & 255,
      h4 >> 16 & 255,
      h4 >> 8 & 255,
      h4 & 255
    ];
  };
  Sha1.prototype.array = Sha1.prototype.digest;
  Sha1.prototype.arrayBuffer = function() {
    this.finalize();
    var buffer = new ArrayBuffer(20);
    var dataView = new DataView(buffer);
    dataView.setUint32(0, this.h0);
    dataView.setUint32(4, this.h1);
    dataView.setUint32(8, this.h2);
    dataView.setUint32(12, this.h3);
    dataView.setUint32(16, this.h4);
    return buffer;
  };
  const insecureHash = (message) => {
    return new Sha1(true).update(message)["hex"]();
  };
  const getCacheKey = (...strings) => insecureHash(strings.join("_"));
  class BaseCache {
  }
  const GLOBAL_MAP = /* @__PURE__ */ new Map();
  class InMemoryCache extends BaseCache {
    constructor(map2) {
      super();
      Object.defineProperty(this, "cache", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.cache = map2 ?? /* @__PURE__ */ new Map();
    }
    /**
     * Retrieves data from the cache using a prompt and an LLM key. If the
     * data is not found, it returns null.
     * @param prompt The prompt used to find the data.
     * @param llmKey The LLM key used to find the data.
     * @returns The data corresponding to the prompt and LLM key, or null if not found.
     */
    lookup(prompt, llmKey) {
      return Promise.resolve(this.cache.get(getCacheKey(prompt, llmKey)) ?? null);
    }
    /**
     * Updates the cache with new data using a prompt and an LLM key.
     * @param prompt The prompt used to store the data.
     * @param llmKey The LLM key used to store the data.
     * @param value The data to be stored.
     */
    async update(prompt, llmKey, value) {
      this.cache.set(getCacheKey(prompt, llmKey), value);
    }
    /**
     * Returns a global instance of InMemoryCache using a predefined global
     * map as the initial cache.
     * @returns A global instance of InMemoryCache.
     */
    static global() {
      return new InMemoryCache(GLOBAL_MAP);
    }
  }
  class BasePromptValue extends Serializable {
  }
  class StringPromptValue extends BasePromptValue {
    static lc_name() {
      return "StringPromptValue";
    }
    constructor(value) {
      super({ value });
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ["langchain_core", "prompt_values"]
      });
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "value", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.value = value;
    }
    toString() {
      return this.value;
    }
    toChatMessages() {
      return [new HumanMessage(this.value)];
    }
  }
  class ChatPromptValue extends BasePromptValue {
    static lc_name() {
      return "ChatPromptValue";
    }
    constructor(fields) {
      if (Array.isArray(fields)) {
        fields = { messages: fields };
      }
      super(fields);
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ["langchain_core", "prompt_values"]
      });
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "messages", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.messages = fields.messages;
    }
    toString() {
      return getBufferString(this.messages);
    }
    toChatMessages() {
      return this.messages;
    }
  }
  var base64Js = {};
  var hasRequiredBase64Js;
  function requireBase64Js() {
    if (hasRequiredBase64Js) return base64Js;
    hasRequiredBase64Js = 1;
    base64Js.byteLength = byteLength;
    base64Js.toByteArray = toByteArray;
    base64Js.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i2 = 0, len = code.length; i2 < len; ++i2) {
      lookup[i2] = code[i2];
      revLookup[code.charCodeAt(i2)] = i2;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr2 = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i3;
      for (i3 = 0; i3 < len2; i3 += 4) {
        tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
        arr2[curByte++] = tmp >> 16 & 255;
        arr2[curByte++] = tmp >> 8 & 255;
        arr2[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
        arr2[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
        arr2[curByte++] = tmp >> 8 & 255;
        arr2[curByte++] = tmp & 255;
      }
      return arr2;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i3 = start; i3 < end; i3 += 3) {
        tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
    return base64Js;
  }
  var base64JsExports = requireBase64Js();
  const base64 = /* @__PURE__ */ getDefaultExportFromCjs(base64JsExports);
  var __defProp$2 = Object.defineProperty;
  var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField$2 = (obj, key, value) => {
    __defNormalProp$2(obj, key + "", value);
    return value;
  };
  function bytePairMerge(piece, ranks) {
    let parts = Array.from(
      { length: piece.length },
      (_, i2) => ({ start: i2, end: i2 + 1 })
    );
    while (parts.length > 1) {
      let minRank = null;
      for (let i2 = 0; i2 < parts.length - 1; i2++) {
        const slice = piece.slice(parts[i2].start, parts[i2 + 1].end);
        const rank = ranks.get(slice.join(","));
        if (rank == null)
          continue;
        if (minRank == null || rank < minRank[0]) {
          minRank = [rank, i2];
        }
      }
      if (minRank != null) {
        const i2 = minRank[1];
        parts[i2] = { start: parts[i2].start, end: parts[i2 + 1].end };
        parts.splice(i2 + 1, 1);
      } else {
        break;
      }
    }
    return parts;
  }
  function bytePairEncode(piece, ranks) {
    if (piece.length === 1)
      return [ranks.get(piece.join(","))];
    return bytePairMerge(piece, ranks).map((p) => ranks.get(piece.slice(p.start, p.end).join(","))).filter((x) => x != null);
  }
  function escapeRegex(str2) {
    return str2.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
  }
  var _Tiktoken = class {
    constructor(ranks, extendedSpecialTokens) {
      /** @internal */
      __publicField(this, "specialTokens");
      /** @internal */
      __publicField(this, "inverseSpecialTokens");
      /** @internal */
      __publicField(this, "patStr");
      /** @internal */
      __publicField(this, "textEncoder", new TextEncoder());
      /** @internal */
      __publicField(this, "textDecoder", new TextDecoder("utf-8"));
      /** @internal */
      __publicField(this, "rankMap", /* @__PURE__ */ new Map());
      /** @internal */
      __publicField(this, "textMap", /* @__PURE__ */ new Map());
      this.patStr = ranks.pat_str;
      const uncompressed = ranks.bpe_ranks.split("\n").filter(Boolean).reduce((memo, x) => {
        const [_, offsetStr, ...tokens] = x.split(" ");
        const offset = Number.parseInt(offsetStr, 10);
        tokens.forEach((token, i2) => memo[token] = offset + i2);
        return memo;
      }, {});
      for (const [token, rank] of Object.entries(uncompressed)) {
        const bytes = base64.toByteArray(token);
        this.rankMap.set(bytes.join(","), rank);
        this.textMap.set(rank, bytes);
      }
      this.specialTokens = { ...ranks.special_tokens, ...extendedSpecialTokens };
      this.inverseSpecialTokens = Object.entries(this.specialTokens).reduce((memo, [text, rank]) => {
        memo[rank] = this.textEncoder.encode(text);
        return memo;
      }, {});
    }
    encode(text, allowedSpecial = [], disallowedSpecial = "all") {
      const regexes = new RegExp(this.patStr, "ug");
      const specialRegex = _Tiktoken.specialTokenRegex(
        Object.keys(this.specialTokens)
      );
      const ret = [];
      const allowedSpecialSet = new Set(
        allowedSpecial === "all" ? Object.keys(this.specialTokens) : allowedSpecial
      );
      const disallowedSpecialSet = new Set(
        disallowedSpecial === "all" ? Object.keys(this.specialTokens).filter(
          (x) => !allowedSpecialSet.has(x)
        ) : disallowedSpecial
      );
      if (disallowedSpecialSet.size > 0) {
        const disallowedSpecialRegex = _Tiktoken.specialTokenRegex([
          ...disallowedSpecialSet
        ]);
        const specialMatch = text.match(disallowedSpecialRegex);
        if (specialMatch != null) {
          throw new Error(
            `The text contains a special token that is not allowed: ${specialMatch[0]}`
          );
        }
      }
      let start = 0;
      while (true) {
        let nextSpecial = null;
        let startFind = start;
        while (true) {
          specialRegex.lastIndex = startFind;
          nextSpecial = specialRegex.exec(text);
          if (nextSpecial == null || allowedSpecialSet.has(nextSpecial[0]))
            break;
          startFind = nextSpecial.index + 1;
        }
        const end = (nextSpecial == null ? void 0 : nextSpecial.index) ?? text.length;
        for (const match of text.substring(start, end).matchAll(regexes)) {
          const piece = this.textEncoder.encode(match[0]);
          const token2 = this.rankMap.get(piece.join(","));
          if (token2 != null) {
            ret.push(token2);
            continue;
          }
          ret.push(...bytePairEncode(piece, this.rankMap));
        }
        if (nextSpecial == null)
          break;
        let token = this.specialTokens[nextSpecial[0]];
        ret.push(token);
        start = nextSpecial.index + nextSpecial[0].length;
      }
      return ret;
    }
    decode(tokens) {
      const res = [];
      let length = 0;
      for (let i22 = 0; i22 < tokens.length; ++i22) {
        const token = tokens[i22];
        const bytes = this.textMap.get(token) ?? this.inverseSpecialTokens[token];
        if (bytes != null) {
          res.push(bytes);
          length += bytes.length;
        }
      }
      const mergedArray = new Uint8Array(length);
      let i2 = 0;
      for (const bytes of res) {
        mergedArray.set(bytes, i2);
        i2 += bytes.length;
      }
      return this.textDecoder.decode(mergedArray);
    }
  };
  var Tiktoken = _Tiktoken;
  __publicField$2(Tiktoken, "specialTokenRegex", (tokens) => {
    return new RegExp(tokens.map((i2) => escapeRegex(i2)).join("|"), "g");
  });
  function getEncodingNameForModel(model) {
    switch (model) {
      case "gpt2": {
        return "gpt2";
      }
      case "code-cushman-001":
      case "code-cushman-002":
      case "code-davinci-001":
      case "code-davinci-002":
      case "cushman-codex":
      case "davinci-codex":
      case "davinci-002":
      case "text-davinci-002":
      case "text-davinci-003": {
        return "p50k_base";
      }
      case "code-davinci-edit-001":
      case "text-davinci-edit-001": {
        return "p50k_edit";
      }
      case "ada":
      case "babbage":
      case "babbage-002":
      case "code-search-ada-code-001":
      case "code-search-babbage-code-001":
      case "curie":
      case "davinci":
      case "text-ada-001":
      case "text-babbage-001":
      case "text-curie-001":
      case "text-davinci-001":
      case "text-search-ada-doc-001":
      case "text-search-babbage-doc-001":
      case "text-search-curie-doc-001":
      case "text-search-davinci-doc-001":
      case "text-similarity-ada-001":
      case "text-similarity-babbage-001":
      case "text-similarity-curie-001":
      case "text-similarity-davinci-001": {
        return "r50k_base";
      }
      case "gpt-3.5-turbo-instruct-0914":
      case "gpt-3.5-turbo-instruct":
      case "gpt-3.5-turbo-16k-0613":
      case "gpt-3.5-turbo-16k":
      case "gpt-3.5-turbo-0613":
      case "gpt-3.5-turbo-0301":
      case "gpt-3.5-turbo":
      case "gpt-4-32k-0613":
      case "gpt-4-32k-0314":
      case "gpt-4-32k":
      case "gpt-4-0613":
      case "gpt-4-0314":
      case "gpt-4":
      case "gpt-3.5-turbo-1106":
      case "gpt-35-turbo":
      case "gpt-4-1106-preview":
      case "gpt-4-vision-preview":
      case "gpt-3.5-turbo-0125":
      case "gpt-4-turbo":
      case "gpt-4-turbo-2024-04-09":
      case "gpt-4-turbo-preview":
      case "gpt-4-0125-preview":
      case "text-embedding-ada-002":
      case "text-embedding-3-small":
      case "text-embedding-3-large": {
        return "cl100k_base";
      }
      case "gpt-4o":
      case "gpt-4o-2024-05-13":
      case "gpt-4o-2024-08-06":
      case "gpt-4o-mini-2024-07-18":
      case "gpt-4o-mini":
      case "o1":
      case "o1-2024-12-17":
      case "o1-mini":
      case "o1-preview":
      case "o1-preview-2024-09-12":
      case "o1-mini-2024-09-12":
      case "o3-mini":
      case "o3-mini-2025-01-31":
      case "chatgpt-4o-latest":
      case "gpt-4o-realtime":
      case "gpt-4o-realtime-preview-2024-10-01": {
        return "o200k_base";
      }
      default:
        throw new Error("Unknown model");
    }
  }
  const cache = {};
  const caller = /* @__PURE__ */ new AsyncCaller({});
  async function getEncoding(encoding) {
    if (!(encoding in cache)) {
      cache[encoding] = caller.fetch(`https://tiktoken.pages.dev/js/${encoding}.json`).then((res) => res.json()).then((data) => new Tiktoken(data)).catch((e) => {
        delete cache[encoding];
        throw e;
      });
    }
    return await cache[encoding];
  }
  async function encodingForModel(model) {
    return getEncoding(getEncodingNameForModel(model));
  }
  const getModelNameForTiktoken = (modelName) => {
    if (modelName.startsWith("gpt-3.5-turbo-16k")) {
      return "gpt-3.5-turbo-16k";
    }
    if (modelName.startsWith("gpt-3.5-turbo-")) {
      return "gpt-3.5-turbo";
    }
    if (modelName.startsWith("gpt-4-32k")) {
      return "gpt-4-32k";
    }
    if (modelName.startsWith("gpt-4-")) {
      return "gpt-4";
    }
    if (modelName.startsWith("gpt-4o")) {
      return "gpt-4o";
    }
    return modelName;
  };
  function isOpenAITool(tool) {
    if (typeof tool !== "object" || !tool)
      return false;
    if ("type" in tool && tool.type === "function" && "function" in tool && typeof tool.function === "object" && tool.function && "name" in tool.function && "parameters" in tool.function) {
      return true;
    }
    return false;
  }
  const getVerbosity = () => false;
  class BaseLangChain extends Runnable {
    get lc_attributes() {
      return {
        callbacks: void 0,
        verbose: void 0
      };
    }
    constructor(params) {
      super(params);
      Object.defineProperty(this, "verbose", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "callbacks", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "tags", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "metadata", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.verbose = params.verbose ?? getVerbosity();
      this.callbacks = params.callbacks;
      this.tags = params.tags ?? [];
      this.metadata = params.metadata ?? {};
    }
  }
  class BaseLanguageModel extends BaseLangChain {
    /**
     * Keys that the language model accepts as call options.
     */
    get callKeys() {
      return ["stop", "timeout", "signal", "tags", "metadata", "callbacks"];
    }
    constructor({ callbacks, callbackManager, ...params }) {
      const { cache: cache2, ...rest } = params;
      super({
        callbacks: callbacks ?? callbackManager,
        ...rest
      });
      Object.defineProperty(this, "caller", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "cache", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "_encoding", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      if (typeof cache2 === "object") {
        this.cache = cache2;
      } else if (cache2) {
        this.cache = InMemoryCache.global();
      } else {
        this.cache = void 0;
      }
      this.caller = new AsyncCaller(params ?? {});
    }
    async getNumTokens(content) {
      if (typeof content !== "string") {
        return 0;
      }
      let numTokens = Math.ceil(content.length / 4);
      if (!this._encoding) {
        try {
          this._encoding = await encodingForModel("modelName" in this ? getModelNameForTiktoken(this.modelName) : "gpt2");
        } catch (error) {
          console.warn("Failed to calculate number of tokens, falling back to approximate count", error);
        }
      }
      if (this._encoding) {
        try {
          numTokens = this._encoding.encode(content).length;
        } catch (error) {
          console.warn("Failed to calculate number of tokens, falling back to approximate count", error);
        }
      }
      return numTokens;
    }
    static _convertInputToPromptValue(input) {
      if (typeof input === "string") {
        return new StringPromptValue(input);
      } else if (Array.isArray(input)) {
        return new ChatPromptValue(input.map(coerceMessageLikeToMessage));
      } else {
        return input;
      }
    }
    /**
     * Get the identifying parameters of the LLM.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _identifyingParams() {
      return {};
    }
    /**
     * Create a unique cache key for a specific call to a specific language model.
     * @param callOptions Call options for the model
     * @returns A unique cache key.
     */
    _getSerializedCacheKeyParametersForCall({ config: config2, ...callOptions }) {
      const params = {
        ...this._identifyingParams(),
        ...callOptions,
        _type: this._llmType(),
        _model: this._modelType()
      };
      const filteredEntries = Object.entries(params).filter(([_, value]) => value !== void 0);
      const serializedEntries = filteredEntries.map(([key, value]) => `${key}:${JSON.stringify(value)}`).sort().join(",");
      return serializedEntries;
    }
    /**
     * @deprecated
     * Return a json-like object representing this LLM.
     */
    serialize() {
      return {
        ...this._identifyingParams(),
        _type: this._llmType(),
        _model: this._modelType()
      };
    }
    /**
     * @deprecated
     * Load an LLM from a json-like object describing it.
     */
    static async deserialize(_data) {
      throw new Error("Use .toJSON() instead");
    }
  }
  class RunnablePassthrough extends Runnable {
    static lc_name() {
      return "RunnablePassthrough";
    }
    constructor(fields) {
      super(fields);
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ["langchain_core", "runnables"]
      });
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "func", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      if (fields) {
        this.func = fields.func;
      }
    }
    async invoke(input, options) {
      const config2 = ensureConfig(options);
      if (this.func) {
        await this.func(input, config2);
      }
      return this._callWithConfig((input2) => Promise.resolve(input2), input, config2);
    }
    async *transform(generator, options) {
      const config2 = ensureConfig(options);
      let finalOutput;
      let finalOutputSupported = true;
      for await (const chunk of this._transformStreamWithConfig(generator, (input) => input, config2)) {
        yield chunk;
        if (finalOutputSupported) {
          if (finalOutput === void 0) {
            finalOutput = chunk;
          } else {
            try {
              finalOutput = concat(finalOutput, chunk);
            } catch {
              finalOutput = void 0;
              finalOutputSupported = false;
            }
          }
        }
      }
      if (this.func && finalOutput !== void 0) {
        await this.func(finalOutput, config2);
      }
    }
    /**
     * A runnable that assigns key-value pairs to the input.
     *
     * The example below shows how you could use it with an inline function.
     *
     * @example
     * ```typescript
     * const prompt =
     *   PromptTemplate.fromTemplate(`Write a SQL query to answer the question using the following schema: {schema}
     * Question: {question}
     * SQL Query:`);
     *
     * // The `RunnablePassthrough.assign()` is used here to passthrough the input from the `.invoke()`
     * // call (in this example it's the question), along with any inputs passed to the `.assign()` method.
     * // In this case, we're passing the schema.
     * const sqlQueryGeneratorChain = RunnableSequence.from([
     *   RunnablePassthrough.assign({
     *     schema: async () => db.getTableInfo(),
     *   }),
     *   prompt,
     *   new ChatOpenAI({}).bind({ stop: ["\nSQLResult:"] }),
     *   new StringOutputParser(),
     * ]);
     * const result = await sqlQueryGeneratorChain.invoke({
     *   question: "How many employees are there?",
     * });
     * ```
     */
    static assign(mapping) {
      return new RunnableAssign(new RunnableMap({ steps: mapping }));
    }
  }
  function isZodSchema$2(input) {
    var _a3;
    if (!input) {
      return false;
    }
    if (typeof input !== "object") {
      return false;
    }
    if (Array.isArray(input)) {
      return false;
    }
    const asZodSchema = input;
    if (asZodSchema._def) {
      return true;
    }
    const zodFirstPartyTypeKinds = Object.values(z.ZodFirstPartyTypeKind);
    if (zodFirstPartyTypeKinds.includes(((_a3 = asZodSchema.constructor) == null ? void 0 : _a3.name) ?? "NOT_INCLUDED")) {
      return true;
    }
    return typeof asZodSchema.parse === "function" && typeof asZodSchema.parseAsync === "function" && typeof asZodSchema.safeParse === "function" && typeof asZodSchema.safeParseAsync === "function";
  }
  class BaseChatModel extends BaseLanguageModel {
    constructor(fields) {
      super(fields);
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ["langchain", "chat_models", this._llmType()]
      });
      Object.defineProperty(this, "disableStreaming", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
    }
    _separateRunnableConfigFromCallOptionsCompat(options) {
      const [runnableConfig, callOptions] = super._separateRunnableConfigFromCallOptions(options);
      callOptions.signal = runnableConfig.signal;
      return [runnableConfig, callOptions];
    }
    /**
     * Invokes the chat model with a single input.
     * @param input The input for the language model.
     * @param options The call options.
     * @returns A Promise that resolves to a BaseMessageChunk.
     */
    async invoke(input, options) {
      const promptValue = BaseChatModel._convertInputToPromptValue(input);
      const result = await this.generatePrompt([promptValue], options, options == null ? void 0 : options.callbacks);
      const chatGeneration = result.generations[0][0];
      return chatGeneration.message;
    }
    // eslint-disable-next-line require-yield
    async *_streamResponseChunks(_messages, _options, _runManager) {
      throw new Error("Not implemented.");
    }
    async *_streamIterator(input, options) {
      var _a3;
      if (this._streamResponseChunks === BaseChatModel.prototype._streamResponseChunks || this.disableStreaming) {
        yield this.invoke(input, options);
      } else {
        const prompt = BaseChatModel._convertInputToPromptValue(input);
        const messages = prompt.toChatMessages();
        const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(options);
        const inheritableMetadata = {
          ...runnableConfig.metadata,
          ...this.getLsParams(callOptions)
        };
        const callbackManager_ = await CallbackManager.configure(runnableConfig.callbacks, this.callbacks, runnableConfig.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });
        const extra = {
          options: callOptions,
          invocation_params: this == null ? void 0 : this.invocationParams(callOptions),
          batch_size: 1
        };
        const runManagers = await (callbackManager_ == null ? void 0 : callbackManager_.handleChatModelStart(this.toJSON(), [messages], runnableConfig.runId, void 0, extra, void 0, void 0, runnableConfig.runName));
        let generationChunk;
        let llmOutput;
        try {
          for await (const chunk of this._streamResponseChunks(messages, callOptions, runManagers == null ? void 0 : runManagers[0])) {
            if (chunk.message.id == null) {
              const runId = (_a3 = runManagers == null ? void 0 : runManagers.at(0)) == null ? void 0 : _a3.runId;
              if (runId != null)
                chunk.message._updateId(`run-${runId}`);
            }
            chunk.message.response_metadata = {
              ...chunk.generationInfo,
              ...chunk.message.response_metadata
            };
            yield chunk.message;
            if (!generationChunk) {
              generationChunk = chunk;
            } else {
              generationChunk = generationChunk.concat(chunk);
            }
            if (isAIMessageChunk(chunk.message) && chunk.message.usage_metadata !== void 0) {
              llmOutput = {
                tokenUsage: {
                  promptTokens: chunk.message.usage_metadata.input_tokens,
                  completionTokens: chunk.message.usage_metadata.output_tokens,
                  totalTokens: chunk.message.usage_metadata.total_tokens
                }
              };
            }
          }
        } catch (err) {
          await Promise.all((runManagers ?? []).map((runManager) => runManager == null ? void 0 : runManager.handleLLMError(err)));
          throw err;
        }
        await Promise.all((runManagers ?? []).map((runManager) => runManager == null ? void 0 : runManager.handleLLMEnd({
          // TODO: Remove cast after figuring out inheritance
          generations: [[generationChunk]],
          llmOutput
        })));
      }
    }
    getLsParams(options) {
      const providerName = this.getName().startsWith("Chat") ? this.getName().replace("Chat", "") : this.getName();
      return {
        ls_model_type: "chat",
        ls_stop: options.stop,
        ls_provider: providerName
      };
    }
    /** @ignore */
    async _generateUncached(messages, parsedOptions, handledOptions, startedRunManagers) {
      var _a3, _b2;
      const baseMessages = messages.map((messageList) => messageList.map(coerceMessageLikeToMessage));
      let runManagers;
      if (startedRunManagers !== void 0 && startedRunManagers.length === baseMessages.length) {
        runManagers = startedRunManagers;
      } else {
        const inheritableMetadata = {
          ...handledOptions.metadata,
          ...this.getLsParams(parsedOptions)
        };
        const callbackManager_ = await CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });
        const extra = {
          options: parsedOptions,
          invocation_params: this == null ? void 0 : this.invocationParams(parsedOptions),
          batch_size: 1
        };
        runManagers = await (callbackManager_ == null ? void 0 : callbackManager_.handleChatModelStart(this.toJSON(), baseMessages, handledOptions.runId, void 0, extra, void 0, void 0, handledOptions.runName));
      }
      const generations = [];
      const llmOutputs = [];
      const hasStreamingHandler = !!(runManagers == null ? void 0 : runManagers[0].handlers.find(callbackHandlerPrefersStreaming));
      if (hasStreamingHandler && !this.disableStreaming && baseMessages.length === 1 && this._streamResponseChunks !== BaseChatModel.prototype._streamResponseChunks) {
        try {
          const stream = await this._streamResponseChunks(baseMessages[0], parsedOptions, runManagers == null ? void 0 : runManagers[0]);
          let aggregated;
          let llmOutput;
          for await (const chunk of stream) {
            if (chunk.message.id == null) {
              const runId = (_a3 = runManagers == null ? void 0 : runManagers.at(0)) == null ? void 0 : _a3.runId;
              if (runId != null)
                chunk.message._updateId(`run-${runId}`);
            }
            if (aggregated === void 0) {
              aggregated = chunk;
            } else {
              aggregated = concat(aggregated, chunk);
            }
            if (isAIMessageChunk(chunk.message) && chunk.message.usage_metadata !== void 0) {
              llmOutput = {
                tokenUsage: {
                  promptTokens: chunk.message.usage_metadata.input_tokens,
                  completionTokens: chunk.message.usage_metadata.output_tokens,
                  totalTokens: chunk.message.usage_metadata.total_tokens
                }
              };
            }
          }
          if (aggregated === void 0) {
            throw new Error("Received empty response from chat model call.");
          }
          generations.push([aggregated]);
          await (runManagers == null ? void 0 : runManagers[0].handleLLMEnd({
            generations,
            llmOutput
          }));
        } catch (e) {
          await (runManagers == null ? void 0 : runManagers[0].handleLLMError(e));
          throw e;
        }
      } else {
        const results = await Promise.allSettled(baseMessages.map((messageList, i2) => this._generate(messageList, { ...parsedOptions, promptIndex: i2 }, runManagers == null ? void 0 : runManagers[i2])));
        await Promise.all(results.map(async (pResult, i2) => {
          var _a4, _b3, _c2;
          if (pResult.status === "fulfilled") {
            const result = pResult.value;
            for (const generation of result.generations) {
              if (generation.message.id == null) {
                const runId = (_a4 = runManagers == null ? void 0 : runManagers.at(0)) == null ? void 0 : _a4.runId;
                if (runId != null)
                  generation.message._updateId(`run-${runId}`);
              }
              generation.message.response_metadata = {
                ...generation.generationInfo,
                ...generation.message.response_metadata
              };
            }
            if (result.generations.length === 1) {
              result.generations[0].message.response_metadata = {
                ...result.llmOutput,
                ...result.generations[0].message.response_metadata
              };
            }
            generations[i2] = result.generations;
            llmOutputs[i2] = result.llmOutput;
            return (_b3 = runManagers == null ? void 0 : runManagers[i2]) == null ? void 0 : _b3.handleLLMEnd({
              generations: [result.generations],
              llmOutput: result.llmOutput
            });
          } else {
            await ((_c2 = runManagers == null ? void 0 : runManagers[i2]) == null ? void 0 : _c2.handleLLMError(pResult.reason));
            return Promise.reject(pResult.reason);
          }
        }));
      }
      const output = {
        generations,
        llmOutput: llmOutputs.length ? (_b2 = this._combineLLMOutput) == null ? void 0 : _b2.call(this, ...llmOutputs) : void 0
      };
      Object.defineProperty(output, RUN_KEY, {
        value: runManagers ? { runIds: runManagers == null ? void 0 : runManagers.map((manager) => manager.runId) } : void 0,
        configurable: true
      });
      return output;
    }
    async _generateCached({ messages, cache: cache2, llmStringKey, parsedOptions, handledOptions }) {
      const baseMessages = messages.map((messageList) => messageList.map(coerceMessageLikeToMessage));
      const inheritableMetadata = {
        ...handledOptions.metadata,
        ...this.getLsParams(parsedOptions)
      };
      const callbackManager_ = await CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });
      const extra = {
        options: parsedOptions,
        invocation_params: this == null ? void 0 : this.invocationParams(parsedOptions),
        batch_size: 1
      };
      const runManagers = await (callbackManager_ == null ? void 0 : callbackManager_.handleChatModelStart(this.toJSON(), baseMessages, handledOptions.runId, void 0, extra, void 0, void 0, handledOptions.runName));
      const missingPromptIndices = [];
      const results = await Promise.allSettled(baseMessages.map(async (baseMessage, index) => {
        const prompt = BaseChatModel._convertInputToPromptValue(baseMessage).toString();
        const result = await cache2.lookup(prompt, llmStringKey);
        if (result == null) {
          missingPromptIndices.push(index);
        }
        return result;
      }));
      const cachedResults = results.map((result, index) => ({ result, runManager: runManagers == null ? void 0 : runManagers[index] })).filter(({ result }) => result.status === "fulfilled" && result.value != null || result.status === "rejected");
      const generations = [];
      await Promise.all(cachedResults.map(async ({ result: promiseResult, runManager }, i2) => {
        if (promiseResult.status === "fulfilled") {
          const result = promiseResult.value;
          generations[i2] = result.map((result2) => {
            if ("message" in result2 && isBaseMessage(result2.message) && isAIMessage(result2.message)) {
              result2.message.usage_metadata = {
                input_tokens: 0,
                output_tokens: 0,
                total_tokens: 0
              };
            }
            result2.generationInfo = {
              ...result2.generationInfo,
              tokenUsage: {}
            };
            return result2;
          });
          if (result.length) {
            await (runManager == null ? void 0 : runManager.handleLLMNewToken(result[0].text));
          }
          return runManager == null ? void 0 : runManager.handleLLMEnd({
            generations: [result]
          }, void 0, void 0, void 0, {
            cached: true
          });
        } else {
          await (runManager == null ? void 0 : runManager.handleLLMError(promiseResult.reason, void 0, void 0, void 0, {
            cached: true
          }));
          return Promise.reject(promiseResult.reason);
        }
      }));
      const output = {
        generations,
        missingPromptIndices,
        startedRunManagers: runManagers
      };
      Object.defineProperty(output, RUN_KEY, {
        value: runManagers ? { runIds: runManagers == null ? void 0 : runManagers.map((manager) => manager.runId) } : void 0,
        configurable: true
      });
      return output;
    }
    /**
     * Generates chat based on the input messages.
     * @param messages An array of arrays of BaseMessage instances.
     * @param options The call options or an array of stop sequences.
     * @param callbacks The callbacks for the language model.
     * @returns A Promise that resolves to an LLMResult.
     */
    async generate(messages, options, callbacks) {
      let parsedOptions;
      if (Array.isArray(options)) {
        parsedOptions = { stop: options };
      } else {
        parsedOptions = options;
      }
      const baseMessages = messages.map((messageList) => messageList.map(coerceMessageLikeToMessage));
      const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(parsedOptions);
      runnableConfig.callbacks = runnableConfig.callbacks ?? callbacks;
      if (!this.cache) {
        return this._generateUncached(baseMessages, callOptions, runnableConfig);
      }
      const { cache: cache2 } = this;
      const llmStringKey = this._getSerializedCacheKeyParametersForCall(callOptions);
      const { generations, missingPromptIndices, startedRunManagers } = await this._generateCached({
        messages: baseMessages,
        cache: cache2,
        llmStringKey,
        parsedOptions: callOptions,
        handledOptions: runnableConfig
      });
      let llmOutput = {};
      if (missingPromptIndices.length > 0) {
        const results = await this._generateUncached(missingPromptIndices.map((i2) => baseMessages[i2]), callOptions, runnableConfig, startedRunManagers !== void 0 ? missingPromptIndices.map((i2) => startedRunManagers == null ? void 0 : startedRunManagers[i2]) : void 0);
        await Promise.all(results.generations.map(async (generation, index) => {
          const promptIndex = missingPromptIndices[index];
          generations[promptIndex] = generation;
          const prompt = BaseChatModel._convertInputToPromptValue(baseMessages[promptIndex]).toString();
          return cache2.update(prompt, llmStringKey, generation);
        }));
        llmOutput = results.llmOutput ?? {};
      }
      return { generations, llmOutput };
    }
    /**
     * Get the parameters used to invoke the model
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    invocationParams(_options) {
      return {};
    }
    _modelType() {
      return "base_chat_model";
    }
    /**
     * @deprecated
     * Return a json-like object representing this LLM.
     */
    serialize() {
      return {
        ...this.invocationParams(),
        _type: this._llmType(),
        _model: this._modelType()
      };
    }
    /**
     * Generates a prompt based on the input prompt values.
     * @param promptValues An array of BasePromptValue instances.
     * @param options The call options or an array of stop sequences.
     * @param callbacks The callbacks for the language model.
     * @returns A Promise that resolves to an LLMResult.
     */
    async generatePrompt(promptValues, options, callbacks) {
      const promptMessages = promptValues.map((promptValue) => promptValue.toChatMessages());
      return this.generate(promptMessages, options, callbacks);
    }
    /**
     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
     *
     * Makes a single call to the chat model.
     * @param messages An array of BaseMessage instances.
     * @param options The call options or an array of stop sequences.
     * @param callbacks The callbacks for the language model.
     * @returns A Promise that resolves to a BaseMessage.
     */
    async call(messages, options, callbacks) {
      const result = await this.generate([messages.map(coerceMessageLikeToMessage)], options, callbacks);
      const generations = result.generations;
      return generations[0][0].message;
    }
    /**
     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
     *
     * Makes a single call to the chat model with a prompt value.
     * @param promptValue The value of the prompt.
     * @param options The call options or an array of stop sequences.
     * @param callbacks The callbacks for the language model.
     * @returns A Promise that resolves to a BaseMessage.
     */
    async callPrompt(promptValue, options, callbacks) {
      const promptMessages = promptValue.toChatMessages();
      return this.call(promptMessages, options, callbacks);
    }
    /**
     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
     *
     * Predicts the next message based on the input messages.
     * @param messages An array of BaseMessage instances.
     * @param options The call options or an array of stop sequences.
     * @param callbacks The callbacks for the language model.
     * @returns A Promise that resolves to a BaseMessage.
     */
    async predictMessages(messages, options, callbacks) {
      return this.call(messages, options, callbacks);
    }
    /**
     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
     *
     * Predicts the next message based on a text input.
     * @param text The text input.
     * @param options The call options or an array of stop sequences.
     * @param callbacks The callbacks for the language model.
     * @returns A Promise that resolves to a string.
     */
    async predict(text, options, callbacks) {
      const message = new HumanMessage(text);
      const result = await this.call([message], options, callbacks);
      if (typeof result.content !== "string") {
        throw new Error("Cannot use predict when output is not a string.");
      }
      return result.content;
    }
    withStructuredOutput(outputSchema, config2) {
      if (typeof this.bindTools !== "function") {
        throw new Error(`Chat model must implement ".bindTools()" to use withStructuredOutput.`);
      }
      if (config2 == null ? void 0 : config2.strict) {
        throw new Error(`"strict" mode is not supported for this model by default.`);
      }
      const schema = outputSchema;
      const name = config2 == null ? void 0 : config2.name;
      const description = schema.description ?? "A function available to call.";
      const method = config2 == null ? void 0 : config2.method;
      const includeRaw = config2 == null ? void 0 : config2.includeRaw;
      if (method === "jsonMode") {
        throw new Error(`Base withStructuredOutput implementation only supports "functionCalling" as a method.`);
      }
      let functionName = name ?? "extract";
      let tools;
      if (isZodSchema$2(schema)) {
        tools = [
          {
            type: "function",
            function: {
              name: functionName,
              description,
              parameters: zodToJsonSchema$5(schema)
            }
          }
        ];
      } else {
        if ("name" in schema) {
          functionName = schema.name;
        }
        tools = [
          {
            type: "function",
            function: {
              name: functionName,
              description,
              parameters: schema
            }
          }
        ];
      }
      const llm = this.bindTools(tools);
      const outputParser = RunnableLambda.from((input) => {
        if (!input.tool_calls || input.tool_calls.length === 0) {
          throw new Error("No tool calls found in the response.");
        }
        const toolCall = input.tool_calls.find((tc) => tc.name === functionName);
        if (!toolCall) {
          throw new Error(`No tool call found with name ${functionName}.`);
        }
        return toolCall.args;
      });
      if (!includeRaw) {
        return llm.pipe(outputParser).withConfig({
          runName: "StructuredOutput"
        });
      }
      const parserAssign = RunnablePassthrough.assign({
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        parsed: (input, config3) => outputParser.invoke(input.raw, config3)
      });
      const parserNone = RunnablePassthrough.assign({
        parsed: () => null
      });
      const parsedWithFallback = parserAssign.withFallbacks({
        fallbacks: [parserNone]
      });
      return RunnableSequence.from([
        {
          raw: llm
        },
        parsedWithFallback
      ]).withConfig({
        runName: "StructuredOutputRunnable"
      });
    }
  }
  class BaseLLMOutputParser extends Runnable {
    /**
     * Parses the result of an LLM call with a given prompt. By default, it
     * simply calls `parseResult`.
     * @param generations The generations from an LLM call.
     * @param _prompt The prompt used in the LLM call.
     * @param callbacks Optional callbacks.
     * @returns A promise of the parsed output.
     */
    parseResultWithPrompt(generations, _prompt2, callbacks) {
      return this.parseResult(generations, callbacks);
    }
    _baseMessageToString(message) {
      return typeof message.content === "string" ? message.content : this._baseMessageContentToString(message.content);
    }
    _baseMessageContentToString(content) {
      return JSON.stringify(content);
    }
    /**
     * Calls the parser with a given input and optional configuration options.
     * If the input is a string, it creates a generation with the input as
     * text and calls `parseResult`. If the input is a `BaseMessage`, it
     * creates a generation with the input as a message and the content of the
     * input as text, and then calls `parseResult`.
     * @param input The input to the parser, which can be a string or a `BaseMessage`.
     * @param options Optional configuration options.
     * @returns A promise of the parsed output.
     */
    async invoke(input, options) {
      if (typeof input === "string") {
        return this._callWithConfig(async (input2, options2) => this.parseResult([{ text: input2 }], options2 == null ? void 0 : options2.callbacks), input, { ...options, runType: "parser" });
      } else {
        return this._callWithConfig(async (input2, options2) => this.parseResult([
          {
            message: input2,
            text: this._baseMessageToString(input2)
          }
        ], options2 == null ? void 0 : options2.callbacks), input, { ...options, runType: "parser" });
      }
    }
  }
  class BaseOutputParser extends BaseLLMOutputParser {
    parseResult(generations, callbacks) {
      return this.parse(generations[0].text, callbacks);
    }
    async parseWithPrompt(text, _prompt2, callbacks) {
      return this.parse(text, callbacks);
    }
    /**
     * Return the string type key uniquely identifying this class of parser
     */
    _type() {
      throw new Error("_type not implemented");
    }
  }
  class OutputParserException extends Error {
    constructor(message, llmOutput, observation, sendToLLM = false) {
      super(message);
      Object.defineProperty(this, "llmOutput", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "observation", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "sendToLLM", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.llmOutput = llmOutput;
      this.observation = observation;
      this.sendToLLM = sendToLLM;
      if (sendToLLM) {
        if (observation === void 0 || llmOutput === void 0) {
          throw new Error("Arguments 'observation' & 'llmOutput' are required if 'sendToLlm' is true");
        }
      }
      addLangChainErrorFields$3(this, "OUTPUT_PARSING_FAILURE");
    }
  }
  function deepCompareStrict(a, b) {
    const typeofa = typeof a;
    if (typeofa !== typeof b) {
      return false;
    }
    if (Array.isArray(a)) {
      if (!Array.isArray(b)) {
        return false;
      }
      const length = a.length;
      if (length !== b.length) {
        return false;
      }
      for (let i2 = 0; i2 < length; i2++) {
        if (!deepCompareStrict(a[i2], b[i2])) {
          return false;
        }
      }
      return true;
    }
    if (typeofa === "object") {
      if (!a || !b) {
        return a === b;
      }
      const aKeys = Object.keys(a);
      const bKeys = Object.keys(b);
      const length = aKeys.length;
      if (length !== bKeys.length) {
        return false;
      }
      for (const k of aKeys) {
        if (!deepCompareStrict(a[k], b[k])) {
          return false;
        }
      }
      return true;
    }
    return a === b;
  }
  class BaseTransformOutputParser extends BaseOutputParser {
    async *_transform(inputGenerator) {
      for await (const chunk of inputGenerator) {
        if (typeof chunk === "string") {
          yield this.parseResult([{ text: chunk }]);
        } else {
          yield this.parseResult([
            {
              message: chunk,
              text: this._baseMessageToString(chunk)
            }
          ]);
        }
      }
    }
    /**
     * Transforms an asynchronous generator of input into an asynchronous
     * generator of parsed output.
     * @param inputGenerator An asynchronous generator of input.
     * @param options A configuration object.
     * @returns An asynchronous generator of parsed output.
     */
    async *transform(inputGenerator, options) {
      yield* this._transformStreamWithConfig(inputGenerator, this._transform.bind(this), {
        ...options,
        runType: "parser"
      });
    }
  }
  class BaseCumulativeTransformOutputParser extends BaseTransformOutputParser {
    constructor(fields) {
      super(fields);
      Object.defineProperty(this, "diff", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      this.diff = (fields == null ? void 0 : fields.diff) ?? this.diff;
    }
    async *_transform(inputGenerator) {
      let prevParsed;
      let accGen;
      for await (const chunk of inputGenerator) {
        if (typeof chunk !== "string" && typeof chunk.content !== "string") {
          throw new Error("Cannot handle non-string output.");
        }
        let chunkGen;
        if (isBaseMessageChunk(chunk)) {
          if (typeof chunk.content !== "string") {
            throw new Error("Cannot handle non-string message output.");
          }
          chunkGen = new ChatGenerationChunk({
            message: chunk,
            text: chunk.content
          });
        } else if (isBaseMessage(chunk)) {
          if (typeof chunk.content !== "string") {
            throw new Error("Cannot handle non-string message output.");
          }
          chunkGen = new ChatGenerationChunk({
            message: convertToChunk(chunk),
            text: chunk.content
          });
        } else {
          chunkGen = new GenerationChunk({ text: chunk });
        }
        if (accGen === void 0) {
          accGen = chunkGen;
        } else {
          accGen = accGen.concat(chunkGen);
        }
        const parsed = await this.parsePartialResult([accGen]);
        if (parsed !== void 0 && parsed !== null && !deepCompareStrict(parsed, prevParsed)) {
          if (this.diff) {
            yield this._diff(prevParsed, parsed);
          } else {
            yield parsed;
          }
          prevParsed = parsed;
        }
      }
    }
    getFormatInstructions() {
      return "";
    }
  }
  class StructuredOutputParser extends BaseOutputParser {
    static lc_name() {
      return "StructuredOutputParser";
    }
    toJSON() {
      return this.toJSONNotImplemented();
    }
    constructor(schema) {
      super(schema);
      Object.defineProperty(this, "schema", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: schema
      });
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ["langchain", "output_parsers", "structured"]
      });
    }
    /**
     * Creates a new StructuredOutputParser from a Zod schema.
     * @param schema The Zod schema which the output should match
     * @returns A new instance of StructuredOutputParser.
     */
    static fromZodSchema(schema) {
      return new this(schema);
    }
    /**
     * Creates a new StructuredOutputParser from a set of names and
     * descriptions.
     * @param schemas An object where each key is a name and each value is a description
     * @returns A new instance of StructuredOutputParser.
     */
    static fromNamesAndDescriptions(schemas) {
      const zodSchema = z.object(Object.fromEntries(Object.entries(schemas).map(([name, description]) => [name, z.string().describe(description)])));
      return new this(zodSchema);
    }
    /**
     * Returns a markdown code snippet with a JSON object formatted according
     * to the schema.
     * @param options Optional. The options for formatting the instructions
     * @returns A markdown code snippet with a JSON object formatted according to the schema.
     */
    getFormatInstructions() {
      return `You must format your output as a JSON value that adheres to a given "JSON Schema" instance.

"JSON Schema" is a declarative language that allows you to annotate and validate JSON documents.

For example, the example "JSON Schema" instance {{"properties": {{"foo": {{"description": "a list of test words", "type": "array", "items": {{"type": "string"}}}}}}, "required": ["foo"]}}}}
would match an object with one required property, "foo". The "type" property specifies "foo" must be an "array", and the "description" property semantically describes it as "a list of test words". The items within "foo" must be strings.
Thus, the object {{"foo": ["bar", "baz"]}} is a well-formatted instance of this example "JSON Schema". The object {{"properties": {{"foo": ["bar", "baz"]}}}} is not well-formatted.

Your output will be parsed and type-checked according to the provided schema instance, so make sure all fields in your output match the schema exactly and there are no trailing commas!

Here is the JSON Schema instance your output must adhere to. Include the enclosing markdown codeblock:
\`\`\`json
${JSON.stringify(zodToJsonSchema$5(this.schema))}
\`\`\`
`;
    }
    /**
     * Parses the given text according to the schema.
     * @param text The text to parse
     * @returns The parsed output.
     */
    async parse(text) {
      try {
        const json = text.includes("```") ? text.trim().split(/```(?:json)?/)[1] : text.trim();
        const escapedJson = json.replace(/"([^"\\]*(\\.[^"\\]*)*)"/g, (_match, capturedGroup) => {
          const escapedInsideQuotes = capturedGroup.replace(/\n/g, "\\n");
          return `"${escapedInsideQuotes}"`;
        }).replace(/\n/g, "");
        return await this.schema.parseAsync(JSON.parse(escapedJson));
      } catch (e) {
        throw new OutputParserException(`Failed to parse. Text: "${text}". Error: ${e}`, text);
      }
    }
  }
  class JsonOutputParser extends BaseCumulativeTransformOutputParser {
    constructor() {
      super(...arguments);
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ["langchain_core", "output_parsers"]
      });
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
    }
    static lc_name() {
      return "JsonOutputParser";
    }
    _diff(prev, next) {
      if (!next) {
        return void 0;
      }
      if (!prev) {
        return [{ op: "replace", path: "", value: next }];
      }
      return compare(prev, next);
    }
    // This should actually return Partial<T>, but there's no way
    // to specify emitted chunks as instances separate from the main output type.
    async parsePartialResult(generations) {
      return parseJsonMarkdown(generations[0].text);
    }
    async parse(text) {
      return parseJsonMarkdown(text, JSON.parse);
    }
    getFormatInstructions() {
      return "";
    }
  }
  function parseToolCall$1(rawToolCall, options) {
    if (rawToolCall.function === void 0) {
      return void 0;
    }
    let functionArgs;
    if (options == null ? void 0 : options.partial) {
      try {
        functionArgs = parsePartialJson(rawToolCall.function.arguments ?? "{}");
      } catch (e) {
        return void 0;
      }
    } else {
      try {
        functionArgs = JSON.parse(rawToolCall.function.arguments);
      } catch (e) {
        throw new OutputParserException([
          `Function "${rawToolCall.function.name}" arguments:`,
          ``,
          rawToolCall.function.arguments,
          ``,
          `are not valid JSON.`,
          `Error: ${e.message}`
        ].join("\n"));
      }
    }
    const parsedToolCall = {
      name: rawToolCall.function.name,
      args: functionArgs,
      type: "tool_call"
    };
    if (options == null ? void 0 : options.returnId) {
      parsedToolCall.id = rawToolCall.id;
    }
    return parsedToolCall;
  }
  function convertLangChainToolCallToOpenAI(toolCall) {
    if (toolCall.id === void 0) {
      throw new Error(`All OpenAI tool calls must have an "id" field.`);
    }
    return {
      id: toolCall.id,
      type: "function",
      function: {
        name: toolCall.name,
        arguments: JSON.stringify(toolCall.args)
      }
    };
  }
  function makeInvalidToolCall(rawToolCall, errorMsg) {
    var _a3, _b2;
    return {
      name: (_a3 = rawToolCall.function) == null ? void 0 : _a3.name,
      args: (_b2 = rawToolCall.function) == null ? void 0 : _b2.arguments,
      id: rawToolCall.id,
      error: errorMsg,
      type: "invalid_tool_call"
    };
  }
  class JsonOutputToolsParser extends BaseCumulativeTransformOutputParser {
    static lc_name() {
      return "JsonOutputToolsParser";
    }
    constructor(fields) {
      super(fields);
      Object.defineProperty(this, "returnId", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ["langchain", "output_parsers", "openai_tools"]
      });
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      this.returnId = (fields == null ? void 0 : fields.returnId) ?? this.returnId;
    }
    _diff() {
      throw new Error("Not supported.");
    }
    async parse() {
      throw new Error("Not implemented.");
    }
    async parseResult(generations) {
      const result = await this.parsePartialResult(generations, false);
      return result;
    }
    /**
     * Parses the output and returns a JSON object. If `argsOnly` is true,
     * only the arguments of the function call are returned.
     * @param generations The output of the LLM to parse.
     * @returns A JSON object representation of the function call or its arguments.
     */
    async parsePartialResult(generations, partial = true) {
      var _a3;
      const message = generations[0].message;
      let toolCalls;
      if (isAIMessage(message) && ((_a3 = message.tool_calls) == null ? void 0 : _a3.length)) {
        toolCalls = message.tool_calls.map((toolCall) => {
          const { id, ...rest } = toolCall;
          if (!this.returnId) {
            return rest;
          }
          return {
            id,
            ...rest
          };
        });
      } else if (message.additional_kwargs.tool_calls !== void 0) {
        const rawToolCalls = JSON.parse(JSON.stringify(message.additional_kwargs.tool_calls));
        toolCalls = rawToolCalls.map((rawToolCall) => {
          return parseToolCall$1(rawToolCall, { returnId: this.returnId, partial });
        });
      }
      if (!toolCalls) {
        return [];
      }
      const parsedToolCalls = [];
      for (const toolCall of toolCalls) {
        if (toolCall !== void 0) {
          const backwardsCompatibleToolCall = {
            type: toolCall.name,
            args: toolCall.args,
            id: toolCall.id
          };
          parsedToolCalls.push(backwardsCompatibleToolCall);
        }
      }
      return parsedToolCalls;
    }
  }
  class JsonOutputKeyToolsParser extends JsonOutputToolsParser {
    static lc_name() {
      return "JsonOutputKeyToolsParser";
    }
    constructor(params) {
      super(params);
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ["langchain", "output_parsers", "openai_tools"]
      });
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "returnId", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "keyName", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "returnSingle", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "zodSchema", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.keyName = params.keyName;
      this.returnSingle = params.returnSingle ?? this.returnSingle;
      this.zodSchema = params.zodSchema;
    }
    async _validateResult(result) {
      if (this.zodSchema === void 0) {
        return result;
      }
      const zodParsedResult = await this.zodSchema.safeParseAsync(result);
      if (zodParsedResult.success) {
        return zodParsedResult.data;
      } else {
        throw new OutputParserException(`Failed to parse. Text: "${JSON.stringify(result, null, 2)}". Error: ${JSON.stringify(zodParsedResult.error.errors)}`, JSON.stringify(result, null, 2));
      }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async parsePartialResult(generations) {
      const results = await super.parsePartialResult(generations);
      const matchingResults = results.filter((result) => result.type === this.keyName);
      let returnedValues = matchingResults;
      if (!matchingResults.length) {
        return void 0;
      }
      if (!this.returnId) {
        returnedValues = matchingResults.map((result) => result.args);
      }
      if (this.returnSingle) {
        return returnedValues[0];
      }
      return returnedValues;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async parseResult(generations) {
      const results = await super.parsePartialResult(generations, false);
      const matchingResults = results.filter((result) => result.type === this.keyName);
      let returnedValues = matchingResults;
      if (!matchingResults.length) {
        return void 0;
      }
      if (!this.returnId) {
        returnedValues = matchingResults.map((result) => result.args);
      }
      if (this.returnSingle) {
        return this._validateResult(returnedValues[0]);
      }
      const toolCallResults = await Promise.all(returnedValues.map((value) => this._validateResult(value)));
      return toolCallResults;
    }
  }
  const ignoreOverride$2 = Symbol("Let zodToJsonSchema decide on which parser to use");
  const defaultOptions$2 = {
    name: void 0,
    $refStrategy: "root",
    basePath: ["#"],
    effectStrategy: "input",
    pipeStrategy: "all",
    dateStrategy: "format:date-time",
    mapStrategy: "entries",
    removeAdditionalStrategy: "passthrough",
    allowedAdditionalProperties: true,
    rejectedAdditionalProperties: false,
    definitionPath: "definitions",
    target: "jsonSchema7",
    strictUnions: false,
    definitions: {},
    errorMessages: false,
    markdownDescription: false,
    patternStrategy: "escape",
    applyRegexFlags: false,
    emailStrategy: "format:email",
    base64Strategy: "contentEncoding:base64",
    nameStrategy: "ref"
  };
  const getDefaultOptions$2 = (options) => ({
    ...defaultOptions$2,
    ...options
  });
  const getRefs$2 = (options) => {
    const _options = getDefaultOptions$2(options);
    const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
    return {
      ..._options,
      currentPath,
      propertyPath: void 0,
      seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [
        def._def,
        {
          def: def._def,
          path: [..._options.basePath, _options.definitionPath, name],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ]))
    };
  };
  function addErrorMessage$2(res, key, errorMessage, refs) {
    if (!(refs == null ? void 0 : refs.errorMessages))
      return;
    if (errorMessage) {
      res.errorMessage = {
        ...res.errorMessage,
        [key]: errorMessage
      };
    }
  }
  function setResponseValueAndErrors$2(res, key, value, errorMessage, refs) {
    res[key] = value;
    addErrorMessage$2(res, key, errorMessage, refs);
  }
  function parseAnyDef$2() {
    return {};
  }
  function parseArrayDef$2(def, refs) {
    var _a3, _b2, _c2;
    const res = {
      type: "array"
    };
    if (((_a3 = def.type) == null ? void 0 : _a3._def) && ((_c2 = (_b2 = def.type) == null ? void 0 : _b2._def) == null ? void 0 : _c2.typeName) !== ZodFirstPartyTypeKind$1.ZodAny) {
      res.items = parseDef$2(def.type._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items"]
      });
    }
    if (def.minLength) {
      setResponseValueAndErrors$2(res, "minItems", def.minLength.value, def.minLength.message, refs);
    }
    if (def.maxLength) {
      setResponseValueAndErrors$2(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
    }
    if (def.exactLength) {
      setResponseValueAndErrors$2(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
      setResponseValueAndErrors$2(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
    }
    return res;
  }
  function parseBigintDef$2(def, refs) {
    const res = {
      type: "integer",
      format: "int64"
    };
    if (!def.checks)
      return res;
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          if (refs.target === "jsonSchema7") {
            if (check.inclusive) {
              setResponseValueAndErrors$2(res, "minimum", check.value, check.message, refs);
            } else {
              setResponseValueAndErrors$2(res, "exclusiveMinimum", check.value, check.message, refs);
            }
          } else {
            if (!check.inclusive) {
              res.exclusiveMinimum = true;
            }
            setResponseValueAndErrors$2(res, "minimum", check.value, check.message, refs);
          }
          break;
        case "max":
          if (refs.target === "jsonSchema7") {
            if (check.inclusive) {
              setResponseValueAndErrors$2(res, "maximum", check.value, check.message, refs);
            } else {
              setResponseValueAndErrors$2(res, "exclusiveMaximum", check.value, check.message, refs);
            }
          } else {
            if (!check.inclusive) {
              res.exclusiveMaximum = true;
            }
            setResponseValueAndErrors$2(res, "maximum", check.value, check.message, refs);
          }
          break;
        case "multipleOf":
          setResponseValueAndErrors$2(res, "multipleOf", check.value, check.message, refs);
          break;
      }
    }
    return res;
  }
  function parseBooleanDef$2() {
    return {
      type: "boolean"
    };
  }
  function parseBrandedDef$2(_def, refs) {
    return parseDef$2(_def.type._def, refs);
  }
  const parseCatchDef$2 = (def, refs) => {
    return parseDef$2(def.innerType._def, refs);
  };
  function parseDateDef$2(def, refs, overrideDateStrategy) {
    const strategy = overrideDateStrategy ?? refs.dateStrategy;
    if (Array.isArray(strategy)) {
      return {
        anyOf: strategy.map((item, i2) => parseDateDef$2(def, refs, item))
      };
    }
    switch (strategy) {
      case "string":
      case "format:date-time":
        return {
          type: "string",
          format: "date-time"
        };
      case "format:date":
        return {
          type: "string",
          format: "date"
        };
      case "integer":
        return integerDateParser$2(def, refs);
    }
  }
  const integerDateParser$2 = (def, refs) => {
    const res = {
      type: "integer",
      format: "unix-time"
    };
    if (refs.target === "openApi3") {
      return res;
    }
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors$2(
            res,
            "minimum",
            check.value,
            // This is in milliseconds
            check.message,
            refs
          );
          break;
        case "max":
          setResponseValueAndErrors$2(
            res,
            "maximum",
            check.value,
            // This is in milliseconds
            check.message,
            refs
          );
          break;
      }
    }
    return res;
  };
  function parseDefaultDef$2(_def, refs) {
    return {
      ...parseDef$2(_def.innerType._def, refs),
      default: _def.defaultValue()
    };
  }
  function parseEffectsDef$2(_def, refs) {
    return refs.effectStrategy === "input" ? parseDef$2(_def.schema._def, refs) : {};
  }
  function parseEnumDef$2(def) {
    return {
      type: "string",
      enum: Array.from(def.values)
    };
  }
  const isJsonSchema7AllOfType$2 = (type) => {
    if ("type" in type && type.type === "string")
      return false;
    return "allOf" in type;
  };
  function parseIntersectionDef$2(def, refs) {
    const allOf = [
      parseDef$2(def.left._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", "0"]
      }),
      parseDef$2(def.right._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", "1"]
      })
    ].filter((x) => !!x);
    let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
    const mergedAllOf = [];
    allOf.forEach((schema) => {
      if (isJsonSchema7AllOfType$2(schema)) {
        mergedAllOf.push(...schema.allOf);
        if (schema.unevaluatedProperties === void 0) {
          unevaluatedProperties = void 0;
        }
      } else {
        let nestedSchema = schema;
        if ("additionalProperties" in schema && schema.additionalProperties === false) {
          const { additionalProperties, ...rest } = schema;
          nestedSchema = rest;
        } else {
          unevaluatedProperties = void 0;
        }
        mergedAllOf.push(nestedSchema);
      }
    });
    return mergedAllOf.length ? {
      allOf: mergedAllOf,
      ...unevaluatedProperties
    } : void 0;
  }
  function parseLiteralDef$2(def, refs) {
    const parsedType = typeof def.value;
    if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
      return {
        type: Array.isArray(def.value) ? "array" : "object"
      };
    }
    if (refs.target === "openApi3") {
      return {
        type: parsedType === "bigint" ? "integer" : parsedType,
        enum: [def.value]
      };
    }
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      const: def.value
    };
  }
  let emojiRegex$2 = void 0;
  const zodPatterns$2 = {
    /**
     * `c` was changed to `[cC]` to replicate /i flag
     */
    cuid: /^[cC][^\s-]{8,}$/,
    cuid2: /^[0-9a-z]+$/,
    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
    /**
     * `a-z` was added to replicate /i flag
     */
    email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
    /**
     * Constructed a valid Unicode RegExp
     *
     * Lazily instantiate since this type of regex isn't supported
     * in all envs (e.g. React Native).
     *
     * See:
     * https://github.com/colinhacks/zod/issues/2433
     * Fix in Zod:
     * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
     */
    emoji: () => {
      if (emojiRegex$2 === void 0) {
        emojiRegex$2 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
      }
      return emojiRegex$2;
    },
    /**
     * Unused
     */
    uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
    /**
     * Unused
     */
    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
    /**
     * Unused
     */
    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
    ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
    base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
    nanoid: /^[a-zA-Z0-9_-]{21}$/,
    jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
  };
  function parseStringDef$2(def, refs) {
    const res = {
      type: "string"
    };
    if (def.checks) {
      for (const check of def.checks) {
        switch (check.kind) {
          case "min":
            setResponseValueAndErrors$2(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
            break;
          case "max":
            setResponseValueAndErrors$2(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
            break;
          case "email":
            switch (refs.emailStrategy) {
              case "format:email":
                addFormat$2(res, "email", check.message, refs);
                break;
              case "format:idn-email":
                addFormat$2(res, "idn-email", check.message, refs);
                break;
              case "pattern:zod":
                addPattern$2(res, zodPatterns$2.email, check.message, refs);
                break;
            }
            break;
          case "url":
            addFormat$2(res, "uri", check.message, refs);
            break;
          case "uuid":
            addFormat$2(res, "uuid", check.message, refs);
            break;
          case "regex":
            addPattern$2(res, check.regex, check.message, refs);
            break;
          case "cuid":
            addPattern$2(res, zodPatterns$2.cuid, check.message, refs);
            break;
          case "cuid2":
            addPattern$2(res, zodPatterns$2.cuid2, check.message, refs);
            break;
          case "startsWith":
            addPattern$2(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);
            break;
          case "endsWith":
            addPattern$2(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);
            break;
          case "datetime":
            addFormat$2(res, "date-time", check.message, refs);
            break;
          case "date":
            addFormat$2(res, "date", check.message, refs);
            break;
          case "time":
            addFormat$2(res, "time", check.message, refs);
            break;
          case "duration":
            addFormat$2(res, "duration", check.message, refs);
            break;
          case "length":
            setResponseValueAndErrors$2(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
            setResponseValueAndErrors$2(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
            break;
          case "includes": {
            addPattern$2(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);
            break;
          }
          case "ip": {
            if (check.version !== "v6") {
              addFormat$2(res, "ipv4", check.message, refs);
            }
            if (check.version !== "v4") {
              addFormat$2(res, "ipv6", check.message, refs);
            }
            break;
          }
          case "base64url":
            addPattern$2(res, zodPatterns$2.base64url, check.message, refs);
            break;
          case "jwt":
            addPattern$2(res, zodPatterns$2.jwt, check.message, refs);
            break;
          case "cidr": {
            if (check.version !== "v6") {
              addPattern$2(res, zodPatterns$2.ipv4Cidr, check.message, refs);
            }
            if (check.version !== "v4") {
              addPattern$2(res, zodPatterns$2.ipv6Cidr, check.message, refs);
            }
            break;
          }
          case "emoji":
            addPattern$2(res, zodPatterns$2.emoji(), check.message, refs);
            break;
          case "ulid": {
            addPattern$2(res, zodPatterns$2.ulid, check.message, refs);
            break;
          }
          case "base64": {
            switch (refs.base64Strategy) {
              case "format:binary": {
                addFormat$2(res, "binary", check.message, refs);
                break;
              }
              case "contentEncoding:base64": {
                setResponseValueAndErrors$2(res, "contentEncoding", "base64", check.message, refs);
                break;
              }
              case "pattern:zod": {
                addPattern$2(res, zodPatterns$2.base64, check.message, refs);
                break;
              }
            }
            break;
          }
          case "nanoid": {
            addPattern$2(res, zodPatterns$2.nanoid, check.message, refs);
          }
        }
      }
    }
    return res;
  }
  function escapeLiteralCheckValue(literal, refs) {
    return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric$2(literal) : literal;
  }
  const ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
  function escapeNonAlphaNumeric$2(source2) {
    let result = "";
    for (let i2 = 0; i2 < source2.length; i2++) {
      if (!ALPHA_NUMERIC.has(source2[i2])) {
        result += "\\";
      }
      result += source2[i2];
    }
    return result;
  }
  function addFormat$2(schema, value, message, refs) {
    var _a3;
    if (schema.format || ((_a3 = schema.anyOf) == null ? void 0 : _a3.some((x) => x.format))) {
      if (!schema.anyOf) {
        schema.anyOf = [];
      }
      if (schema.format) {
        schema.anyOf.push({
          format: schema.format,
          ...schema.errorMessage && refs.errorMessages && {
            errorMessage: { format: schema.errorMessage.format }
          }
        });
        delete schema.format;
        if (schema.errorMessage) {
          delete schema.errorMessage.format;
          if (Object.keys(schema.errorMessage).length === 0) {
            delete schema.errorMessage;
          }
        }
      }
      schema.anyOf.push({
        format: value,
        ...message && refs.errorMessages && { errorMessage: { format: message } }
      });
    } else {
      setResponseValueAndErrors$2(schema, "format", value, message, refs);
    }
  }
  function addPattern$2(schema, regex, message, refs) {
    var _a3;
    if (schema.pattern || ((_a3 = schema.allOf) == null ? void 0 : _a3.some((x) => x.pattern))) {
      if (!schema.allOf) {
        schema.allOf = [];
      }
      if (schema.pattern) {
        schema.allOf.push({
          pattern: schema.pattern,
          ...schema.errorMessage && refs.errorMessages && {
            errorMessage: { pattern: schema.errorMessage.pattern }
          }
        });
        delete schema.pattern;
        if (schema.errorMessage) {
          delete schema.errorMessage.pattern;
          if (Object.keys(schema.errorMessage).length === 0) {
            delete schema.errorMessage;
          }
        }
      }
      schema.allOf.push({
        pattern: stringifyRegExpWithFlags(regex, refs),
        ...message && refs.errorMessages && { errorMessage: { pattern: message } }
      });
    } else {
      setResponseValueAndErrors$2(schema, "pattern", stringifyRegExpWithFlags(regex, refs), message, refs);
    }
  }
  function stringifyRegExpWithFlags(regex, refs) {
    var _a3;
    if (!refs.applyRegexFlags || !regex.flags) {
      return regex.source;
    }
    const flags = {
      i: regex.flags.includes("i"),
      m: regex.flags.includes("m"),
      s: regex.flags.includes("s")
      // `.` matches newlines
    };
    const source2 = flags.i ? regex.source.toLowerCase() : regex.source;
    let pattern = "";
    let isEscaped = false;
    let inCharGroup = false;
    let inCharRange = false;
    for (let i2 = 0; i2 < source2.length; i2++) {
      if (isEscaped) {
        pattern += source2[i2];
        isEscaped = false;
        continue;
      }
      if (flags.i) {
        if (inCharGroup) {
          if (source2[i2].match(/[a-z]/)) {
            if (inCharRange) {
              pattern += source2[i2];
              pattern += `${source2[i2 - 2]}-${source2[i2]}`.toUpperCase();
              inCharRange = false;
            } else if (source2[i2 + 1] === "-" && ((_a3 = source2[i2 + 2]) == null ? void 0 : _a3.match(/[a-z]/))) {
              pattern += source2[i2];
              inCharRange = true;
            } else {
              pattern += `${source2[i2]}${source2[i2].toUpperCase()}`;
            }
            continue;
          }
        } else if (source2[i2].match(/[a-z]/)) {
          pattern += `[${source2[i2]}${source2[i2].toUpperCase()}]`;
          continue;
        }
      }
      if (flags.m) {
        if (source2[i2] === "^") {
          pattern += `(^|(?<=[\r
]))`;
          continue;
        } else if (source2[i2] === "$") {
          pattern += `($|(?=[\r
]))`;
          continue;
        }
      }
      if (flags.s && source2[i2] === ".") {
        pattern += inCharGroup ? `${source2[i2]}\r
` : `[${source2[i2]}\r
]`;
        continue;
      }
      pattern += source2[i2];
      if (source2[i2] === "\\") {
        isEscaped = true;
      } else if (inCharGroup && source2[i2] === "]") {
        inCharGroup = false;
      } else if (!inCharGroup && source2[i2] === "[") {
        inCharGroup = true;
      }
    }
    try {
      new RegExp(pattern);
    } catch {
      console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
      return regex.source;
    }
    return pattern;
  }
  function parseRecordDef$2(def, refs) {
    var _a3, _b2, _c2, _d2, _e2, _f2;
    if (refs.target === "openAi") {
      console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
    }
    if (refs.target === "openApi3" && ((_a3 = def.keyType) == null ? void 0 : _a3._def.typeName) === ZodFirstPartyTypeKind$1.ZodEnum) {
      return {
        type: "object",
        required: def.keyType._def.values,
        properties: def.keyType._def.values.reduce((acc, key) => ({
          ...acc,
          [key]: parseDef$2(def.valueType._def, {
            ...refs,
            currentPath: [...refs.currentPath, "properties", key]
          }) ?? {}
        }), {}),
        additionalProperties: refs.rejectedAdditionalProperties
      };
    }
    const schema = {
      type: "object",
      additionalProperties: parseDef$2(def.valueType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalProperties"]
      }) ?? refs.allowedAdditionalProperties
    };
    if (refs.target === "openApi3") {
      return schema;
    }
    if (((_b2 = def.keyType) == null ? void 0 : _b2._def.typeName) === ZodFirstPartyTypeKind$1.ZodString && ((_c2 = def.keyType._def.checks) == null ? void 0 : _c2.length)) {
      const { type, ...keyType } = parseStringDef$2(def.keyType._def, refs);
      return {
        ...schema,
        propertyNames: keyType
      };
    } else if (((_d2 = def.keyType) == null ? void 0 : _d2._def.typeName) === ZodFirstPartyTypeKind$1.ZodEnum) {
      return {
        ...schema,
        propertyNames: {
          enum: def.keyType._def.values
        }
      };
    } else if (((_e2 = def.keyType) == null ? void 0 : _e2._def.typeName) === ZodFirstPartyTypeKind$1.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind$1.ZodString && ((_f2 = def.keyType._def.type._def.checks) == null ? void 0 : _f2.length)) {
      const { type, ...keyType } = parseBrandedDef$2(def.keyType._def, refs);
      return {
        ...schema,
        propertyNames: keyType
      };
    }
    return schema;
  }
  function parseMapDef$2(def, refs) {
    if (refs.mapStrategy === "record") {
      return parseRecordDef$2(def, refs);
    }
    const keys = parseDef$2(def.keyType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items", "items", "0"]
    }) || {};
    const values = parseDef$2(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items", "items", "1"]
    }) || {};
    return {
      type: "array",
      maxItems: 125,
      items: {
        type: "array",
        items: [keys, values],
        minItems: 2,
        maxItems: 2
      }
    };
  }
  function parseNativeEnumDef$2(def) {
    const object = def.values;
    const actualKeys = Object.keys(def.values).filter((key) => {
      return typeof object[object[key]] !== "number";
    });
    const actualValues = actualKeys.map((key) => object[key]);
    const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
    return {
      type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
      enum: actualValues
    };
  }
  function parseNeverDef$2() {
    return {
      not: {}
    };
  }
  function parseNullDef$2(refs) {
    return refs.target === "openApi3" ? {
      enum: ["null"],
      nullable: true
    } : {
      type: "null"
    };
  }
  const primitiveMappings$2 = {
    ZodString: "string",
    ZodNumber: "number",
    ZodBigInt: "integer",
    ZodBoolean: "boolean",
    ZodNull: "null"
  };
  function parseUnionDef$2(def, refs) {
    if (refs.target === "openApi3")
      return asAnyOf$2(def, refs);
    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
    if (options.every((x) => x._def.typeName in primitiveMappings$2 && (!x._def.checks || !x._def.checks.length))) {
      const types = options.reduce((types2, x) => {
        const type = primitiveMappings$2[x._def.typeName];
        return type && !types2.includes(type) ? [...types2, type] : types2;
      }, []);
      return {
        type: types.length > 1 ? types : types[0]
      };
    } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
      const types = options.reduce((acc, x) => {
        const type = typeof x._def.value;
        switch (type) {
          case "string":
          case "number":
          case "boolean":
            return [...acc, type];
          case "bigint":
            return [...acc, "integer"];
          case "object":
            if (x._def.value === null)
              return [...acc, "null"];
          case "symbol":
          case "undefined":
          case "function":
          default:
            return acc;
        }
      }, []);
      if (types.length === options.length) {
        const uniqueTypes = types.filter((x, i2, a) => a.indexOf(x) === i2);
        return {
          type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
          enum: options.reduce((acc, x) => {
            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
          }, [])
        };
      }
    } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
      return {
        type: "string",
        enum: options.reduce((acc, x) => [
          ...acc,
          ...x._def.values.filter((x2) => !acc.includes(x2))
        ], [])
      };
    }
    return asAnyOf$2(def, refs);
  }
  const asAnyOf$2 = (def, refs) => {
    const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i2) => parseDef$2(x._def, {
      ...refs,
      currentPath: [...refs.currentPath, "anyOf", `${i2}`]
    })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
    return anyOf.length ? { anyOf } : void 0;
  };
  function parseNullableDef$2(def, refs) {
    if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
      if (refs.target === "openApi3") {
        return {
          type: primitiveMappings$2[def.innerType._def.typeName],
          nullable: true
        };
      }
      return {
        type: [
          primitiveMappings$2[def.innerType._def.typeName],
          "null"
        ]
      };
    }
    if (refs.target === "openApi3") {
      const base2 = parseDef$2(def.innerType._def, {
        ...refs,
        currentPath: [...refs.currentPath]
      });
      if (base2 && "$ref" in base2)
        return { allOf: [base2], nullable: true };
      return base2 && { ...base2, nullable: true };
    }
    const base = parseDef$2(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "anyOf", "0"]
    });
    return base && { anyOf: [base, { type: "null" }] };
  }
  function parseNumberDef$2(def, refs) {
    const res = {
      type: "number"
    };
    if (!def.checks)
      return res;
    for (const check of def.checks) {
      switch (check.kind) {
        case "int":
          res.type = "integer";
          addErrorMessage$2(res, "type", check.message, refs);
          break;
        case "min":
          if (refs.target === "jsonSchema7") {
            if (check.inclusive) {
              setResponseValueAndErrors$2(res, "minimum", check.value, check.message, refs);
            } else {
              setResponseValueAndErrors$2(res, "exclusiveMinimum", check.value, check.message, refs);
            }
          } else {
            if (!check.inclusive) {
              res.exclusiveMinimum = true;
            }
            setResponseValueAndErrors$2(res, "minimum", check.value, check.message, refs);
          }
          break;
        case "max":
          if (refs.target === "jsonSchema7") {
            if (check.inclusive) {
              setResponseValueAndErrors$2(res, "maximum", check.value, check.message, refs);
            } else {
              setResponseValueAndErrors$2(res, "exclusiveMaximum", check.value, check.message, refs);
            }
          } else {
            if (!check.inclusive) {
              res.exclusiveMaximum = true;
            }
            setResponseValueAndErrors$2(res, "maximum", check.value, check.message, refs);
          }
          break;
        case "multipleOf":
          setResponseValueAndErrors$2(res, "multipleOf", check.value, check.message, refs);
          break;
      }
    }
    return res;
  }
  function parseObjectDef$2(def, refs) {
    const forceOptionalIntoNullable = refs.target === "openAi";
    const result = {
      type: "object",
      properties: {}
    };
    const required = [];
    const shape = def.shape();
    for (const propName in shape) {
      let propDef = shape[propName];
      if (propDef === void 0 || propDef._def === void 0) {
        continue;
      }
      let propOptional = safeIsOptional(propDef);
      if (propOptional && forceOptionalIntoNullable) {
        if (propDef instanceof ZodOptional$1) {
          propDef = propDef._def.innerType;
        }
        if (!propDef.isNullable()) {
          propDef = propDef.nullable();
        }
        propOptional = false;
      }
      const parsedDef = parseDef$2(propDef._def, {
        ...refs,
        currentPath: [...refs.currentPath, "properties", propName],
        propertyPath: [...refs.currentPath, "properties", propName]
      });
      if (parsedDef === void 0) {
        continue;
      }
      result.properties[propName] = parsedDef;
      if (!propOptional) {
        required.push(propName);
      }
    }
    if (required.length) {
      result.required = required;
    }
    const additionalProperties = decideAdditionalProperties$2(def, refs);
    if (additionalProperties !== void 0) {
      result.additionalProperties = additionalProperties;
    }
    return result;
  }
  function decideAdditionalProperties$2(def, refs) {
    if (def.catchall._def.typeName !== "ZodNever") {
      return parseDef$2(def.catchall._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalProperties"]
      });
    }
    switch (def.unknownKeys) {
      case "passthrough":
        return refs.allowedAdditionalProperties;
      case "strict":
        return refs.rejectedAdditionalProperties;
      case "strip":
        return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
    }
  }
  function safeIsOptional(schema) {
    try {
      return schema.isOptional();
    } catch {
      return true;
    }
  }
  const parseOptionalDef$2 = (def, refs) => {
    var _a3;
    if (refs.currentPath.toString() === ((_a3 = refs.propertyPath) == null ? void 0 : _a3.toString())) {
      return parseDef$2(def.innerType._def, refs);
    }
    const innerSchema = parseDef$2(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "anyOf", "1"]
    });
    return innerSchema ? {
      anyOf: [
        {
          not: {}
        },
        innerSchema
      ]
    } : {};
  };
  const parsePipelineDef$2 = (def, refs) => {
    if (refs.pipeStrategy === "input") {
      return parseDef$2(def.in._def, refs);
    } else if (refs.pipeStrategy === "output") {
      return parseDef$2(def.out._def, refs);
    }
    const a = parseDef$2(def.in._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    });
    const b = parseDef$2(def.out._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
    });
    return {
      allOf: [a, b].filter((x) => x !== void 0)
    };
  };
  function parsePromiseDef$2(def, refs) {
    return parseDef$2(def.type._def, refs);
  }
  function parseSetDef$2(def, refs) {
    const items = parseDef$2(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
    const schema = {
      type: "array",
      uniqueItems: true,
      items
    };
    if (def.minSize) {
      setResponseValueAndErrors$2(schema, "minItems", def.minSize.value, def.minSize.message, refs);
    }
    if (def.maxSize) {
      setResponseValueAndErrors$2(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
    }
    return schema;
  }
  function parseTupleDef$2(def, refs) {
    if (def.rest) {
      return {
        type: "array",
        minItems: def.items.length,
        items: def.items.map((x, i2) => parseDef$2(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i2}`]
        })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
        additionalItems: parseDef$2(def.rest._def, {
          ...refs,
          currentPath: [...refs.currentPath, "additionalItems"]
        })
      };
    } else {
      return {
        type: "array",
        minItems: def.items.length,
        maxItems: def.items.length,
        items: def.items.map((x, i2) => parseDef$2(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i2}`]
        })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
      };
    }
  }
  function parseUndefinedDef$2() {
    return {
      not: {}
    };
  }
  function parseUnknownDef$2() {
    return {};
  }
  const parseReadonlyDef$2 = (def, refs) => {
    return parseDef$2(def.innerType._def, refs);
  };
  const selectParser$2 = (def, typeName, refs) => {
    switch (typeName) {
      case ZodFirstPartyTypeKind$1.ZodString:
        return parseStringDef$2(def, refs);
      case ZodFirstPartyTypeKind$1.ZodNumber:
        return parseNumberDef$2(def, refs);
      case ZodFirstPartyTypeKind$1.ZodObject:
        return parseObjectDef$2(def, refs);
      case ZodFirstPartyTypeKind$1.ZodBigInt:
        return parseBigintDef$2(def, refs);
      case ZodFirstPartyTypeKind$1.ZodBoolean:
        return parseBooleanDef$2();
      case ZodFirstPartyTypeKind$1.ZodDate:
        return parseDateDef$2(def, refs);
      case ZodFirstPartyTypeKind$1.ZodUndefined:
        return parseUndefinedDef$2();
      case ZodFirstPartyTypeKind$1.ZodNull:
        return parseNullDef$2(refs);
      case ZodFirstPartyTypeKind$1.ZodArray:
        return parseArrayDef$2(def, refs);
      case ZodFirstPartyTypeKind$1.ZodUnion:
      case ZodFirstPartyTypeKind$1.ZodDiscriminatedUnion:
        return parseUnionDef$2(def, refs);
      case ZodFirstPartyTypeKind$1.ZodIntersection:
        return parseIntersectionDef$2(def, refs);
      case ZodFirstPartyTypeKind$1.ZodTuple:
        return parseTupleDef$2(def, refs);
      case ZodFirstPartyTypeKind$1.ZodRecord:
        return parseRecordDef$2(def, refs);
      case ZodFirstPartyTypeKind$1.ZodLiteral:
        return parseLiteralDef$2(def, refs);
      case ZodFirstPartyTypeKind$1.ZodEnum:
        return parseEnumDef$2(def);
      case ZodFirstPartyTypeKind$1.ZodNativeEnum:
        return parseNativeEnumDef$2(def);
      case ZodFirstPartyTypeKind$1.ZodNullable:
        return parseNullableDef$2(def, refs);
      case ZodFirstPartyTypeKind$1.ZodOptional:
        return parseOptionalDef$2(def, refs);
      case ZodFirstPartyTypeKind$1.ZodMap:
        return parseMapDef$2(def, refs);
      case ZodFirstPartyTypeKind$1.ZodSet:
        return parseSetDef$2(def, refs);
      case ZodFirstPartyTypeKind$1.ZodLazy:
        return () => def.getter()._def;
      case ZodFirstPartyTypeKind$1.ZodPromise:
        return parsePromiseDef$2(def, refs);
      case ZodFirstPartyTypeKind$1.ZodNaN:
      case ZodFirstPartyTypeKind$1.ZodNever:
        return parseNeverDef$2();
      case ZodFirstPartyTypeKind$1.ZodEffects:
        return parseEffectsDef$2(def, refs);
      case ZodFirstPartyTypeKind$1.ZodAny:
        return parseAnyDef$2();
      case ZodFirstPartyTypeKind$1.ZodUnknown:
        return parseUnknownDef$2();
      case ZodFirstPartyTypeKind$1.ZodDefault:
        return parseDefaultDef$2(def, refs);
      case ZodFirstPartyTypeKind$1.ZodBranded:
        return parseBrandedDef$2(def, refs);
      case ZodFirstPartyTypeKind$1.ZodReadonly:
        return parseReadonlyDef$2(def, refs);
      case ZodFirstPartyTypeKind$1.ZodCatch:
        return parseCatchDef$2(def, refs);
      case ZodFirstPartyTypeKind$1.ZodPipeline:
        return parsePipelineDef$2(def, refs);
      case ZodFirstPartyTypeKind$1.ZodFunction:
      case ZodFirstPartyTypeKind$1.ZodVoid:
      case ZodFirstPartyTypeKind$1.ZodSymbol:
        return void 0;
      default:
        return /* @__PURE__ */ ((_) => void 0)();
    }
  };
  function parseDef$2(def, refs, forceResolution = false) {
    var _a3;
    const seenItem = refs.seen.get(def);
    if (refs.override) {
      const overrideResult = (_a3 = refs.override) == null ? void 0 : _a3.call(refs, def, refs, seenItem, forceResolution);
      if (overrideResult !== ignoreOverride$2) {
        return overrideResult;
      }
    }
    if (seenItem && !forceResolution) {
      const seenSchema = get$ref$2(seenItem, refs);
      if (seenSchema !== void 0) {
        return seenSchema;
      }
    }
    const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
    refs.seen.set(def, newItem);
    const jsonSchemaOrGetter = selectParser$2(def, def.typeName, refs);
    const jsonSchema = typeof jsonSchemaOrGetter === "function" ? parseDef$2(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
    if (jsonSchema) {
      addMeta$2(def, refs, jsonSchema);
    }
    if (refs.postProcess) {
      const postProcessResult = refs.postProcess(jsonSchema, def, refs);
      newItem.jsonSchema = jsonSchema;
      return postProcessResult;
    }
    newItem.jsonSchema = jsonSchema;
    return jsonSchema;
  }
  const get$ref$2 = (item, refs) => {
    switch (refs.$refStrategy) {
      case "root":
        return { $ref: item.path.join("/") };
      case "relative":
        return { $ref: getRelativePath$2(refs.currentPath, item.path) };
      case "none":
      case "seen": {
        if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
          console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
          return {};
        }
        return refs.$refStrategy === "seen" ? {} : void 0;
      }
    }
  };
  const getRelativePath$2 = (pathA, pathB) => {
    let i2 = 0;
    for (; i2 < pathA.length && i2 < pathB.length; i2++) {
      if (pathA[i2] !== pathB[i2])
        break;
    }
    return [(pathA.length - i2).toString(), ...pathB.slice(i2)].join("/");
  };
  const addMeta$2 = (def, refs, jsonSchema) => {
    if (def.description) {
      jsonSchema.description = def.description;
      if (refs.markdownDescription) {
        jsonSchema.markdownDescription = def.description;
      }
    }
    return jsonSchema;
  };
  const zodToJsonSchema$4 = (schema, options) => {
    const refs = getRefs$2(options);
    const definitions = void 0;
    const name = options == null ? void 0 : options.name;
    const main = parseDef$2(
      schema._def,
      refs,
      false
    ) ?? {};
    const combined = name === void 0 ? definitions ? {
      ...main,
      [refs.definitionPath]: definitions
    } : main : {
      $ref: [
        ...refs.$refStrategy === "relative" ? [] : refs.basePath,
        refs.definitionPath,
        name
      ].join("/"),
      [refs.definitionPath]: {
        ...definitions,
        [name]: main
      }
    };
    if (refs.target === "jsonSchema7") {
      combined.$schema = "http://json-schema.org/draft-07/schema#";
    } else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") {
      combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
    }
    if (refs.target === "openAi" && ("anyOf" in combined || "oneOf" in combined || "allOf" in combined || "type" in combined && Array.isArray(combined.type))) {
      console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
    }
    return combined;
  };
  const ignoreOverride$1 = Symbol("Let zodToJsonSchema decide on which parser to use");
  const defaultOptions$1 = {
    name: void 0,
    $refStrategy: "root",
    effectStrategy: "input",
    pipeStrategy: "all",
    dateStrategy: "format:date-time",
    mapStrategy: "entries",
    nullableStrategy: "from-target",
    removeAdditionalStrategy: "passthrough",
    definitionPath: "definitions",
    target: "jsonSchema7",
    strictUnions: false,
    errorMessages: false,
    markdownDescription: false,
    patternStrategy: "escape",
    applyRegexFlags: false,
    emailStrategy: "format:email",
    base64Strategy: "contentEncoding:base64",
    nameStrategy: "ref"
  };
  const getDefaultOptions$1 = (options) => {
    return typeof options === "string" ? {
      ...defaultOptions$1,
      basePath: ["#"],
      definitions: {},
      name: options
    } : {
      ...defaultOptions$1,
      basePath: ["#"],
      definitions: {},
      ...options
    };
  };
  const zodDef$1 = (zodSchema) => {
    return "_def" in zodSchema ? zodSchema._def : zodSchema;
  };
  function isEmptyObj$3(obj) {
    if (!obj)
      return true;
    for (const _k2 in obj)
      return false;
    return true;
  }
  const getRefs$1 = (options) => {
    const _options = getDefaultOptions$1(options);
    const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
    return {
      ..._options,
      currentPath,
      propertyPath: void 0,
      seenRefs: /* @__PURE__ */ new Set(),
      seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [
        zodDef$1(def),
        {
          def: zodDef$1(def),
          path: [..._options.basePath, _options.definitionPath, name],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ]))
    };
  };
  function addErrorMessage$1(res, key, errorMessage, refs) {
    if (!(refs == null ? void 0 : refs.errorMessages))
      return;
    if (errorMessage) {
      res.errorMessage = {
        ...res.errorMessage,
        [key]: errorMessage
      };
    }
  }
  function setResponseValueAndErrors$1(res, key, value, errorMessage, refs) {
    res[key] = value;
    addErrorMessage$1(res, key, errorMessage, refs);
  }
  function parseAnyDef$1() {
    return {};
  }
  function parseArrayDef$1(def, refs) {
    var _a3, _b2;
    const res = {
      type: "array"
    };
    if (((_b2 = (_a3 = def.type) == null ? void 0 : _a3._def) == null ? void 0 : _b2.typeName) !== ZodFirstPartyTypeKind$1.ZodAny) {
      res.items = parseDef$1(def.type._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items"]
      });
    }
    if (def.minLength) {
      setResponseValueAndErrors$1(res, "minItems", def.minLength.value, def.minLength.message, refs);
    }
    if (def.maxLength) {
      setResponseValueAndErrors$1(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
    }
    if (def.exactLength) {
      setResponseValueAndErrors$1(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
      setResponseValueAndErrors$1(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
    }
    return res;
  }
  function parseBigintDef$1(def, refs) {
    const res = {
      type: "integer",
      format: "int64"
    };
    if (!def.checks)
      return res;
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          if (refs.target === "jsonSchema7") {
            if (check.inclusive) {
              setResponseValueAndErrors$1(res, "minimum", check.value, check.message, refs);
            } else {
              setResponseValueAndErrors$1(res, "exclusiveMinimum", check.value, check.message, refs);
            }
          } else {
            if (!check.inclusive) {
              res.exclusiveMinimum = true;
            }
            setResponseValueAndErrors$1(res, "minimum", check.value, check.message, refs);
          }
          break;
        case "max":
          if (refs.target === "jsonSchema7") {
            if (check.inclusive) {
              setResponseValueAndErrors$1(res, "maximum", check.value, check.message, refs);
            } else {
              setResponseValueAndErrors$1(res, "exclusiveMaximum", check.value, check.message, refs);
            }
          } else {
            if (!check.inclusive) {
              res.exclusiveMaximum = true;
            }
            setResponseValueAndErrors$1(res, "maximum", check.value, check.message, refs);
          }
          break;
        case "multipleOf":
          setResponseValueAndErrors$1(res, "multipleOf", check.value, check.message, refs);
          break;
      }
    }
    return res;
  }
  function parseBooleanDef$1() {
    return {
      type: "boolean"
    };
  }
  function parseBrandedDef$1(_def, refs) {
    return parseDef$1(_def.type._def, refs);
  }
  const parseCatchDef$1 = (def, refs) => {
    return parseDef$1(def.innerType._def, refs);
  };
  function parseDateDef$1(def, refs, overrideDateStrategy) {
    const strategy = overrideDateStrategy ?? refs.dateStrategy;
    if (Array.isArray(strategy)) {
      return {
        anyOf: strategy.map((item, i2) => parseDateDef$1(def, refs, item))
      };
    }
    switch (strategy) {
      case "string":
      case "format:date-time":
        return {
          type: "string",
          format: "date-time"
        };
      case "format:date":
        return {
          type: "string",
          format: "date"
        };
      case "integer":
        return integerDateParser$1(def, refs);
    }
  }
  const integerDateParser$1 = (def, refs) => {
    const res = {
      type: "integer",
      format: "unix-time"
    };
    if (refs.target === "openApi3") {
      return res;
    }
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors$1(
            res,
            "minimum",
            check.value,
            // This is in milliseconds
            check.message,
            refs
          );
          break;
        case "max":
          setResponseValueAndErrors$1(
            res,
            "maximum",
            check.value,
            // This is in milliseconds
            check.message,
            refs
          );
          break;
      }
    }
    return res;
  };
  function parseDefaultDef$1(_def, refs) {
    return {
      ...parseDef$1(_def.innerType._def, refs),
      default: _def.defaultValue()
    };
  }
  function parseEffectsDef$1(_def, refs, forceResolution) {
    return refs.effectStrategy === "input" ? parseDef$1(_def.schema._def, refs, forceResolution) : {};
  }
  function parseEnumDef$1(def) {
    return {
      type: "string",
      enum: [...def.values]
    };
  }
  const isJsonSchema7AllOfType$1 = (type) => {
    if ("type" in type && type.type === "string")
      return false;
    return "allOf" in type;
  };
  function parseIntersectionDef$1(def, refs) {
    const allOf = [
      parseDef$1(def.left._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", "0"]
      }),
      parseDef$1(def.right._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", "1"]
      })
    ].filter((x) => !!x);
    let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
    const mergedAllOf = [];
    allOf.forEach((schema) => {
      if (isJsonSchema7AllOfType$1(schema)) {
        mergedAllOf.push(...schema.allOf);
        if (schema.unevaluatedProperties === void 0) {
          unevaluatedProperties = void 0;
        }
      } else {
        let nestedSchema = schema;
        if ("additionalProperties" in schema && schema.additionalProperties === false) {
          const { additionalProperties, ...rest } = schema;
          nestedSchema = rest;
        } else {
          unevaluatedProperties = void 0;
        }
        mergedAllOf.push(nestedSchema);
      }
    });
    return mergedAllOf.length ? {
      allOf: mergedAllOf,
      ...unevaluatedProperties
    } : void 0;
  }
  function parseLiteralDef$1(def, refs) {
    const parsedType = typeof def.value;
    if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
      return {
        type: Array.isArray(def.value) ? "array" : "object"
      };
    }
    if (refs.target === "openApi3") {
      return {
        type: parsedType === "bigint" ? "integer" : parsedType,
        enum: [def.value]
      };
    }
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      const: def.value
    };
  }
  let emojiRegex$1;
  const zodPatterns$1 = {
    /**
     * `c` was changed to `[cC]` to replicate /i flag
     */
    cuid: /^[cC][^\s-]{8,}$/,
    cuid2: /^[0-9a-z]+$/,
    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
    /**
     * `a-z` was added to replicate /i flag
     */
    email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
    /**
     * Constructed a valid Unicode RegExp
     *
     * Lazily instantiate since this type of regex isn't supported
     * in all envs (e.g. React Native).
     *
     * See:
     * https://github.com/colinhacks/zod/issues/2433
     * Fix in Zod:
     * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
     */
    emoji: () => {
      if (emojiRegex$1 === void 0) {
        emojiRegex$1 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
      }
      return emojiRegex$1;
    },
    /**
     * Unused
     */
    uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
    /**
     * Unused
     */
    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    /**
     * Unused
     */
    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
    nanoid: /^[a-zA-Z0-9_-]{21}$/
  };
  function parseStringDef$1(def, refs) {
    const res = {
      type: "string"
    };
    function processPattern(value) {
      return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric$1(value) : value;
    }
    if (def.checks) {
      for (const check of def.checks) {
        switch (check.kind) {
          case "min":
            setResponseValueAndErrors$1(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
            break;
          case "max":
            setResponseValueAndErrors$1(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
            break;
          case "email":
            switch (refs.emailStrategy) {
              case "format:email":
                addFormat$1(res, "email", check.message, refs);
                break;
              case "format:idn-email":
                addFormat$1(res, "idn-email", check.message, refs);
                break;
              case "pattern:zod":
                addPattern$1(res, zodPatterns$1.email, check.message, refs);
                break;
            }
            break;
          case "url":
            addFormat$1(res, "uri", check.message, refs);
            break;
          case "uuid":
            addFormat$1(res, "uuid", check.message, refs);
            break;
          case "regex":
            addPattern$1(res, check.regex, check.message, refs);
            break;
          case "cuid":
            addPattern$1(res, zodPatterns$1.cuid, check.message, refs);
            break;
          case "cuid2":
            addPattern$1(res, zodPatterns$1.cuid2, check.message, refs);
            break;
          case "startsWith":
            addPattern$1(res, RegExp(`^${processPattern(check.value)}`), check.message, refs);
            break;
          case "endsWith":
            addPattern$1(res, RegExp(`${processPattern(check.value)}$`), check.message, refs);
            break;
          case "datetime":
            addFormat$1(res, "date-time", check.message, refs);
            break;
          case "date":
            addFormat$1(res, "date", check.message, refs);
            break;
          case "time":
            addFormat$1(res, "time", check.message, refs);
            break;
          case "duration":
            addFormat$1(res, "duration", check.message, refs);
            break;
          case "length":
            setResponseValueAndErrors$1(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
            setResponseValueAndErrors$1(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
            break;
          case "includes": {
            addPattern$1(res, RegExp(processPattern(check.value)), check.message, refs);
            break;
          }
          case "ip": {
            if (check.version !== "v6") {
              addFormat$1(res, "ipv4", check.message, refs);
            }
            if (check.version !== "v4") {
              addFormat$1(res, "ipv6", check.message, refs);
            }
            break;
          }
          case "emoji":
            addPattern$1(res, zodPatterns$1.emoji, check.message, refs);
            break;
          case "ulid": {
            addPattern$1(res, zodPatterns$1.ulid, check.message, refs);
            break;
          }
          case "base64": {
            switch (refs.base64Strategy) {
              case "format:binary": {
                addFormat$1(res, "binary", check.message, refs);
                break;
              }
              case "contentEncoding:base64": {
                setResponseValueAndErrors$1(res, "contentEncoding", "base64", check.message, refs);
                break;
              }
              case "pattern:zod": {
                addPattern$1(res, zodPatterns$1.base64, check.message, refs);
                break;
              }
            }
            break;
          }
          case "nanoid": {
            addPattern$1(res, zodPatterns$1.nanoid, check.message, refs);
          }
        }
      }
    }
    return res;
  }
  const escapeNonAlphaNumeric$1 = (value) => Array.from(value).map((c) => /[a-zA-Z0-9]/.test(c) ? c : `\\${c}`).join("");
  const addFormat$1 = (schema, value, message, refs) => {
    var _a3;
    if (schema.format || ((_a3 = schema.anyOf) == null ? void 0 : _a3.some((x) => x.format))) {
      if (!schema.anyOf) {
        schema.anyOf = [];
      }
      if (schema.format) {
        schema.anyOf.push({
          format: schema.format,
          ...schema.errorMessage && refs.errorMessages && {
            errorMessage: { format: schema.errorMessage.format }
          }
        });
        delete schema.format;
        if (schema.errorMessage) {
          delete schema.errorMessage.format;
          if (Object.keys(schema.errorMessage).length === 0) {
            delete schema.errorMessage;
          }
        }
      }
      schema.anyOf.push({
        format: value,
        ...message && refs.errorMessages && { errorMessage: { format: message } }
      });
    } else {
      setResponseValueAndErrors$1(schema, "format", value, message, refs);
    }
  };
  const addPattern$1 = (schema, regex, message, refs) => {
    var _a3;
    if (schema.pattern || ((_a3 = schema.allOf) == null ? void 0 : _a3.some((x) => x.pattern))) {
      if (!schema.allOf) {
        schema.allOf = [];
      }
      if (schema.pattern) {
        schema.allOf.push({
          pattern: schema.pattern,
          ...schema.errorMessage && refs.errorMessages && {
            errorMessage: { pattern: schema.errorMessage.pattern }
          }
        });
        delete schema.pattern;
        if (schema.errorMessage) {
          delete schema.errorMessage.pattern;
          if (Object.keys(schema.errorMessage).length === 0) {
            delete schema.errorMessage;
          }
        }
      }
      schema.allOf.push({
        pattern: processRegExp$1(regex, refs),
        ...message && refs.errorMessages && { errorMessage: { pattern: message } }
      });
    } else {
      setResponseValueAndErrors$1(schema, "pattern", processRegExp$1(regex, refs), message, refs);
    }
  };
  const processRegExp$1 = (regexOrFunction, refs) => {
    var _a3;
    const regex = typeof regexOrFunction === "function" ? regexOrFunction() : regexOrFunction;
    if (!refs.applyRegexFlags || !regex.flags)
      return regex.source;
    const flags = {
      i: regex.flags.includes("i"),
      m: regex.flags.includes("m"),
      s: regex.flags.includes("s")
      // `.` matches newlines
    };
    const source2 = flags.i ? regex.source.toLowerCase() : regex.source;
    let pattern = "";
    let isEscaped = false;
    let inCharGroup = false;
    let inCharRange = false;
    for (let i2 = 0; i2 < source2.length; i2++) {
      if (isEscaped) {
        pattern += source2[i2];
        isEscaped = false;
        continue;
      }
      if (flags.i) {
        if (inCharGroup) {
          if (source2[i2].match(/[a-z]/)) {
            if (inCharRange) {
              pattern += source2[i2];
              pattern += `${source2[i2 - 2]}-${source2[i2]}`.toUpperCase();
              inCharRange = false;
            } else if (source2[i2 + 1] === "-" && ((_a3 = source2[i2 + 2]) == null ? void 0 : _a3.match(/[a-z]/))) {
              pattern += source2[i2];
              inCharRange = true;
            } else {
              pattern += `${source2[i2]}${source2[i2].toUpperCase()}`;
            }
            continue;
          }
        } else if (source2[i2].match(/[a-z]/)) {
          pattern += `[${source2[i2]}${source2[i2].toUpperCase()}]`;
          continue;
        }
      }
      if (flags.m) {
        if (source2[i2] === "^") {
          pattern += `(^|(?<=[\r
]))`;
          continue;
        } else if (source2[i2] === "$") {
          pattern += `($|(?=[\r
]))`;
          continue;
        }
      }
      if (flags.s && source2[i2] === ".") {
        pattern += inCharGroup ? `${source2[i2]}\r
` : `[${source2[i2]}\r
]`;
        continue;
      }
      pattern += source2[i2];
      if (source2[i2] === "\\") {
        isEscaped = true;
      } else if (inCharGroup && source2[i2] === "]") {
        inCharGroup = false;
      } else if (!inCharGroup && source2[i2] === "[") {
        inCharGroup = true;
      }
    }
    try {
      const regexTest = new RegExp(pattern);
    } catch {
      console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
      return regex.source;
    }
    return pattern;
  };
  function parseRecordDef$1(def, refs) {
    var _a3, _b2, _c2, _d2;
    if (refs.target === "openApi3" && ((_a3 = def.keyType) == null ? void 0 : _a3._def.typeName) === ZodFirstPartyTypeKind$1.ZodEnum) {
      return {
        type: "object",
        required: def.keyType._def.values,
        properties: def.keyType._def.values.reduce((acc, key) => ({
          ...acc,
          [key]: parseDef$1(def.valueType._def, {
            ...refs,
            currentPath: [...refs.currentPath, "properties", key]
          }) ?? {}
        }), {}),
        additionalProperties: false
      };
    }
    const schema = {
      type: "object",
      additionalProperties: parseDef$1(def.valueType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalProperties"]
      }) ?? {}
    };
    if (refs.target === "openApi3") {
      return schema;
    }
    if (((_b2 = def.keyType) == null ? void 0 : _b2._def.typeName) === ZodFirstPartyTypeKind$1.ZodString && ((_c2 = def.keyType._def.checks) == null ? void 0 : _c2.length)) {
      const keyType = Object.entries(parseStringDef$1(def.keyType._def, refs)).reduce((acc, [key, value]) => key === "type" ? acc : { ...acc, [key]: value }, {});
      return {
        ...schema,
        propertyNames: keyType
      };
    } else if (((_d2 = def.keyType) == null ? void 0 : _d2._def.typeName) === ZodFirstPartyTypeKind$1.ZodEnum) {
      return {
        ...schema,
        propertyNames: {
          enum: def.keyType._def.values
        }
      };
    }
    return schema;
  }
  function parseMapDef$1(def, refs) {
    if (refs.mapStrategy === "record") {
      return parseRecordDef$1(def, refs);
    }
    const keys = parseDef$1(def.keyType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items", "items", "0"]
    }) || {};
    const values = parseDef$1(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items", "items", "1"]
    }) || {};
    return {
      type: "array",
      maxItems: 125,
      items: {
        type: "array",
        items: [keys, values],
        minItems: 2,
        maxItems: 2
      }
    };
  }
  function parseNativeEnumDef$1(def) {
    const object = def.values;
    const actualKeys = Object.keys(def.values).filter((key) => {
      return typeof object[object[key]] !== "number";
    });
    const actualValues = actualKeys.map((key) => object[key]);
    const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
    return {
      type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
      enum: actualValues
    };
  }
  function parseNeverDef$1() {
    return {
      not: {}
    };
  }
  function parseNullDef$1(refs) {
    return refs.target === "openApi3" ? {
      enum: ["null"],
      nullable: true
    } : {
      type: "null"
    };
  }
  const primitiveMappings$1 = {
    ZodString: "string",
    ZodNumber: "number",
    ZodBigInt: "integer",
    ZodBoolean: "boolean",
    ZodNull: "null"
  };
  function parseUnionDef$1(def, refs) {
    if (refs.target === "openApi3")
      return asAnyOf$1(def, refs);
    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
    if (options.every((x) => x._def.typeName in primitiveMappings$1 && (!x._def.checks || !x._def.checks.length))) {
      const types = options.reduce((types2, x) => {
        const type = primitiveMappings$1[x._def.typeName];
        return type && !types2.includes(type) ? [...types2, type] : types2;
      }, []);
      return {
        type: types.length > 1 ? types : types[0]
      };
    } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
      const types = options.reduce((acc, x) => {
        const type = typeof x._def.value;
        switch (type) {
          case "string":
          case "number":
          case "boolean":
            return [...acc, type];
          case "bigint":
            return [...acc, "integer"];
          case "object":
            if (x._def.value === null)
              return [...acc, "null"];
          case "symbol":
          case "undefined":
          case "function":
          default:
            return acc;
        }
      }, []);
      if (types.length === options.length) {
        const uniqueTypes = types.filter((x, i2, a) => a.indexOf(x) === i2);
        return {
          type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
          enum: options.reduce((acc, x) => {
            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
          }, [])
        };
      }
    } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
      return {
        type: "string",
        enum: options.reduce((acc, x) => [...acc, ...x._def.values.filter((x2) => !acc.includes(x2))], [])
      };
    }
    return asAnyOf$1(def, refs);
  }
  const asAnyOf$1 = (def, refs) => {
    const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i2) => parseDef$1(x._def, {
      ...refs,
      currentPath: [...refs.currentPath, "anyOf", `${i2}`]
    })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
    return anyOf.length ? { anyOf } : void 0;
  };
  function parseNullableDef$1(def, refs) {
    if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
      if (refs.target === "openApi3" || refs.nullableStrategy === "property") {
        return {
          type: primitiveMappings$1[def.innerType._def.typeName],
          nullable: true
        };
      }
      return {
        type: [primitiveMappings$1[def.innerType._def.typeName], "null"]
      };
    }
    if (refs.target === "openApi3") {
      const base2 = parseDef$1(def.innerType._def, {
        ...refs,
        currentPath: [...refs.currentPath]
      });
      if (base2 && "$ref" in base2)
        return { allOf: [base2], nullable: true };
      return base2 && { ...base2, nullable: true };
    }
    const base = parseDef$1(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "anyOf", "0"]
    });
    return base && { anyOf: [base, { type: "null" }] };
  }
  function parseNumberDef$1(def, refs) {
    const res = {
      type: "number"
    };
    if (!def.checks)
      return res;
    for (const check of def.checks) {
      switch (check.kind) {
        case "int":
          res.type = "integer";
          addErrorMessage$1(res, "type", check.message, refs);
          break;
        case "min":
          if (refs.target === "jsonSchema7") {
            if (check.inclusive) {
              setResponseValueAndErrors$1(res, "minimum", check.value, check.message, refs);
            } else {
              setResponseValueAndErrors$1(res, "exclusiveMinimum", check.value, check.message, refs);
            }
          } else {
            if (!check.inclusive) {
              res.exclusiveMinimum = true;
            }
            setResponseValueAndErrors$1(res, "minimum", check.value, check.message, refs);
          }
          break;
        case "max":
          if (refs.target === "jsonSchema7") {
            if (check.inclusive) {
              setResponseValueAndErrors$1(res, "maximum", check.value, check.message, refs);
            } else {
              setResponseValueAndErrors$1(res, "exclusiveMaximum", check.value, check.message, refs);
            }
          } else {
            if (!check.inclusive) {
              res.exclusiveMaximum = true;
            }
            setResponseValueAndErrors$1(res, "maximum", check.value, check.message, refs);
          }
          break;
        case "multipleOf":
          setResponseValueAndErrors$1(res, "multipleOf", check.value, check.message, refs);
          break;
      }
    }
    return res;
  }
  function decideAdditionalProperties$1(def, refs) {
    if (refs.removeAdditionalStrategy === "strict") {
      return def.catchall._def.typeName === "ZodNever" ? def.unknownKeys !== "strict" : parseDef$1(def.catchall._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalProperties"]
      }) ?? true;
    } else {
      return def.catchall._def.typeName === "ZodNever" ? def.unknownKeys === "passthrough" : parseDef$1(def.catchall._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalProperties"]
      }) ?? true;
    }
  }
  function parseObjectDef$1(def, refs) {
    const result = {
      type: "object",
      ...Object.entries(def.shape()).reduce((acc, [propName, propDef]) => {
        if (propDef === void 0 || propDef._def === void 0)
          return acc;
        const parsedDef = parseDef$1(propDef._def, {
          ...refs,
          currentPath: [...refs.currentPath, "properties", propName],
          propertyPath: [...refs.currentPath, "properties", propName]
        });
        if (parsedDef === void 0)
          return acc;
        return {
          properties: {
            ...acc.properties,
            [propName]: parsedDef
          },
          required: propDef.isOptional() && !refs.openaiStrictMode ? acc.required : [...acc.required, propName]
        };
      }, { properties: {}, required: [] }),
      additionalProperties: decideAdditionalProperties$1(def, refs)
    };
    if (!result.required.length)
      delete result.required;
    return result;
  }
  const parseOptionalDef$1 = (def, refs) => {
    var _a3;
    if (refs.currentPath.toString() === ((_a3 = refs.propertyPath) == null ? void 0 : _a3.toString())) {
      return parseDef$1(def.innerType._def, refs);
    }
    const innerSchema = parseDef$1(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "anyOf", "1"]
    });
    return innerSchema ? {
      anyOf: [
        {
          not: {}
        },
        innerSchema
      ]
    } : {};
  };
  const parsePipelineDef$1 = (def, refs) => {
    if (refs.pipeStrategy === "input") {
      return parseDef$1(def.in._def, refs);
    } else if (refs.pipeStrategy === "output") {
      return parseDef$1(def.out._def, refs);
    }
    const a = parseDef$1(def.in._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    });
    const b = parseDef$1(def.out._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
    });
    return {
      allOf: [a, b].filter((x) => x !== void 0)
    };
  };
  function parsePromiseDef$1(def, refs) {
    return parseDef$1(def.type._def, refs);
  }
  function parseSetDef$1(def, refs) {
    const items = parseDef$1(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
    const schema = {
      type: "array",
      uniqueItems: true,
      items
    };
    if (def.minSize) {
      setResponseValueAndErrors$1(schema, "minItems", def.minSize.value, def.minSize.message, refs);
    }
    if (def.maxSize) {
      setResponseValueAndErrors$1(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
    }
    return schema;
  }
  function parseTupleDef$1(def, refs) {
    if (def.rest) {
      return {
        type: "array",
        minItems: def.items.length,
        items: def.items.map((x, i2) => parseDef$1(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i2}`]
        })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
        additionalItems: parseDef$1(def.rest._def, {
          ...refs,
          currentPath: [...refs.currentPath, "additionalItems"]
        })
      };
    } else {
      return {
        type: "array",
        minItems: def.items.length,
        maxItems: def.items.length,
        items: def.items.map((x, i2) => parseDef$1(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i2}`]
        })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
      };
    }
  }
  function parseUndefinedDef$1() {
    return {
      not: {}
    };
  }
  function parseUnknownDef$1() {
    return {};
  }
  const parseReadonlyDef$1 = (def, refs) => {
    return parseDef$1(def.innerType._def, refs);
  };
  function parseDef$1(def, refs, forceResolution = false) {
    var _a3;
    const seenItem = refs.seen.get(def);
    if (refs.override) {
      const overrideResult = (_a3 = refs.override) == null ? void 0 : _a3.call(refs, def, refs, seenItem, forceResolution);
      if (overrideResult !== ignoreOverride$1) {
        return overrideResult;
      }
    }
    if (seenItem && !forceResolution) {
      const seenSchema = get$ref$1(seenItem, refs);
      if (seenSchema !== void 0) {
        if ("$ref" in seenSchema) {
          refs.seenRefs.add(seenSchema.$ref);
        }
        return seenSchema;
      }
    }
    const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
    refs.seen.set(def, newItem);
    const jsonSchema = selectParser$1(def, def.typeName, refs, forceResolution);
    if (jsonSchema) {
      addMeta$1(def, refs, jsonSchema);
    }
    newItem.jsonSchema = jsonSchema;
    return jsonSchema;
  }
  const get$ref$1 = (item, refs) => {
    switch (refs.$refStrategy) {
      case "root":
        return { $ref: item.path.join("/") };
      // this case is needed as OpenAI strict mode doesn't support top-level `$ref`s, i.e.
      // the top-level schema *must* be `{"type": "object", "properties": {...}}` but if we ever
      // need to define a `$ref`, relative `$ref`s aren't supported, so we need to extract
      // the schema to `#/definitions/` and reference that.
      //
      // e.g. if we need to reference a schema at
      // `["#","definitions","contactPerson","properties","person1","properties","name"]`
      // then we'll extract it out to `contactPerson_properties_person1_properties_name`
      case "extract-to-root":
        const name = item.path.slice(refs.basePath.length + 1).join("_");
        if (name !== refs.name && refs.nameStrategy === "duplicate-ref") {
          refs.definitions[name] = item.def;
        }
        return { $ref: [...refs.basePath, refs.definitionPath, name].join("/") };
      case "relative":
        return { $ref: getRelativePath$1(refs.currentPath, item.path) };
      case "none":
      case "seen": {
        if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
          console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
          return {};
        }
        return refs.$refStrategy === "seen" ? {} : void 0;
      }
    }
  };
  const getRelativePath$1 = (pathA, pathB) => {
    let i2 = 0;
    for (; i2 < pathA.length && i2 < pathB.length; i2++) {
      if (pathA[i2] !== pathB[i2])
        break;
    }
    return [(pathA.length - i2).toString(), ...pathB.slice(i2)].join("/");
  };
  const selectParser$1 = (def, typeName, refs, forceResolution) => {
    switch (typeName) {
      case ZodFirstPartyTypeKind$1.ZodString:
        return parseStringDef$1(def, refs);
      case ZodFirstPartyTypeKind$1.ZodNumber:
        return parseNumberDef$1(def, refs);
      case ZodFirstPartyTypeKind$1.ZodObject:
        return parseObjectDef$1(def, refs);
      case ZodFirstPartyTypeKind$1.ZodBigInt:
        return parseBigintDef$1(def, refs);
      case ZodFirstPartyTypeKind$1.ZodBoolean:
        return parseBooleanDef$1();
      case ZodFirstPartyTypeKind$1.ZodDate:
        return parseDateDef$1(def, refs);
      case ZodFirstPartyTypeKind$1.ZodUndefined:
        return parseUndefinedDef$1();
      case ZodFirstPartyTypeKind$1.ZodNull:
        return parseNullDef$1(refs);
      case ZodFirstPartyTypeKind$1.ZodArray:
        return parseArrayDef$1(def, refs);
      case ZodFirstPartyTypeKind$1.ZodUnion:
      case ZodFirstPartyTypeKind$1.ZodDiscriminatedUnion:
        return parseUnionDef$1(def, refs);
      case ZodFirstPartyTypeKind$1.ZodIntersection:
        return parseIntersectionDef$1(def, refs);
      case ZodFirstPartyTypeKind$1.ZodTuple:
        return parseTupleDef$1(def, refs);
      case ZodFirstPartyTypeKind$1.ZodRecord:
        return parseRecordDef$1(def, refs);
      case ZodFirstPartyTypeKind$1.ZodLiteral:
        return parseLiteralDef$1(def, refs);
      case ZodFirstPartyTypeKind$1.ZodEnum:
        return parseEnumDef$1(def);
      case ZodFirstPartyTypeKind$1.ZodNativeEnum:
        return parseNativeEnumDef$1(def);
      case ZodFirstPartyTypeKind$1.ZodNullable:
        return parseNullableDef$1(def, refs);
      case ZodFirstPartyTypeKind$1.ZodOptional:
        return parseOptionalDef$1(def, refs);
      case ZodFirstPartyTypeKind$1.ZodMap:
        return parseMapDef$1(def, refs);
      case ZodFirstPartyTypeKind$1.ZodSet:
        return parseSetDef$1(def, refs);
      case ZodFirstPartyTypeKind$1.ZodLazy:
        return parseDef$1(def.getter()._def, refs);
      case ZodFirstPartyTypeKind$1.ZodPromise:
        return parsePromiseDef$1(def, refs);
      case ZodFirstPartyTypeKind$1.ZodNaN:
      case ZodFirstPartyTypeKind$1.ZodNever:
        return parseNeverDef$1();
      case ZodFirstPartyTypeKind$1.ZodEffects:
        return parseEffectsDef$1(def, refs, forceResolution);
      case ZodFirstPartyTypeKind$1.ZodAny:
        return parseAnyDef$1();
      case ZodFirstPartyTypeKind$1.ZodUnknown:
        return parseUnknownDef$1();
      case ZodFirstPartyTypeKind$1.ZodDefault:
        return parseDefaultDef$1(def, refs);
      case ZodFirstPartyTypeKind$1.ZodBranded:
        return parseBrandedDef$1(def, refs);
      case ZodFirstPartyTypeKind$1.ZodReadonly:
        return parseReadonlyDef$1(def, refs);
      case ZodFirstPartyTypeKind$1.ZodCatch:
        return parseCatchDef$1(def, refs);
      case ZodFirstPartyTypeKind$1.ZodPipeline:
        return parsePipelineDef$1(def, refs);
      case ZodFirstPartyTypeKind$1.ZodFunction:
      case ZodFirstPartyTypeKind$1.ZodVoid:
      case ZodFirstPartyTypeKind$1.ZodSymbol:
        return void 0;
      default:
        return /* @__PURE__ */ ((_) => void 0)();
    }
  };
  const addMeta$1 = (def, refs, jsonSchema) => {
    if (def.description) {
      jsonSchema.description = def.description;
      if (refs.markdownDescription) {
        jsonSchema.markdownDescription = def.description;
      }
    }
    return jsonSchema;
  };
  const zodToJsonSchema$3 = (schema, options) => {
    const refs = getRefs$1(options);
    const name = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
    const main = parseDef$1(schema._def, name === void 0 ? refs : {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name]
    }, false) ?? {};
    const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
    if (title !== void 0) {
      main.title = title;
    }
    const definitions = (() => {
      if (isEmptyObj$3(refs.definitions)) {
        return void 0;
      }
      const definitions2 = {};
      const processedDefinitions = /* @__PURE__ */ new Set();
      for (let i2 = 0; i2 < 500; i2++) {
        const newDefinitions = Object.entries(refs.definitions).filter(([key]) => !processedDefinitions.has(key));
        if (newDefinitions.length === 0)
          break;
        for (const [key, schema2] of newDefinitions) {
          definitions2[key] = parseDef$1(zodDef$1(schema2), { ...refs, currentPath: [...refs.basePath, refs.definitionPath, key] }, true) ?? {};
          processedDefinitions.add(key);
        }
      }
      return definitions2;
    })();
    const combined = name === void 0 ? definitions ? {
      ...main,
      [refs.definitionPath]: definitions
    } : main : refs.nameStrategy === "duplicate-ref" ? {
      ...main,
      ...definitions || refs.seenRefs.size ? {
        [refs.definitionPath]: {
          ...definitions,
          // only actually duplicate the schema definition if it was ever referenced
          // otherwise the duplication is completely pointless
          ...refs.seenRefs.size ? { [name]: main } : void 0
        }
      } : void 0
    } : {
      $ref: [...refs.$refStrategy === "relative" ? [] : refs.basePath, refs.definitionPath, name].join("/"),
      [refs.definitionPath]: {
        ...definitions,
        [name]: main
      }
    };
    if (refs.target === "jsonSchema7") {
      combined.$schema = "http://json-schema.org/draft-07/schema#";
    } else if (refs.target === "jsonSchema2019-09") {
      combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
    }
    return combined;
  };
  function zodToJsonSchema$2(schema, options) {
    return zodToJsonSchema$3(schema, {
      openaiStrictMode: true,
      name: options.name,
      nameStrategy: "duplicate-ref",
      $refStrategy: "extract-to-root",
      nullableStrategy: "property"
    });
  }
  function zodResponseFormat$1(zodObject, name, props) {
    return makeParseableResponseFormat$1({
      type: "json_schema",
      json_schema: {
        ...props,
        name,
        strict: true,
        schema: zodToJsonSchema$2(zodObject, { name })
      }
    }, (content) => zodObject.parse(JSON.parse(content)));
  }
  function zodFunction$1(options) {
    return makeParseableTool$1({
      type: "function",
      function: {
        name: options.name,
        parameters: zodToJsonSchema$2(options.parameters, { name: options.name }),
        strict: true,
        ...options.description ? { description: options.description } : void 0
      }
    }, {
      callback: options.function,
      parser: (args) => options.parameters.parse(JSON.parse(args))
    });
  }
  function getEndpoint$1(config2) {
    const { azureOpenAIApiDeploymentName, azureOpenAIApiInstanceName, azureOpenAIApiKey, azureOpenAIBasePath, baseURL, azureADTokenProvider, azureOpenAIEndpoint } = config2;
    if ((azureOpenAIApiKey || azureADTokenProvider) && azureOpenAIBasePath && azureOpenAIApiDeploymentName) {
      return `${azureOpenAIBasePath}/${azureOpenAIApiDeploymentName}`;
    }
    if ((azureOpenAIApiKey || azureADTokenProvider) && azureOpenAIEndpoint && azureOpenAIApiDeploymentName) {
      return `${azureOpenAIEndpoint}/openai/deployments/${azureOpenAIApiDeploymentName}`;
    }
    if (azureOpenAIApiKey || azureADTokenProvider) {
      if (!azureOpenAIApiInstanceName) {
        throw new Error("azureOpenAIApiInstanceName is required when using azureOpenAIApiKey");
      }
      if (!azureOpenAIApiDeploymentName) {
        throw new Error("azureOpenAIApiDeploymentName is a required parameter when using azureOpenAIApiKey");
      }
      return `https://${azureOpenAIApiInstanceName}.openai.azure.com/openai/deployments/${azureOpenAIApiDeploymentName}`;
    }
    return baseURL;
  }
  function isStructuredTool(tool) {
    return tool !== void 0 && Array.isArray(tool.lc_namespace);
  }
  function isRunnableToolLike(tool) {
    return tool !== void 0 && Runnable.isRunnable(tool) && "lc_name" in tool.constructor && typeof tool.constructor.lc_name === "function" && tool.constructor.lc_name() === "RunnableToolLike";
  }
  function isStructuredToolParams(tool) {
    return !!tool && typeof tool === "object" && "name" in tool && "schema" in tool && // eslint-disable-next-line @typescript-eslint/no-explicit-any
    isZodSchema$2(tool.schema);
  }
  function isLangChainTool(tool) {
    return isStructuredToolParams(tool) || isRunnableToolLike(tool) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
    isStructuredTool(tool);
  }
  function toJsonSchema(schema) {
    if (isZodSchema$2(schema)) {
      return zodToJsonSchema$5(schema);
    }
    return schema;
  }
  function convertToOpenAIFunction(tool, fields) {
    const fieldsCopy = typeof fields === "number" ? void 0 : fields;
    return {
      name: tool.name,
      description: tool.description,
      parameters: toJsonSchema(tool.schema),
      // Do not include the `strict` field if it is `undefined`.
      ...(fieldsCopy == null ? void 0 : fieldsCopy.strict) !== void 0 ? { strict: fieldsCopy.strict } : {}
    };
  }
  function convertToOpenAITool(tool, fields) {
    let toolDef;
    if (isLangChainTool(tool)) {
      toolDef = {
        type: "function",
        function: convertToOpenAIFunction(tool)
      };
    } else {
      toolDef = tool;
    }
    return toolDef;
  }
  function addLangChainErrorFields$2(error, lc_error_code) {
    error.lc_error_code = lc_error_code;
    error.message = `${error.message}

Troubleshooting URL: https://js.langchain.com/docs/troubleshooting/errors/${lc_error_code}/
`;
    return error;
  }
  function wrapOpenAIClientError$1(e) {
    let error;
    if (e.constructor.name === APIConnectionTimeoutError$2.name) {
      error = new Error(e.message);
      error.name = "TimeoutError";
    } else if (e.constructor.name === APIUserAbortError$2.name) {
      error = new Error(e.message);
      error.name = "AbortError";
    } else if (e.status === 400 && e.message.includes("tool_calls")) {
      error = addLangChainErrorFields$2(e, "INVALID_TOOL_RESULTS");
    } else if (e.status === 401) {
      error = addLangChainErrorFields$2(e, "MODEL_AUTHENTICATION");
    } else if (e.status === 429) {
      error = addLangChainErrorFields$2(e, "MODEL_RATE_LIMIT");
    } else if (e.status === 404) {
      error = addLangChainErrorFields$2(e, "MODEL_NOT_FOUND");
    } else {
      error = e;
    }
    return error;
  }
  function formatToOpenAIToolChoice$1(toolChoice) {
    if (!toolChoice) {
      return void 0;
    } else if (toolChoice === "any" || toolChoice === "required") {
      return "required";
    } else if (toolChoice === "auto") {
      return "auto";
    } else if (toolChoice === "none") {
      return "none";
    } else if (typeof toolChoice === "string") {
      return {
        type: "function",
        function: {
          name: toolChoice
        }
      };
    } else {
      return toolChoice;
    }
  }
  function isAnyOfProp$1(prop) {
    return prop.anyOf !== void 0 && Array.isArray(prop.anyOf);
  }
  function formatFunctionDefinitions$1(functions) {
    const lines = ["namespace functions {", ""];
    for (const f of functions) {
      if (f.description) {
        lines.push(`// ${f.description}`);
      }
      if (Object.keys(f.parameters.properties ?? {}).length > 0) {
        lines.push(`type ${f.name} = (_: {`);
        lines.push(formatObjectProperties$1(f.parameters, 0));
        lines.push("}) => any;");
      } else {
        lines.push(`type ${f.name} = () => any;`);
      }
      lines.push("");
    }
    lines.push("} // namespace functions");
    return lines.join("\n");
  }
  function formatObjectProperties$1(obj, indent) {
    var _a3;
    const lines = [];
    for (const [name, param] of Object.entries(obj.properties ?? {})) {
      if (param.description && indent < 2) {
        lines.push(`// ${param.description}`);
      }
      if ((_a3 = obj.required) == null ? void 0 : _a3.includes(name)) {
        lines.push(`${name}: ${formatType$1(param, indent)},`);
      } else {
        lines.push(`${name}?: ${formatType$1(param, indent)},`);
      }
    }
    return lines.map((line) => " ".repeat(indent) + line).join("\n");
  }
  function formatType$1(param, indent) {
    if (isAnyOfProp$1(param)) {
      return param.anyOf.map((v) => formatType$1(v, indent)).join(" | ");
    }
    switch (param.type) {
      case "string":
        if (param.enum) {
          return param.enum.map((v) => `"${v}"`).join(" | ");
        }
        return "string";
      case "number":
        if (param.enum) {
          return param.enum.map((v) => `${v}`).join(" | ");
        }
        return "number";
      case "integer":
        if (param.enum) {
          return param.enum.map((v) => `${v}`).join(" | ");
        }
        return "number";
      case "boolean":
        return "boolean";
      case "null":
        return "null";
      case "object":
        return ["{", formatObjectProperties$1(param, indent + 2), "}"].join("\n");
      case "array":
        if (param.items) {
          return `${formatType$1(param.items, indent)}[]`;
        }
        return "any[]";
      default:
        return "";
    }
  }
  function _convertToOpenAITool$1(tool, fields) {
    let toolDef;
    if (isLangChainTool(tool)) {
      const oaiToolDef = zodFunction$1({
        name: tool.name,
        parameters: tool.schema,
        description: tool.description
      });
      if (!oaiToolDef.function.parameters) {
        toolDef = {
          type: "function",
          function: convertToOpenAIFunction(tool, fields)
        };
      } else {
        toolDef = {
          type: oaiToolDef.type,
          function: {
            name: oaiToolDef.function.name,
            description: oaiToolDef.function.description,
            parameters: oaiToolDef.function.parameters,
            ...(fields == null ? void 0 : fields.strict) !== void 0 ? { strict: fields.strict } : {}
          }
        };
      }
    } else {
      toolDef = tool;
    }
    if ((fields == null ? void 0 : fields.strict) !== void 0) {
      toolDef.function.strict = fields.strict;
    }
    return toolDef;
  }
  function extractGenericMessageCustomRole$1(message) {
    if (message.role !== "system" && message.role !== "developer" && message.role !== "assistant" && message.role !== "user" && message.role !== "function" && message.role !== "tool") {
      console.warn(`Unknown message role: ${message.role}`);
    }
    return message.role;
  }
  function messageToOpenAIRole$1(message) {
    const type = message._getType();
    switch (type) {
      case "system":
        return "system";
      case "ai":
        return "assistant";
      case "human":
        return "user";
      case "function":
        return "function";
      case "tool":
        return "tool";
      case "generic": {
        if (!ChatMessage.isInstance(message))
          throw new Error("Invalid generic chat message");
        return extractGenericMessageCustomRole$1(message);
      }
      default:
        throw new Error(`Unknown message type: ${type}`);
    }
  }
  function _convertMessagesToOpenAIParams$1(messages, model) {
    return messages.flatMap((message) => {
      var _a3;
      let role = messageToOpenAIRole$1(message);
      if (role === "system" && (model == null ? void 0 : model.startsWith("o1"))) {
        role = "developer";
      }
      const completionParam = {
        role,
        content: message.content
      };
      if (message.name != null) {
        completionParam.name = message.name;
      }
      if (message.additional_kwargs.function_call != null) {
        completionParam.function_call = message.additional_kwargs.function_call;
        completionParam.content = null;
      }
      if (isAIMessage(message) && !!((_a3 = message.tool_calls) == null ? void 0 : _a3.length)) {
        completionParam.tool_calls = message.tool_calls.map(convertLangChainToolCallToOpenAI);
        completionParam.content = null;
      } else {
        if (message.additional_kwargs.tool_calls != null) {
          completionParam.tool_calls = message.additional_kwargs.tool_calls;
        }
        if (message.tool_call_id != null) {
          completionParam.tool_call_id = message.tool_call_id;
        }
      }
      if (message.additional_kwargs.audio && typeof message.additional_kwargs.audio === "object" && "id" in message.additional_kwargs.audio) {
        const audioMessage = {
          role: "assistant",
          audio: {
            id: message.additional_kwargs.audio.id
          }
        };
        return [completionParam, audioMessage];
      }
      return completionParam;
    });
  }
  function _convertChatOpenAIToolTypeToOpenAITool$1(tool, fields) {
    if (isOpenAITool(tool)) {
      if ((fields == null ? void 0 : fields.strict) !== void 0) {
        return {
          ...tool,
          function: {
            ...tool.function,
            strict: fields.strict
          }
        };
      }
      return tool;
    }
    return _convertToOpenAITool$1(tool, fields);
  }
  let ChatOpenAI$1 = class ChatOpenAI extends BaseChatModel {
    static lc_name() {
      return "ChatOpenAI";
    }
    get callKeys() {
      return [
        ...super.callKeys,
        "options",
        "function_call",
        "functions",
        "tools",
        "tool_choice",
        "promptIndex",
        "response_format",
        "seed",
        "reasoning_effort"
      ];
    }
    get lc_secrets() {
      return {
        openAIApiKey: "OPENAI_API_KEY",
        apiKey: "OPENAI_API_KEY",
        organization: "OPENAI_ORGANIZATION"
      };
    }
    get lc_aliases() {
      return {
        modelName: "model",
        openAIApiKey: "openai_api_key",
        apiKey: "openai_api_key"
      };
    }
    constructor(fields) {
      var _a3, _b2;
      super(fields ?? {});
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "temperature", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "topP", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "frequencyPenalty", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "presencePenalty", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "n", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 1
      });
      Object.defineProperty(this, "logitBias", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "modelName", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "model", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "gpt-3.5-turbo"
      });
      Object.defineProperty(this, "modelKwargs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "stop", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "stopSequences", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "user", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "timeout", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "streaming", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "streamUsage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "maxTokens", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "logprobs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "topLogprobs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "openAIApiKey", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "apiKey", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "organization", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "__includeRawResponse", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "client", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "clientConfig", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "supportsStrictToolCalling", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "audio", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "modalities", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "reasoningEffort", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.openAIApiKey = (fields == null ? void 0 : fields.apiKey) ?? (fields == null ? void 0 : fields.openAIApiKey) ?? ((_a3 = fields == null ? void 0 : fields.configuration) == null ? void 0 : _a3.apiKey) ?? getEnvironmentVariable("OPENAI_API_KEY");
      this.apiKey = this.openAIApiKey;
      this.organization = ((_b2 = fields == null ? void 0 : fields.configuration) == null ? void 0 : _b2.organization) ?? getEnvironmentVariable("OPENAI_ORGANIZATION");
      this.model = (fields == null ? void 0 : fields.model) ?? (fields == null ? void 0 : fields.modelName) ?? this.model;
      this.modelName = this.model;
      this.modelKwargs = (fields == null ? void 0 : fields.modelKwargs) ?? {};
      this.timeout = fields == null ? void 0 : fields.timeout;
      this.temperature = (fields == null ? void 0 : fields.temperature) ?? this.temperature;
      this.topP = (fields == null ? void 0 : fields.topP) ?? this.topP;
      this.frequencyPenalty = (fields == null ? void 0 : fields.frequencyPenalty) ?? this.frequencyPenalty;
      this.presencePenalty = (fields == null ? void 0 : fields.presencePenalty) ?? this.presencePenalty;
      this.maxTokens = fields == null ? void 0 : fields.maxTokens;
      this.logprobs = fields == null ? void 0 : fields.logprobs;
      this.topLogprobs = fields == null ? void 0 : fields.topLogprobs;
      this.n = (fields == null ? void 0 : fields.n) ?? this.n;
      this.logitBias = fields == null ? void 0 : fields.logitBias;
      this.stop = (fields == null ? void 0 : fields.stopSequences) ?? (fields == null ? void 0 : fields.stop);
      this.stopSequences = this == null ? void 0 : this.stop;
      this.user = fields == null ? void 0 : fields.user;
      this.__includeRawResponse = fields == null ? void 0 : fields.__includeRawResponse;
      this.audio = fields == null ? void 0 : fields.audio;
      this.modalities = fields == null ? void 0 : fields.modalities;
      this.reasoningEffort = fields == null ? void 0 : fields.reasoningEffort;
      if (this.model === "o1") {
        this.disableStreaming = true;
      }
      this.streaming = (fields == null ? void 0 : fields.streaming) ?? false;
      this.streamUsage = (fields == null ? void 0 : fields.streamUsage) ?? this.streamUsage;
      this.clientConfig = {
        apiKey: this.apiKey,
        organization: this.organization,
        dangerouslyAllowBrowser: true,
        ...fields == null ? void 0 : fields.configuration
      };
      if ((fields == null ? void 0 : fields.supportsStrictToolCalling) !== void 0) {
        this.supportsStrictToolCalling = fields.supportsStrictToolCalling;
      }
    }
    getLsParams(options) {
      const params = this.invocationParams(options);
      return {
        ls_provider: "openai",
        ls_model_name: this.model,
        ls_model_type: "chat",
        ls_temperature: params.temperature ?? void 0,
        ls_max_tokens: params.max_tokens ?? void 0,
        ls_stop: options.stop
      };
    }
    bindTools(tools, kwargs) {
      let strict;
      if ((kwargs == null ? void 0 : kwargs.strict) !== void 0) {
        strict = kwargs.strict;
      } else if (this.supportsStrictToolCalling !== void 0) {
        strict = this.supportsStrictToolCalling;
      }
      return this.bind({
        tools: tools.map((tool) => _convertChatOpenAIToolTypeToOpenAITool$1(tool, { strict })),
        ...kwargs
      });
    }
    createResponseFormat(resFormat) {
      if (resFormat && resFormat.type === "json_schema" && resFormat.json_schema.schema && isZodSchema$1(resFormat.json_schema.schema)) {
        return zodResponseFormat$1(resFormat.json_schema.schema, resFormat.json_schema.name, {
          description: resFormat.json_schema.description
        });
      }
      return resFormat;
    }
    /**
     * Get the parameters used to invoke the model
     */
    invocationParams(options, extra) {
      var _a3;
      let strict;
      if ((options == null ? void 0 : options.strict) !== void 0) {
        strict = options.strict;
      } else if (this.supportsStrictToolCalling !== void 0) {
        strict = this.supportsStrictToolCalling;
      }
      let streamOptionsConfig = {};
      if ((options == null ? void 0 : options.stream_options) !== void 0) {
        streamOptionsConfig = { stream_options: options.stream_options };
      } else if (this.streamUsage && (this.streaming || (extra == null ? void 0 : extra.streaming))) {
        streamOptionsConfig = { stream_options: { include_usage: true } };
      }
      const params = {
        model: this.model,
        temperature: this.temperature,
        top_p: this.topP,
        frequency_penalty: this.frequencyPenalty,
        presence_penalty: this.presencePenalty,
        max_tokens: this.maxTokens === -1 ? void 0 : this.maxTokens,
        logprobs: this.logprobs,
        top_logprobs: this.topLogprobs,
        n: this.n,
        logit_bias: this.logitBias,
        stop: (options == null ? void 0 : options.stop) ?? this.stopSequences,
        user: this.user,
        // if include_usage is set or streamUsage then stream must be set to true.
        stream: this.streaming,
        functions: options == null ? void 0 : options.functions,
        function_call: options == null ? void 0 : options.function_call,
        tools: ((_a3 = options == null ? void 0 : options.tools) == null ? void 0 : _a3.length) ? options.tools.map((tool) => _convertChatOpenAIToolTypeToOpenAITool$1(tool, { strict })) : void 0,
        tool_choice: formatToOpenAIToolChoice$1(options == null ? void 0 : options.tool_choice),
        response_format: this.createResponseFormat(options == null ? void 0 : options.response_format),
        seed: options == null ? void 0 : options.seed,
        ...streamOptionsConfig,
        parallel_tool_calls: options == null ? void 0 : options.parallel_tool_calls,
        ...this.audio || (options == null ? void 0 : options.audio) ? { audio: this.audio || (options == null ? void 0 : options.audio) } : {},
        ...this.modalities || (options == null ? void 0 : options.modalities) ? { modalities: this.modalities || (options == null ? void 0 : options.modalities) } : {},
        ...this.modelKwargs
      };
      if ((options == null ? void 0 : options.prediction) !== void 0) {
        params.prediction = options.prediction;
      }
      const reasoningEffort = (options == null ? void 0 : options.reasoning_effort) ?? this.reasoningEffort;
      if (reasoningEffort !== void 0) {
        params.reasoning_effort = reasoningEffort;
      }
      return params;
    }
    _convertOpenAIChatCompletionMessageToBaseMessage(message, rawResponse) {
      const rawToolCalls = message.tool_calls;
      switch (message.role) {
        case "assistant": {
          const toolCalls = [];
          const invalidToolCalls = [];
          for (const rawToolCall of rawToolCalls ?? []) {
            try {
              toolCalls.push(parseToolCall$1(rawToolCall, { returnId: true }));
            } catch (e) {
              invalidToolCalls.push(makeInvalidToolCall(rawToolCall, e.message));
            }
          }
          const additional_kwargs = {
            function_call: message.function_call,
            tool_calls: rawToolCalls
          };
          if (this.__includeRawResponse !== void 0) {
            additional_kwargs.__raw_response = rawResponse;
          }
          const response_metadata = {
            model_name: rawResponse.model,
            ...rawResponse.system_fingerprint ? {
              usage: { ...rawResponse.usage },
              system_fingerprint: rawResponse.system_fingerprint
            } : {}
          };
          if (message.audio) {
            additional_kwargs.audio = message.audio;
          }
          return new AIMessage({
            content: message.content || "",
            tool_calls: toolCalls,
            invalid_tool_calls: invalidToolCalls,
            additional_kwargs,
            response_metadata,
            id: rawResponse.id
          });
        }
        default:
          return new ChatMessage(message.content || "", message.role ?? "unknown");
      }
    }
    _convertOpenAIDeltaToBaseMessageChunk(delta, rawResponse, defaultRole) {
      var _a3, _b2;
      const role = delta.role ?? defaultRole;
      const content = delta.content ?? "";
      let additional_kwargs;
      if (delta.function_call) {
        additional_kwargs = {
          function_call: delta.function_call
        };
      } else if (delta.tool_calls) {
        additional_kwargs = {
          tool_calls: delta.tool_calls
        };
      } else {
        additional_kwargs = {};
      }
      if (this.__includeRawResponse) {
        additional_kwargs.__raw_response = rawResponse;
      }
      if (delta.audio) {
        additional_kwargs.audio = {
          ...delta.audio,
          index: rawResponse.choices[0].index
        };
      }
      const response_metadata = { usage: { ...rawResponse.usage } };
      if (role === "user") {
        return new HumanMessageChunk({ content, response_metadata });
      } else if (role === "assistant") {
        const toolCallChunks = [];
        if (Array.isArray(delta.tool_calls)) {
          for (const rawToolCall of delta.tool_calls) {
            toolCallChunks.push({
              name: (_a3 = rawToolCall.function) == null ? void 0 : _a3.name,
              args: (_b2 = rawToolCall.function) == null ? void 0 : _b2.arguments,
              id: rawToolCall.id,
              index: rawToolCall.index,
              type: "tool_call_chunk"
            });
          }
        }
        return new AIMessageChunk({
          content,
          tool_call_chunks: toolCallChunks,
          additional_kwargs,
          id: rawResponse.id,
          response_metadata
        });
      } else if (role === "system") {
        return new SystemMessageChunk({ content, response_metadata });
      } else if (role === "developer") {
        return new SystemMessageChunk({
          content,
          response_metadata,
          additional_kwargs: {
            __openai_role__: "developer"
          }
        });
      } else if (role === "function") {
        return new FunctionMessageChunk({
          content,
          additional_kwargs,
          name: delta.name,
          response_metadata
        });
      } else if (role === "tool") {
        return new ToolMessageChunk({
          content,
          additional_kwargs,
          tool_call_id: delta.tool_call_id,
          response_metadata
        });
      } else {
        return new ChatMessageChunk({ content, role, response_metadata });
      }
    }
    /** @ignore */
    _identifyingParams() {
      return {
        model_name: this.model,
        ...this.invocationParams(),
        ...this.clientConfig
      };
    }
    async *_streamResponseChunks(messages, options, runManager) {
      var _a3, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2;
      const messagesMapped = _convertMessagesToOpenAIParams$1(messages, this.model);
      const params = {
        ...this.invocationParams(options, {
          streaming: true
        }),
        messages: messagesMapped,
        stream: true
      };
      let defaultRole;
      const streamIterable = await this.completionWithRetry(params, options);
      let usage;
      for await (const data of streamIterable) {
        const choice = (_a3 = data == null ? void 0 : data.choices) == null ? void 0 : _a3[0];
        if (data.usage) {
          usage = data.usage;
        }
        if (!choice) {
          continue;
        }
        const { delta } = choice;
        if (!delta) {
          continue;
        }
        const chunk = this._convertOpenAIDeltaToBaseMessageChunk(delta, data, defaultRole);
        defaultRole = delta.role ?? defaultRole;
        const newTokenIndices = {
          prompt: options.promptIndex ?? 0,
          completion: choice.index ?? 0
        };
        if (typeof chunk.content !== "string") {
          console.log("[WARNING]: Received non-string content from OpenAI. This is currently not supported.");
          continue;
        }
        const generationInfo = { ...newTokenIndices };
        if (choice.finish_reason != null) {
          generationInfo.finish_reason = choice.finish_reason;
          generationInfo.system_fingerprint = data.system_fingerprint;
          generationInfo.model_name = data.model;
        }
        if (this.logprobs) {
          generationInfo.logprobs = choice.logprobs;
        }
        const generationChunk = new ChatGenerationChunk({
          message: chunk,
          text: chunk.content,
          generationInfo
        });
        yield generationChunk;
        await (runManager == null ? void 0 : runManager.handleLLMNewToken(generationChunk.text ?? "", newTokenIndices, void 0, void 0, void 0, { chunk: generationChunk }));
      }
      if (usage) {
        const inputTokenDetails = {
          ...((_b2 = usage.prompt_tokens_details) == null ? void 0 : _b2.audio_tokens) !== null && {
            audio: (_c2 = usage.prompt_tokens_details) == null ? void 0 : _c2.audio_tokens
          },
          ...((_d2 = usage.prompt_tokens_details) == null ? void 0 : _d2.cached_tokens) !== null && {
            cache_read: (_e2 = usage.prompt_tokens_details) == null ? void 0 : _e2.cached_tokens
          }
        };
        const outputTokenDetails = {
          ...((_f2 = usage.completion_tokens_details) == null ? void 0 : _f2.audio_tokens) !== null && {
            audio: (_g2 = usage.completion_tokens_details) == null ? void 0 : _g2.audio_tokens
          },
          ...((_h2 = usage.completion_tokens_details) == null ? void 0 : _h2.reasoning_tokens) !== null && {
            reasoning: (_i2 = usage.completion_tokens_details) == null ? void 0 : _i2.reasoning_tokens
          }
        };
        const generationChunk = new ChatGenerationChunk({
          message: new AIMessageChunk({
            content: "",
            response_metadata: {
              usage: { ...usage }
            },
            usage_metadata: {
              input_tokens: usage.prompt_tokens,
              output_tokens: usage.completion_tokens,
              total_tokens: usage.total_tokens,
              ...Object.keys(inputTokenDetails).length > 0 && {
                input_token_details: inputTokenDetails
              },
              ...Object.keys(outputTokenDetails).length > 0 && {
                output_token_details: outputTokenDetails
              }
            }
          }),
          text: ""
        });
        yield generationChunk;
      }
      if ((_j2 = options.signal) == null ? void 0 : _j2.aborted) {
        throw new Error("AbortError");
      }
    }
    /**
     * Get the identifying parameters for the model
     *
     */
    identifyingParams() {
      return this._identifyingParams();
    }
    /** @ignore */
    async _generate(messages, options, runManager) {
      var _a3, _b2;
      const usageMetadata = {};
      const params = this.invocationParams(options);
      const messagesMapped = _convertMessagesToOpenAIParams$1(messages, this.model);
      if (params.stream) {
        const stream = this._streamResponseChunks(messages, options, runManager);
        const finalChunks = {};
        for await (const chunk of stream) {
          chunk.message.response_metadata = {
            ...chunk.generationInfo,
            ...chunk.message.response_metadata
          };
          const index = ((_a3 = chunk.generationInfo) == null ? void 0 : _a3.completion) ?? 0;
          if (finalChunks[index] === void 0) {
            finalChunks[index] = chunk;
          } else {
            finalChunks[index] = finalChunks[index].concat(chunk);
          }
        }
        const generations = Object.entries(finalChunks).sort(([aKey], [bKey]) => parseInt(aKey, 10) - parseInt(bKey, 10)).map(([_, value]) => value);
        const { functions, function_call } = this.invocationParams(options);
        const promptTokenUsage = await this.getEstimatedTokenCountFromPrompt(messages, functions, function_call);
        const completionTokenUsage = await this.getNumTokensFromGenerations(generations);
        usageMetadata.input_tokens = promptTokenUsage;
        usageMetadata.output_tokens = completionTokenUsage;
        usageMetadata.total_tokens = promptTokenUsage + completionTokenUsage;
        return {
          generations,
          llmOutput: {
            estimatedTokenUsage: {
              promptTokens: usageMetadata.input_tokens,
              completionTokens: usageMetadata.output_tokens,
              totalTokens: usageMetadata.total_tokens
            }
          }
        };
      } else {
        let data;
        if (options.response_format && options.response_format.type === "json_schema") {
          data = await this.betaParsedCompletionWithRetry({
            ...params,
            stream: false,
            messages: messagesMapped
          }, {
            signal: options == null ? void 0 : options.signal,
            ...options == null ? void 0 : options.options
          });
        } else {
          data = await this.completionWithRetry({
            ...params,
            stream: false,
            messages: messagesMapped
          }, {
            signal: options == null ? void 0 : options.signal,
            ...options == null ? void 0 : options.options
          });
        }
        const { completion_tokens: completionTokens, prompt_tokens: promptTokens, total_tokens: totalTokens, prompt_tokens_details: promptTokensDetails, completion_tokens_details: completionTokensDetails } = (data == null ? void 0 : data.usage) ?? {};
        if (completionTokens) {
          usageMetadata.output_tokens = (usageMetadata.output_tokens ?? 0) + completionTokens;
        }
        if (promptTokens) {
          usageMetadata.input_tokens = (usageMetadata.input_tokens ?? 0) + promptTokens;
        }
        if (totalTokens) {
          usageMetadata.total_tokens = (usageMetadata.total_tokens ?? 0) + totalTokens;
        }
        if ((promptTokensDetails == null ? void 0 : promptTokensDetails.audio_tokens) !== null || (promptTokensDetails == null ? void 0 : promptTokensDetails.cached_tokens) !== null) {
          usageMetadata.input_token_details = {
            ...(promptTokensDetails == null ? void 0 : promptTokensDetails.audio_tokens) !== null && {
              audio: promptTokensDetails == null ? void 0 : promptTokensDetails.audio_tokens
            },
            ...(promptTokensDetails == null ? void 0 : promptTokensDetails.cached_tokens) !== null && {
              cache_read: promptTokensDetails == null ? void 0 : promptTokensDetails.cached_tokens
            }
          };
        }
        if ((completionTokensDetails == null ? void 0 : completionTokensDetails.audio_tokens) !== null || (completionTokensDetails == null ? void 0 : completionTokensDetails.reasoning_tokens) !== null) {
          usageMetadata.output_token_details = {
            ...(completionTokensDetails == null ? void 0 : completionTokensDetails.audio_tokens) !== null && {
              audio: completionTokensDetails == null ? void 0 : completionTokensDetails.audio_tokens
            },
            ...(completionTokensDetails == null ? void 0 : completionTokensDetails.reasoning_tokens) !== null && {
              reasoning: completionTokensDetails == null ? void 0 : completionTokensDetails.reasoning_tokens
            }
          };
        }
        const generations = [];
        for (const part of (data == null ? void 0 : data.choices) ?? []) {
          const text = ((_b2 = part.message) == null ? void 0 : _b2.content) ?? "";
          const generation = {
            text,
            message: this._convertOpenAIChatCompletionMessageToBaseMessage(part.message ?? { role: "assistant" }, data)
          };
          generation.generationInfo = {
            ...part.finish_reason ? { finish_reason: part.finish_reason } : {},
            ...part.logprobs ? { logprobs: part.logprobs } : {}
          };
          if (isAIMessage(generation.message)) {
            generation.message.usage_metadata = usageMetadata;
          }
          generation.message = new AIMessage(Object.fromEntries(Object.entries(generation.message).filter(([key]) => !key.startsWith("lc_"))));
          generations.push(generation);
        }
        return {
          generations,
          llmOutput: {
            tokenUsage: {
              promptTokens: usageMetadata.input_tokens,
              completionTokens: usageMetadata.output_tokens,
              totalTokens: usageMetadata.total_tokens
            }
          }
        };
      }
    }
    /**
     * Estimate the number of tokens a prompt will use.
     * Modified from: https://github.com/hmarr/openai-chat-tokens/blob/main/src/index.ts
     */
    async getEstimatedTokenCountFromPrompt(messages, functions, function_call) {
      let tokens = (await this.getNumTokensFromMessages(messages)).totalCount;
      if (functions && function_call !== "auto") {
        const promptDefinitions = formatFunctionDefinitions$1(functions);
        tokens += await this.getNumTokens(promptDefinitions);
        tokens += 9;
      }
      if (functions && messages.find((m) => m._getType() === "system")) {
        tokens -= 4;
      }
      if (function_call === "none") {
        tokens += 1;
      } else if (typeof function_call === "object") {
        tokens += await this.getNumTokens(function_call.name) + 4;
      }
      return tokens;
    }
    /**
     * Estimate the number of tokens an array of generations have used.
     */
    async getNumTokensFromGenerations(generations) {
      const generationUsages = await Promise.all(generations.map(async (generation) => {
        var _a3;
        if ((_a3 = generation.message.additional_kwargs) == null ? void 0 : _a3.function_call) {
          return (await this.getNumTokensFromMessages([generation.message])).countPerMessage[0];
        } else {
          return await this.getNumTokens(generation.message.content);
        }
      }));
      return generationUsages.reduce((a, b) => a + b, 0);
    }
    async getNumTokensFromMessages(messages) {
      let totalCount = 0;
      let tokensPerMessage = 0;
      let tokensPerName = 0;
      if (this.model === "gpt-3.5-turbo-0301") {
        tokensPerMessage = 4;
        tokensPerName = -1;
      } else {
        tokensPerMessage = 3;
        tokensPerName = 1;
      }
      const countPerMessage = await Promise.all(messages.map(async (message) => {
        var _a3, _b2, _c2, _d2, _e2, _f2;
        const textCount = await this.getNumTokens(message.content);
        const roleCount = await this.getNumTokens(messageToOpenAIRole$1(message));
        const nameCount = message.name !== void 0 ? tokensPerName + await this.getNumTokens(message.name) : 0;
        let count = textCount + tokensPerMessage + roleCount + nameCount;
        const openAIMessage = message;
        if (openAIMessage._getType() === "function") {
          count -= 2;
        }
        if ((_a3 = openAIMessage.additional_kwargs) == null ? void 0 : _a3.function_call) {
          count += 3;
        }
        if ((_b2 = openAIMessage == null ? void 0 : openAIMessage.additional_kwargs.function_call) == null ? void 0 : _b2.name) {
          count += await this.getNumTokens((_c2 = openAIMessage.additional_kwargs.function_call) == null ? void 0 : _c2.name);
        }
        if ((_d2 = openAIMessage.additional_kwargs.function_call) == null ? void 0 : _d2.arguments) {
          try {
            count += await this.getNumTokens(
              // Remove newlines and spaces
              JSON.stringify(JSON.parse((_e2 = openAIMessage.additional_kwargs.function_call) == null ? void 0 : _e2.arguments))
            );
          } catch (error) {
            console.error("Error parsing function arguments", error, JSON.stringify(openAIMessage.additional_kwargs.function_call));
            count += await this.getNumTokens((_f2 = openAIMessage.additional_kwargs.function_call) == null ? void 0 : _f2.arguments);
          }
        }
        totalCount += count;
        return count;
      }));
      totalCount += 3;
      return { totalCount, countPerMessage };
    }
    async completionWithRetry(request, options) {
      const requestOptions = this._getClientOptions(options);
      return this.caller.call(async () => {
        try {
          const res = await this.client.chat.completions.create(request, requestOptions);
          return res;
        } catch (e) {
          const error = wrapOpenAIClientError$1(e);
          throw error;
        }
      });
    }
    /**
     * Call the beta chat completions parse endpoint. This should only be called if
     * response_format is set to "json_object".
     * @param {OpenAIClient.Chat.ChatCompletionCreateParamsNonStreaming} request
     * @param {OpenAICoreRequestOptions | undefined} options
     */
    async betaParsedCompletionWithRetry(request, options) {
      const requestOptions = this._getClientOptions(options);
      return this.caller.call(async () => {
        try {
          const res = await this.client.beta.chat.completions.parse(request, requestOptions);
          return res;
        } catch (e) {
          const error = wrapOpenAIClientError$1(e);
          throw error;
        }
      });
    }
    _getClientOptions(options) {
      if (!this.client) {
        const openAIEndpointConfig = {
          baseURL: this.clientConfig.baseURL
        };
        const endpoint = getEndpoint$1(openAIEndpointConfig);
        const params = {
          ...this.clientConfig,
          baseURL: endpoint,
          timeout: this.timeout,
          maxRetries: 0
        };
        if (!params.baseURL) {
          delete params.baseURL;
        }
        this.client = new OpenAI$2(params);
      }
      const requestOptions = {
        ...this.clientConfig,
        ...options
      };
      return requestOptions;
    }
    _llmType() {
      return "openai";
    }
    /** @ignore */
    _combineLLMOutput(...llmOutputs) {
      return llmOutputs.reduce((acc, llmOutput) => {
        if (llmOutput && llmOutput.tokenUsage) {
          acc.tokenUsage.completionTokens += llmOutput.tokenUsage.completionTokens ?? 0;
          acc.tokenUsage.promptTokens += llmOutput.tokenUsage.promptTokens ?? 0;
          acc.tokenUsage.totalTokens += llmOutput.tokenUsage.totalTokens ?? 0;
        }
        return acc;
      }, {
        tokenUsage: {
          completionTokens: 0,
          promptTokens: 0,
          totalTokens: 0
        }
      });
    }
    withStructuredOutput(outputSchema, config2) {
      let schema;
      let name;
      let method;
      let includeRaw;
      if (isStructuredOutputMethodParams$1(outputSchema)) {
        schema = outputSchema.schema;
        name = outputSchema.name;
        method = outputSchema.method;
        includeRaw = outputSchema.includeRaw;
      } else {
        schema = outputSchema;
        name = config2 == null ? void 0 : config2.name;
        method = config2 == null ? void 0 : config2.method;
        includeRaw = config2 == null ? void 0 : config2.includeRaw;
      }
      let llm;
      let outputParser;
      if ((config2 == null ? void 0 : config2.strict) !== void 0 && method === "jsonMode") {
        throw new Error("Argument `strict` is only supported for `method` = 'function_calling'");
      }
      if (!this.model.startsWith("gpt-3") && !this.model.startsWith("gpt-4-") && this.model !== "gpt-4") {
        if (method === void 0) {
          method = "jsonSchema";
        }
      } else if (method === "jsonSchema") {
        console.warn(`[WARNING]: JSON Schema is not supported for model "${this.model}". Falling back to tool calling.`);
      }
      if (method === "jsonMode") {
        llm = this.bind({
          response_format: { type: "json_object" }
        });
        if (isZodSchema$1(schema)) {
          outputParser = StructuredOutputParser.fromZodSchema(schema);
        } else {
          outputParser = new JsonOutputParser();
        }
      } else if (method === "jsonSchema") {
        llm = this.bind({
          response_format: {
            type: "json_schema",
            json_schema: {
              name: name ?? "extract",
              description: schema.description,
              schema,
              strict: config2 == null ? void 0 : config2.strict
            }
          }
        });
        if (isZodSchema$1(schema)) {
          outputParser = StructuredOutputParser.fromZodSchema(schema);
        } else {
          outputParser = new JsonOutputParser();
        }
      } else {
        let functionName = name ?? "extract";
        if (isZodSchema$1(schema)) {
          const asJsonSchema = zodToJsonSchema$4(schema);
          llm = this.bind({
            tools: [
              {
                type: "function",
                function: {
                  name: functionName,
                  description: asJsonSchema.description,
                  parameters: asJsonSchema
                }
              }
            ],
            tool_choice: {
              type: "function",
              function: {
                name: functionName
              }
            },
            // Do not pass `strict` argument to OpenAI if `config.strict` is undefined
            ...(config2 == null ? void 0 : config2.strict) !== void 0 ? { strict: config2.strict } : {}
          });
          outputParser = new JsonOutputKeyToolsParser({
            returnSingle: true,
            keyName: functionName,
            zodSchema: schema
          });
        } else {
          let openAIFunctionDefinition;
          if (typeof schema.name === "string" && typeof schema.parameters === "object" && schema.parameters != null) {
            openAIFunctionDefinition = schema;
            functionName = schema.name;
          } else {
            functionName = schema.title ?? functionName;
            openAIFunctionDefinition = {
              name: functionName,
              description: schema.description ?? "",
              parameters: schema
            };
          }
          llm = this.bind({
            tools: [
              {
                type: "function",
                function: openAIFunctionDefinition
              }
            ],
            tool_choice: {
              type: "function",
              function: {
                name: functionName
              }
            },
            // Do not pass `strict` argument to OpenAI if `config.strict` is undefined
            ...(config2 == null ? void 0 : config2.strict) !== void 0 ? { strict: config2.strict } : {}
          });
          outputParser = new JsonOutputKeyToolsParser({
            returnSingle: true,
            keyName: functionName
          });
        }
      }
      if (!includeRaw) {
        return llm.pipe(outputParser);
      }
      const parserAssign = RunnablePassthrough.assign({
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        parsed: (input, config3) => outputParser.invoke(input.raw, config3)
      });
      const parserNone = RunnablePassthrough.assign({
        parsed: () => null
      });
      const parsedWithFallback = parserAssign.withFallbacks({
        fallbacks: [parserNone]
      });
      return RunnableSequence.from([
        {
          raw: llm
        },
        parsedWithFallback
      ]);
    }
  };
  function isZodSchema$1(input) {
    return typeof (input == null ? void 0 : input.parse) === "function";
  }
  function isStructuredOutputMethodParams$1(x) {
    return x !== void 0 && // eslint-disable-next-line @typescript-eslint/no-explicit-any
    typeof x.schema === "object";
  }
  class AzureChatOpenAI extends ChatOpenAI$1 {
    _llmType() {
      return "azure_openai";
    }
    get lc_aliases() {
      return {
        ...super.lc_aliases,
        openAIApiKey: "openai_api_key",
        openAIApiVersion: "openai_api_version",
        openAIBasePath: "openai_api_base",
        deploymentName: "deployment_name",
        azureOpenAIEndpoint: "azure_endpoint",
        azureOpenAIApiVersion: "openai_api_version",
        azureOpenAIBasePath: "openai_api_base",
        azureOpenAIApiDeploymentName: "deployment_name"
      };
    }
    get lc_secrets() {
      return {
        ...super.lc_secrets,
        azureOpenAIApiKey: "AZURE_OPENAI_API_KEY"
      };
    }
    constructor(fields) {
      super(fields);
      Object.defineProperty(this, "azureOpenAIApiVersion", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "azureOpenAIApiKey", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "azureADTokenProvider", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "azureOpenAIApiInstanceName", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "azureOpenAIApiDeploymentName", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "azureOpenAIBasePath", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "azureOpenAIEndpoint", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.azureOpenAIApiKey = (fields == null ? void 0 : fields.azureOpenAIApiKey) ?? (fields == null ? void 0 : fields.openAIApiKey) ?? (fields == null ? void 0 : fields.apiKey) ?? getEnvironmentVariable("AZURE_OPENAI_API_KEY");
      this.azureOpenAIApiInstanceName = (fields == null ? void 0 : fields.azureOpenAIApiInstanceName) ?? getEnvironmentVariable("AZURE_OPENAI_API_INSTANCE_NAME");
      this.azureOpenAIApiDeploymentName = (fields == null ? void 0 : fields.azureOpenAIApiDeploymentName) ?? (fields == null ? void 0 : fields.deploymentName) ?? getEnvironmentVariable("AZURE_OPENAI_API_DEPLOYMENT_NAME");
      this.azureOpenAIApiVersion = (fields == null ? void 0 : fields.azureOpenAIApiVersion) ?? (fields == null ? void 0 : fields.openAIApiVersion) ?? getEnvironmentVariable("AZURE_OPENAI_API_VERSION");
      this.azureOpenAIBasePath = (fields == null ? void 0 : fields.azureOpenAIBasePath) ?? getEnvironmentVariable("AZURE_OPENAI_BASE_PATH");
      this.azureOpenAIEndpoint = (fields == null ? void 0 : fields.azureOpenAIEndpoint) ?? getEnvironmentVariable("AZURE_OPENAI_ENDPOINT");
      this.azureADTokenProvider = fields == null ? void 0 : fields.azureADTokenProvider;
      if (!this.azureOpenAIApiKey && !this.apiKey && !this.azureADTokenProvider) {
        throw new Error("Azure OpenAI API key or Token Provider not found");
      }
    }
    getLsParams(options) {
      const params = super.getLsParams(options);
      params.ls_provider = "azure";
      return params;
    }
    _getClientOptions(options) {
      var _a3;
      if (!this.client) {
        const openAIEndpointConfig = {
          azureOpenAIApiDeploymentName: this.azureOpenAIApiDeploymentName,
          azureOpenAIApiInstanceName: this.azureOpenAIApiInstanceName,
          azureOpenAIApiKey: this.azureOpenAIApiKey,
          azureOpenAIBasePath: this.azureOpenAIBasePath,
          azureADTokenProvider: this.azureADTokenProvider,
          baseURL: this.clientConfig.baseURL,
          azureOpenAIEndpoint: this.azureOpenAIEndpoint
        };
        const endpoint = getEndpoint$1(openAIEndpointConfig);
        const params = {
          ...this.clientConfig,
          baseURL: endpoint,
          timeout: this.timeout,
          maxRetries: 0
        };
        if (!this.azureADTokenProvider) {
          params.apiKey = openAIEndpointConfig.azureOpenAIApiKey;
        }
        if (!params.baseURL) {
          delete params.baseURL;
        }
        params.defaultHeaders = {
          ...params.defaultHeaders,
          "User-Agent": ((_a3 = params.defaultHeaders) == null ? void 0 : _a3["User-Agent"]) ? `${params.defaultHeaders["User-Agent"]}: langchainjs-azure-openai-v2` : `langchainjs-azure-openai-v2`
        };
        this.client = new AzureOpenAI$1({
          apiVersion: this.azureOpenAIApiVersion,
          azureADTokenProvider: this.azureADTokenProvider,
          deployment: this.azureOpenAIApiDeploymentName,
          ...params
        });
      }
      const requestOptions = {
        ...this.clientConfig,
        ...options
      };
      if (this.azureOpenAIApiKey) {
        requestOptions.headers = {
          "api-key": this.azureOpenAIApiKey,
          ...requestOptions.headers
        };
        requestOptions.query = {
          "api-version": this.azureOpenAIApiVersion,
          ...requestOptions.query
        };
      }
      return requestOptions;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    toJSON() {
      const json = super.toJSON();
      function isRecord(obj) {
        return typeof obj === "object" && obj != null;
      }
      if (isRecord(json) && isRecord(json.kwargs)) {
        delete json.kwargs.azure_openai_base_path;
        delete json.kwargs.azure_openai_api_deployment_name;
        delete json.kwargs.azure_openai_api_key;
        delete json.kwargs.azure_openai_api_version;
        delete json.kwargs.azure_open_ai_base_path;
        if (!json.kwargs.azure_endpoint && this.azureOpenAIEndpoint) {
          json.kwargs.azure_endpoint = this.azureOpenAIEndpoint;
        }
        if (!json.kwargs.azure_endpoint && this.azureOpenAIBasePath) {
          const parts = this.azureOpenAIBasePath.split("/openai/deployments/");
          if (parts.length === 2 && parts[0].startsWith("http")) {
            const [endpoint] = parts;
            json.kwargs.azure_endpoint = endpoint;
          }
        }
        if (!json.kwargs.azure_endpoint && this.azureOpenAIApiInstanceName) {
          json.kwargs.azure_endpoint = `https://${this.azureOpenAIApiInstanceName}.openai.azure.com/`;
        }
        if (!json.kwargs.deployment_name && this.azureOpenAIApiDeploymentName) {
          json.kwargs.deployment_name = this.azureOpenAIApiDeploymentName;
        }
        if (!json.kwargs.deployment_name && this.azureOpenAIBasePath) {
          const parts = this.azureOpenAIBasePath.split("/openai/deployments/");
          if (parts.length === 2) {
            const [, deployment] = parts;
            json.kwargs.deployment_name = deployment;
          }
        }
        if (json.kwargs.azure_endpoint && json.kwargs.deployment_name && json.kwargs.openai_api_base) {
          delete json.kwargs.openai_api_base;
        }
        if (json.kwargs.azure_openai_api_instance_name && json.kwargs.azure_endpoint) {
          delete json.kwargs.azure_openai_api_instance_name;
        }
      }
      return json;
    }
    withStructuredOutput(outputSchema, config2) {
      const ensuredConfig = { ...config2 };
      if (this.model.startsWith("gpt-4o")) {
        if ((ensuredConfig == null ? void 0 : ensuredConfig.method) === void 0) {
          ensuredConfig.method = "functionCalling";
        }
      }
      return super.withStructuredOutput(outputSchema, ensuredConfig);
    }
  }
  const VERSION$1 = "0.32.1";
  let auto$1 = false;
  let kind$1 = void 0;
  let fetch$3 = void 0;
  let File$2 = void 0;
  let ReadableStream$2 = void 0;
  let getDefaultAgent$1 = void 0;
  let fileFromPath$1 = void 0;
  function setShims$1(shims, options = { auto: false }) {
    if (auto$1) {
      throw new Error(`you must \`import '@anthropic-ai/sdk/shims/${shims.kind}'\` before importing anything else from @anthropic-ai/sdk`);
    }
    if (kind$1) {
      throw new Error(`can't \`import '@anthropic-ai/sdk/shims/${shims.kind}'\` after \`import '@anthropic-ai/sdk/shims/${kind$1}'\``);
    }
    auto$1 = options.auto;
    kind$1 = shims.kind;
    fetch$3 = shims.fetch;
    File$2 = shims.File;
    ReadableStream$2 = shims.ReadableStream;
    getDefaultAgent$1 = shims.getDefaultAgent;
    fileFromPath$1 = shims.fileFromPath;
  }
  let MultipartBody$1 = class MultipartBody {
    constructor(body) {
      this.body = body;
    }
    get [Symbol.toStringTag]() {
      return "MultipartBody";
    }
  };
  function getRuntime$1({ manuallyImported } = {}) {
    const recommendation = manuallyImported ? `You may need to use polyfills` : `Add one of these imports before your first \`import … from '@anthropic-ai/sdk'\`:
- \`import '@anthropic-ai/sdk/shims/node'\` (if you're running on Node)
- \`import '@anthropic-ai/sdk/shims/web'\` (otherwise)
`;
    let _fetch, _Request, _Response, _Headers;
    try {
      _fetch = fetch;
      _Request = Request;
      _Response = Response;
      _Headers = Headers;
    } catch (error) {
      throw new Error(`this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`);
    }
    return {
      kind: "web",
      fetch: _fetch,
      Request: _Request,
      Response: _Response,
      Headers: _Headers,
      FormData: (
        // @ts-ignore
        typeof FormData !== "undefined" ? FormData : class FormData {
          // @ts-ignore
          constructor() {
            throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);
          }
        }
      ),
      Blob: typeof Blob !== "undefined" ? Blob : class Blob {
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);
        }
      },
      File: (
        // @ts-ignore
        typeof File !== "undefined" ? File : class File {
          // @ts-ignore
          constructor() {
            throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);
          }
        }
      ),
      ReadableStream: (
        // @ts-ignore
        typeof ReadableStream !== "undefined" ? ReadableStream : class ReadableStream {
          // @ts-ignore
          constructor() {
            throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`);
          }
        }
      ),
      getMultipartRequestOptions: async (form, opts) => ({
        ...opts,
        body: new MultipartBody$1(form)
      }),
      getDefaultAgent: (url) => void 0,
      fileFromPath: () => {
        throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/anthropics/anthropic-sdk-typescript#file-uploads");
      },
      isFsReadStream: (value) => false
    };
  }
  if (!kind$1) setShims$1(getRuntime$1(), { auto: true });
  class AnthropicError extends Error {
  }
  let APIError$1 = class APIError2 extends AnthropicError {
    constructor(status, error, message, headers) {
      super(`${APIError2.makeMessage(status, error, message)}`);
      this.status = status;
      this.headers = headers;
      this.request_id = headers == null ? void 0 : headers["request-id"];
      this.error = error;
    }
    static makeMessage(status, error, message) {
      const msg = (error == null ? void 0 : error.message) ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
      if (status && msg) {
        return `${status} ${msg}`;
      }
      if (status) {
        return `${status} status code (no body)`;
      }
      if (msg) {
        return msg;
      }
      return "(no status code or body)";
    }
    static generate(status, errorResponse, message, headers) {
      if (!status) {
        return new APIConnectionError$1({ message, cause: castToError$1(errorResponse) });
      }
      const error = errorResponse;
      if (status === 400) {
        return new BadRequestError$1(status, error, message, headers);
      }
      if (status === 401) {
        return new AuthenticationError$1(status, error, message, headers);
      }
      if (status === 403) {
        return new PermissionDeniedError$1(status, error, message, headers);
      }
      if (status === 404) {
        return new NotFoundError$1(status, error, message, headers);
      }
      if (status === 409) {
        return new ConflictError$1(status, error, message, headers);
      }
      if (status === 422) {
        return new UnprocessableEntityError$1(status, error, message, headers);
      }
      if (status === 429) {
        return new RateLimitError$1(status, error, message, headers);
      }
      if (status >= 500) {
        return new InternalServerError$1(status, error, message, headers);
      }
      return new APIError2(status, error, message, headers);
    }
  };
  let APIUserAbortError$1 = class APIUserAbortError extends APIError$1 {
    constructor({ message } = {}) {
      super(void 0, void 0, message || "Request was aborted.", void 0);
      this.status = void 0;
    }
  };
  let APIConnectionError$1 = class APIConnectionError extends APIError$1 {
    constructor({ message, cause }) {
      super(void 0, void 0, message || "Connection error.", void 0);
      this.status = void 0;
      if (cause)
        this.cause = cause;
    }
  };
  let APIConnectionTimeoutError$1 = class APIConnectionTimeoutError extends APIConnectionError$1 {
    constructor({ message } = {}) {
      super({ message: message ?? "Request timed out." });
    }
  };
  let BadRequestError$1 = class BadRequestError extends APIError$1 {
    constructor() {
      super(...arguments);
      this.status = 400;
    }
  };
  let AuthenticationError$1 = class AuthenticationError extends APIError$1 {
    constructor() {
      super(...arguments);
      this.status = 401;
    }
  };
  let PermissionDeniedError$1 = class PermissionDeniedError extends APIError$1 {
    constructor() {
      super(...arguments);
      this.status = 403;
    }
  };
  let NotFoundError$1 = class NotFoundError extends APIError$1 {
    constructor() {
      super(...arguments);
      this.status = 404;
    }
  };
  let ConflictError$1 = class ConflictError extends APIError$1 {
    constructor() {
      super(...arguments);
      this.status = 409;
    }
  };
  let UnprocessableEntityError$1 = class UnprocessableEntityError extends APIError$1 {
    constructor() {
      super(...arguments);
      this.status = 422;
    }
  };
  let RateLimitError$1 = class RateLimitError extends APIError$1 {
    constructor() {
      super(...arguments);
      this.status = 429;
    }
  };
  let InternalServerError$1 = class InternalServerError extends APIError$1 {
  };
  let LineDecoder$1 = class LineDecoder2 {
    constructor() {
      this.buffer = [];
      this.trailingCR = false;
    }
    decode(chunk) {
      let text = this.decodeText(chunk);
      if (this.trailingCR) {
        text = "\r" + text;
        this.trailingCR = false;
      }
      if (text.endsWith("\r")) {
        this.trailingCR = true;
        text = text.slice(0, -1);
      }
      if (!text) {
        return [];
      }
      const trailingNewline = LineDecoder2.NEWLINE_CHARS.has(text[text.length - 1] || "");
      let lines = text.split(LineDecoder2.NEWLINE_REGEXP);
      if (trailingNewline) {
        lines.pop();
      }
      if (lines.length === 1 && !trailingNewline) {
        this.buffer.push(lines[0]);
        return [];
      }
      if (this.buffer.length > 0) {
        lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
        this.buffer = [];
      }
      if (!trailingNewline) {
        this.buffer = [lines.pop() || ""];
      }
      return lines;
    }
    decodeText(bytes) {
      if (bytes == null)
        return "";
      if (typeof bytes === "string")
        return bytes;
      if (typeof Buffer !== "undefined") {
        if (bytes instanceof Buffer) {
          return bytes.toString();
        }
        if (bytes instanceof Uint8Array) {
          return Buffer.from(bytes).toString();
        }
        throw new AnthropicError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
      }
      if (typeof TextDecoder !== "undefined") {
        if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
          this.textDecoder ?? (this.textDecoder = new TextDecoder("utf8"));
          return this.textDecoder.decode(bytes);
        }
        throw new AnthropicError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
      }
      throw new AnthropicError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
    }
    flush() {
      if (!this.buffer.length && !this.trailingCR) {
        return [];
      }
      const lines = [this.buffer.join("")];
      this.buffer = [];
      this.trailingCR = false;
      return lines;
    }
  };
  LineDecoder$1.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
  LineDecoder$1.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
  let Stream$1 = class Stream2 {
    constructor(iterator2, controller) {
      this.iterator = iterator2;
      this.controller = controller;
    }
    static fromSSEResponse(response, controller) {
      let consumed2 = false;
      async function* iterator2() {
        if (consumed2) {
          throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
        }
        consumed2 = true;
        let done = false;
        try {
          for await (const sse of _iterSSEMessages$1(response, controller)) {
            if (sse.event === "completion") {
              try {
                yield JSON.parse(sse.data);
              } catch (e) {
                console.error(`Could not parse message into JSON:`, sse.data);
                console.error(`From chunk:`, sse.raw);
                throw e;
              }
            }
            if (sse.event === "message_start" || sse.event === "message_delta" || sse.event === "message_stop" || sse.event === "content_block_start" || sse.event === "content_block_delta" || sse.event === "content_block_stop") {
              try {
                yield JSON.parse(sse.data);
              } catch (e) {
                console.error(`Could not parse message into JSON:`, sse.data);
                console.error(`From chunk:`, sse.raw);
                throw e;
              }
            }
            if (sse.event === "ping") {
              continue;
            }
            if (sse.event === "error") {
              throw APIError$1.generate(void 0, `SSE Error: ${sse.data}`, sse.data, createResponseHeaders$1(response.headers));
            }
          }
          done = true;
        } catch (e) {
          if (e instanceof Error && e.name === "AbortError")
            return;
          throw e;
        } finally {
          if (!done)
            controller.abort();
        }
      }
      return new Stream2(iterator2, controller);
    }
    /**
     * Generates a Stream from a newline-separated ReadableStream
     * where each item is a JSON value.
     */
    static fromReadableStream(readableStream, controller) {
      let consumed2 = false;
      async function* iterLines() {
        const lineDecoder = new LineDecoder$1();
        const iter = readableStreamAsyncIterable(readableStream);
        for await (const chunk of iter) {
          for (const line of lineDecoder.decode(chunk)) {
            yield line;
          }
        }
        for (const line of lineDecoder.flush()) {
          yield line;
        }
      }
      async function* iterator2() {
        if (consumed2) {
          throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
        }
        consumed2 = true;
        let done = false;
        try {
          for await (const line of iterLines()) {
            if (done)
              continue;
            if (line)
              yield JSON.parse(line);
          }
          done = true;
        } catch (e) {
          if (e instanceof Error && e.name === "AbortError")
            return;
          throw e;
        } finally {
          if (!done)
            controller.abort();
        }
      }
      return new Stream2(iterator2, controller);
    }
    [Symbol.asyncIterator]() {
      return this.iterator();
    }
    /**
     * Splits the stream into two streams which can be
     * independently read from at different speeds.
     */
    tee() {
      const left = [];
      const right = [];
      const iterator2 = this.iterator();
      const teeIterator = (queue2) => {
        return {
          next: () => {
            if (queue2.length === 0) {
              const result = iterator2.next();
              left.push(result);
              right.push(result);
            }
            return queue2.shift();
          }
        };
      };
      return [
        new Stream2(() => teeIterator(left), this.controller),
        new Stream2(() => teeIterator(right), this.controller)
      ];
    }
    /**
     * Converts this stream to a newline-separated ReadableStream of
     * JSON stringified values in the stream
     * which can be turned back into a Stream with `Stream.fromReadableStream()`.
     */
    toReadableStream() {
      const self2 = this;
      let iter;
      const encoder = new TextEncoder();
      return new ReadableStream$2({
        async start() {
          iter = self2[Symbol.asyncIterator]();
        },
        async pull(ctrl) {
          try {
            const { value, done } = await iter.next();
            if (done)
              return ctrl.close();
            const bytes = encoder.encode(JSON.stringify(value) + "\n");
            ctrl.enqueue(bytes);
          } catch (err) {
            ctrl.error(err);
          }
        },
        async cancel() {
          var _a3;
          await ((_a3 = iter.return) == null ? void 0 : _a3.call(iter));
        }
      });
    }
  };
  async function* _iterSSEMessages$1(response, controller) {
    if (!response.body) {
      controller.abort();
      throw new AnthropicError(`Attempted to iterate over a response with no body`);
    }
    const sseDecoder = new SSEDecoder$1();
    const lineDecoder = new LineDecoder$1();
    const iter = readableStreamAsyncIterable(response.body);
    for await (const sseChunk of iterSSEChunks$1(iter)) {
      for (const line of lineDecoder.decode(sseChunk)) {
        const sse = sseDecoder.decode(line);
        if (sse)
          yield sse;
      }
    }
    for (const line of lineDecoder.flush()) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  async function* iterSSEChunks$1(iterator2) {
    let data = new Uint8Array();
    for await (const chunk of iterator2) {
      if (chunk == null) {
        continue;
      }
      const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
      let newData = new Uint8Array(data.length + binaryChunk.length);
      newData.set(data);
      newData.set(binaryChunk, data.length);
      data = newData;
      let patternIndex;
      while ((patternIndex = findDoubleNewlineIndex$1(data)) !== -1) {
        yield data.slice(0, patternIndex);
        data = data.slice(patternIndex);
      }
    }
    if (data.length > 0) {
      yield data;
    }
  }
  function findDoubleNewlineIndex$1(buffer) {
    const newline = 10;
    const carriage = 13;
    for (let i2 = 0; i2 < buffer.length - 2; i2++) {
      if (buffer[i2] === newline && buffer[i2 + 1] === newline) {
        return i2 + 2;
      }
      if (buffer[i2] === carriage && buffer[i2 + 1] === carriage) {
        return i2 + 2;
      }
      if (buffer[i2] === carriage && buffer[i2 + 1] === newline && i2 + 3 < buffer.length && buffer[i2 + 2] === carriage && buffer[i2 + 3] === newline) {
        return i2 + 4;
      }
    }
    return -1;
  }
  let SSEDecoder$1 = class SSEDecoder {
    constructor() {
      this.event = null;
      this.data = [];
      this.chunks = [];
    }
    decode(line) {
      if (line.endsWith("\r")) {
        line = line.substring(0, line.length - 1);
      }
      if (!line) {
        if (!this.event && !this.data.length)
          return null;
        const sse = {
          event: this.event,
          data: this.data.join("\n"),
          raw: this.chunks
        };
        this.event = null;
        this.data = [];
        this.chunks = [];
        return sse;
      }
      this.chunks.push(line);
      if (line.startsWith(":")) {
        return null;
      }
      let [fieldname, _, value] = partition$1(line, ":");
      if (value.startsWith(" ")) {
        value = value.substring(1);
      }
      if (fieldname === "event") {
        this.event = value;
      } else if (fieldname === "data") {
        this.data.push(value);
      }
      return null;
    }
  };
  function partition$1(str2, delimiter) {
    const index = str2.indexOf(delimiter);
    if (index !== -1) {
      return [str2.substring(0, index), delimiter, str2.substring(index + delimiter.length)];
    }
    return [str2, "", ""];
  }
  function readableStreamAsyncIterable(stream) {
    if (stream[Symbol.asyncIterator])
      return stream;
    const reader = stream.getReader();
    return {
      async next() {
        try {
          const result = await reader.read();
          if (result == null ? void 0 : result.done)
            reader.releaseLock();
          return result;
        } catch (e) {
          reader.releaseLock();
          throw e;
        }
      },
      async return() {
        const cancelPromise = reader.cancel();
        reader.releaseLock();
        await cancelPromise;
        return { done: true, value: void 0 };
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  const isResponseLike$1 = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
  const isFileLike$1 = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike$1(value);
  const isBlobLike$1 = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
  async function toFile$1(value, name, options) {
    var _a3;
    value = await value;
    if (isFileLike$1(value)) {
      return value;
    }
    if (isResponseLike$1(value)) {
      const blob = await value.blob();
      name || (name = new URL(value.url).pathname.split(/[\\/]/).pop() ?? "unknown_file");
      const data = isBlobLike$1(blob) ? [await blob.arrayBuffer()] : [blob];
      return new File$2(data, name, options);
    }
    const bits = await getBytes$1(value);
    name || (name = getName$1(value) ?? "unknown_file");
    if (!(options == null ? void 0 : options.type)) {
      const type = (_a3 = bits[0]) == null ? void 0 : _a3.type;
      if (typeof type === "string") {
        options = { ...options, type };
      }
    }
    return new File$2(bits, name, options);
  }
  async function getBytes$1(value) {
    var _a3;
    let parts = [];
    if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
    value instanceof ArrayBuffer) {
      parts.push(value);
    } else if (isBlobLike$1(value)) {
      parts.push(await value.arrayBuffer());
    } else if (isAsyncIterableIterator$1(value)) {
      for await (const chunk of value) {
        parts.push(chunk);
      }
    } else {
      throw new Error(`Unexpected data type: ${typeof value}; constructor: ${(_a3 = value == null ? void 0 : value.constructor) == null ? void 0 : _a3.name}; props: ${propsForError$1(value)}`);
    }
    return parts;
  }
  function propsForError$1(value) {
    const props = Object.getOwnPropertyNames(value);
    return `[${props.map((p) => `"${p}"`).join(", ")}]`;
  }
  function getName$1(value) {
    var _a3;
    return getStringFromMaybeBuffer$1(value.name) || getStringFromMaybeBuffer$1(value.filename) || // For fs.ReadStream
    ((_a3 = getStringFromMaybeBuffer$1(value.path)) == null ? void 0 : _a3.split(/[\\/]/).pop());
  }
  const getStringFromMaybeBuffer$1 = (x) => {
    if (typeof x === "string")
      return x;
    if (typeof Buffer !== "undefined" && x instanceof Buffer)
      return String(x);
    return void 0;
  };
  const isAsyncIterableIterator$1 = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
  const isMultipartBody$1 = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";
  var __classPrivateFieldSet$6 = function(receiver, state, value, kind2, f) {
    if (kind2 === "m") throw new TypeError("Private method is not writable");
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet$7 = function(receiver, state, kind2, f) {
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _AbstractPage_client$1;
  async function defaultParseResponse$1(props) {
    const { response } = props;
    if (props.options.stream) {
      debug$1("response", response.status, response.url, response.headers, response.body);
      if (props.options.__streamClass) {
        return props.options.__streamClass.fromSSEResponse(response, props.controller);
      }
      return Stream$1.fromSSEResponse(response, props.controller);
    }
    if (response.status === 204) {
      return null;
    }
    if (props.options.__binaryResponse) {
      return response;
    }
    const contentType = response.headers.get("content-type");
    const isJSON = (contentType == null ? void 0 : contentType.includes("application/json")) || (contentType == null ? void 0 : contentType.includes("application/vnd.api+json"));
    if (isJSON) {
      const json = await response.json();
      debug$1("response", response.status, response.url, response.headers, json);
      return json;
    }
    const text = await response.text();
    debug$1("response", response.status, response.url, response.headers, text);
    return text;
  }
  let APIPromise$1 = class APIPromise2 extends Promise {
    constructor(responsePromise, parseResponse = defaultParseResponse$1) {
      super((resolve) => {
        resolve(null);
      });
      this.responsePromise = responsePromise;
      this.parseResponse = parseResponse;
    }
    _thenUnwrap(transform) {
      return new APIPromise2(this.responsePromise, async (props) => transform(await this.parseResponse(props), props));
    }
    /**
     * Gets the raw `Response` instance instead of parsing the response
     * data.
     *
     * If you want to parse the response body but still get the `Response`
     * instance, you can use {@link withResponse()}.
     *
     * 👋 Getting the wrong TypeScript type for `Response`?
     * Try setting `"moduleResolution": "NodeNext"` if you can,
     * or add one of these imports before your first `import … from '@anthropic-ai/sdk'`:
     * - `import '@anthropic-ai/sdk/shims/node'` (if you're running on Node)
     * - `import '@anthropic-ai/sdk/shims/web'` (otherwise)
     */
    asResponse() {
      return this.responsePromise.then((p) => p.response);
    }
    /**
     * Gets the parsed response data and the raw `Response` instance.
     *
     * If you just want to get the raw `Response` instance without parsing it,
     * you can use {@link asResponse()}.
     *
     *
     * 👋 Getting the wrong TypeScript type for `Response`?
     * Try setting `"moduleResolution": "NodeNext"` if you can,
     * or add one of these imports before your first `import … from '@anthropic-ai/sdk'`:
     * - `import '@anthropic-ai/sdk/shims/node'` (if you're running on Node)
     * - `import '@anthropic-ai/sdk/shims/web'` (otherwise)
     */
    async withResponse() {
      const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
      return { data, response };
    }
    parse() {
      if (!this.parsedPromise) {
        this.parsedPromise = this.responsePromise.then(this.parseResponse);
      }
      return this.parsedPromise;
    }
    then(onfulfilled, onrejected) {
      return this.parse().then(onfulfilled, onrejected);
    }
    catch(onrejected) {
      return this.parse().catch(onrejected);
    }
    finally(onfinally) {
      return this.parse().finally(onfinally);
    }
  };
  let APIClient$1 = class APIClient {
    constructor({
      baseURL,
      maxRetries = 2,
      timeout: timeout2 = 6e5,
      // 10 minutes
      httpAgent,
      fetch: overridenFetch
    }) {
      this.baseURL = baseURL;
      this.maxRetries = validatePositiveInteger$1("maxRetries", maxRetries);
      this.timeout = validatePositiveInteger$1("timeout", timeout2);
      this.httpAgent = httpAgent;
      this.fetch = overridenFetch ?? fetch$3;
    }
    authHeaders(opts) {
      return {};
    }
    /**
     * Override this to add your own default headers, for example:
     *
     *  {
     *    ...super.defaultHeaders(),
     *    Authorization: 'Bearer 123',
     *  }
     */
    defaultHeaders(opts) {
      return {
        Accept: "application/json",
        "Content-Type": "application/json",
        "User-Agent": this.getUserAgent(),
        ...getPlatformHeaders$1(),
        ...this.authHeaders(opts)
      };
    }
    /**
     * Override this to add your own headers validation:
     */
    validateHeaders(headers, customHeaders) {
    }
    defaultIdempotencyKey() {
      return `stainless-node-retry-${uuid4$1()}`;
    }
    get(path, opts) {
      return this.methodRequest("get", path, opts);
    }
    post(path, opts) {
      return this.methodRequest("post", path, opts);
    }
    patch(path, opts) {
      return this.methodRequest("patch", path, opts);
    }
    put(path, opts) {
      return this.methodRequest("put", path, opts);
    }
    delete(path, opts) {
      return this.methodRequest("delete", path, opts);
    }
    methodRequest(method, path, opts) {
      return this.request(Promise.resolve(opts).then(async (opts2) => {
        const body = opts2 && isBlobLike$1(opts2 == null ? void 0 : opts2.body) ? new DataView(await opts2.body.arrayBuffer()) : (opts2 == null ? void 0 : opts2.body) instanceof DataView ? opts2.body : (opts2 == null ? void 0 : opts2.body) instanceof ArrayBuffer ? new DataView(opts2.body) : opts2 && ArrayBuffer.isView(opts2 == null ? void 0 : opts2.body) ? new DataView(opts2.body.buffer) : opts2 == null ? void 0 : opts2.body;
        return { method, path, ...opts2, body };
      }));
    }
    getAPIList(path, Page2, opts) {
      return this.requestAPIList(Page2, { method: "get", path, ...opts });
    }
    calculateContentLength(body) {
      if (typeof body === "string") {
        if (typeof Buffer !== "undefined") {
          return Buffer.byteLength(body, "utf8").toString();
        }
        if (typeof TextEncoder !== "undefined") {
          const encoder = new TextEncoder();
          const encoded = encoder.encode(body);
          return encoded.length.toString();
        }
      } else if (ArrayBuffer.isView(body)) {
        return body.byteLength.toString();
      }
      return null;
    }
    buildRequest(options, { retryCount = 0 } = {}) {
      var _a3;
      const { method, path, query, headers = {} } = options;
      const body = ArrayBuffer.isView(options.body) || options.__binaryRequest && typeof options.body === "string" ? options.body : isMultipartBody$1(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
      const contentLength = this.calculateContentLength(body);
      const url = this.buildURL(path, query);
      if ("timeout" in options)
        validatePositiveInteger$1("timeout", options.timeout);
      const timeout2 = options.timeout ?? this.timeout;
      const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent$1(url);
      const minAgentTimeout = timeout2 + 1e3;
      if (typeof ((_a3 = httpAgent == null ? void 0 : httpAgent.options) == null ? void 0 : _a3.timeout) === "number" && minAgentTimeout > (httpAgent.options.timeout ?? 0)) {
        httpAgent.options.timeout = minAgentTimeout;
      }
      if (this.idempotencyHeader && method !== "get") {
        if (!options.idempotencyKey)
          options.idempotencyKey = this.defaultIdempotencyKey();
        headers[this.idempotencyHeader] = options.idempotencyKey;
      }
      const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });
      const req = {
        method,
        ...body && { body },
        headers: reqHeaders,
        ...httpAgent && { agent: httpAgent },
        // @ts-ignore node-fetch uses a custom AbortSignal type that is
        // not compatible with standard web types
        signal: options.signal ?? null
      };
      return { req, url, timeout: timeout2 };
    }
    buildHeaders({ options, headers, contentLength, retryCount }) {
      const reqHeaders = {};
      if (contentLength) {
        reqHeaders["content-length"] = contentLength;
      }
      const defaultHeaders = this.defaultHeaders(options);
      applyHeadersMut$1(reqHeaders, defaultHeaders);
      applyHeadersMut$1(reqHeaders, headers);
      if (isMultipartBody$1(options.body) && kind$1 !== "node") {
        delete reqHeaders["content-type"];
      }
      if (getHeader$1(defaultHeaders, "x-stainless-retry-count") === void 0 && getHeader$1(headers, "x-stainless-retry-count") === void 0) {
        reqHeaders["x-stainless-retry-count"] = String(retryCount);
      }
      this.validateHeaders(reqHeaders, headers);
      return reqHeaders;
    }
    /**
     * Used as a callback for mutating the given `FinalRequestOptions` object.
     */
    async prepareOptions(options) {
    }
    /**
     * Used as a callback for mutating the given `RequestInit` object.
     *
     * This is useful for cases where you want to add certain headers based off of
     * the request properties, e.g. `method` or `url`.
     */
    async prepareRequest(request, { url, options }) {
    }
    parseHeaders(headers) {
      return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
    }
    makeStatusError(status, error, message, headers) {
      return APIError$1.generate(status, error, message, headers);
    }
    request(options, remainingRetries = null) {
      return new APIPromise$1(this.makeRequest(options, remainingRetries));
    }
    async makeRequest(optionsInput, retriesRemaining) {
      var _a3, _b2;
      const options = await optionsInput;
      const maxRetries = options.maxRetries ?? this.maxRetries;
      if (retriesRemaining == null) {
        retriesRemaining = maxRetries;
      }
      await this.prepareOptions(options);
      const { req, url, timeout: timeout2 } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });
      await this.prepareRequest(req, { url, options });
      debug$1("request", url, options, req.headers);
      if ((_a3 = options.signal) == null ? void 0 : _a3.aborted) {
        throw new APIUserAbortError$1();
      }
      const controller = new AbortController();
      const response = await this.fetchWithTimeout(url, req, timeout2, controller).catch(castToError$1);
      if (response instanceof Error) {
        if ((_b2 = options.signal) == null ? void 0 : _b2.aborted) {
          throw new APIUserAbortError$1();
        }
        if (retriesRemaining) {
          return this.retryRequest(options, retriesRemaining);
        }
        if (response.name === "AbortError") {
          throw new APIConnectionTimeoutError$1();
        }
        throw new APIConnectionError$1({ cause: response });
      }
      const responseHeaders = createResponseHeaders$1(response.headers);
      if (!response.ok) {
        if (retriesRemaining && this.shouldRetry(response)) {
          const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
          debug$1(`response (error; ${retryMessage2})`, response.status, url, responseHeaders);
          return this.retryRequest(options, retriesRemaining, responseHeaders);
        }
        const errText = await response.text().catch((e) => castToError$1(e).message);
        const errJSON = safeJSON$1(errText);
        const errMessage = errJSON ? void 0 : errText;
        const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;
        debug$1(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);
        const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
        throw err;
      }
      return { response, options, controller };
    }
    requestAPIList(Page2, options) {
      const request = this.makeRequest(options, null);
      return new PagePromise$1(this, request, Page2);
    }
    buildURL(path, query) {
      const url = isAbsoluteURL$1(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path.startsWith("/") ? path.slice(1) : path));
      const defaultQuery = this.defaultQuery();
      if (!isEmptyObj$2(defaultQuery)) {
        query = { ...defaultQuery, ...query };
      }
      if (typeof query === "object" && query && !Array.isArray(query)) {
        url.search = this.stringifyQuery(query);
      }
      return url.toString();
    }
    stringifyQuery(query) {
      return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
        if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
          return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
        }
        if (value === null) {
          return `${encodeURIComponent(key)}=`;
        }
        throw new AnthropicError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
      }).join("&");
    }
    async fetchWithTimeout(url, init, ms2, controller) {
      const { signal, ...options } = init || {};
      if (signal)
        signal.addEventListener("abort", () => controller.abort());
      const timeout2 = setTimeout(() => controller.abort(), ms2);
      return this.getRequestClient().fetch.call(void 0, url, { signal: controller.signal, ...options }).finally(() => {
        clearTimeout(timeout2);
      });
    }
    getRequestClient() {
      return { fetch: this.fetch };
    }
    shouldRetry(response) {
      const shouldRetryHeader = response.headers.get("x-should-retry");
      if (shouldRetryHeader === "true")
        return true;
      if (shouldRetryHeader === "false")
        return false;
      if (response.status === 408)
        return true;
      if (response.status === 409)
        return true;
      if (response.status === 429)
        return true;
      if (response.status >= 500)
        return true;
      return false;
    }
    async retryRequest(options, retriesRemaining, responseHeaders) {
      let timeoutMillis;
      const retryAfterMillisHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after-ms"];
      if (retryAfterMillisHeader) {
        const timeoutMs = parseFloat(retryAfterMillisHeader);
        if (!Number.isNaN(timeoutMs)) {
          timeoutMillis = timeoutMs;
        }
      }
      const retryAfterHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after"];
      if (retryAfterHeader && !timeoutMillis) {
        const timeoutSeconds = parseFloat(retryAfterHeader);
        if (!Number.isNaN(timeoutSeconds)) {
          timeoutMillis = timeoutSeconds * 1e3;
        } else {
          timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
        }
      }
      if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
        const maxRetries = options.maxRetries ?? this.maxRetries;
        timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
      }
      await sleep$1(timeoutMillis);
      return this.makeRequest(options, retriesRemaining - 1);
    }
    calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
      const initialRetryDelay = 0.5;
      const maxRetryDelay = 8;
      const numRetries = maxRetries - retriesRemaining;
      const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
      const jitter = 1 - Math.random() * 0.25;
      return sleepSeconds * jitter * 1e3;
    }
    getUserAgent() {
      return `${this.constructor.name}/JS ${VERSION$1}`;
    }
  };
  let AbstractPage$1 = class AbstractPage {
    constructor(client2, response, body, options) {
      _AbstractPage_client$1.set(this, void 0);
      __classPrivateFieldSet$6(this, _AbstractPage_client$1, client2, "f");
      this.options = options;
      this.response = response;
      this.body = body;
    }
    hasNextPage() {
      const items = this.getPaginatedItems();
      if (!items.length)
        return false;
      return this.nextPageInfo() != null;
    }
    async getNextPage() {
      const nextInfo = this.nextPageInfo();
      if (!nextInfo) {
        throw new AnthropicError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
      }
      const nextOptions = { ...this.options };
      if ("params" in nextInfo && typeof nextOptions.query === "object") {
        nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
      } else if ("url" in nextInfo) {
        const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
        for (const [key, value] of params) {
          nextInfo.url.searchParams.set(key, value);
        }
        nextOptions.query = void 0;
        nextOptions.path = nextInfo.url.toString();
      }
      return await __classPrivateFieldGet$7(this, _AbstractPage_client$1, "f").requestAPIList(this.constructor, nextOptions);
    }
    async *iterPages() {
      let page = this;
      yield page;
      while (page.hasNextPage()) {
        page = await page.getNextPage();
        yield page;
      }
    }
    async *[(_AbstractPage_client$1 = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
      for await (const page of this.iterPages()) {
        for (const item of page.getPaginatedItems()) {
          yield item;
        }
      }
    }
  };
  let PagePromise$1 = class PagePromise extends APIPromise$1 {
    constructor(client2, request, Page2) {
      super(request, async (props) => new Page2(client2, props.response, await defaultParseResponse$1(props), props.options));
    }
    /**
     * Allow auto-paginating iteration on an unawaited list call, eg:
     *
     *    for await (const item of client.items.list()) {
     *      console.log(item)
     *    }
     */
    async *[Symbol.asyncIterator]() {
      const page = await this;
      for await (const item of page) {
        yield item;
      }
    }
  };
  const createResponseHeaders$1 = (headers) => {
    return new Proxy(Object.fromEntries(
      // @ts-ignore
      headers.entries()
    ), {
      get(target, name) {
        const key = name.toString();
        return target[key.toLowerCase()] || target[key];
      }
    });
  };
  const requestOptionsKeys$1 = {
    method: true,
    path: true,
    query: true,
    body: true,
    headers: true,
    maxRetries: true,
    stream: true,
    timeout: true,
    httpAgent: true,
    signal: true,
    idempotencyKey: true,
    __binaryRequest: true,
    __binaryResponse: true,
    __streamClass: true
  };
  const isRequestOptions$1 = (obj) => {
    return typeof obj === "object" && obj !== null && !isEmptyObj$2(obj) && Object.keys(obj).every((k) => hasOwn$1(requestOptionsKeys$1, k));
  };
  const getPlatformProperties$1 = () => {
    var _a3;
    if (typeof Deno !== "undefined" && Deno.build != null) {
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION$1,
        "X-Stainless-OS": normalizePlatform$1(Deno.build.os),
        "X-Stainless-Arch": normalizeArch$1(Deno.build.arch),
        "X-Stainless-Runtime": "deno",
        "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : ((_a3 = Deno.version) == null ? void 0 : _a3.deno) ?? "unknown"
      };
    }
    if (typeof EdgeRuntime !== "undefined") {
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION$1,
        "X-Stainless-OS": "Unknown",
        "X-Stainless-Arch": `other:${EdgeRuntime}`,
        "X-Stainless-Runtime": "edge",
        "X-Stainless-Runtime-Version": process.version
      };
    }
    if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION$1,
        "X-Stainless-OS": normalizePlatform$1(process.platform),
        "X-Stainless-Arch": normalizeArch$1(process.arch),
        "X-Stainless-Runtime": "node",
        "X-Stainless-Runtime-Version": process.version
      };
    }
    const browserInfo = getBrowserInfo$1();
    if (browserInfo) {
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION$1,
        "X-Stainless-OS": "Unknown",
        "X-Stainless-Arch": "unknown",
        "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
        "X-Stainless-Runtime-Version": browserInfo.version
      };
    }
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION$1,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": "unknown",
      "X-Stainless-Runtime-Version": "unknown"
    };
  };
  function getBrowserInfo$1() {
    if (typeof navigator === "undefined" || !navigator) {
      return null;
    }
    const browserPatterns = [
      { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
    ];
    for (const { key, pattern } of browserPatterns) {
      const match = pattern.exec(navigator.userAgent);
      if (match) {
        const major = match[1] || 0;
        const minor = match[2] || 0;
        const patch = match[3] || 0;
        return { browser: key, version: `${major}.${minor}.${patch}` };
      }
    }
    return null;
  }
  const normalizeArch$1 = (arch) => {
    if (arch === "x32")
      return "x32";
    if (arch === "x86_64" || arch === "x64")
      return "x64";
    if (arch === "arm")
      return "arm";
    if (arch === "aarch64" || arch === "arm64")
      return "arm64";
    if (arch)
      return `other:${arch}`;
    return "unknown";
  };
  const normalizePlatform$1 = (platform) => {
    platform = platform.toLowerCase();
    if (platform.includes("ios"))
      return "iOS";
    if (platform === "android")
      return "Android";
    if (platform === "darwin")
      return "MacOS";
    if (platform === "win32")
      return "Windows";
    if (platform === "freebsd")
      return "FreeBSD";
    if (platform === "openbsd")
      return "OpenBSD";
    if (platform === "linux")
      return "Linux";
    if (platform)
      return `Other:${platform}`;
    return "Unknown";
  };
  let _platformHeaders$1;
  const getPlatformHeaders$1 = () => {
    return _platformHeaders$1 ?? (_platformHeaders$1 = getPlatformProperties$1());
  };
  const safeJSON$1 = (text) => {
    try {
      return JSON.parse(text);
    } catch (err) {
      return void 0;
    }
  };
  const startsWithSchemeRegexp$1 = new RegExp("^(?:[a-z]+:)?//", "i");
  const isAbsoluteURL$1 = (url) => {
    return startsWithSchemeRegexp$1.test(url);
  };
  const sleep$1 = (ms2) => new Promise((resolve) => setTimeout(resolve, ms2));
  const validatePositiveInteger$1 = (name, n) => {
    if (typeof n !== "number" || !Number.isInteger(n)) {
      throw new AnthropicError(`${name} must be an integer`);
    }
    if (n < 0) {
      throw new AnthropicError(`${name} must be a positive integer`);
    }
    return n;
  };
  const castToError$1 = (err) => {
    if (err instanceof Error)
      return err;
    if (typeof err === "object" && err !== null) {
      try {
        return new Error(JSON.stringify(err));
      } catch {
      }
    }
    return new Error(String(err));
  };
  const readEnv$1 = (env) => {
    var _a3, _b2, _c2, _d2, _e2;
    if (typeof process !== "undefined") {
      return ((_b2 = (_a3 = process.env) == null ? void 0 : _a3[env]) == null ? void 0 : _b2.trim()) ?? void 0;
    }
    if (typeof Deno !== "undefined") {
      return (_e2 = (_d2 = (_c2 = Deno.env) == null ? void 0 : _c2.get) == null ? void 0 : _d2.call(_c2, env)) == null ? void 0 : _e2.trim();
    }
    return void 0;
  };
  function isEmptyObj$2(obj) {
    if (!obj)
      return true;
    for (const _k2 in obj)
      return false;
    return true;
  }
  function hasOwn$1(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  function applyHeadersMut$1(targetHeaders, newHeaders) {
    for (const k in newHeaders) {
      if (!hasOwn$1(newHeaders, k))
        continue;
      const lowerKey = k.toLowerCase();
      if (!lowerKey)
        continue;
      const val = newHeaders[k];
      if (val === null) {
        delete targetHeaders[lowerKey];
      } else if (val !== void 0) {
        targetHeaders[lowerKey] = val;
      }
    }
  }
  function debug$1(action, ...args) {
    var _a3;
    if (typeof process !== "undefined" && ((_a3 = process == null ? void 0 : process.env) == null ? void 0 : _a3["DEBUG"]) === "true") {
      console.log(`Anthropic:DEBUG:${action}`, ...args);
    }
  }
  const uuid4$1 = () => {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  };
  const isRunningInBrowser$1 = () => {
    return (
      // @ts-ignore
      typeof window !== "undefined" && // @ts-ignore
      typeof window.document !== "undefined" && // @ts-ignore
      typeof navigator !== "undefined"
    );
  };
  const isHeadersProtocol$1 = (headers) => {
    return typeof (headers == null ? void 0 : headers.get) === "function";
  };
  const getHeader$1 = (headers, header) => {
    var _a3;
    const lowerCasedHeader = header.toLowerCase();
    if (isHeadersProtocol$1(headers)) {
      const intercapsHeader = ((_a3 = header[0]) == null ? void 0 : _a3.toUpperCase()) + header.substring(1).replace(/([^\w])(\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());
      for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {
        const value = headers.get(key);
        if (value) {
          return value;
        }
      }
    }
    for (const [key, value] of Object.entries(headers)) {
      if (key.toLowerCase() === lowerCasedHeader) {
        if (Array.isArray(value)) {
          if (value.length <= 1)
            return value[0];
          console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);
          return value[0];
        }
        return value;
      }
    }
    return void 0;
  };
  let Page$1 = class Page extends AbstractPage$1 {
    constructor(client2, response, body, options) {
      super(client2, response, body, options);
      this.data = body.data || [];
      this.has_more = body.has_more || false;
      this.first_id = body.first_id || null;
      this.last_id = body.last_id || null;
    }
    getPaginatedItems() {
      return this.data ?? [];
    }
    // @deprecated Please use `nextPageInfo()` instead
    nextPageParams() {
      const info = this.nextPageInfo();
      if (!info)
        return null;
      if ("params" in info)
        return info.params;
      const params = Object.fromEntries(info.url.searchParams);
      if (!Object.keys(params).length)
        return null;
      return params;
    }
    nextPageInfo() {
      var _a3;
      if ((_a3 = this.options.query) == null ? void 0 : _a3["before_id"]) {
        const firstId = this.first_id;
        if (!firstId) {
          return null;
        }
        return {
          params: {
            before_id: firstId
          }
        };
      }
      const cursor = this.last_id;
      if (!cursor) {
        return null;
      }
      return {
        params: {
          after_id: cursor
        }
      };
    }
  };
  let APIResource$1 = class APIResource {
    constructor(client2) {
      this._client = client2;
    }
  };
  class JSONLDecoder {
    constructor(iterator2, controller) {
      this.iterator = iterator2;
      this.controller = controller;
    }
    async *decoder() {
      const lineDecoder = new LineDecoder$1();
      for await (const chunk of this.iterator) {
        for (const line of lineDecoder.decode(chunk)) {
          yield JSON.parse(line);
        }
      }
      for (const line of lineDecoder.flush()) {
        yield JSON.parse(line);
      }
    }
    [Symbol.asyncIterator]() {
      return this.decoder();
    }
    static fromResponse(response, controller) {
      if (!response.body) {
        controller.abort();
        throw new AnthropicError(`Attempted to iterate over a response with no body`);
      }
      return new JSONLDecoder(readableStreamAsyncIterable(response.body), controller);
    }
  }
  let Batches$1 = class Batches extends APIResource$1 {
    /**
     * Send a batch of Message creation requests.
     *
     * The Message Batches API can be used to process multiple Messages API requests at
     * once. Once a Message Batch is created, it begins processing immediately. Batches
     * can take up to 24 hours to complete.
     */
    create(params, options) {
      const { betas, ...body } = params;
      return this._client.post("/v1/messages/batches?beta=true", {
        body,
        ...options,
        headers: {
          "anthropic-beta": [...betas ?? [], "message-batches-2024-09-24"].toString(),
          ...options == null ? void 0 : options.headers
        }
      });
    }
    retrieve(messageBatchId, params = {}, options) {
      if (isRequestOptions$1(params)) {
        return this.retrieve(messageBatchId, {}, params);
      }
      const { betas } = params;
      return this._client.get(`/v1/messages/batches/${messageBatchId}?beta=true`, {
        ...options,
        headers: {
          "anthropic-beta": [...betas ?? [], "message-batches-2024-09-24"].toString(),
          ...options == null ? void 0 : options.headers
        }
      });
    }
    list(params = {}, options) {
      if (isRequestOptions$1(params)) {
        return this.list({}, params);
      }
      const { betas, ...query } = params;
      return this._client.getAPIList("/v1/messages/batches?beta=true", BetaMessageBatchesPage, {
        query,
        ...options,
        headers: {
          "anthropic-beta": [...betas ?? [], "message-batches-2024-09-24"].toString(),
          ...options == null ? void 0 : options.headers
        }
      });
    }
    cancel(messageBatchId, params = {}, options) {
      if (isRequestOptions$1(params)) {
        return this.cancel(messageBatchId, {}, params);
      }
      const { betas } = params;
      return this._client.post(`/v1/messages/batches/${messageBatchId}/cancel?beta=true`, {
        ...options,
        headers: {
          "anthropic-beta": [...betas ?? [], "message-batches-2024-09-24"].toString(),
          ...options == null ? void 0 : options.headers
        }
      });
    }
    async results(messageBatchId, params = {}, options) {
      if (isRequestOptions$1(params)) {
        return this.results(messageBatchId, {}, params);
      }
      const batch = await this.retrieve(messageBatchId);
      if (!batch.results_url) {
        throw new AnthropicError(`No batch \`results_url\`; Has it finished processing? ${batch.processing_status} - ${batch.id}`);
      }
      const { betas } = params;
      return this._client.get(batch.results_url, {
        ...options,
        headers: {
          "anthropic-beta": [...betas ?? [], "message-batches-2024-09-24"].toString(),
          ...options == null ? void 0 : options.headers
        },
        __binaryResponse: true
      })._thenUnwrap((_, props) => JSONLDecoder.fromResponse(props.response, props.controller));
    }
  };
  class BetaMessageBatchesPage extends Page$1 {
  }
  Batches$1.BetaMessageBatchesPage = BetaMessageBatchesPage;
  let Messages$3 = class Messages extends APIResource$1 {
    constructor() {
      super(...arguments);
      this.batches = new Batches$1(this._client);
    }
    create(params, options) {
      const { betas, ...body } = params;
      return this._client.post("/v1/messages?beta=true", {
        body,
        timeout: this._client._options.timeout ?? 6e5,
        ...options,
        headers: {
          ...(betas == null ? void 0 : betas.toString()) != null ? { "anthropic-beta": betas == null ? void 0 : betas.toString() } : void 0,
          ...options == null ? void 0 : options.headers
        },
        stream: params.stream ?? false
      });
    }
    /**
     * Count the number of tokens in a Message.
     *
     * The Token Count API can be used to count the number of tokens in a Message,
     * including tools, images, and documents, without creating it.
     */
    countTokens(params, options) {
      const { betas, ...body } = params;
      return this._client.post("/v1/messages/count_tokens?beta=true", {
        body,
        ...options,
        headers: {
          "anthropic-beta": [...betas ?? [], "token-counting-2024-11-01"].toString(),
          ...options == null ? void 0 : options.headers
        }
      });
    }
  };
  Messages$3.Batches = Batches$1;
  Messages$3.BetaMessageBatchesPage = BetaMessageBatchesPage;
  const tokenize = (input) => {
    let current = 0;
    let tokens = [];
    while (current < input.length) {
      let char = input[current];
      if (char === "\\") {
        current++;
        continue;
      }
      if (char === "{") {
        tokens.push({
          type: "brace",
          value: "{"
        });
        current++;
        continue;
      }
      if (char === "}") {
        tokens.push({
          type: "brace",
          value: "}"
        });
        current++;
        continue;
      }
      if (char === "[") {
        tokens.push({
          type: "paren",
          value: "["
        });
        current++;
        continue;
      }
      if (char === "]") {
        tokens.push({
          type: "paren",
          value: "]"
        });
        current++;
        continue;
      }
      if (char === ":") {
        tokens.push({
          type: "separator",
          value: ":"
        });
        current++;
        continue;
      }
      if (char === ",") {
        tokens.push({
          type: "delimiter",
          value: ","
        });
        current++;
        continue;
      }
      if (char === '"') {
        let value = "";
        let danglingQuote = false;
        char = input[++current];
        while (char !== '"') {
          if (current === input.length) {
            danglingQuote = true;
            break;
          }
          if (char === "\\") {
            current++;
            if (current === input.length) {
              danglingQuote = true;
              break;
            }
            value += char + input[current];
            char = input[++current];
          } else {
            value += char;
            char = input[++current];
          }
        }
        char = input[++current];
        if (!danglingQuote) {
          tokens.push({
            type: "string",
            value
          });
        }
        continue;
      }
      let WHITESPACE = /\s/;
      if (char && WHITESPACE.test(char)) {
        current++;
        continue;
      }
      let NUMBERS = /[0-9]/;
      if (char && NUMBERS.test(char) || char === "-" || char === ".") {
        let value = "";
        if (char === "-") {
          value += char;
          char = input[++current];
        }
        while (char && NUMBERS.test(char) || char === ".") {
          value += char;
          char = input[++current];
        }
        tokens.push({
          type: "number",
          value
        });
        continue;
      }
      let LETTERS = /[a-z]/i;
      if (char && LETTERS.test(char)) {
        let value = "";
        while (char && LETTERS.test(char)) {
          if (current === input.length) {
            break;
          }
          value += char;
          char = input[++current];
        }
        if (value == "true" || value == "false" || value === "null") {
          tokens.push({
            type: "name",
            value
          });
        } else {
          current++;
          continue;
        }
        continue;
      }
      current++;
    }
    return tokens;
  }, strip = (tokens) => {
    if (tokens.length === 0) {
      return tokens;
    }
    let lastToken = tokens[tokens.length - 1];
    switch (lastToken.type) {
      case "separator":
        tokens = tokens.slice(0, tokens.length - 1);
        return strip(tokens);
      case "number":
        let lastCharacterOfLastToken = lastToken.value[lastToken.value.length - 1];
        if (lastCharacterOfLastToken === "." || lastCharacterOfLastToken === "-") {
          tokens = tokens.slice(0, tokens.length - 1);
          return strip(tokens);
        }
      case "string":
        let tokenBeforeTheLastToken = tokens[tokens.length - 2];
        if ((tokenBeforeTheLastToken == null ? void 0 : tokenBeforeTheLastToken.type) === "delimiter") {
          tokens = tokens.slice(0, tokens.length - 1);
          return strip(tokens);
        } else if ((tokenBeforeTheLastToken == null ? void 0 : tokenBeforeTheLastToken.type) === "brace" && tokenBeforeTheLastToken.value === "{") {
          tokens = tokens.slice(0, tokens.length - 1);
          return strip(tokens);
        }
        break;
      case "delimiter":
        tokens = tokens.slice(0, tokens.length - 1);
        return strip(tokens);
    }
    return tokens;
  }, unstrip = (tokens) => {
    let tail = [];
    tokens.map((token) => {
      if (token.type === "brace") {
        if (token.value === "{") {
          tail.push("}");
        } else {
          tail.splice(tail.lastIndexOf("}"), 1);
        }
      }
      if (token.type === "paren") {
        if (token.value === "[") {
          tail.push("]");
        } else {
          tail.splice(tail.lastIndexOf("]"), 1);
        }
      }
    });
    if (tail.length > 0) {
      tail.reverse().map((item) => {
        if (item === "}") {
          tokens.push({
            type: "brace",
            value: "}"
          });
        } else if (item === "]") {
          tokens.push({
            type: "paren",
            value: "]"
          });
        }
      });
    }
    return tokens;
  }, generate = (tokens) => {
    let output = "";
    tokens.map((token) => {
      switch (token.type) {
        case "string":
          output += '"' + token.value + '"';
          break;
        default:
          output += token.value;
          break;
      }
    });
    return output;
  }, partialParse$1 = (input) => JSON.parse(generate(unstrip(strip(tokenize(input)))));
  var __classPrivateFieldSet$5 = function(receiver, state, value, kind2, f) {
    if (kind2 === "m") throw new TypeError("Private method is not writable");
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet$6 = function(receiver, state, kind2, f) {
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _PromptCachingBetaMessageStream_instances, _PromptCachingBetaMessageStream_currentMessageSnapshot, _PromptCachingBetaMessageStream_connectedPromise, _PromptCachingBetaMessageStream_resolveConnectedPromise, _PromptCachingBetaMessageStream_rejectConnectedPromise, _PromptCachingBetaMessageStream_endPromise, _PromptCachingBetaMessageStream_resolveEndPromise, _PromptCachingBetaMessageStream_rejectEndPromise, _PromptCachingBetaMessageStream_listeners, _PromptCachingBetaMessageStream_ended, _PromptCachingBetaMessageStream_errored, _PromptCachingBetaMessageStream_aborted, _PromptCachingBetaMessageStream_catchingPromiseCreated, _PromptCachingBetaMessageStream_getFinalMessage, _PromptCachingBetaMessageStream_getFinalText, _PromptCachingBetaMessageStream_handleError, _PromptCachingBetaMessageStream_beginRequest, _PromptCachingBetaMessageStream_addStreamEvent, _PromptCachingBetaMessageStream_endRequest, _PromptCachingBetaMessageStream_accumulateMessage;
  const JSON_BUF_PROPERTY$1 = "__json_buf";
  class PromptCachingBetaMessageStream {
    constructor() {
      _PromptCachingBetaMessageStream_instances.add(this);
      this.messages = [];
      this.receivedMessages = [];
      _PromptCachingBetaMessageStream_currentMessageSnapshot.set(this, void 0);
      this.controller = new AbortController();
      _PromptCachingBetaMessageStream_connectedPromise.set(this, void 0);
      _PromptCachingBetaMessageStream_resolveConnectedPromise.set(this, () => {
      });
      _PromptCachingBetaMessageStream_rejectConnectedPromise.set(this, () => {
      });
      _PromptCachingBetaMessageStream_endPromise.set(this, void 0);
      _PromptCachingBetaMessageStream_resolveEndPromise.set(this, () => {
      });
      _PromptCachingBetaMessageStream_rejectEndPromise.set(this, () => {
      });
      _PromptCachingBetaMessageStream_listeners.set(this, {});
      _PromptCachingBetaMessageStream_ended.set(this, false);
      _PromptCachingBetaMessageStream_errored.set(this, false);
      _PromptCachingBetaMessageStream_aborted.set(this, false);
      _PromptCachingBetaMessageStream_catchingPromiseCreated.set(this, false);
      _PromptCachingBetaMessageStream_handleError.set(this, (error) => {
        __classPrivateFieldSet$5(this, _PromptCachingBetaMessageStream_errored, true, "f");
        if (error instanceof Error && error.name === "AbortError") {
          error = new APIUserAbortError$1();
        }
        if (error instanceof APIUserAbortError$1) {
          __classPrivateFieldSet$5(this, _PromptCachingBetaMessageStream_aborted, true, "f");
          return this._emit("abort", error);
        }
        if (error instanceof AnthropicError) {
          return this._emit("error", error);
        }
        if (error instanceof Error) {
          const anthropicError = new AnthropicError(error.message);
          anthropicError.cause = error;
          return this._emit("error", anthropicError);
        }
        return this._emit("error", new AnthropicError(String(error)));
      });
      __classPrivateFieldSet$5(this, _PromptCachingBetaMessageStream_connectedPromise, new Promise((resolve, reject) => {
        __classPrivateFieldSet$5(this, _PromptCachingBetaMessageStream_resolveConnectedPromise, resolve, "f");
        __classPrivateFieldSet$5(this, _PromptCachingBetaMessageStream_rejectConnectedPromise, reject, "f");
      }), "f");
      __classPrivateFieldSet$5(this, _PromptCachingBetaMessageStream_endPromise, new Promise((resolve, reject) => {
        __classPrivateFieldSet$5(this, _PromptCachingBetaMessageStream_resolveEndPromise, resolve, "f");
        __classPrivateFieldSet$5(this, _PromptCachingBetaMessageStream_rejectEndPromise, reject, "f");
      }), "f");
      __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_connectedPromise, "f").catch(() => {
      });
      __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_endPromise, "f").catch(() => {
      });
    }
    /**
     * Intended for use on the frontend, consuming a stream produced with
     * `.toReadableStream()` on the backend.
     *
     * Note that messages sent to the model do not appear in `.on('message')`
     * in this context.
     */
    static fromReadableStream(stream) {
      const runner = new PromptCachingBetaMessageStream();
      runner._run(() => runner._fromReadableStream(stream));
      return runner;
    }
    static createMessage(messages, params, options) {
      const runner = new PromptCachingBetaMessageStream();
      for (const message of params.messages) {
        runner._addPromptCachingBetaMessageParam(message);
      }
      runner._run(() => runner._createPromptCachingBetaMessage(messages, { ...params, stream: true }, { ...options, headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" } }));
      return runner;
    }
    _run(executor) {
      executor().then(() => {
        this._emitFinal();
        this._emit("end");
      }, __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_handleError, "f"));
    }
    _addPromptCachingBetaMessageParam(message) {
      this.messages.push(message);
    }
    _addPromptCachingBetaMessage(message, emit = true) {
      this.receivedMessages.push(message);
      if (emit) {
        this._emit("message", message);
      }
    }
    async _createPromptCachingBetaMessage(messages, params, options) {
      var _a3;
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_instances, "m", _PromptCachingBetaMessageStream_beginRequest).call(this);
      const stream = await messages.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
      this._connected();
      for await (const event of stream) {
        __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_instances, "m", _PromptCachingBetaMessageStream_addStreamEvent).call(this, event);
      }
      if ((_a3 = stream.controller.signal) == null ? void 0 : _a3.aborted) {
        throw new APIUserAbortError$1();
      }
      __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_instances, "m", _PromptCachingBetaMessageStream_endRequest).call(this);
    }
    _connected() {
      if (this.ended)
        return;
      __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_resolveConnectedPromise, "f").call(this);
      this._emit("connect");
    }
    get ended() {
      return __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_ended, "f");
    }
    get errored() {
      return __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_errored, "f");
    }
    get aborted() {
      return __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_aborted, "f");
    }
    abort() {
      this.controller.abort();
    }
    /**
     * Adds the listener function to the end of the listeners array for the event.
     * No checks are made to see if the listener has already been added. Multiple calls passing
     * the same combination of event and listener will result in the listener being added, and
     * called, multiple times.
     * @returns this PromptCachingBetaMessageStream, so that calls can be chained
     */
    on(event, listener) {
      const listeners = __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_listeners, "f")[event] || (__classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_listeners, "f")[event] = []);
      listeners.push({ listener });
      return this;
    }
    /**
     * Removes the specified listener from the listener array for the event.
     * off() will remove, at most, one instance of a listener from the listener array. If any single
     * listener has been added multiple times to the listener array for the specified event, then
     * off() must be called multiple times to remove each instance.
     * @returns this PromptCachingBetaMessageStream, so that calls can be chained
     */
    off(event, listener) {
      const listeners = __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_listeners, "f")[event];
      if (!listeners)
        return this;
      const index = listeners.findIndex((l) => l.listener === listener);
      if (index >= 0)
        listeners.splice(index, 1);
      return this;
    }
    /**
     * Adds a one-time listener function for the event. The next time the event is triggered,
     * this listener is removed and then invoked.
     * @returns this PromptCachingBetaMessageStream, so that calls can be chained
     */
    once(event, listener) {
      const listeners = __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_listeners, "f")[event] || (__classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_listeners, "f")[event] = []);
      listeners.push({ listener, once: true });
      return this;
    }
    /**
     * This is similar to `.once()`, but returns a Promise that resolves the next time
     * the event is triggered, instead of calling a listener callback.
     * @returns a Promise that resolves the next time given event is triggered,
     * or rejects if an error is emitted.  (If you request the 'error' event,
     * returns a promise that resolves with the error).
     *
     * Example:
     *
     *   const message = await stream.emitted('message') // rejects if the stream errors
     */
    emitted(event) {
      return new Promise((resolve, reject) => {
        __classPrivateFieldSet$5(this, _PromptCachingBetaMessageStream_catchingPromiseCreated, true, "f");
        if (event !== "error")
          this.once("error", reject);
        this.once(event, resolve);
      });
    }
    async done() {
      __classPrivateFieldSet$5(this, _PromptCachingBetaMessageStream_catchingPromiseCreated, true, "f");
      await __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_endPromise, "f");
    }
    get currentMessage() {
      return __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_currentMessageSnapshot, "f");
    }
    /**
     * @returns a promise that resolves with the the final assistant PromptCachingBetaMessage response,
     * or rejects if an error occurred or the stream ended prematurely without producing a PromptCachingBetaMessage.
     */
    async finalMessage() {
      await this.done();
      return __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_instances, "m", _PromptCachingBetaMessageStream_getFinalMessage).call(this);
    }
    /**
     * @returns a promise that resolves with the the final assistant PromptCachingBetaMessage's text response, concatenated
     * together if there are more than one text blocks.
     * Rejects if an error occurred or the stream ended prematurely without producing a PromptCachingBetaMessage.
     */
    async finalText() {
      await this.done();
      return __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_instances, "m", _PromptCachingBetaMessageStream_getFinalText).call(this);
    }
    _emit(event, ...args) {
      if (__classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_ended, "f"))
        return;
      if (event === "end") {
        __classPrivateFieldSet$5(this, _PromptCachingBetaMessageStream_ended, true, "f");
        __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_resolveEndPromise, "f").call(this);
      }
      const listeners = __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_listeners, "f")[event];
      if (listeners) {
        __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
        listeners.forEach(({ listener }) => listener(...args));
      }
      if (event === "abort") {
        const error = args[0];
        if (!__classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
          Promise.reject(error);
        }
        __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_rejectConnectedPromise, "f").call(this, error);
        __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_rejectEndPromise, "f").call(this, error);
        this._emit("end");
        return;
      }
      if (event === "error") {
        const error = args[0];
        if (!__classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
          Promise.reject(error);
        }
        __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_rejectConnectedPromise, "f").call(this, error);
        __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_rejectEndPromise, "f").call(this, error);
        this._emit("end");
      }
    }
    _emitFinal() {
      const finalPromptCachingBetaMessage = this.receivedMessages.at(-1);
      if (finalPromptCachingBetaMessage) {
        this._emit("finalPromptCachingBetaMessage", __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_instances, "m", _PromptCachingBetaMessageStream_getFinalMessage).call(this));
      }
    }
    async _fromReadableStream(readableStream, options) {
      var _a3;
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_instances, "m", _PromptCachingBetaMessageStream_beginRequest).call(this);
      this._connected();
      const stream = Stream$1.fromReadableStream(readableStream, this.controller);
      for await (const event of stream) {
        __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_instances, "m", _PromptCachingBetaMessageStream_addStreamEvent).call(this, event);
      }
      if ((_a3 = stream.controller.signal) == null ? void 0 : _a3.aborted) {
        throw new APIUserAbortError$1();
      }
      __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_instances, "m", _PromptCachingBetaMessageStream_endRequest).call(this);
    }
    [(_PromptCachingBetaMessageStream_currentMessageSnapshot = /* @__PURE__ */ new WeakMap(), _PromptCachingBetaMessageStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _PromptCachingBetaMessageStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _PromptCachingBetaMessageStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _PromptCachingBetaMessageStream_endPromise = /* @__PURE__ */ new WeakMap(), _PromptCachingBetaMessageStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _PromptCachingBetaMessageStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _PromptCachingBetaMessageStream_listeners = /* @__PURE__ */ new WeakMap(), _PromptCachingBetaMessageStream_ended = /* @__PURE__ */ new WeakMap(), _PromptCachingBetaMessageStream_errored = /* @__PURE__ */ new WeakMap(), _PromptCachingBetaMessageStream_aborted = /* @__PURE__ */ new WeakMap(), _PromptCachingBetaMessageStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _PromptCachingBetaMessageStream_handleError = /* @__PURE__ */ new WeakMap(), _PromptCachingBetaMessageStream_instances = /* @__PURE__ */ new WeakSet(), _PromptCachingBetaMessageStream_getFinalMessage = function _PromptCachingBetaMessageStream_getFinalMessage2() {
      if (this.receivedMessages.length === 0) {
        throw new AnthropicError("stream ended without producing a PromptCachingBetaMessage with role=assistant");
      }
      return this.receivedMessages.at(-1);
    }, _PromptCachingBetaMessageStream_getFinalText = function _PromptCachingBetaMessageStream_getFinalText2() {
      if (this.receivedMessages.length === 0) {
        throw new AnthropicError("stream ended without producing a PromptCachingBetaMessage with role=assistant");
      }
      const textBlocks = this.receivedMessages.at(-1).content.filter((block) => block.type === "text").map((block) => block.text);
      if (textBlocks.length === 0) {
        throw new AnthropicError("stream ended without producing a content block with type=text");
      }
      return textBlocks.join(" ");
    }, _PromptCachingBetaMessageStream_beginRequest = function _PromptCachingBetaMessageStream_beginRequest2() {
      if (this.ended)
        return;
      __classPrivateFieldSet$5(this, _PromptCachingBetaMessageStream_currentMessageSnapshot, void 0, "f");
    }, _PromptCachingBetaMessageStream_addStreamEvent = function _PromptCachingBetaMessageStream_addStreamEvent2(event) {
      if (this.ended)
        return;
      const messageSnapshot = __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_instances, "m", _PromptCachingBetaMessageStream_accumulateMessage).call(this, event);
      this._emit("streamEvent", event, messageSnapshot);
      switch (event.type) {
        case "content_block_delta": {
          const content = messageSnapshot.content.at(-1);
          if (event.delta.type === "text_delta" && content.type === "text") {
            this._emit("text", event.delta.text, content.text || "");
          } else if (event.delta.type === "input_json_delta" && content.type === "tool_use") {
            if (content.input) {
              this._emit("inputJson", event.delta.partial_json, content.input);
            }
          }
          break;
        }
        case "message_stop": {
          this._addPromptCachingBetaMessageParam(messageSnapshot);
          this._addPromptCachingBetaMessage(messageSnapshot, true);
          break;
        }
        case "content_block_stop": {
          this._emit("contentBlock", messageSnapshot.content.at(-1));
          break;
        }
        case "message_start": {
          __classPrivateFieldSet$5(this, _PromptCachingBetaMessageStream_currentMessageSnapshot, messageSnapshot, "f");
          break;
        }
      }
    }, _PromptCachingBetaMessageStream_endRequest = function _PromptCachingBetaMessageStream_endRequest2() {
      if (this.ended) {
        throw new AnthropicError(`stream has ended, this shouldn't happen`);
      }
      const snapshot = __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_currentMessageSnapshot, "f");
      if (!snapshot) {
        throw new AnthropicError(`request ended without sending any chunks`);
      }
      __classPrivateFieldSet$5(this, _PromptCachingBetaMessageStream_currentMessageSnapshot, void 0, "f");
      return snapshot;
    }, _PromptCachingBetaMessageStream_accumulateMessage = function _PromptCachingBetaMessageStream_accumulateMessage2(event) {
      let snapshot = __classPrivateFieldGet$6(this, _PromptCachingBetaMessageStream_currentMessageSnapshot, "f");
      if (event.type === "message_start") {
        if (snapshot) {
          throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving "message_stop"`);
        }
        return event.message;
      }
      if (!snapshot) {
        throw new AnthropicError(`Unexpected event order, got ${event.type} before "message_start"`);
      }
      switch (event.type) {
        case "message_stop":
          return snapshot;
        case "message_delta":
          snapshot.stop_reason = event.delta.stop_reason;
          snapshot.stop_sequence = event.delta.stop_sequence;
          snapshot.usage.output_tokens = event.usage.output_tokens;
          return snapshot;
        case "content_block_start":
          snapshot.content.push(event.content_block);
          return snapshot;
        case "content_block_delta": {
          const snapshotContent = snapshot.content.at(event.index);
          if ((snapshotContent == null ? void 0 : snapshotContent.type) === "text" && event.delta.type === "text_delta") {
            snapshotContent.text += event.delta.text;
          } else if ((snapshotContent == null ? void 0 : snapshotContent.type) === "tool_use" && event.delta.type === "input_json_delta") {
            let jsonBuf = snapshotContent[JSON_BUF_PROPERTY$1] || "";
            jsonBuf += event.delta.partial_json;
            Object.defineProperty(snapshotContent, JSON_BUF_PROPERTY$1, {
              value: jsonBuf,
              enumerable: false,
              writable: true
            });
            if (jsonBuf) {
              snapshotContent.input = partialParse$1(jsonBuf);
            }
          }
          return snapshot;
        }
        case "content_block_stop":
          return snapshot;
      }
    }, Symbol.asyncIterator)]() {
      const pushQueue = [];
      const readQueue = [];
      let done = false;
      this.on("streamEvent", (event) => {
        const reader = readQueue.shift();
        if (reader) {
          reader.resolve(event);
        } else {
          pushQueue.push(event);
        }
      });
      this.on("end", () => {
        done = true;
        for (const reader of readQueue) {
          reader.resolve(void 0);
        }
        readQueue.length = 0;
      });
      this.on("abort", (err) => {
        done = true;
        for (const reader of readQueue) {
          reader.reject(err);
        }
        readQueue.length = 0;
      });
      this.on("error", (err) => {
        done = true;
        for (const reader of readQueue) {
          reader.reject(err);
        }
        readQueue.length = 0;
      });
      return {
        next: async () => {
          if (!pushQueue.length) {
            if (done) {
              return { value: void 0, done: true };
            }
            return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
          }
          const chunk = pushQueue.shift();
          return { value: chunk, done: false };
        },
        return: async () => {
          this.abort();
          return { value: void 0, done: true };
        }
      };
    }
    toReadableStream() {
      const stream = new Stream$1(this[Symbol.asyncIterator].bind(this), this.controller);
      return stream.toReadableStream();
    }
  }
  let Messages$2 = class Messages extends APIResource$1 {
    create(params, options) {
      const { betas, ...body } = params;
      return this._client.post("/v1/messages?beta=prompt_caching", {
        body,
        timeout: this._client._options.timeout ?? 6e5,
        ...options,
        headers: {
          "anthropic-beta": [...betas ?? [], "prompt-caching-2024-07-31"].toString(),
          ...options == null ? void 0 : options.headers
        },
        stream: params.stream ?? false
      });
    }
    /**
     * Create a Message stream
     */
    stream(body, options) {
      return PromptCachingBetaMessageStream.createMessage(this, body, options);
    }
  };
  class PromptCaching extends APIResource$1 {
    constructor() {
      super(...arguments);
      this.messages = new Messages$2(this._client);
    }
  }
  PromptCaching.Messages = Messages$2;
  let Beta$1 = class Beta extends APIResource$1 {
    constructor() {
      super(...arguments);
      this.messages = new Messages$3(this._client);
      this.promptCaching = new PromptCaching(this._client);
    }
  };
  Beta$1.Messages = Messages$3;
  Beta$1.PromptCaching = PromptCaching;
  let Completions$3 = class Completions extends APIResource$1 {
    create(body, options) {
      return this._client.post("/v1/complete", {
        body,
        timeout: this._client._options.timeout ?? 6e5,
        ...options,
        stream: body.stream ?? false
      });
    }
  };
  var __classPrivateFieldSet$4 = function(receiver, state, value, kind2, f) {
    if (kind2 === "m") throw new TypeError("Private method is not writable");
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet$5 = function(receiver, state, kind2, f) {
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _MessageStream_instances, _MessageStream_currentMessageSnapshot, _MessageStream_connectedPromise, _MessageStream_resolveConnectedPromise, _MessageStream_rejectConnectedPromise, _MessageStream_endPromise, _MessageStream_resolveEndPromise, _MessageStream_rejectEndPromise, _MessageStream_listeners, _MessageStream_ended, _MessageStream_errored, _MessageStream_aborted, _MessageStream_catchingPromiseCreated, _MessageStream_getFinalMessage, _MessageStream_getFinalText, _MessageStream_handleError, _MessageStream_beginRequest, _MessageStream_addStreamEvent, _MessageStream_endRequest, _MessageStream_accumulateMessage;
  const JSON_BUF_PROPERTY = "__json_buf";
  class MessageStream {
    constructor() {
      _MessageStream_instances.add(this);
      this.messages = [];
      this.receivedMessages = [];
      _MessageStream_currentMessageSnapshot.set(this, void 0);
      this.controller = new AbortController();
      _MessageStream_connectedPromise.set(this, void 0);
      _MessageStream_resolveConnectedPromise.set(this, () => {
      });
      _MessageStream_rejectConnectedPromise.set(this, () => {
      });
      _MessageStream_endPromise.set(this, void 0);
      _MessageStream_resolveEndPromise.set(this, () => {
      });
      _MessageStream_rejectEndPromise.set(this, () => {
      });
      _MessageStream_listeners.set(this, {});
      _MessageStream_ended.set(this, false);
      _MessageStream_errored.set(this, false);
      _MessageStream_aborted.set(this, false);
      _MessageStream_catchingPromiseCreated.set(this, false);
      _MessageStream_handleError.set(this, (error) => {
        __classPrivateFieldSet$4(this, _MessageStream_errored, true, "f");
        if (error instanceof Error && error.name === "AbortError") {
          error = new APIUserAbortError$1();
        }
        if (error instanceof APIUserAbortError$1) {
          __classPrivateFieldSet$4(this, _MessageStream_aborted, true, "f");
          return this._emit("abort", error);
        }
        if (error instanceof AnthropicError) {
          return this._emit("error", error);
        }
        if (error instanceof Error) {
          const anthropicError = new AnthropicError(error.message);
          anthropicError.cause = error;
          return this._emit("error", anthropicError);
        }
        return this._emit("error", new AnthropicError(String(error)));
      });
      __classPrivateFieldSet$4(this, _MessageStream_connectedPromise, new Promise((resolve, reject) => {
        __classPrivateFieldSet$4(this, _MessageStream_resolveConnectedPromise, resolve, "f");
        __classPrivateFieldSet$4(this, _MessageStream_rejectConnectedPromise, reject, "f");
      }), "f");
      __classPrivateFieldSet$4(this, _MessageStream_endPromise, new Promise((resolve, reject) => {
        __classPrivateFieldSet$4(this, _MessageStream_resolveEndPromise, resolve, "f");
        __classPrivateFieldSet$4(this, _MessageStream_rejectEndPromise, reject, "f");
      }), "f");
      __classPrivateFieldGet$5(this, _MessageStream_connectedPromise, "f").catch(() => {
      });
      __classPrivateFieldGet$5(this, _MessageStream_endPromise, "f").catch(() => {
      });
    }
    /**
     * Intended for use on the frontend, consuming a stream produced with
     * `.toReadableStream()` on the backend.
     *
     * Note that messages sent to the model do not appear in `.on('message')`
     * in this context.
     */
    static fromReadableStream(stream) {
      const runner = new MessageStream();
      runner._run(() => runner._fromReadableStream(stream));
      return runner;
    }
    static createMessage(messages, params, options) {
      const runner = new MessageStream();
      for (const message of params.messages) {
        runner._addMessageParam(message);
      }
      runner._run(() => runner._createMessage(messages, { ...params, stream: true }, { ...options, headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" } }));
      return runner;
    }
    _run(executor) {
      executor().then(() => {
        this._emitFinal();
        this._emit("end");
      }, __classPrivateFieldGet$5(this, _MessageStream_handleError, "f"));
    }
    _addMessageParam(message) {
      this.messages.push(message);
    }
    _addMessage(message, emit = true) {
      this.receivedMessages.push(message);
      if (emit) {
        this._emit("message", message);
      }
    }
    async _createMessage(messages, params, options) {
      var _a3;
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      __classPrivateFieldGet$5(this, _MessageStream_instances, "m", _MessageStream_beginRequest).call(this);
      const stream = await messages.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
      this._connected();
      for await (const event of stream) {
        __classPrivateFieldGet$5(this, _MessageStream_instances, "m", _MessageStream_addStreamEvent).call(this, event);
      }
      if ((_a3 = stream.controller.signal) == null ? void 0 : _a3.aborted) {
        throw new APIUserAbortError$1();
      }
      __classPrivateFieldGet$5(this, _MessageStream_instances, "m", _MessageStream_endRequest).call(this);
    }
    _connected() {
      if (this.ended)
        return;
      __classPrivateFieldGet$5(this, _MessageStream_resolveConnectedPromise, "f").call(this);
      this._emit("connect");
    }
    get ended() {
      return __classPrivateFieldGet$5(this, _MessageStream_ended, "f");
    }
    get errored() {
      return __classPrivateFieldGet$5(this, _MessageStream_errored, "f");
    }
    get aborted() {
      return __classPrivateFieldGet$5(this, _MessageStream_aborted, "f");
    }
    abort() {
      this.controller.abort();
    }
    /**
     * Adds the listener function to the end of the listeners array for the event.
     * No checks are made to see if the listener has already been added. Multiple calls passing
     * the same combination of event and listener will result in the listener being added, and
     * called, multiple times.
     * @returns this MessageStream, so that calls can be chained
     */
    on(event, listener) {
      const listeners = __classPrivateFieldGet$5(this, _MessageStream_listeners, "f")[event] || (__classPrivateFieldGet$5(this, _MessageStream_listeners, "f")[event] = []);
      listeners.push({ listener });
      return this;
    }
    /**
     * Removes the specified listener from the listener array for the event.
     * off() will remove, at most, one instance of a listener from the listener array. If any single
     * listener has been added multiple times to the listener array for the specified event, then
     * off() must be called multiple times to remove each instance.
     * @returns this MessageStream, so that calls can be chained
     */
    off(event, listener) {
      const listeners = __classPrivateFieldGet$5(this, _MessageStream_listeners, "f")[event];
      if (!listeners)
        return this;
      const index = listeners.findIndex((l) => l.listener === listener);
      if (index >= 0)
        listeners.splice(index, 1);
      return this;
    }
    /**
     * Adds a one-time listener function for the event. The next time the event is triggered,
     * this listener is removed and then invoked.
     * @returns this MessageStream, so that calls can be chained
     */
    once(event, listener) {
      const listeners = __classPrivateFieldGet$5(this, _MessageStream_listeners, "f")[event] || (__classPrivateFieldGet$5(this, _MessageStream_listeners, "f")[event] = []);
      listeners.push({ listener, once: true });
      return this;
    }
    /**
     * This is similar to `.once()`, but returns a Promise that resolves the next time
     * the event is triggered, instead of calling a listener callback.
     * @returns a Promise that resolves the next time given event is triggered,
     * or rejects if an error is emitted.  (If you request the 'error' event,
     * returns a promise that resolves with the error).
     *
     * Example:
     *
     *   const message = await stream.emitted('message') // rejects if the stream errors
     */
    emitted(event) {
      return new Promise((resolve, reject) => {
        __classPrivateFieldSet$4(this, _MessageStream_catchingPromiseCreated, true, "f");
        if (event !== "error")
          this.once("error", reject);
        this.once(event, resolve);
      });
    }
    async done() {
      __classPrivateFieldSet$4(this, _MessageStream_catchingPromiseCreated, true, "f");
      await __classPrivateFieldGet$5(this, _MessageStream_endPromise, "f");
    }
    get currentMessage() {
      return __classPrivateFieldGet$5(this, _MessageStream_currentMessageSnapshot, "f");
    }
    /**
     * @returns a promise that resolves with the the final assistant Message response,
     * or rejects if an error occurred or the stream ended prematurely without producing a Message.
     */
    async finalMessage() {
      await this.done();
      return __classPrivateFieldGet$5(this, _MessageStream_instances, "m", _MessageStream_getFinalMessage).call(this);
    }
    /**
     * @returns a promise that resolves with the the final assistant Message's text response, concatenated
     * together if there are more than one text blocks.
     * Rejects if an error occurred or the stream ended prematurely without producing a Message.
     */
    async finalText() {
      await this.done();
      return __classPrivateFieldGet$5(this, _MessageStream_instances, "m", _MessageStream_getFinalText).call(this);
    }
    _emit(event, ...args) {
      if (__classPrivateFieldGet$5(this, _MessageStream_ended, "f"))
        return;
      if (event === "end") {
        __classPrivateFieldSet$4(this, _MessageStream_ended, true, "f");
        __classPrivateFieldGet$5(this, _MessageStream_resolveEndPromise, "f").call(this);
      }
      const listeners = __classPrivateFieldGet$5(this, _MessageStream_listeners, "f")[event];
      if (listeners) {
        __classPrivateFieldGet$5(this, _MessageStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
        listeners.forEach(({ listener }) => listener(...args));
      }
      if (event === "abort") {
        const error = args[0];
        if (!__classPrivateFieldGet$5(this, _MessageStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
          Promise.reject(error);
        }
        __classPrivateFieldGet$5(this, _MessageStream_rejectConnectedPromise, "f").call(this, error);
        __classPrivateFieldGet$5(this, _MessageStream_rejectEndPromise, "f").call(this, error);
        this._emit("end");
        return;
      }
      if (event === "error") {
        const error = args[0];
        if (!__classPrivateFieldGet$5(this, _MessageStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
          Promise.reject(error);
        }
        __classPrivateFieldGet$5(this, _MessageStream_rejectConnectedPromise, "f").call(this, error);
        __classPrivateFieldGet$5(this, _MessageStream_rejectEndPromise, "f").call(this, error);
        this._emit("end");
      }
    }
    _emitFinal() {
      const finalMessage = this.receivedMessages.at(-1);
      if (finalMessage) {
        this._emit("finalMessage", __classPrivateFieldGet$5(this, _MessageStream_instances, "m", _MessageStream_getFinalMessage).call(this));
      }
    }
    async _fromReadableStream(readableStream, options) {
      var _a3;
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      __classPrivateFieldGet$5(this, _MessageStream_instances, "m", _MessageStream_beginRequest).call(this);
      this._connected();
      const stream = Stream$1.fromReadableStream(readableStream, this.controller);
      for await (const event of stream) {
        __classPrivateFieldGet$5(this, _MessageStream_instances, "m", _MessageStream_addStreamEvent).call(this, event);
      }
      if ((_a3 = stream.controller.signal) == null ? void 0 : _a3.aborted) {
        throw new APIUserAbortError$1();
      }
      __classPrivateFieldGet$5(this, _MessageStream_instances, "m", _MessageStream_endRequest).call(this);
    }
    [(_MessageStream_currentMessageSnapshot = /* @__PURE__ */ new WeakMap(), _MessageStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_endPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_listeners = /* @__PURE__ */ new WeakMap(), _MessageStream_ended = /* @__PURE__ */ new WeakMap(), _MessageStream_errored = /* @__PURE__ */ new WeakMap(), _MessageStream_aborted = /* @__PURE__ */ new WeakMap(), _MessageStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _MessageStream_handleError = /* @__PURE__ */ new WeakMap(), _MessageStream_instances = /* @__PURE__ */ new WeakSet(), _MessageStream_getFinalMessage = function _MessageStream_getFinalMessage2() {
      if (this.receivedMessages.length === 0) {
        throw new AnthropicError("stream ended without producing a Message with role=assistant");
      }
      return this.receivedMessages.at(-1);
    }, _MessageStream_getFinalText = function _MessageStream_getFinalText2() {
      if (this.receivedMessages.length === 0) {
        throw new AnthropicError("stream ended without producing a Message with role=assistant");
      }
      const textBlocks = this.receivedMessages.at(-1).content.filter((block) => block.type === "text").map((block) => block.text);
      if (textBlocks.length === 0) {
        throw new AnthropicError("stream ended without producing a content block with type=text");
      }
      return textBlocks.join(" ");
    }, _MessageStream_beginRequest = function _MessageStream_beginRequest2() {
      if (this.ended)
        return;
      __classPrivateFieldSet$4(this, _MessageStream_currentMessageSnapshot, void 0, "f");
    }, _MessageStream_addStreamEvent = function _MessageStream_addStreamEvent2(event) {
      if (this.ended)
        return;
      const messageSnapshot = __classPrivateFieldGet$5(this, _MessageStream_instances, "m", _MessageStream_accumulateMessage).call(this, event);
      this._emit("streamEvent", event, messageSnapshot);
      switch (event.type) {
        case "content_block_delta": {
          const content = messageSnapshot.content.at(-1);
          if (event.delta.type === "text_delta" && content.type === "text") {
            this._emit("text", event.delta.text, content.text || "");
          } else if (event.delta.type === "input_json_delta" && content.type === "tool_use") {
            if (content.input) {
              this._emit("inputJson", event.delta.partial_json, content.input);
            }
          }
          break;
        }
        case "message_stop": {
          this._addMessageParam(messageSnapshot);
          this._addMessage(messageSnapshot, true);
          break;
        }
        case "content_block_stop": {
          this._emit("contentBlock", messageSnapshot.content.at(-1));
          break;
        }
        case "message_start": {
          __classPrivateFieldSet$4(this, _MessageStream_currentMessageSnapshot, messageSnapshot, "f");
          break;
        }
      }
    }, _MessageStream_endRequest = function _MessageStream_endRequest2() {
      if (this.ended) {
        throw new AnthropicError(`stream has ended, this shouldn't happen`);
      }
      const snapshot = __classPrivateFieldGet$5(this, _MessageStream_currentMessageSnapshot, "f");
      if (!snapshot) {
        throw new AnthropicError(`request ended without sending any chunks`);
      }
      __classPrivateFieldSet$4(this, _MessageStream_currentMessageSnapshot, void 0, "f");
      return snapshot;
    }, _MessageStream_accumulateMessage = function _MessageStream_accumulateMessage2(event) {
      let snapshot = __classPrivateFieldGet$5(this, _MessageStream_currentMessageSnapshot, "f");
      if (event.type === "message_start") {
        if (snapshot) {
          throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving "message_stop"`);
        }
        return event.message;
      }
      if (!snapshot) {
        throw new AnthropicError(`Unexpected event order, got ${event.type} before "message_start"`);
      }
      switch (event.type) {
        case "message_stop":
          return snapshot;
        case "message_delta":
          snapshot.stop_reason = event.delta.stop_reason;
          snapshot.stop_sequence = event.delta.stop_sequence;
          snapshot.usage.output_tokens = event.usage.output_tokens;
          return snapshot;
        case "content_block_start":
          snapshot.content.push(event.content_block);
          return snapshot;
        case "content_block_delta": {
          const snapshotContent = snapshot.content.at(event.index);
          if ((snapshotContent == null ? void 0 : snapshotContent.type) === "text" && event.delta.type === "text_delta") {
            snapshotContent.text += event.delta.text;
          } else if ((snapshotContent == null ? void 0 : snapshotContent.type) === "tool_use" && event.delta.type === "input_json_delta") {
            let jsonBuf = snapshotContent[JSON_BUF_PROPERTY] || "";
            jsonBuf += event.delta.partial_json;
            Object.defineProperty(snapshotContent, JSON_BUF_PROPERTY, {
              value: jsonBuf,
              enumerable: false,
              writable: true
            });
            if (jsonBuf) {
              snapshotContent.input = partialParse$1(jsonBuf);
            }
          }
          return snapshot;
        }
        case "content_block_stop":
          return snapshot;
      }
    }, Symbol.asyncIterator)]() {
      const pushQueue = [];
      const readQueue = [];
      let done = false;
      this.on("streamEvent", (event) => {
        const reader = readQueue.shift();
        if (reader) {
          reader.resolve(event);
        } else {
          pushQueue.push(event);
        }
      });
      this.on("end", () => {
        done = true;
        for (const reader of readQueue) {
          reader.resolve(void 0);
        }
        readQueue.length = 0;
      });
      this.on("abort", (err) => {
        done = true;
        for (const reader of readQueue) {
          reader.reject(err);
        }
        readQueue.length = 0;
      });
      this.on("error", (err) => {
        done = true;
        for (const reader of readQueue) {
          reader.reject(err);
        }
        readQueue.length = 0;
      });
      return {
        next: async () => {
          if (!pushQueue.length) {
            if (done) {
              return { value: void 0, done: true };
            }
            return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
          }
          const chunk = pushQueue.shift();
          return { value: chunk, done: false };
        },
        return: async () => {
          this.abort();
          return { value: void 0, done: true };
        }
      };
    }
    toReadableStream() {
      const stream = new Stream$1(this[Symbol.asyncIterator].bind(this), this.controller);
      return stream.toReadableStream();
    }
  }
  let Messages$1 = class Messages extends APIResource$1 {
    create(body, options) {
      if (body.model in DEPRECATED_MODELS) {
        console.warn(`The model '${body.model}' is deprecated and will reach end-of-life on ${DEPRECATED_MODELS[body.model]}
Please migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);
      }
      return this._client.post("/v1/messages", {
        body,
        timeout: this._client._options.timeout ?? 6e5,
        ...options,
        stream: body.stream ?? false
      });
    }
    /**
     * Create a Message stream
     */
    stream(body, options) {
      return MessageStream.createMessage(this, body, options);
    }
  };
  const DEPRECATED_MODELS = {
    "claude-1.3": "November 6th, 2024",
    "claude-1.3-100k": "November 6th, 2024",
    "claude-instant-1.1": "November 6th, 2024",
    "claude-instant-1.1-100k": "November 6th, 2024",
    "claude-instant-1.2": "November 6th, 2024"
  };
  var _a$3;
  class Anthropic extends APIClient$1 {
    /**
     * API Client for interfacing with the Anthropic API.
     *
     * @param {string | null | undefined} [opts.apiKey=process.env['ANTHROPIC_API_KEY'] ?? null]
     * @param {string | null | undefined} [opts.authToken=process.env['ANTHROPIC_AUTH_TOKEN'] ?? null]
     * @param {string} [opts.baseURL=process.env['ANTHROPIC_BASE_URL'] ?? https://api.anthropic.com] - Override the default base URL for the API.
     * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
     * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
     * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
     * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
     * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
     * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
     * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
     */
    constructor({ baseURL = readEnv$1("ANTHROPIC_BASE_URL"), apiKey = readEnv$1("ANTHROPIC_API_KEY") ?? null, authToken = readEnv$1("ANTHROPIC_AUTH_TOKEN") ?? null, ...opts } = {}) {
      const options = {
        apiKey,
        authToken,
        ...opts,
        baseURL: baseURL || `https://api.anthropic.com`
      };
      if (!options.dangerouslyAllowBrowser && isRunningInBrowser$1()) {
        throw new AnthropicError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew Anthropic({ apiKey, dangerouslyAllowBrowser: true });\n\nTODO: link!\n");
      }
      super({
        baseURL: options.baseURL,
        timeout: options.timeout ?? 6e5,
        httpAgent: options.httpAgent,
        maxRetries: options.maxRetries,
        fetch: options.fetch
      });
      this.completions = new Completions$3(this);
      this.messages = new Messages$1(this);
      this.beta = new Beta$1(this);
      this._options = options;
      this.apiKey = apiKey;
      this.authToken = authToken;
    }
    defaultQuery() {
      return this._options.defaultQuery;
    }
    defaultHeaders(opts) {
      return {
        ...super.defaultHeaders(opts),
        ...this._options.dangerouslyAllowBrowser ? { "anthropic-dangerous-direct-browser-access": "true" } : void 0,
        "anthropic-version": "2023-06-01",
        ...this._options.defaultHeaders
      };
    }
    validateHeaders(headers, customHeaders) {
      if (this.apiKey && headers["x-api-key"]) {
        return;
      }
      if (customHeaders["x-api-key"] === null) {
        return;
      }
      if (this.authToken && headers["authorization"]) {
        return;
      }
      if (customHeaders["authorization"] === null) {
        return;
      }
      throw new Error('Could not resolve authentication method. Expected either apiKey or authToken to be set. Or for one of the "X-Api-Key" or "Authorization" headers to be explicitly omitted');
    }
    authHeaders(opts) {
      const apiKeyAuth = this.apiKeyAuth(opts);
      const bearerAuth = this.bearerAuth(opts);
      if (apiKeyAuth != null && !isEmptyObj$2(apiKeyAuth)) {
        return apiKeyAuth;
      }
      if (bearerAuth != null && !isEmptyObj$2(bearerAuth)) {
        return bearerAuth;
      }
      return {};
    }
    apiKeyAuth(opts) {
      if (this.apiKey == null) {
        return {};
      }
      return { "X-Api-Key": this.apiKey };
    }
    bearerAuth(opts) {
      if (this.authToken == null) {
        return {};
      }
      return { Authorization: `Bearer ${this.authToken}` };
    }
  }
  _a$3 = Anthropic;
  Anthropic.Anthropic = _a$3;
  Anthropic.HUMAN_PROMPT = "\n\nHuman:";
  Anthropic.AI_PROMPT = "\n\nAssistant:";
  Anthropic.DEFAULT_TIMEOUT = 6e5;
  Anthropic.AnthropicError = AnthropicError;
  Anthropic.APIError = APIError$1;
  Anthropic.APIConnectionError = APIConnectionError$1;
  Anthropic.APIConnectionTimeoutError = APIConnectionTimeoutError$1;
  Anthropic.APIUserAbortError = APIUserAbortError$1;
  Anthropic.NotFoundError = NotFoundError$1;
  Anthropic.ConflictError = ConflictError$1;
  Anthropic.RateLimitError = RateLimitError$1;
  Anthropic.BadRequestError = BadRequestError$1;
  Anthropic.AuthenticationError = AuthenticationError$1;
  Anthropic.InternalServerError = InternalServerError$1;
  Anthropic.PermissionDeniedError = PermissionDeniedError$1;
  Anthropic.UnprocessableEntityError = UnprocessableEntityError$1;
  Anthropic.toFile = toFile$1;
  Anthropic.fileFromPath = fileFromPath$1;
  Anthropic.Completions = Completions$3;
  Anthropic.Messages = Messages$1;
  Anthropic.Beta = Beta$1;
  class AnthropicToolsOutputParser extends BaseLLMOutputParser {
    static lc_name() {
      return "AnthropicToolsOutputParser";
    }
    constructor(params) {
      super(params);
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ["langchain", "anthropic", "output_parsers"]
      });
      Object.defineProperty(this, "returnId", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "keyName", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "returnSingle", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "zodSchema", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.keyName = params.keyName;
      this.returnSingle = params.returnSingle ?? this.returnSingle;
      this.zodSchema = params.zodSchema;
    }
    async _validateResult(result) {
      let parsedResult = result;
      if (typeof result === "string") {
        try {
          parsedResult = JSON.parse(result);
        } catch (e) {
          throw new OutputParserException(`Failed to parse. Text: "${JSON.stringify(result, null, 2)}". Error: ${JSON.stringify(e.message)}`, result);
        }
      } else {
        parsedResult = result;
      }
      if (this.zodSchema === void 0) {
        return parsedResult;
      }
      const zodParsedResult = await this.zodSchema.safeParseAsync(parsedResult);
      if (zodParsedResult.success) {
        return zodParsedResult.data;
      } else {
        throw new OutputParserException(`Failed to parse. Text: "${JSON.stringify(result, null, 2)}". Error: ${JSON.stringify(zodParsedResult.error.errors)}`, JSON.stringify(parsedResult, null, 2));
      }
    }
    async parseResult(generations) {
      const tools = generations.flatMap((generation) => {
        const { message } = generation;
        if (!Array.isArray(message.content)) {
          return [];
        }
        const tool2 = extractToolCalls(message.content)[0];
        return tool2;
      });
      if (tools[0] === void 0) {
        throw new Error("No parseable tool calls provided to AnthropicToolsOutputParser.");
      }
      const [tool] = tools;
      const validatedResult = await this._validateResult(tool.args);
      return validatedResult;
    }
  }
  function extractToolCalls(content) {
    const toolCalls = [];
    for (const block of content) {
      if (block.type === "tool_use") {
        toolCalls.push({
          name: block.name,
          args: block.input,
          id: block.id,
          type: "tool_call"
        });
      }
    }
    return toolCalls;
  }
  function handleToolChoice(toolChoice) {
    if (!toolChoice) {
      return void 0;
    } else if (toolChoice === "any") {
      return {
        type: "any"
      };
    } else if (toolChoice === "auto") {
      return {
        type: "auto"
      };
    } else if (typeof toolChoice === "string") {
      return {
        type: "tool",
        name: toolChoice
      };
    } else {
      return toolChoice;
    }
  }
  function _formatImage(imageUrl) {
    const regex = /^data:(image\/.+);base64,(.+)$/;
    const match = imageUrl.match(regex);
    if (match === null) {
      throw new Error([
        "Anthropic only supports base64-encoded images currently.",
        "Example: data:image/png;base64,/9j/4AAQSk..."
      ].join("\n\n"));
    }
    return {
      type: "base64",
      media_type: match[1] ?? "",
      data: match[2] ?? ""
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    };
  }
  function _ensureMessageContents(messages) {
    const updatedMsgs = [];
    for (const message of messages) {
      if (message._getType() === "tool") {
        if (typeof message.content === "string") {
          const previousMessage = updatedMsgs[updatedMsgs.length - 1];
          if ((previousMessage == null ? void 0 : previousMessage._getType()) === "human" && Array.isArray(previousMessage.content) && "type" in previousMessage.content[0] && previousMessage.content[0].type === "tool_result") {
            previousMessage.content.push({
              type: "tool_result",
              content: message.content,
              tool_use_id: message.tool_call_id
            });
          } else {
            updatedMsgs.push(new HumanMessage({
              content: [
                {
                  type: "tool_result",
                  content: message.content,
                  tool_use_id: message.tool_call_id
                }
              ]
            }));
          }
        } else {
          updatedMsgs.push(new HumanMessage({
            content: [
              {
                type: "tool_result",
                content: _formatContent(message.content),
                tool_use_id: message.tool_call_id
              }
            ]
          }));
        }
      } else {
        updatedMsgs.push(message);
      }
    }
    return updatedMsgs;
  }
  function _convertLangChainToolCallToAnthropic(toolCall) {
    if (toolCall.id === void 0) {
      throw new Error(`Anthropic requires all tool calls to have an "id".`);
    }
    return {
      type: "tool_use",
      id: toolCall.id,
      name: toolCall.name,
      input: toolCall.args
    };
  }
  function _formatContent(content) {
    const toolTypes = ["tool_use", "tool_result", "input_json_delta"];
    const textTypes = ["text", "text_delta"];
    if (typeof content === "string") {
      return content;
    } else {
      const contentBlocks = content.map((contentPart) => {
        const cacheControl = "cache_control" in contentPart ? contentPart.cache_control : void 0;
        if (contentPart.type === "image_url") {
          let source2;
          if (typeof contentPart.image_url === "string") {
            source2 = _formatImage(contentPart.image_url);
          } else {
            source2 = _formatImage(contentPart.image_url.url);
          }
          return {
            type: "image",
            source: source2,
            ...cacheControl ? { cache_control: cacheControl } : {}
          };
        } else if (contentPart.type === "document") {
          return {
            type: "document",
            source: contentPart.source,
            ...cacheControl ? { cache_control: cacheControl } : {}
          };
        } else if (textTypes.find((t) => t === contentPart.type) && "text" in contentPart) {
          return {
            type: "text",
            text: contentPart.text,
            ...cacheControl ? { cache_control: cacheControl } : {}
          };
        } else if (toolTypes.find((t) => t === contentPart.type)) {
          const contentPartCopy = { ...contentPart };
          if ("index" in contentPartCopy) {
            delete contentPartCopy.index;
          }
          if (contentPartCopy.type === "input_json_delta") {
            contentPartCopy.type = "tool_use";
          }
          if ("input" in contentPartCopy) {
            try {
              contentPartCopy.input = JSON.parse(contentPartCopy.input);
            } catch {
            }
          }
          return {
            ...contentPartCopy,
            ...cacheControl ? { cache_control: cacheControl } : {}
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
          };
        } else {
          throw new Error("Unsupported message content format");
        }
      });
      return contentBlocks;
    }
  }
  function _convertMessagesToAnthropicPayload(messages) {
    const mergedMessages = _ensureMessageContents(messages);
    let system;
    if (mergedMessages.length > 0 && mergedMessages[0]._getType() === "system") {
      system = messages[0].content;
    }
    const conversationMessages = system !== void 0 ? mergedMessages.slice(1) : mergedMessages;
    const formattedMessages = conversationMessages.map((message) => {
      var _a3;
      let role;
      if (message._getType() === "human") {
        role = "user";
      } else if (message._getType() === "ai") {
        role = "assistant";
      } else if (message._getType() === "tool") {
        role = "user";
      } else if (message._getType() === "system") {
        throw new Error("System messages are only permitted as the first passed message.");
      } else {
        throw new Error(`Message type "${message._getType()}" is not supported.`);
      }
      if (isAIMessage(message) && !!((_a3 = message.tool_calls) == null ? void 0 : _a3.length)) {
        if (typeof message.content === "string") {
          if (message.content === "") {
            return {
              role,
              content: message.tool_calls.map(_convertLangChainToolCallToAnthropic)
            };
          } else {
            return {
              role,
              content: [
                { type: "text", text: message.content },
                ...message.tool_calls.map(_convertLangChainToolCallToAnthropic)
              ]
            };
          }
        } else {
          const { content } = message;
          const hasMismatchedToolCalls = !message.tool_calls.every((toolCall) => content.find((contentPart) => (contentPart.type === "tool_use" || contentPart.type === "input_json_delta") && contentPart.id === toolCall.id));
          if (hasMismatchedToolCalls) {
            console.warn(`The "tool_calls" field on a message is only respected if content is a string.`);
          }
          return {
            role,
            content: _formatContent(message.content)
          };
        }
      } else {
        return {
          role,
          content: _formatContent(message.content)
        };
      }
    });
    return {
      messages: mergeMessages(formattedMessages),
      system
    };
  }
  function mergeMessages(messages) {
    if (!messages || messages.length <= 1) {
      return messages;
    }
    const result = [];
    let currentMessage = messages[0];
    const normalizeContent = (content) => {
      if (typeof content === "string") {
        return [
          {
            type: "text",
            text: content
          }
        ];
      }
      return content;
    };
    const isToolResultMessage = (msg) => {
      if (msg.role !== "user")
        return false;
      if (typeof msg.content === "string") {
        return false;
      }
      return Array.isArray(msg.content) && msg.content.every((item) => item.type === "tool_result");
    };
    for (let i2 = 1; i2 < messages.length; i2 += 1) {
      const nextMessage = messages[i2];
      if (isToolResultMessage(currentMessage) && isToolResultMessage(nextMessage)) {
        currentMessage = {
          ...currentMessage,
          content: [
            ...normalizeContent(currentMessage.content),
            ...normalizeContent(nextMessage.content)
          ]
        };
      } else {
        result.push(currentMessage);
        currentMessage = nextMessage;
      }
    }
    result.push(currentMessage);
    return result;
  }
  function _makeMessageChunkFromAnthropicEvent(data, fields) {
    var _a3, _b2;
    if (data.type === "message_start") {
      const { content, usage, ...additionalKwargs } = data.message;
      const filteredAdditionalKwargs = {};
      for (const [key, value] of Object.entries(additionalKwargs)) {
        if (value !== void 0 && value !== null) {
          filteredAdditionalKwargs[key] = value;
        }
      }
      const { input_tokens, output_tokens, ...rest } = usage ?? {};
      const usageMetadata = {
        input_tokens,
        output_tokens,
        total_tokens: input_tokens + output_tokens,
        input_token_details: {
          cache_creation: rest.cache_creation_input_tokens,
          cache_read: rest.cache_read_input_tokens
        }
      };
      return {
        chunk: new AIMessageChunk({
          content: fields.coerceContentToString ? "" : [],
          additional_kwargs: filteredAdditionalKwargs,
          usage_metadata: fields.streamUsage ? usageMetadata : void 0,
          response_metadata: {
            usage: {
              ...rest
            }
          },
          id: data.message.id
        })
      };
    } else if (data.type === "message_delta") {
      const usageMetadata = {
        input_tokens: 0,
        output_tokens: data.usage.output_tokens,
        total_tokens: data.usage.output_tokens,
        input_token_details: {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          cache_creation: data.usage.cache_creation_input_tokens,
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          cache_read: data.usage.cache_read_input_tokens
        }
      };
      return {
        chunk: new AIMessageChunk({
          content: fields.coerceContentToString ? "" : [],
          additional_kwargs: { ...data.delta },
          usage_metadata: fields.streamUsage ? usageMetadata : void 0
        })
      };
    } else if (data.type === "content_block_start" && data.content_block.type === "tool_use") {
      const toolCallContentBlock = data.content_block;
      return {
        chunk: new AIMessageChunk({
          content: fields.coerceContentToString ? "" : [
            {
              index: data.index,
              ...data.content_block,
              input: ""
            }
          ],
          additional_kwargs: {},
          tool_call_chunks: [
            {
              id: toolCallContentBlock.id,
              index: data.index,
              name: toolCallContentBlock.name,
              args: ""
            }
          ]
        })
      };
    } else if (data.type === "content_block_delta" && data.delta.type === "text_delta") {
      const content = (_a3 = data.delta) == null ? void 0 : _a3.text;
      if (content !== void 0) {
        return {
          chunk: new AIMessageChunk({
            content: fields.coerceContentToString ? content : [
              {
                index: data.index,
                ...data.delta
              }
            ],
            additional_kwargs: {}
          })
        };
      }
    } else if (data.type === "content_block_delta" && data.delta.type === "input_json_delta") {
      return {
        chunk: new AIMessageChunk({
          content: fields.coerceContentToString ? "" : [
            {
              index: data.index,
              input: data.delta.partial_json,
              type: data.delta.type
            }
          ],
          additional_kwargs: {},
          tool_call_chunks: [
            {
              index: data.index,
              args: data.delta.partial_json
            }
          ]
        })
      };
    } else if (data.type === "content_block_start" && data.content_block.type === "text") {
      const content = (_b2 = data.content_block) == null ? void 0 : _b2.text;
      if (content !== void 0) {
        return {
          chunk: new AIMessageChunk({
            content: fields.coerceContentToString ? content : [
              {
                index: data.index,
                ...data.content_block
              }
            ],
            additional_kwargs: {}
          })
        };
      }
    }
    return null;
  }
  function anthropicResponseToChatMessages(messages, additionalKwargs) {
    const usage = additionalKwargs.usage;
    const usageMetadata = usage != null ? {
      input_tokens: usage.input_tokens ?? 0,
      output_tokens: usage.output_tokens ?? 0,
      total_tokens: (usage.input_tokens ?? 0) + (usage.output_tokens ?? 0),
      input_token_details: {
        cache_creation: usage.cache_creation_input_tokens,
        cache_read: usage.cache_read_input_tokens
      }
    } : void 0;
    if (messages.length === 1 && messages[0].type === "text") {
      return [
        {
          text: messages[0].text,
          message: new AIMessage({
            content: messages[0].text,
            additional_kwargs: additionalKwargs,
            usage_metadata: usageMetadata,
            response_metadata: additionalKwargs,
            id: additionalKwargs.id
          })
        }
      ];
    } else {
      const toolCalls = extractToolCalls(messages);
      const generations = [
        {
          text: "",
          message: new AIMessage({
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            content: messages,
            additional_kwargs: additionalKwargs,
            tool_calls: toolCalls,
            usage_metadata: usageMetadata,
            response_metadata: additionalKwargs,
            id: additionalKwargs.id
          })
        }
      ];
      return generations;
    }
  }
  function addLangChainErrorFields$1(error, lc_error_code) {
    error.lc_error_code = lc_error_code;
    error.message = `${error.message}

Troubleshooting URL: https://js.langchain.com/docs/troubleshooting/errors/${lc_error_code}/
`;
    return error;
  }
  function wrapAnthropicClientError(e) {
    let error;
    if (e.status === 400 && e.message.includes("tool")) {
      error = addLangChainErrorFields$1(e, "INVALID_TOOL_RESULTS");
    } else if (e.status === 401) {
      error = addLangChainErrorFields$1(e, "MODEL_AUTHENTICATION");
    } else if (e.status === 404) {
      error = addLangChainErrorFields$1(e, "MODEL_NOT_FOUND");
    } else if (e.status === 429) {
      error = addLangChainErrorFields$1(e, "MODEL_RATE_LIMIT");
    } else {
      error = e;
    }
    return error;
  }
  function _toolsInParams(params) {
    return !!(params.tools && params.tools.length > 0);
  }
  function isAnthropicTool(tool) {
    return "input_schema" in tool;
  }
  function extractToken(chunk) {
    if (typeof chunk.content === "string") {
      return chunk.content;
    } else if (Array.isArray(chunk.content) && chunk.content.length >= 1 && "input" in chunk.content[0]) {
      return typeof chunk.content[0].input === "string" ? chunk.content[0].input : JSON.stringify(chunk.content[0].input);
    } else if (Array.isArray(chunk.content) && chunk.content.length >= 1 && "text" in chunk.content[0]) {
      return chunk.content[0].text;
    }
    return void 0;
  }
  class ChatAnthropicMessages extends BaseChatModel {
    static lc_name() {
      return "ChatAnthropic";
    }
    get lc_secrets() {
      return {
        anthropicApiKey: "ANTHROPIC_API_KEY",
        apiKey: "ANTHROPIC_API_KEY"
      };
    }
    get lc_aliases() {
      return {
        modelName: "model"
      };
    }
    constructor(fields) {
      super(fields ?? {});
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "anthropicApiKey", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "apiKey", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "apiUrl", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "temperature", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 1
      });
      Object.defineProperty(this, "topK", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -1
      });
      Object.defineProperty(this, "topP", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -1
      });
      Object.defineProperty(this, "maxTokens", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 2048
      });
      Object.defineProperty(this, "modelName", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "claude-2.1"
      });
      Object.defineProperty(this, "model", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "claude-2.1"
      });
      Object.defineProperty(this, "invocationKwargs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "stopSequences", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "streaming", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "clientOptions", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "batchClient", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "streamingClient", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "streamUsage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "createClient", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.anthropicApiKey = (fields == null ? void 0 : fields.apiKey) ?? (fields == null ? void 0 : fields.anthropicApiKey) ?? getEnvironmentVariable("ANTHROPIC_API_KEY");
      if (!this.anthropicApiKey && !(fields == null ? void 0 : fields.createClient)) {
        throw new Error("Anthropic API key not found");
      }
      this.clientOptions = (fields == null ? void 0 : fields.clientOptions) ?? {};
      this.apiKey = this.anthropicApiKey;
      this.apiUrl = fields == null ? void 0 : fields.anthropicApiUrl;
      this.modelName = (fields == null ? void 0 : fields.model) ?? (fields == null ? void 0 : fields.modelName) ?? this.model;
      this.model = this.modelName;
      this.invocationKwargs = (fields == null ? void 0 : fields.invocationKwargs) ?? {};
      this.temperature = (fields == null ? void 0 : fields.temperature) ?? this.temperature;
      this.topK = (fields == null ? void 0 : fields.topK) ?? this.topK;
      this.topP = (fields == null ? void 0 : fields.topP) ?? this.topP;
      this.maxTokens = (fields == null ? void 0 : fields.maxTokensToSample) ?? (fields == null ? void 0 : fields.maxTokens) ?? this.maxTokens;
      this.stopSequences = (fields == null ? void 0 : fields.stopSequences) ?? this.stopSequences;
      this.streaming = (fields == null ? void 0 : fields.streaming) ?? false;
      this.streamUsage = (fields == null ? void 0 : fields.streamUsage) ?? this.streamUsage;
      this.createClient = (fields == null ? void 0 : fields.createClient) ?? ((options) => new Anthropic(options));
    }
    getLsParams(options) {
      const params = this.invocationParams(options);
      return {
        ls_provider: "anthropic",
        ls_model_name: this.model,
        ls_model_type: "chat",
        ls_temperature: params.temperature ?? void 0,
        ls_max_tokens: params.max_tokens ?? void 0,
        ls_stop: options.stop
      };
    }
    /**
     * Formats LangChain StructuredTools to AnthropicTools.
     *
     * @param {ChatAnthropicCallOptions["tools"]} tools The tools to format
     * @returns {AnthropicTool[] | undefined} The formatted tools, or undefined if none are passed.
     */
    formatStructuredToolToAnthropic(tools) {
      if (!tools || !tools.length) {
        return void 0;
      }
      return tools.map((tool) => {
        if (isAnthropicTool(tool)) {
          return tool;
        }
        if (isOpenAITool(tool)) {
          return {
            name: tool.function.name,
            description: tool.function.description,
            input_schema: tool.function.parameters
          };
        }
        if (isLangChainTool(tool)) {
          return {
            name: tool.name,
            description: tool.description,
            input_schema: zodToJsonSchema$4(tool.schema)
          };
        }
        throw new Error(`Unknown tool type passed to ChatAnthropic: ${JSON.stringify(tool, null, 2)}`);
      });
    }
    bindTools(tools, kwargs) {
      return this.bind({
        tools: this.formatStructuredToolToAnthropic(tools),
        ...kwargs
      });
    }
    /**
     * Get the parameters used to invoke the model
     */
    invocationParams(options) {
      const tool_choice = handleToolChoice(options == null ? void 0 : options.tool_choice);
      return {
        model: this.model,
        temperature: this.temperature,
        top_k: this.topK,
        top_p: this.topP,
        stop_sequences: (options == null ? void 0 : options.stop) ?? this.stopSequences,
        stream: this.streaming,
        max_tokens: this.maxTokens,
        tools: this.formatStructuredToolToAnthropic(options == null ? void 0 : options.tools),
        tool_choice,
        ...this.invocationKwargs
      };
    }
    /** @ignore */
    _identifyingParams() {
      return {
        model_name: this.model,
        ...this.invocationParams()
      };
    }
    /**
     * Get the identifying parameters for the model
     */
    identifyingParams() {
      return {
        model_name: this.model,
        ...this.invocationParams()
      };
    }
    async *_streamResponseChunks(messages, options, runManager) {
      var _a3;
      const params = this.invocationParams(options);
      const formattedMessages = _convertMessagesToAnthropicPayload(messages);
      const coerceContentToString = !_toolsInParams({
        ...params,
        ...formattedMessages,
        stream: false
      });
      const stream = await this.createStreamWithRetry({
        ...params,
        ...formattedMessages,
        stream: true
      }, {
        headers: options.headers
      });
      for await (const data of stream) {
        if ((_a3 = options.signal) == null ? void 0 : _a3.aborted) {
          stream.controller.abort();
          throw new Error("AbortError: User aborted the request.");
        }
        const shouldStreamUsage = this.streamUsage ?? options.streamUsage;
        const result = _makeMessageChunkFromAnthropicEvent(data, {
          streamUsage: shouldStreamUsage,
          coerceContentToString
        });
        if (!result)
          continue;
        const { chunk } = result;
        const token = extractToken(chunk);
        const generationChunk = new ChatGenerationChunk({
          message: new AIMessageChunk({
            // Just yield chunk as it is and tool_use will be concat by BaseChatModel._generateUncached().
            content: chunk.content,
            additional_kwargs: chunk.additional_kwargs,
            tool_call_chunks: chunk.tool_call_chunks,
            usage_metadata: shouldStreamUsage ? chunk.usage_metadata : void 0,
            response_metadata: chunk.response_metadata,
            id: chunk.id
          }),
          text: token ?? ""
        });
        yield generationChunk;
        await (runManager == null ? void 0 : runManager.handleLLMNewToken(token ?? "", void 0, void 0, void 0, void 0, { chunk: generationChunk }));
      }
    }
    /** @ignore */
    async _generateNonStreaming(messages, params, requestOptions) {
      const response = await this.completionWithRetry({
        ...params,
        stream: false,
        ..._convertMessagesToAnthropicPayload(messages)
      }, requestOptions);
      const { content, ...additionalKwargs } = response;
      const generations = anthropicResponseToChatMessages(content, additionalKwargs);
      const { role: _role2, type: _type3, ...rest } = additionalKwargs;
      return { generations, llmOutput: rest };
    }
    /** @ignore */
    async _generate(messages, options, runManager) {
      if (this.stopSequences && options.stop) {
        throw new Error(`"stopSequence" parameter found in input and default params`);
      }
      const params = this.invocationParams(options);
      if (params.stream) {
        let finalChunk;
        const stream = this._streamResponseChunks(messages, options, runManager);
        for await (const chunk of stream) {
          if (finalChunk === void 0) {
            finalChunk = chunk;
          } else {
            finalChunk = finalChunk.concat(chunk);
          }
        }
        if (finalChunk === void 0) {
          throw new Error("No chunks returned from Anthropic API.");
        }
        return {
          generations: [
            {
              text: finalChunk.text,
              message: finalChunk.message
            }
          ]
        };
      } else {
        return this._generateNonStreaming(messages, params, {
          signal: options.signal,
          headers: options.headers
        });
      }
    }
    /**
     * Creates a streaming request with retry.
     * @param request The parameters for creating a completion.
     * @param options
     * @returns A streaming request.
     */
    async createStreamWithRetry(request, options) {
      if (!this.streamingClient) {
        const options_ = this.apiUrl ? { baseURL: this.apiUrl } : void 0;
        this.streamingClient = this.createClient({
          dangerouslyAllowBrowser: true,
          ...this.clientOptions,
          ...options_,
          apiKey: this.apiKey,
          // Prefer LangChain built-in retries
          maxRetries: 0
        });
      }
      const makeCompletionRequest = async () => {
        try {
          return await this.streamingClient.messages.create({
            ...request,
            ...this.invocationKwargs,
            stream: true
          }, options);
        } catch (e) {
          const error = wrapAnthropicClientError(e);
          throw error;
        }
      };
      return this.caller.call(makeCompletionRequest);
    }
    /** @ignore */
    async completionWithRetry(request, options) {
      if (!this.batchClient) {
        const options2 = this.apiUrl ? { baseURL: this.apiUrl } : void 0;
        this.batchClient = this.createClient({
          dangerouslyAllowBrowser: true,
          ...this.clientOptions,
          ...options2,
          apiKey: this.apiKey,
          maxRetries: 0
        });
      }
      const makeCompletionRequest = async () => {
        try {
          return await this.batchClient.messages.create({
            ...request,
            ...this.invocationKwargs
          }, options);
        } catch (e) {
          const error = wrapAnthropicClientError(e);
          throw error;
        }
      };
      return this.caller.callWithOptions({ signal: options.signal ?? void 0 }, makeCompletionRequest);
    }
    _llmType() {
      return "anthropic";
    }
    withStructuredOutput(outputSchema, config2) {
      const schema = outputSchema;
      const name = config2 == null ? void 0 : config2.name;
      const method = config2 == null ? void 0 : config2.method;
      const includeRaw = config2 == null ? void 0 : config2.includeRaw;
      if (method === "jsonMode") {
        throw new Error(`Anthropic only supports "functionCalling" as a method.`);
      }
      let functionName = name ?? "extract";
      let outputParser;
      let tools;
      if (isZodSchema$2(schema)) {
        const jsonSchema = zodToJsonSchema$4(schema);
        tools = [
          {
            name: functionName,
            description: jsonSchema.description ?? "A function available to call.",
            input_schema: jsonSchema
          }
        ];
        outputParser = new AnthropicToolsOutputParser({
          returnSingle: true,
          keyName: functionName,
          zodSchema: schema
        });
      } else {
        let anthropicTools;
        if (typeof schema.name === "string" && typeof schema.description === "string" && typeof schema.input_schema === "object" && schema.input_schema != null) {
          anthropicTools = schema;
          functionName = schema.name;
        } else {
          anthropicTools = {
            name: functionName,
            description: schema.description ?? "",
            input_schema: schema
          };
        }
        tools = [anthropicTools];
        outputParser = new AnthropicToolsOutputParser({
          returnSingle: true,
          keyName: functionName
        });
      }
      const llm = this.bind({
        tools,
        tool_choice: {
          type: "tool",
          name: functionName
        }
      });
      if (!includeRaw) {
        return llm.pipe(outputParser).withConfig({
          runName: "ChatAnthropicStructuredOutput"
        });
      }
      const parserAssign = RunnablePassthrough.assign({
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        parsed: (input, config3) => outputParser.invoke(input.raw, config3)
      });
      const parserNone = RunnablePassthrough.assign({
        parsed: () => null
      });
      const parsedWithFallback = parserAssign.withFallbacks({
        fallbacks: [parserNone]
      });
      return RunnableSequence.from([
        {
          raw: llm
        },
        parsedWithFallback
      ]).withConfig({
        runName: "StructuredOutputRunnable"
      });
    }
  }
  class ChatAnthropic extends ChatAnthropicMessages {
  }
  var SchemaType;
  (function(SchemaType2) {
    SchemaType2["STRING"] = "string";
    SchemaType2["NUMBER"] = "number";
    SchemaType2["INTEGER"] = "integer";
    SchemaType2["BOOLEAN"] = "boolean";
    SchemaType2["ARRAY"] = "array";
    SchemaType2["OBJECT"] = "object";
  })(SchemaType || (SchemaType = {}));
  /**
   * @license
   * Copyright 2024 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var ExecutableCodeLanguage;
  (function(ExecutableCodeLanguage2) {
    ExecutableCodeLanguage2["LANGUAGE_UNSPECIFIED"] = "language_unspecified";
    ExecutableCodeLanguage2["PYTHON"] = "python";
  })(ExecutableCodeLanguage || (ExecutableCodeLanguage = {}));
  var Outcome;
  (function(Outcome2) {
    Outcome2["OUTCOME_UNSPECIFIED"] = "outcome_unspecified";
    Outcome2["OUTCOME_OK"] = "outcome_ok";
    Outcome2["OUTCOME_FAILED"] = "outcome_failed";
    Outcome2["OUTCOME_DEADLINE_EXCEEDED"] = "outcome_deadline_exceeded";
  })(Outcome || (Outcome = {}));
  /**
   * @license
   * Copyright 2024 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const POSSIBLE_ROLES = ["user", "model", "function", "system"];
  var HarmCategory;
  (function(HarmCategory2) {
    HarmCategory2["HARM_CATEGORY_UNSPECIFIED"] = "HARM_CATEGORY_UNSPECIFIED";
    HarmCategory2["HARM_CATEGORY_HATE_SPEECH"] = "HARM_CATEGORY_HATE_SPEECH";
    HarmCategory2["HARM_CATEGORY_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_SEXUALLY_EXPLICIT";
    HarmCategory2["HARM_CATEGORY_HARASSMENT"] = "HARM_CATEGORY_HARASSMENT";
    HarmCategory2["HARM_CATEGORY_DANGEROUS_CONTENT"] = "HARM_CATEGORY_DANGEROUS_CONTENT";
  })(HarmCategory || (HarmCategory = {}));
  var HarmBlockThreshold;
  (function(HarmBlockThreshold2) {
    HarmBlockThreshold2["HARM_BLOCK_THRESHOLD_UNSPECIFIED"] = "HARM_BLOCK_THRESHOLD_UNSPECIFIED";
    HarmBlockThreshold2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
    HarmBlockThreshold2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
    HarmBlockThreshold2["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
    HarmBlockThreshold2["BLOCK_NONE"] = "BLOCK_NONE";
  })(HarmBlockThreshold || (HarmBlockThreshold = {}));
  var HarmProbability;
  (function(HarmProbability2) {
    HarmProbability2["HARM_PROBABILITY_UNSPECIFIED"] = "HARM_PROBABILITY_UNSPECIFIED";
    HarmProbability2["NEGLIGIBLE"] = "NEGLIGIBLE";
    HarmProbability2["LOW"] = "LOW";
    HarmProbability2["MEDIUM"] = "MEDIUM";
    HarmProbability2["HIGH"] = "HIGH";
  })(HarmProbability || (HarmProbability = {}));
  var BlockReason;
  (function(BlockReason2) {
    BlockReason2["BLOCKED_REASON_UNSPECIFIED"] = "BLOCKED_REASON_UNSPECIFIED";
    BlockReason2["SAFETY"] = "SAFETY";
    BlockReason2["OTHER"] = "OTHER";
  })(BlockReason || (BlockReason = {}));
  var FinishReason;
  (function(FinishReason2) {
    FinishReason2["FINISH_REASON_UNSPECIFIED"] = "FINISH_REASON_UNSPECIFIED";
    FinishReason2["STOP"] = "STOP";
    FinishReason2["MAX_TOKENS"] = "MAX_TOKENS";
    FinishReason2["SAFETY"] = "SAFETY";
    FinishReason2["RECITATION"] = "RECITATION";
    FinishReason2["LANGUAGE"] = "LANGUAGE";
    FinishReason2["OTHER"] = "OTHER";
  })(FinishReason || (FinishReason = {}));
  var TaskType;
  (function(TaskType2) {
    TaskType2["TASK_TYPE_UNSPECIFIED"] = "TASK_TYPE_UNSPECIFIED";
    TaskType2["RETRIEVAL_QUERY"] = "RETRIEVAL_QUERY";
    TaskType2["RETRIEVAL_DOCUMENT"] = "RETRIEVAL_DOCUMENT";
    TaskType2["SEMANTIC_SIMILARITY"] = "SEMANTIC_SIMILARITY";
    TaskType2["CLASSIFICATION"] = "CLASSIFICATION";
    TaskType2["CLUSTERING"] = "CLUSTERING";
  })(TaskType || (TaskType = {}));
  var FunctionCallingMode;
  (function(FunctionCallingMode2) {
    FunctionCallingMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
    FunctionCallingMode2["AUTO"] = "AUTO";
    FunctionCallingMode2["ANY"] = "ANY";
    FunctionCallingMode2["NONE"] = "NONE";
  })(FunctionCallingMode || (FunctionCallingMode = {}));
  var DynamicRetrievalMode;
  (function(DynamicRetrievalMode2) {
    DynamicRetrievalMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
    DynamicRetrievalMode2["MODE_DYNAMIC"] = "MODE_DYNAMIC";
  })(DynamicRetrievalMode || (DynamicRetrievalMode = {}));
  /**
   * @license
   * Copyright 2024 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class GoogleGenerativeAIError extends Error {
    constructor(message) {
      super(`[GoogleGenerativeAI Error]: ${message}`);
    }
  }
  class GoogleGenerativeAIResponseError extends GoogleGenerativeAIError {
    constructor(message, response) {
      super(message);
      this.response = response;
    }
  }
  class GoogleGenerativeAIFetchError extends GoogleGenerativeAIError {
    constructor(message, status, statusText, errorDetails) {
      super(message);
      this.status = status;
      this.statusText = statusText;
      this.errorDetails = errorDetails;
    }
  }
  class GoogleGenerativeAIRequestInputError extends GoogleGenerativeAIError {
  }
  /**
   * @license
   * Copyright 2024 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const DEFAULT_BASE_URL = "https://generativelanguage.googleapis.com";
  const DEFAULT_API_VERSION = "v1beta";
  const PACKAGE_VERSION = "0.21.0";
  const PACKAGE_LOG_HEADER = "genai-js";
  var Task;
  (function(Task2) {
    Task2["GENERATE_CONTENT"] = "generateContent";
    Task2["STREAM_GENERATE_CONTENT"] = "streamGenerateContent";
    Task2["COUNT_TOKENS"] = "countTokens";
    Task2["EMBED_CONTENT"] = "embedContent";
    Task2["BATCH_EMBED_CONTENTS"] = "batchEmbedContents";
  })(Task || (Task = {}));
  class RequestUrl {
    constructor(model, task, apiKey, stream, requestOptions) {
      this.model = model;
      this.task = task;
      this.apiKey = apiKey;
      this.stream = stream;
      this.requestOptions = requestOptions;
    }
    toString() {
      var _a3, _b2;
      const apiVersion = ((_a3 = this.requestOptions) === null || _a3 === void 0 ? void 0 : _a3.apiVersion) || DEFAULT_API_VERSION;
      const baseUrl = ((_b2 = this.requestOptions) === null || _b2 === void 0 ? void 0 : _b2.baseUrl) || DEFAULT_BASE_URL;
      let url = `${baseUrl}/${apiVersion}/${this.model}:${this.task}`;
      if (this.stream) {
        url += "?alt=sse";
      }
      return url;
    }
  }
  function getClientHeaders(requestOptions) {
    const clientHeaders = [];
    if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiClient) {
      clientHeaders.push(requestOptions.apiClient);
    }
    clientHeaders.push(`${PACKAGE_LOG_HEADER}/${PACKAGE_VERSION}`);
    return clientHeaders.join(" ");
  }
  async function getHeaders(url) {
    var _a3;
    const headers = new Headers();
    headers.append("Content-Type", "application/json");
    headers.append("x-goog-api-client", getClientHeaders(url.requestOptions));
    headers.append("x-goog-api-key", url.apiKey);
    let customHeaders = (_a3 = url.requestOptions) === null || _a3 === void 0 ? void 0 : _a3.customHeaders;
    if (customHeaders) {
      if (!(customHeaders instanceof Headers)) {
        try {
          customHeaders = new Headers(customHeaders);
        } catch (e) {
          throw new GoogleGenerativeAIRequestInputError(`unable to convert customHeaders value ${JSON.stringify(customHeaders)} to Headers: ${e.message}`);
        }
      }
      for (const [headerName, headerValue] of customHeaders.entries()) {
        if (headerName === "x-goog-api-key") {
          throw new GoogleGenerativeAIRequestInputError(`Cannot set reserved header name ${headerName}`);
        } else if (headerName === "x-goog-api-client") {
          throw new GoogleGenerativeAIRequestInputError(`Header name ${headerName} can only be set using the apiClient field`);
        }
        headers.append(headerName, headerValue);
      }
    }
    return headers;
  }
  async function constructModelRequest(model, task, apiKey, stream, body, requestOptions) {
    const url = new RequestUrl(model, task, apiKey, stream, requestOptions);
    return {
      url: url.toString(),
      fetchOptions: Object.assign(Object.assign({}, buildFetchOptions(requestOptions)), { method: "POST", headers: await getHeaders(url), body })
    };
  }
  async function makeModelRequest(model, task, apiKey, stream, body, requestOptions = {}, fetchFn = fetch) {
    const { url, fetchOptions } = await constructModelRequest(model, task, apiKey, stream, body, requestOptions);
    return makeRequest(url, fetchOptions, fetchFn);
  }
  async function makeRequest(url, fetchOptions, fetchFn = fetch) {
    let response;
    try {
      response = await fetchFn(url, fetchOptions);
    } catch (e) {
      handleResponseError(e, url);
    }
    if (!response.ok) {
      await handleResponseNotOk(response, url);
    }
    return response;
  }
  function handleResponseError(e, url) {
    let err = e;
    if (!(e instanceof GoogleGenerativeAIFetchError || e instanceof GoogleGenerativeAIRequestInputError)) {
      err = new GoogleGenerativeAIError(`Error fetching from ${url.toString()}: ${e.message}`);
      err.stack = e.stack;
    }
    throw err;
  }
  async function handleResponseNotOk(response, url) {
    let message = "";
    let errorDetails;
    try {
      const json = await response.json();
      message = json.error.message;
      if (json.error.details) {
        message += ` ${JSON.stringify(json.error.details)}`;
        errorDetails = json.error.details;
      }
    } catch (e) {
    }
    throw new GoogleGenerativeAIFetchError(`Error fetching from ${url.toString()}: [${response.status} ${response.statusText}] ${message}`, response.status, response.statusText, errorDetails);
  }
  function buildFetchOptions(requestOptions) {
    const fetchOptions = {};
    if ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.signal) !== void 0 || (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeout) >= 0) {
      const controller = new AbortController();
      if ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeout) >= 0) {
        setTimeout(() => controller.abort(), requestOptions.timeout);
      }
      if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.signal) {
        requestOptions.signal.addEventListener("abort", () => {
          controller.abort();
        });
      }
      fetchOptions.signal = controller.signal;
    }
    return fetchOptions;
  }
  /**
   * @license
   * Copyright 2024 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function addHelpers(response) {
    response.text = () => {
      if (response.candidates && response.candidates.length > 0) {
        if (response.candidates.length > 1) {
          console.warn(`This response had ${response.candidates.length} candidates. Returning text from the first candidate only. Access response.candidates directly to use the other candidates.`);
        }
        if (hadBadFinishReason(response.candidates[0])) {
          throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
        }
        return getText(response);
      } else if (response.promptFeedback) {
        throw new GoogleGenerativeAIResponseError(`Text not available. ${formatBlockErrorMessage(response)}`, response);
      }
      return "";
    };
    response.functionCall = () => {
      if (response.candidates && response.candidates.length > 0) {
        if (response.candidates.length > 1) {
          console.warn(`This response had ${response.candidates.length} candidates. Returning function calls from the first candidate only. Access response.candidates directly to use the other candidates.`);
        }
        if (hadBadFinishReason(response.candidates[0])) {
          throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
        }
        console.warn(`response.functionCall() is deprecated. Use response.functionCalls() instead.`);
        return getFunctionCalls(response)[0];
      } else if (response.promptFeedback) {
        throw new GoogleGenerativeAIResponseError(`Function call not available. ${formatBlockErrorMessage(response)}`, response);
      }
      return void 0;
    };
    response.functionCalls = () => {
      if (response.candidates && response.candidates.length > 0) {
        if (response.candidates.length > 1) {
          console.warn(`This response had ${response.candidates.length} candidates. Returning function calls from the first candidate only. Access response.candidates directly to use the other candidates.`);
        }
        if (hadBadFinishReason(response.candidates[0])) {
          throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
        }
        return getFunctionCalls(response);
      } else if (response.promptFeedback) {
        throw new GoogleGenerativeAIResponseError(`Function call not available. ${formatBlockErrorMessage(response)}`, response);
      }
      return void 0;
    };
    return response;
  }
  function getText(response) {
    var _a3, _b2, _c2, _d2;
    const textStrings = [];
    if ((_b2 = (_a3 = response.candidates) === null || _a3 === void 0 ? void 0 : _a3[0].content) === null || _b2 === void 0 ? void 0 : _b2.parts) {
      for (const part of (_d2 = (_c2 = response.candidates) === null || _c2 === void 0 ? void 0 : _c2[0].content) === null || _d2 === void 0 ? void 0 : _d2.parts) {
        if (part.text) {
          textStrings.push(part.text);
        }
        if (part.executableCode) {
          textStrings.push("\n```" + part.executableCode.language + "\n" + part.executableCode.code + "\n```\n");
        }
        if (part.codeExecutionResult) {
          textStrings.push("\n```\n" + part.codeExecutionResult.output + "\n```\n");
        }
      }
    }
    if (textStrings.length > 0) {
      return textStrings.join("");
    } else {
      return "";
    }
  }
  function getFunctionCalls(response) {
    var _a3, _b2, _c2, _d2;
    const functionCalls = [];
    if ((_b2 = (_a3 = response.candidates) === null || _a3 === void 0 ? void 0 : _a3[0].content) === null || _b2 === void 0 ? void 0 : _b2.parts) {
      for (const part of (_d2 = (_c2 = response.candidates) === null || _c2 === void 0 ? void 0 : _c2[0].content) === null || _d2 === void 0 ? void 0 : _d2.parts) {
        if (part.functionCall) {
          functionCalls.push(part.functionCall);
        }
      }
    }
    if (functionCalls.length > 0) {
      return functionCalls;
    } else {
      return void 0;
    }
  }
  const badFinishReasons = [
    FinishReason.RECITATION,
    FinishReason.SAFETY,
    FinishReason.LANGUAGE
  ];
  function hadBadFinishReason(candidate) {
    return !!candidate.finishReason && badFinishReasons.includes(candidate.finishReason);
  }
  function formatBlockErrorMessage(response) {
    var _a3, _b2, _c2;
    let message = "";
    if ((!response.candidates || response.candidates.length === 0) && response.promptFeedback) {
      message += "Response was blocked";
      if ((_a3 = response.promptFeedback) === null || _a3 === void 0 ? void 0 : _a3.blockReason) {
        message += ` due to ${response.promptFeedback.blockReason}`;
      }
      if ((_b2 = response.promptFeedback) === null || _b2 === void 0 ? void 0 : _b2.blockReasonMessage) {
        message += `: ${response.promptFeedback.blockReasonMessage}`;
      }
    } else if ((_c2 = response.candidates) === null || _c2 === void 0 ? void 0 : _c2[0]) {
      const firstCandidate = response.candidates[0];
      if (hadBadFinishReason(firstCandidate)) {
        message += `Candidate was blocked due to ${firstCandidate.finishReason}`;
        if (firstCandidate.finishMessage) {
          message += `: ${firstCandidate.finishMessage}`;
        }
      }
    }
    return message;
  }
  function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g2 = generator.apply(thisArg, _arguments || []), i2, q = [];
    return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2;
    function verb(n) {
      if (g2[n]) i2[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
    }
    function resume(n, v) {
      try {
        step(g2[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
  }
  typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };
  /**
   * @license
   * Copyright 2024 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const responseLineRE = /^data\: (.*)(?:\n\n|\r\r|\r\n\r\n)/;
  function processStream(response) {
    const inputStream = response.body.pipeThrough(new TextDecoderStream("utf8", { fatal: true }));
    const responseStream = getResponseStream(inputStream);
    const [stream1, stream2] = responseStream.tee();
    return {
      stream: generateResponseSequence(stream1),
      response: getResponsePromise(stream2)
    };
  }
  async function getResponsePromise(stream) {
    const allResponses = [];
    const reader = stream.getReader();
    while (true) {
      const { done, value } = await reader.read();
      if (done) {
        return addHelpers(aggregateResponses(allResponses));
      }
      allResponses.push(value);
    }
  }
  function generateResponseSequence(stream) {
    return __asyncGenerator(this, arguments, function* generateResponseSequence_1() {
      const reader = stream.getReader();
      while (true) {
        const { value, done } = yield __await(reader.read());
        if (done) {
          break;
        }
        yield yield __await(addHelpers(value));
      }
    });
  }
  function getResponseStream(inputStream) {
    const reader = inputStream.getReader();
    const stream = new ReadableStream({
      start(controller) {
        let currentText = "";
        return pump();
        function pump() {
          return reader.read().then(({ value, done }) => {
            if (done) {
              if (currentText.trim()) {
                controller.error(new GoogleGenerativeAIError("Failed to parse stream"));
                return;
              }
              controller.close();
              return;
            }
            currentText += value;
            let match = currentText.match(responseLineRE);
            let parsedResponse;
            while (match) {
              try {
                parsedResponse = JSON.parse(match[1]);
              } catch (e) {
                controller.error(new GoogleGenerativeAIError(`Error parsing JSON response: "${match[1]}"`));
                return;
              }
              controller.enqueue(parsedResponse);
              currentText = currentText.substring(match[0].length);
              match = currentText.match(responseLineRE);
            }
            return pump();
          });
        }
      }
    });
    return stream;
  }
  function aggregateResponses(responses) {
    const lastResponse = responses[responses.length - 1];
    const aggregatedResponse = {
      promptFeedback: lastResponse === null || lastResponse === void 0 ? void 0 : lastResponse.promptFeedback
    };
    for (const response of responses) {
      if (response.candidates) {
        for (const candidate of response.candidates) {
          const i2 = candidate.index;
          if (!aggregatedResponse.candidates) {
            aggregatedResponse.candidates = [];
          }
          if (!aggregatedResponse.candidates[i2]) {
            aggregatedResponse.candidates[i2] = {
              index: candidate.index
            };
          }
          aggregatedResponse.candidates[i2].citationMetadata = candidate.citationMetadata;
          aggregatedResponse.candidates[i2].groundingMetadata = candidate.groundingMetadata;
          aggregatedResponse.candidates[i2].finishReason = candidate.finishReason;
          aggregatedResponse.candidates[i2].finishMessage = candidate.finishMessage;
          aggregatedResponse.candidates[i2].safetyRatings = candidate.safetyRatings;
          if (candidate.content && candidate.content.parts) {
            if (!aggregatedResponse.candidates[i2].content) {
              aggregatedResponse.candidates[i2].content = {
                role: candidate.content.role || "user",
                parts: []
              };
            }
            const newPart = {};
            for (const part of candidate.content.parts) {
              if (part.text) {
                newPart.text = part.text;
              }
              if (part.functionCall) {
                newPart.functionCall = part.functionCall;
              }
              if (part.executableCode) {
                newPart.executableCode = part.executableCode;
              }
              if (part.codeExecutionResult) {
                newPart.codeExecutionResult = part.codeExecutionResult;
              }
              if (Object.keys(newPart).length === 0) {
                newPart.text = "";
              }
              aggregatedResponse.candidates[i2].content.parts.push(newPart);
            }
          }
        }
      }
      if (response.usageMetadata) {
        aggregatedResponse.usageMetadata = response.usageMetadata;
      }
    }
    return aggregatedResponse;
  }
  /**
   * @license
   * Copyright 2024 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  async function generateContentStream(apiKey, model, params, requestOptions) {
    const response = await makeModelRequest(
      model,
      Task.STREAM_GENERATE_CONTENT,
      apiKey,
      /* stream */
      true,
      JSON.stringify(params),
      requestOptions
    );
    return processStream(response);
  }
  async function generateContent(apiKey, model, params, requestOptions) {
    const response = await makeModelRequest(
      model,
      Task.GENERATE_CONTENT,
      apiKey,
      /* stream */
      false,
      JSON.stringify(params),
      requestOptions
    );
    const responseJson = await response.json();
    const enhancedResponse = addHelpers(responseJson);
    return {
      response: enhancedResponse
    };
  }
  /**
   * @license
   * Copyright 2024 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function formatSystemInstruction(input) {
    if (input == null) {
      return void 0;
    } else if (typeof input === "string") {
      return { role: "system", parts: [{ text: input }] };
    } else if (input.text) {
      return { role: "system", parts: [input] };
    } else if (input.parts) {
      if (!input.role) {
        return { role: "system", parts: input.parts };
      } else {
        return input;
      }
    }
  }
  function formatNewContent(request) {
    let newParts = [];
    if (typeof request === "string") {
      newParts = [{ text: request }];
    } else {
      for (const partOrString of request) {
        if (typeof partOrString === "string") {
          newParts.push({ text: partOrString });
        } else {
          newParts.push(partOrString);
        }
      }
    }
    return assignRoleToPartsAndValidateSendMessageRequest(newParts);
  }
  function assignRoleToPartsAndValidateSendMessageRequest(parts) {
    const userContent = { role: "user", parts: [] };
    const functionContent = { role: "function", parts: [] };
    let hasUserContent = false;
    let hasFunctionContent = false;
    for (const part of parts) {
      if ("functionResponse" in part) {
        functionContent.parts.push(part);
        hasFunctionContent = true;
      } else {
        userContent.parts.push(part);
        hasUserContent = true;
      }
    }
    if (hasUserContent && hasFunctionContent) {
      throw new GoogleGenerativeAIError("Within a single message, FunctionResponse cannot be mixed with other type of part in the request for sending chat message.");
    }
    if (!hasUserContent && !hasFunctionContent) {
      throw new GoogleGenerativeAIError("No content is provided for sending chat message.");
    }
    if (hasUserContent) {
      return userContent;
    }
    return functionContent;
  }
  function formatCountTokensInput(params, modelParams) {
    var _a3;
    let formattedGenerateContentRequest = {
      model: modelParams === null || modelParams === void 0 ? void 0 : modelParams.model,
      generationConfig: modelParams === null || modelParams === void 0 ? void 0 : modelParams.generationConfig,
      safetySettings: modelParams === null || modelParams === void 0 ? void 0 : modelParams.safetySettings,
      tools: modelParams === null || modelParams === void 0 ? void 0 : modelParams.tools,
      toolConfig: modelParams === null || modelParams === void 0 ? void 0 : modelParams.toolConfig,
      systemInstruction: modelParams === null || modelParams === void 0 ? void 0 : modelParams.systemInstruction,
      cachedContent: (_a3 = modelParams === null || modelParams === void 0 ? void 0 : modelParams.cachedContent) === null || _a3 === void 0 ? void 0 : _a3.name,
      contents: []
    };
    const containsGenerateContentRequest = params.generateContentRequest != null;
    if (params.contents) {
      if (containsGenerateContentRequest) {
        throw new GoogleGenerativeAIRequestInputError("CountTokensRequest must have one of contents or generateContentRequest, not both.");
      }
      formattedGenerateContentRequest.contents = params.contents;
    } else if (containsGenerateContentRequest) {
      formattedGenerateContentRequest = Object.assign(Object.assign({}, formattedGenerateContentRequest), params.generateContentRequest);
    } else {
      const content = formatNewContent(params);
      formattedGenerateContentRequest.contents = [content];
    }
    return { generateContentRequest: formattedGenerateContentRequest };
  }
  function formatGenerateContentInput(params) {
    let formattedRequest;
    if (params.contents) {
      formattedRequest = params;
    } else {
      const content = formatNewContent(params);
      formattedRequest = { contents: [content] };
    }
    if (params.systemInstruction) {
      formattedRequest.systemInstruction = formatSystemInstruction(params.systemInstruction);
    }
    return formattedRequest;
  }
  function formatEmbedContentInput(params) {
    if (typeof params === "string" || Array.isArray(params)) {
      const content = formatNewContent(params);
      return { content };
    }
    return params;
  }
  /**
   * @license
   * Copyright 2024 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const VALID_PART_FIELDS = [
    "text",
    "inlineData",
    "functionCall",
    "functionResponse",
    "executableCode",
    "codeExecutionResult"
  ];
  const VALID_PARTS_PER_ROLE = {
    user: ["text", "inlineData"],
    function: ["functionResponse"],
    model: ["text", "functionCall", "executableCode", "codeExecutionResult"],
    // System instructions shouldn't be in history anyway.
    system: ["text"]
  };
  function validateChatHistory(history) {
    let prevContent = false;
    for (const currContent of history) {
      const { role, parts } = currContent;
      if (!prevContent && role !== "user") {
        throw new GoogleGenerativeAIError(`First content should be with role 'user', got ${role}`);
      }
      if (!POSSIBLE_ROLES.includes(role)) {
        throw new GoogleGenerativeAIError(`Each item should include role field. Got ${role} but valid roles are: ${JSON.stringify(POSSIBLE_ROLES)}`);
      }
      if (!Array.isArray(parts)) {
        throw new GoogleGenerativeAIError("Content should have 'parts' property with an array of Parts");
      }
      if (parts.length === 0) {
        throw new GoogleGenerativeAIError("Each Content should have at least one part");
      }
      const countFields = {
        text: 0,
        inlineData: 0,
        functionCall: 0,
        functionResponse: 0,
        fileData: 0,
        executableCode: 0,
        codeExecutionResult: 0
      };
      for (const part of parts) {
        for (const key of VALID_PART_FIELDS) {
          if (key in part) {
            countFields[key] += 1;
          }
        }
      }
      const validParts = VALID_PARTS_PER_ROLE[role];
      for (const key of VALID_PART_FIELDS) {
        if (!validParts.includes(key) && countFields[key] > 0) {
          throw new GoogleGenerativeAIError(`Content with role '${role}' can't contain '${key}' part`);
        }
      }
      prevContent = true;
    }
  }
  /**
   * @license
   * Copyright 2024 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const SILENT_ERROR = "SILENT_ERROR";
  class ChatSession {
    constructor(apiKey, model, params, _requestOptions = {}) {
      this.model = model;
      this.params = params;
      this._requestOptions = _requestOptions;
      this._history = [];
      this._sendPromise = Promise.resolve();
      this._apiKey = apiKey;
      if (params === null || params === void 0 ? void 0 : params.history) {
        validateChatHistory(params.history);
        this._history = params.history;
      }
    }
    /**
     * Gets the chat history so far. Blocked prompts are not added to history.
     * Blocked candidates are not added to history, nor are the prompts that
     * generated them.
     */
    async getHistory() {
      await this._sendPromise;
      return this._history;
    }
    /**
     * Sends a chat message and receives a non-streaming
     * {@link GenerateContentResult}.
     *
     * Fields set in the optional {@link SingleRequestOptions} parameter will
     * take precedence over the {@link RequestOptions} values provided to
     * {@link GoogleGenerativeAI.getGenerativeModel }.
     */
    async sendMessage(request, requestOptions = {}) {
      var _a3, _b2, _c2, _d2, _e2, _f2;
      await this._sendPromise;
      const newContent = formatNewContent(request);
      const generateContentRequest = {
        safetySettings: (_a3 = this.params) === null || _a3 === void 0 ? void 0 : _a3.safetySettings,
        generationConfig: (_b2 = this.params) === null || _b2 === void 0 ? void 0 : _b2.generationConfig,
        tools: (_c2 = this.params) === null || _c2 === void 0 ? void 0 : _c2.tools,
        toolConfig: (_d2 = this.params) === null || _d2 === void 0 ? void 0 : _d2.toolConfig,
        systemInstruction: (_e2 = this.params) === null || _e2 === void 0 ? void 0 : _e2.systemInstruction,
        cachedContent: (_f2 = this.params) === null || _f2 === void 0 ? void 0 : _f2.cachedContent,
        contents: [...this._history, newContent]
      };
      const chatSessionRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
      let finalResult;
      this._sendPromise = this._sendPromise.then(() => generateContent(this._apiKey, this.model, generateContentRequest, chatSessionRequestOptions)).then((result) => {
        var _a4;
        if (result.response.candidates && result.response.candidates.length > 0) {
          this._history.push(newContent);
          const responseContent = Object.assign({
            parts: [],
            // Response seems to come back without a role set.
            role: "model"
          }, (_a4 = result.response.candidates) === null || _a4 === void 0 ? void 0 : _a4[0].content);
          this._history.push(responseContent);
        } else {
          const blockErrorMessage = formatBlockErrorMessage(result.response);
          if (blockErrorMessage) {
            console.warn(`sendMessage() was unsuccessful. ${blockErrorMessage}. Inspect response object for details.`);
          }
        }
        finalResult = result;
      });
      await this._sendPromise;
      return finalResult;
    }
    /**
     * Sends a chat message and receives the response as a
     * {@link GenerateContentStreamResult} containing an iterable stream
     * and a response promise.
     *
     * Fields set in the optional {@link SingleRequestOptions} parameter will
     * take precedence over the {@link RequestOptions} values provided to
     * {@link GoogleGenerativeAI.getGenerativeModel }.
     */
    async sendMessageStream(request, requestOptions = {}) {
      var _a3, _b2, _c2, _d2, _e2, _f2;
      await this._sendPromise;
      const newContent = formatNewContent(request);
      const generateContentRequest = {
        safetySettings: (_a3 = this.params) === null || _a3 === void 0 ? void 0 : _a3.safetySettings,
        generationConfig: (_b2 = this.params) === null || _b2 === void 0 ? void 0 : _b2.generationConfig,
        tools: (_c2 = this.params) === null || _c2 === void 0 ? void 0 : _c2.tools,
        toolConfig: (_d2 = this.params) === null || _d2 === void 0 ? void 0 : _d2.toolConfig,
        systemInstruction: (_e2 = this.params) === null || _e2 === void 0 ? void 0 : _e2.systemInstruction,
        cachedContent: (_f2 = this.params) === null || _f2 === void 0 ? void 0 : _f2.cachedContent,
        contents: [...this._history, newContent]
      };
      const chatSessionRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
      const streamPromise = generateContentStream(this._apiKey, this.model, generateContentRequest, chatSessionRequestOptions);
      this._sendPromise = this._sendPromise.then(() => streamPromise).catch((_ignored2) => {
        throw new Error(SILENT_ERROR);
      }).then((streamResult) => streamResult.response).then((response) => {
        if (response.candidates && response.candidates.length > 0) {
          this._history.push(newContent);
          const responseContent = Object.assign({}, response.candidates[0].content);
          if (!responseContent.role) {
            responseContent.role = "model";
          }
          this._history.push(responseContent);
        } else {
          const blockErrorMessage = formatBlockErrorMessage(response);
          if (blockErrorMessage) {
            console.warn(`sendMessageStream() was unsuccessful. ${blockErrorMessage}. Inspect response object for details.`);
          }
        }
      }).catch((e) => {
        if (e.message !== SILENT_ERROR) {
          console.error(e);
        }
      });
      return streamPromise;
    }
  }
  /**
   * @license
   * Copyright 2024 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  async function countTokens(apiKey, model, params, singleRequestOptions) {
    const response = await makeModelRequest(model, Task.COUNT_TOKENS, apiKey, false, JSON.stringify(params), singleRequestOptions);
    return response.json();
  }
  /**
   * @license
   * Copyright 2024 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  async function embedContent(apiKey, model, params, requestOptions) {
    const response = await makeModelRequest(model, Task.EMBED_CONTENT, apiKey, false, JSON.stringify(params), requestOptions);
    return response.json();
  }
  async function batchEmbedContents(apiKey, model, params, requestOptions) {
    const requestsWithModel = params.requests.map((request) => {
      return Object.assign(Object.assign({}, request), { model });
    });
    const response = await makeModelRequest(model, Task.BATCH_EMBED_CONTENTS, apiKey, false, JSON.stringify({ requests: requestsWithModel }), requestOptions);
    return response.json();
  }
  /**
   * @license
   * Copyright 2024 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class GenerativeModel {
    constructor(apiKey, modelParams, _requestOptions = {}) {
      this.apiKey = apiKey;
      this._requestOptions = _requestOptions;
      if (modelParams.model.includes("/")) {
        this.model = modelParams.model;
      } else {
        this.model = `models/${modelParams.model}`;
      }
      this.generationConfig = modelParams.generationConfig || {};
      this.safetySettings = modelParams.safetySettings || [];
      this.tools = modelParams.tools;
      this.toolConfig = modelParams.toolConfig;
      this.systemInstruction = formatSystemInstruction(modelParams.systemInstruction);
      this.cachedContent = modelParams.cachedContent;
    }
    /**
     * Makes a single non-streaming call to the model
     * and returns an object containing a single {@link GenerateContentResponse}.
     *
     * Fields set in the optional {@link SingleRequestOptions} parameter will
     * take precedence over the {@link RequestOptions} values provided to
     * {@link GoogleGenerativeAI.getGenerativeModel }.
     */
    async generateContent(request, requestOptions = {}) {
      var _a3;
      const formattedParams = formatGenerateContentInput(request);
      const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
      return generateContent(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a3 = this.cachedContent) === null || _a3 === void 0 ? void 0 : _a3.name }, formattedParams), generativeModelRequestOptions);
    }
    /**
     * Makes a single streaming call to the model and returns an object
     * containing an iterable stream that iterates over all chunks in the
     * streaming response as well as a promise that returns the final
     * aggregated response.
     *
     * Fields set in the optional {@link SingleRequestOptions} parameter will
     * take precedence over the {@link RequestOptions} values provided to
     * {@link GoogleGenerativeAI.getGenerativeModel }.
     */
    async generateContentStream(request, requestOptions = {}) {
      var _a3;
      const formattedParams = formatGenerateContentInput(request);
      const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
      return generateContentStream(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a3 = this.cachedContent) === null || _a3 === void 0 ? void 0 : _a3.name }, formattedParams), generativeModelRequestOptions);
    }
    /**
     * Gets a new {@link ChatSession} instance which can be used for
     * multi-turn chats.
     */
    startChat(startChatParams) {
      var _a3;
      return new ChatSession(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a3 = this.cachedContent) === null || _a3 === void 0 ? void 0 : _a3.name }, startChatParams), this._requestOptions);
    }
    /**
     * Counts the tokens in the provided request.
     *
     * Fields set in the optional {@link SingleRequestOptions} parameter will
     * take precedence over the {@link RequestOptions} values provided to
     * {@link GoogleGenerativeAI.getGenerativeModel }.
     */
    async countTokens(request, requestOptions = {}) {
      const formattedParams = formatCountTokensInput(request, {
        model: this.model,
        generationConfig: this.generationConfig,
        safetySettings: this.safetySettings,
        tools: this.tools,
        toolConfig: this.toolConfig,
        systemInstruction: this.systemInstruction,
        cachedContent: this.cachedContent
      });
      const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
      return countTokens(this.apiKey, this.model, formattedParams, generativeModelRequestOptions);
    }
    /**
     * Embeds the provided content.
     *
     * Fields set in the optional {@link SingleRequestOptions} parameter will
     * take precedence over the {@link RequestOptions} values provided to
     * {@link GoogleGenerativeAI.getGenerativeModel }.
     */
    async embedContent(request, requestOptions = {}) {
      const formattedParams = formatEmbedContentInput(request);
      const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
      return embedContent(this.apiKey, this.model, formattedParams, generativeModelRequestOptions);
    }
    /**
     * Embeds an array of {@link EmbedContentRequest}s.
     *
     * Fields set in the optional {@link SingleRequestOptions} parameter will
     * take precedence over the {@link RequestOptions} values provided to
     * {@link GoogleGenerativeAI.getGenerativeModel }.
     */
    async batchEmbedContents(batchEmbedContentRequest, requestOptions = {}) {
      const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
      return batchEmbedContents(this.apiKey, this.model, batchEmbedContentRequest, generativeModelRequestOptions);
    }
  }
  /**
   * @license
   * Copyright 2024 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class GoogleGenerativeAI {
    constructor(apiKey) {
      this.apiKey = apiKey;
    }
    /**
     * Gets a {@link GenerativeModel} instance for the provided model name.
     */
    getGenerativeModel(modelParams, requestOptions) {
      if (!modelParams.model) {
        throw new GoogleGenerativeAIError(`Must provide a model name. Example: genai.getGenerativeModel({ model: 'my-model-name' })`);
      }
      return new GenerativeModel(this.apiKey, modelParams, requestOptions);
    }
    /**
     * Creates a {@link GenerativeModel} instance from provided content cache.
     */
    getGenerativeModelFromCachedContent(cachedContent, modelParams, requestOptions) {
      if (!cachedContent.name) {
        throw new GoogleGenerativeAIRequestInputError("Cached content must contain a `name` field.");
      }
      if (!cachedContent.model) {
        throw new GoogleGenerativeAIRequestInputError("Cached content must contain a `model` field.");
      }
      const disallowedDuplicates = ["model", "systemInstruction"];
      for (const key of disallowedDuplicates) {
        if ((modelParams === null || modelParams === void 0 ? void 0 : modelParams[key]) && cachedContent[key] && (modelParams === null || modelParams === void 0 ? void 0 : modelParams[key]) !== cachedContent[key]) {
          if (key === "model") {
            const modelParamsComp = modelParams.model.startsWith("models/") ? modelParams.model.replace("models/", "") : modelParams.model;
            const cachedContentComp = cachedContent.model.startsWith("models/") ? cachedContent.model.replace("models/", "") : cachedContent.model;
            if (modelParamsComp === cachedContentComp) {
              continue;
            }
          }
          throw new GoogleGenerativeAIRequestInputError(`Different value for "${key}" specified in modelParams (${modelParams[key]}) and cachedContent (${cachedContent[key]})`);
        }
      }
      const modelParamsFromCache = Object.assign(Object.assign({}, modelParams), { model: cachedContent.model, tools: cachedContent.tools, toolConfig: cachedContent.toolConfig, systemInstruction: cachedContent.systemInstruction, cachedContent });
      return new GenerativeModel(this.apiKey, modelParamsFromCache, requestOptions);
    }
  }
  function removeAdditionalProperties(obj) {
    if (typeof obj === "object" && obj !== null) {
      const newObj = { ...obj };
      if ("additionalProperties" in newObj) {
        delete newObj.additionalProperties;
      }
      if ("$schema" in newObj) {
        delete newObj.$schema;
      }
      for (const key in newObj) {
        if (key in newObj) {
          if (Array.isArray(newObj[key])) {
            newObj[key] = newObj[key].map(removeAdditionalProperties);
          } else if (typeof newObj[key] === "object" && newObj[key] !== null) {
            newObj[key] = removeAdditionalProperties(newObj[key]);
          }
        }
      }
      return newObj;
    }
    return obj;
  }
  function zodToGenerativeAIParameters(zodObj) {
    const jsonSchema = removeAdditionalProperties(zodToJsonSchema$4(zodObj));
    const { $schema, ...rest } = jsonSchema;
    return rest;
  }
  function jsonSchemaToGeminiParameters(schema) {
    const jsonSchema = removeAdditionalProperties(schema);
    const { $schema, ...rest } = jsonSchema;
    return rest;
  }
  function getMessageAuthor(message) {
    const type = message._getType();
    if (ChatMessage.isInstance(message)) {
      return message.role;
    }
    if (type === "tool") {
      return type;
    }
    return message.name ?? type;
  }
  function convertAuthorToRole(author) {
    switch (author) {
      /**
       *  Note: Gemini currently is not supporting system messages
       *  we will convert them to human messages and merge with following
       * */
      case "ai":
      case "model":
        return "model";
      case "system":
        return "system";
      case "human":
        return "user";
      case "tool":
      case "function":
        return "function";
      default:
        throw new Error(`Unknown / unsupported author: ${author}`);
    }
  }
  function messageContentMedia(content) {
    if ("mimeType" in content && "data" in content) {
      return {
        inlineData: {
          mimeType: content.mimeType,
          data: content.data
        }
      };
    }
    if ("mimeType" in content && "fileUri" in content) {
      return {
        fileData: {
          mimeType: content.mimeType,
          fileUri: content.fileUri
        }
      };
    }
    throw new Error("Invalid media content");
  }
  function convertMessageContentToParts(message, isMultimodalModel) {
    if (typeof message.content === "string" && message.content !== "") {
      return [{ text: message.content }];
    }
    let functionCalls = [];
    let functionResponses = [];
    let messageParts = [];
    if ("tool_calls" in message && Array.isArray(message.tool_calls) && message.tool_calls.length > 0) {
      functionCalls = message.tool_calls.map((tc) => ({
        functionCall: {
          name: tc.name,
          args: tc.args
        }
      }));
    } else if (message.getType() === "tool" && message.name && message.content) {
      functionResponses = [
        {
          functionResponse: {
            name: message.name,
            response: message.content
          }
        }
      ];
    } else if (Array.isArray(message.content)) {
      messageParts = message.content.map((c) => {
        var _a3;
        if (c.type === "text") {
          return {
            text: c.text
          };
        } else if (c.type === "executableCode") {
          return {
            executableCode: c.executableCode
          };
        } else if (c.type === "codeExecutionResult") {
          return {
            codeExecutionResult: c.codeExecutionResult
          };
        }
        if (c.type === "image_url") {
          if (!isMultimodalModel) {
            throw new Error(`This model does not support images`);
          }
          let source2;
          if (typeof c.image_url === "string") {
            source2 = c.image_url;
          } else if (typeof c.image_url === "object" && "url" in c.image_url) {
            source2 = c.image_url.url;
          } else {
            throw new Error("Please provide image as base64 encoded data URL");
          }
          const [dm, data] = source2.split(",");
          if (!dm.startsWith("data:")) {
            throw new Error("Please provide image as base64 encoded data URL");
          }
          const [mimeType, encoding] = dm.replace(/^data:/, "").split(";");
          if (encoding !== "base64") {
            throw new Error("Please provide image as base64 encoded data URL");
          }
          return {
            inlineData: {
              data,
              mimeType
            }
          };
        } else if (c.type === "media") {
          return messageContentMedia(c);
        } else if (c.type === "tool_use") {
          return {
            functionCall: {
              name: c.name,
              args: c.input
            }
          };
        } else if (((_a3 = c.type) == null ? void 0 : _a3.includes("/")) && // Ensure it's a single slash.
        c.type.split("/").length === 2 && "data" in c && typeof c.data === "string") {
          return {
            inlineData: {
              mimeType: c.type,
              data: c.data
            }
          };
        }
        throw new Error(`Unknown content type ${c.type}`);
      });
    }
    return [...messageParts, ...functionCalls, ...functionResponses];
  }
  function convertBaseMessagesToContent(messages, isMultimodalModel, convertSystemMessageToHumanContent = false) {
    return messages.reduce((acc, message, index) => {
      if (!isBaseMessage(message)) {
        throw new Error("Unsupported message input");
      }
      const author = getMessageAuthor(message);
      if (author === "system" && index !== 0) {
        throw new Error("System message should be the first one");
      }
      const role = convertAuthorToRole(author);
      const prevContent = acc.content[acc.content.length];
      if (!acc.mergeWithPreviousContent && prevContent && prevContent.role === role) {
        throw new Error("Google Generative AI requires alternate messages between authors");
      }
      const parts = convertMessageContentToParts(message, isMultimodalModel);
      if (acc.mergeWithPreviousContent) {
        const prevContent2 = acc.content[acc.content.length - 1];
        if (!prevContent2) {
          throw new Error("There was a problem parsing your system message. Please try a prompt without one.");
        }
        prevContent2.parts.push(...parts);
        return {
          mergeWithPreviousContent: false,
          content: acc.content
        };
      }
      let actualRole = role;
      if (actualRole === "function" || actualRole === "system" && !convertSystemMessageToHumanContent) {
        actualRole = "user";
      }
      const content = {
        role: actualRole,
        parts
      };
      return {
        mergeWithPreviousContent: author === "system" && !convertSystemMessageToHumanContent,
        content: [...acc.content, content]
      };
    }, { content: [], mergeWithPreviousContent: false }).content;
  }
  function mapGenerateContentResultToChatResult(response, extra) {
    var _a3, _b2, _c2;
    if (!response.candidates || response.candidates.length === 0 || !response.candidates[0]) {
      return {
        generations: [],
        llmOutput: {
          filters: response.promptFeedback
        }
      };
    }
    const functionCalls = response.functionCalls();
    const [candidate] = response.candidates;
    const { content: candidateContent, ...generationInfo } = candidate;
    let content;
    if ((candidateContent == null ? void 0 : candidateContent.parts.length) === 1 && candidateContent.parts[0].text) {
      content = candidateContent.parts[0].text;
    } else {
      content = candidateContent.parts.map((p) => {
        if ("text" in p) {
          return {
            type: "text",
            text: p.text
          };
        } else if ("executableCode" in p) {
          return {
            type: "executableCode",
            executableCode: p.executableCode
          };
        } else if ("codeExecutionResult" in p) {
          return {
            type: "codeExecutionResult",
            codeExecutionResult: p.codeExecutionResult
          };
        }
        return p;
      });
    }
    let text = "";
    if (typeof content === "string") {
      text = content;
    } else if ("text" in content[0]) {
      text = content[0].text;
    }
    const generation = {
      text,
      message: new AIMessage({
        content,
        tool_calls: functionCalls == null ? void 0 : functionCalls.map((fc) => ({
          ...fc,
          type: "tool_call"
        })),
        additional_kwargs: {
          ...generationInfo
        },
        usage_metadata: extra == null ? void 0 : extra.usageMetadata
      }),
      generationInfo
    };
    return {
      generations: [generation],
      llmOutput: {
        tokenUsage: {
          promptTokens: (_a3 = extra == null ? void 0 : extra.usageMetadata) == null ? void 0 : _a3.input_tokens,
          completionTokens: (_b2 = extra == null ? void 0 : extra.usageMetadata) == null ? void 0 : _b2.output_tokens,
          totalTokens: (_c2 = extra == null ? void 0 : extra.usageMetadata) == null ? void 0 : _c2.total_tokens
        }
      }
    };
  }
  function convertResponseContentToChatGenerationChunk(response, extra) {
    if (!response.candidates || response.candidates.length === 0) {
      return null;
    }
    const functionCalls = response.functionCalls();
    const [candidate] = response.candidates;
    const { content: candidateContent, ...generationInfo } = candidate;
    let content;
    if ((candidateContent == null ? void 0 : candidateContent.parts) && candidateContent.parts.every((p) => "text" in p)) {
      content = candidateContent.parts.map((p) => p.text).join("");
    } else if (candidateContent.parts) {
      content = candidateContent.parts.map((p) => {
        if ("text" in p) {
          return {
            type: "text",
            text: p.text
          };
        } else if ("executableCode" in p) {
          return {
            type: "executableCode",
            executableCode: p.executableCode
          };
        } else if ("codeExecutionResult" in p) {
          return {
            type: "codeExecutionResult",
            codeExecutionResult: p.codeExecutionResult
          };
        }
        return p;
      });
    }
    let text = "";
    if (content && typeof content === "string") {
      text = content;
    } else if (content && typeof content === "object" && "text" in content[0]) {
      text = content[0].text;
    }
    const toolCallChunks = [];
    if (functionCalls) {
      toolCallChunks.push(...functionCalls.map((fc) => ({
        ...fc,
        args: JSON.stringify(fc.args),
        index: extra.index,
        type: "tool_call_chunk"
      })));
    }
    return new ChatGenerationChunk({
      text,
      message: new AIMessageChunk({
        content: content || "",
        name: !candidateContent ? void 0 : candidateContent.role,
        tool_call_chunks: toolCallChunks,
        // Each chunk can have unique "generationInfo", and merging strategy is unclear,
        // so leave blank for now.
        additional_kwargs: {},
        usage_metadata: extra.usageMetadata
      }),
      generationInfo
    });
  }
  function convertToGenerativeAITools(tools) {
    if (tools.every((tool) => "functionDeclarations" in tool && Array.isArray(tool.functionDeclarations))) {
      return tools;
    }
    return [
      {
        functionDeclarations: tools.map((tool) => {
          if (isLangChainTool(tool)) {
            const jsonSchema = zodToGenerativeAIParameters(tool.schema);
            return {
              name: tool.name,
              description: tool.description,
              parameters: jsonSchema
            };
          }
          if (isOpenAITool(tool)) {
            return {
              name: tool.function.name,
              description: tool.function.description ?? `A function available to call.`,
              parameters: jsonSchemaToGeminiParameters(tool.function.parameters)
            };
          }
          return tool;
        })
      }
    ];
  }
  class GoogleGenerativeAIToolsOutputParser extends BaseLLMOutputParser {
    static lc_name() {
      return "GoogleGenerativeAIToolsOutputParser";
    }
    constructor(params) {
      super(params);
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ["langchain", "google_genai", "output_parsers"]
      });
      Object.defineProperty(this, "returnId", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "keyName", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "returnSingle", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "zodSchema", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.keyName = params.keyName;
      this.returnSingle = params.returnSingle ?? this.returnSingle;
      this.zodSchema = params.zodSchema;
    }
    async _validateResult(result) {
      if (this.zodSchema === void 0) {
        return result;
      }
      const zodParsedResult = await this.zodSchema.safeParseAsync(result);
      if (zodParsedResult.success) {
        return zodParsedResult.data;
      } else {
        throw new OutputParserException(`Failed to parse. Text: "${JSON.stringify(result, null, 2)}". Error: ${JSON.stringify(zodParsedResult.error.errors)}`, JSON.stringify(result, null, 2));
      }
    }
    async parseResult(generations) {
      const tools = generations.flatMap((generation) => {
        const { message } = generation;
        if (!("tool_calls" in message) || !Array.isArray(message.tool_calls)) {
          return [];
        }
        return message.tool_calls;
      });
      if (tools[0] === void 0) {
        throw new Error("No parseable tool calls provided to GoogleGenerativeAIToolsOutputParser.");
      }
      const [tool] = tools;
      const validatedResult = await this._validateResult(tool.args);
      return validatedResult;
    }
  }
  function convertToolsToGenAI(tools, extra) {
    const genAITools = processTools(tools);
    const toolConfig = createToolConfig(genAITools, extra);
    return { tools: genAITools, toolConfig };
  }
  function processTools(tools) {
    let functionDeclarationTools = [];
    const genAITools = [];
    tools.forEach((tool) => {
      if (isLangChainTool(tool)) {
        const [convertedTool] = convertToGenerativeAITools([
          tool
        ]);
        if (convertedTool.functionDeclarations) {
          functionDeclarationTools.push(...convertedTool.functionDeclarations);
        }
      } else if (isOpenAITool(tool)) {
        const { functionDeclarations } = convertOpenAIToolToGenAI(tool);
        if (functionDeclarations) {
          functionDeclarationTools.push(...functionDeclarations);
        } else {
          throw new Error("Failed to convert OpenAI structured tool to GenerativeAI tool");
        }
      } else {
        genAITools.push(tool);
      }
    });
    const genAIFunctionDeclaration = genAITools.find((t) => "functionDeclarations" in t);
    if (genAIFunctionDeclaration) {
      return genAITools.map((tool) => {
        if ((functionDeclarationTools == null ? void 0 : functionDeclarationTools.length) > 0 && "functionDeclarations" in tool) {
          const newTool = {
            functionDeclarations: [
              ...tool.functionDeclarations || [],
              ...functionDeclarationTools
            ]
          };
          functionDeclarationTools = [];
          return newTool;
        }
        return tool;
      });
    }
    return [
      ...genAITools,
      ...functionDeclarationTools.length > 0 ? [
        {
          functionDeclarations: functionDeclarationTools
        }
      ] : []
    ];
  }
  function convertOpenAIToolToGenAI(tool) {
    return {
      functionDeclarations: [
        {
          name: tool.function.name,
          description: tool.function.description,
          parameters: removeAdditionalProperties(tool.function.parameters)
        }
      ]
    };
  }
  function createToolConfig(genAITools, extra) {
    if (!genAITools.length || !extra)
      return void 0;
    const { toolChoice, allowedFunctionNames } = extra;
    const modeMap = {
      any: FunctionCallingMode.ANY,
      auto: FunctionCallingMode.AUTO,
      none: FunctionCallingMode.NONE
    };
    if (toolChoice && ["any", "auto", "none"].includes(toolChoice)) {
      return {
        functionCallingConfig: {
          mode: modeMap[toolChoice] ?? "MODE_UNSPECIFIED",
          allowedFunctionNames
        }
      };
    }
    if (typeof toolChoice === "string" || allowedFunctionNames) {
      return {
        functionCallingConfig: {
          mode: FunctionCallingMode.ANY,
          allowedFunctionNames: [
            ...allowedFunctionNames ?? [],
            ...toolChoice && typeof toolChoice === "string" ? [toolChoice] : []
          ]
        }
      };
    }
    return void 0;
  }
  class ChatGoogleGenerativeAI extends BaseChatModel {
    static lc_name() {
      return "ChatGoogleGenerativeAI";
    }
    get lc_secrets() {
      return {
        apiKey: "GOOGLE_API_KEY"
      };
    }
    get lc_aliases() {
      return {
        apiKey: "google_api_key"
      };
    }
    get _isMultimodalModel() {
      return this.model.includes("vision") || this.model.startsWith("gemini-1.5") || this.model.startsWith("gemini-2");
    }
    constructor(fields) {
      var _a3, _b2;
      super(fields ?? {});
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ["langchain", "chat_models", "google_genai"]
      });
      Object.defineProperty(this, "modelName", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "gemini-pro"
      });
      Object.defineProperty(this, "model", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "gemini-pro"
      });
      Object.defineProperty(this, "temperature", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "maxOutputTokens", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "topP", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "topK", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "stopSequences", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
      Object.defineProperty(this, "safetySettings", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "apiKey", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "streaming", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "streamUsage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "convertSystemMessageToHumanContent", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "client", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.modelName = ((_a3 = fields == null ? void 0 : fields.model) == null ? void 0 : _a3.replace(/^models\//, "")) ?? ((_b2 = fields == null ? void 0 : fields.modelName) == null ? void 0 : _b2.replace(/^models\//, "")) ?? this.model;
      this.model = this.modelName;
      this.maxOutputTokens = (fields == null ? void 0 : fields.maxOutputTokens) ?? this.maxOutputTokens;
      if (this.maxOutputTokens && this.maxOutputTokens < 0) {
        throw new Error("`maxOutputTokens` must be a positive integer");
      }
      this.temperature = (fields == null ? void 0 : fields.temperature) ?? this.temperature;
      if (this.temperature && (this.temperature < 0 || this.temperature > 2)) {
        throw new Error("`temperature` must be in the range of [0.0,2.0]");
      }
      this.topP = (fields == null ? void 0 : fields.topP) ?? this.topP;
      if (this.topP && this.topP < 0) {
        throw new Error("`topP` must be a positive integer");
      }
      if (this.topP && this.topP > 1) {
        throw new Error("`topP` must be below 1.");
      }
      this.topK = (fields == null ? void 0 : fields.topK) ?? this.topK;
      if (this.topK && this.topK < 0) {
        throw new Error("`topK` must be a positive integer");
      }
      this.stopSequences = (fields == null ? void 0 : fields.stopSequences) ?? this.stopSequences;
      this.apiKey = (fields == null ? void 0 : fields.apiKey) ?? getEnvironmentVariable("GOOGLE_API_KEY");
      if (!this.apiKey) {
        throw new Error("Please set an API key for Google GenerativeAI in the environment variable GOOGLE_API_KEY or in the `apiKey` field of the ChatGoogleGenerativeAI constructor");
      }
      this.safetySettings = (fields == null ? void 0 : fields.safetySettings) ?? this.safetySettings;
      if (this.safetySettings && this.safetySettings.length > 0) {
        const safetySettingsSet = new Set(this.safetySettings.map((s) => s.category));
        if (safetySettingsSet.size !== this.safetySettings.length) {
          throw new Error("The categories in `safetySettings` array must be unique");
        }
      }
      this.streaming = (fields == null ? void 0 : fields.streaming) ?? this.streaming;
      this.client = new GoogleGenerativeAI(this.apiKey).getGenerativeModel({
        model: this.model,
        safetySettings: this.safetySettings,
        generationConfig: {
          candidateCount: 1,
          stopSequences: this.stopSequences,
          maxOutputTokens: this.maxOutputTokens,
          temperature: this.temperature,
          topP: this.topP,
          topK: this.topK,
          ...(fields == null ? void 0 : fields.json) ? { responseMimeType: "application/json" } : {}
        }
      }, {
        apiVersion: fields == null ? void 0 : fields.apiVersion,
        baseUrl: fields == null ? void 0 : fields.baseUrl
      });
      this.streamUsage = (fields == null ? void 0 : fields.streamUsage) ?? this.streamUsage;
    }
    useCachedContent(cachedContent, modelParams, requestOptions) {
      if (!this.apiKey)
        return;
      this.client = new GoogleGenerativeAI(this.apiKey).getGenerativeModelFromCachedContent(cachedContent, modelParams, requestOptions);
    }
    get useSystemInstruction() {
      return typeof this.convertSystemMessageToHumanContent === "boolean" ? !this.convertSystemMessageToHumanContent : this.computeUseSystemInstruction;
    }
    get computeUseSystemInstruction() {
      if (this.modelName === "gemini-1.0-pro-001") {
        return false;
      } else if (this.modelName.startsWith("gemini-pro-vision")) {
        return false;
      } else if (this.modelName.startsWith("gemini-1.0-pro-vision")) {
        return false;
      } else if (this.modelName === "gemini-pro") {
        return false;
      }
      return true;
    }
    getLsParams(options) {
      return {
        ls_provider: "google_genai",
        ls_model_name: this.model,
        ls_model_type: "chat",
        ls_temperature: this.client.generationConfig.temperature,
        ls_max_tokens: this.client.generationConfig.maxOutputTokens,
        ls_stop: options.stop
      };
    }
    _combineLLMOutput() {
      return [];
    }
    _llmType() {
      return "googlegenerativeai";
    }
    bindTools(tools, kwargs) {
      var _a3;
      return this.bind({ tools: (_a3 = convertToolsToGenAI(tools)) == null ? void 0 : _a3.tools, ...kwargs });
    }
    invocationParams(options) {
      var _a3;
      const toolsAndConfig = ((_a3 = options == null ? void 0 : options.tools) == null ? void 0 : _a3.length) ? convertToolsToGenAI(options.tools, {
        toolChoice: options.tool_choice,
        allowedFunctionNames: options.allowedFunctionNames
      }) : void 0;
      return {
        ...(toolsAndConfig == null ? void 0 : toolsAndConfig.tools) ? { tools: toolsAndConfig.tools } : {},
        ...(toolsAndConfig == null ? void 0 : toolsAndConfig.toolConfig) ? { toolConfig: toolsAndConfig.toolConfig } : {}
      };
    }
    async _generate(messages, options, runManager) {
      var _a3;
      const prompt = convertBaseMessagesToContent(messages, this._isMultimodalModel, this.useSystemInstruction);
      let actualPrompt = prompt;
      if (prompt[0].role === "system") {
        const [systemInstruction] = prompt;
        this.client.systemInstruction = systemInstruction;
        actualPrompt = prompt.slice(1);
      }
      const parameters = this.invocationParams(options);
      if (this.streaming) {
        const tokenUsage = {};
        const stream = this._streamResponseChunks(messages, options, runManager);
        const finalChunks = {};
        for await (const chunk of stream) {
          const index = ((_a3 = chunk.generationInfo) == null ? void 0 : _a3.completion) ?? 0;
          if (finalChunks[index] === void 0) {
            finalChunks[index] = chunk;
          } else {
            finalChunks[index] = finalChunks[index].concat(chunk);
          }
        }
        const generations = Object.entries(finalChunks).sort(([aKey], [bKey]) => parseInt(aKey, 10) - parseInt(bKey, 10)).map(([_, value]) => value);
        return { generations, llmOutput: { estimatedTokenUsage: tokenUsage } };
      }
      const res = await this.completionWithRetry({
        ...parameters,
        contents: actualPrompt
      });
      let usageMetadata;
      if ("usageMetadata" in res.response) {
        const genAIUsageMetadata = res.response.usageMetadata;
        usageMetadata = {
          input_tokens: genAIUsageMetadata.promptTokenCount ?? 0,
          output_tokens: genAIUsageMetadata.candidatesTokenCount ?? 0,
          total_tokens: genAIUsageMetadata.totalTokenCount ?? 0
        };
      }
      const generationResult = mapGenerateContentResultToChatResult(res.response, {
        usageMetadata
      });
      await (runManager == null ? void 0 : runManager.handleLLMNewToken(generationResult.generations[0].text ?? ""));
      return generationResult;
    }
    async *_streamResponseChunks(messages, options, runManager) {
      const prompt = convertBaseMessagesToContent(messages, this._isMultimodalModel, this.useSystemInstruction);
      let actualPrompt = prompt;
      if (prompt[0].role === "system") {
        const [systemInstruction] = prompt;
        this.client.systemInstruction = systemInstruction;
        actualPrompt = prompt.slice(1);
      }
      const parameters = this.invocationParams(options);
      const request = {
        ...parameters,
        contents: actualPrompt
      };
      const stream = await this.caller.callWithOptions({ signal: options == null ? void 0 : options.signal }, async () => {
        const { stream: stream2 } = await this.client.generateContentStream(request);
        return stream2;
      });
      let usageMetadata;
      let index = 0;
      for await (const response of stream) {
        if ("usageMetadata" in response && this.streamUsage !== false && options.streamUsage !== false) {
          const genAIUsageMetadata = response.usageMetadata;
          if (!usageMetadata) {
            usageMetadata = {
              input_tokens: genAIUsageMetadata.promptTokenCount ?? 0,
              output_tokens: genAIUsageMetadata.candidatesTokenCount ?? 0,
              total_tokens: genAIUsageMetadata.totalTokenCount ?? 0
            };
          } else {
            const outputTokenDiff = (genAIUsageMetadata.candidatesTokenCount ?? 0) - usageMetadata.output_tokens;
            usageMetadata = {
              input_tokens: 0,
              output_tokens: outputTokenDiff,
              total_tokens: outputTokenDiff
            };
          }
        }
        const chunk = convertResponseContentToChatGenerationChunk(response, {
          usageMetadata,
          index
        });
        index += 1;
        if (!chunk) {
          continue;
        }
        yield chunk;
        await (runManager == null ? void 0 : runManager.handleLLMNewToken(chunk.text ?? ""));
      }
    }
    async completionWithRetry(request, options) {
      return this.caller.callWithOptions({ signal: options == null ? void 0 : options.signal }, async () => {
        var _a3;
        try {
          return await this.client.generateContent(request);
        } catch (e) {
          if ((_a3 = e.message) == null ? void 0 : _a3.includes("400 Bad Request")) {
            e.status = 400;
          }
          throw e;
        }
      });
    }
    withStructuredOutput(outputSchema, config2) {
      const schema = outputSchema;
      const name = config2 == null ? void 0 : config2.name;
      const method = config2 == null ? void 0 : config2.method;
      const includeRaw = config2 == null ? void 0 : config2.includeRaw;
      if (method === "jsonMode") {
        throw new Error(`ChatGoogleGenerativeAI only supports "functionCalling" as a method.`);
      }
      let functionName = name ?? "extract";
      let outputParser;
      let tools;
      if (isZodSchema$2(schema)) {
        const jsonSchema = zodToGenerativeAIParameters(schema);
        tools = [
          {
            functionDeclarations: [
              {
                name: functionName,
                description: jsonSchema.description ?? "A function available to call.",
                parameters: jsonSchema
              }
            ]
          }
        ];
        outputParser = new GoogleGenerativeAIToolsOutputParser({
          returnSingle: true,
          keyName: functionName,
          zodSchema: schema
        });
      } else {
        let geminiFunctionDefinition;
        if (typeof schema.name === "string" && typeof schema.parameters === "object" && schema.parameters != null) {
          geminiFunctionDefinition = schema;
          functionName = schema.name;
        } else {
          geminiFunctionDefinition = {
            name: functionName,
            description: schema.description ?? "",
            parameters: schema
          };
        }
        tools = [
          {
            functionDeclarations: [geminiFunctionDefinition]
          }
        ];
        outputParser = new GoogleGenerativeAIToolsOutputParser({
          returnSingle: true,
          keyName: functionName
        });
      }
      const llm = this.bind({
        tools,
        tool_choice: functionName
      });
      if (!includeRaw) {
        return llm.pipe(outputParser).withConfig({
          runName: "ChatGoogleGenerativeAIStructuredOutput"
        });
      }
      const parserAssign = RunnablePassthrough.assign({
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        parsed: (input, config3) => outputParser.invoke(input.raw, config3)
      });
      const parserNone = RunnablePassthrough.assign({
        parsed: () => null
      });
      const parsedWithFallback = parserAssign.withFallbacks({
        fallbacks: [parserNone]
      });
      return RunnableSequence.from([
        {
          raw: llm
        },
        parsedWithFallback
      ]).withConfig({
        runName: "StructuredOutputRunnable"
      });
    }
  }
  const default_format = "RFC3986";
  const formatters = {
    RFC1738: (v) => String(v).replace(/%20/g, "+"),
    RFC3986: (v) => String(v)
  };
  const RFC1738 = "RFC1738";
  const is_array$1 = Array.isArray;
  const hex_table = (() => {
    const array = [];
    for (let i2 = 0; i2 < 256; ++i2) {
      array.push("%" + ((i2 < 16 ? "0" : "") + i2.toString(16)).toUpperCase());
    }
    return array;
  })();
  const limit = 1024;
  const encode = (str2, _defaultEncoder, charset, _kind, format) => {
    if (str2.length === 0) {
      return str2;
    }
    let string = str2;
    if (typeof str2 === "symbol") {
      string = Symbol.prototype.toString.call(str2);
    } else if (typeof str2 !== "string") {
      string = String(str2);
    }
    if (charset === "iso-8859-1") {
      return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
        return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
      });
    }
    let out = "";
    for (let j = 0; j < string.length; j += limit) {
      const segment = string.length >= limit ? string.slice(j, j + limit) : string;
      const arr2 = [];
      for (let i2 = 0; i2 < segment.length; ++i2) {
        let c = segment.charCodeAt(i2);
        if (c === 45 || // -
        c === 46 || // .
        c === 95 || // _
        c === 126 || // ~
        c >= 48 && c <= 57 || // 0-9
        c >= 65 && c <= 90 || // a-z
        c >= 97 && c <= 122 || // A-Z
        format === RFC1738 && (c === 40 || c === 41)) {
          arr2[arr2.length] = segment.charAt(i2);
          continue;
        }
        if (c < 128) {
          arr2[arr2.length] = hex_table[c];
          continue;
        }
        if (c < 2048) {
          arr2[arr2.length] = hex_table[192 | c >> 6] + hex_table[128 | c & 63];
          continue;
        }
        if (c < 55296 || c >= 57344) {
          arr2[arr2.length] = hex_table[224 | c >> 12] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
          continue;
        }
        i2 += 1;
        c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i2) & 1023);
        arr2[arr2.length] = hex_table[240 | c >> 18] + hex_table[128 | c >> 12 & 63] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
      }
      out += arr2.join("");
    }
    return out;
  };
  function is_buffer(obj) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
  }
  function maybe_map(val, fn) {
    if (is_array$1(val)) {
      const mapped = [];
      for (let i2 = 0; i2 < val.length; i2 += 1) {
        mapped.push(fn(val[i2]));
      }
      return mapped;
    }
    return fn(val);
  }
  const has = Object.prototype.hasOwnProperty;
  const array_prefix_generators = {
    brackets(prefix) {
      return String(prefix) + "[]";
    },
    comma: "comma",
    indices(prefix, key) {
      return String(prefix) + "[" + key + "]";
    },
    repeat(prefix) {
      return String(prefix);
    }
  };
  const is_array = Array.isArray;
  const push = Array.prototype.push;
  const push_to_array = function(arr2, value_or_array) {
    push.apply(arr2, is_array(value_or_array) ? value_or_array : [value_or_array]);
  };
  const to_ISO = Date.prototype.toISOString;
  const defaults = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: "indices",
    charset: "utf-8",
    charsetSentinel: false,
    delimiter: "&",
    encode: true,
    encodeDotInKeys: false,
    encoder: encode,
    encodeValuesOnly: false,
    format: default_format,
    formatter: formatters[default_format],
    /** @deprecated */
    indices: false,
    serializeDate(date) {
      return to_ISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
  };
  function is_non_nullish_primitive(v) {
    return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
  }
  const sentinel = {};
  function inner_stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter2, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
    let obj = object;
    let tmp_sc = sideChannel;
    let step = 0;
    let find_flag = false;
    while ((tmp_sc = tmp_sc.get(sentinel)) !== void 0 && !find_flag) {
      const pos = tmp_sc.get(object);
      step += 1;
      if (typeof pos !== "undefined") {
        if (pos === step) {
          throw new RangeError("Cyclic object value");
        } else {
          find_flag = true;
        }
      }
      if (typeof tmp_sc.get(sentinel) === "undefined") {
        step = 0;
      }
    }
    if (typeof filter2 === "function") {
      obj = filter2(prefix, obj);
    } else if (obj instanceof Date) {
      obj = serializeDate == null ? void 0 : serializeDate(obj);
    } else if (generateArrayPrefix === "comma" && is_array(obj)) {
      obj = maybe_map(obj, function(value) {
        if (value instanceof Date) {
          return serializeDate == null ? void 0 : serializeDate(value);
        }
        return value;
      });
    }
    if (obj === null) {
      if (strictNullHandling) {
        return encoder && !encodeValuesOnly ? (
          // @ts-expect-error
          encoder(prefix, defaults.encoder, charset, "key", format)
        ) : prefix;
      }
      obj = "";
    }
    if (is_non_nullish_primitive(obj) || is_buffer(obj)) {
      if (encoder) {
        const key_value = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
        return [
          (formatter == null ? void 0 : formatter(key_value)) + "=" + // @ts-expect-error
          (formatter == null ? void 0 : formatter(encoder(obj, defaults.encoder, charset, "value", format)))
        ];
      }
      return [(formatter == null ? void 0 : formatter(prefix)) + "=" + (formatter == null ? void 0 : formatter(String(obj)))];
    }
    const values = [];
    if (typeof obj === "undefined") {
      return values;
    }
    let obj_keys;
    if (generateArrayPrefix === "comma" && is_array(obj)) {
      if (encodeValuesOnly && encoder) {
        obj = maybe_map(obj, encoder);
      }
      obj_keys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
    } else if (is_array(filter2)) {
      obj_keys = filter2;
    } else {
      const keys = Object.keys(obj);
      obj_keys = sort ? keys.sort(sort) : keys;
    }
    const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
    const adjusted_prefix = commaRoundTrip && is_array(obj) && obj.length === 1 ? encoded_prefix + "[]" : encoded_prefix;
    if (allowEmptyArrays && is_array(obj) && obj.length === 0) {
      return adjusted_prefix + "[]";
    }
    for (let j = 0; j < obj_keys.length; ++j) {
      const key = obj_keys[j];
      const value = (
        // @ts-ignore
        typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key]
      );
      if (skipNulls && value === null) {
        continue;
      }
      const encoded_key = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
      const key_prefix = is_array(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjusted_prefix, encoded_key) : adjusted_prefix : adjusted_prefix + (allowDots ? "." + encoded_key : "[" + encoded_key + "]");
      sideChannel.set(object, step);
      const valueSideChannel = /* @__PURE__ */ new WeakMap();
      valueSideChannel.set(sentinel, sideChannel);
      push_to_array(values, inner_stringify(
        value,
        key_prefix,
        generateArrayPrefix,
        commaRoundTrip,
        allowEmptyArrays,
        strictNullHandling,
        skipNulls,
        encodeDotInKeys,
        // @ts-ignore
        generateArrayPrefix === "comma" && encodeValuesOnly && is_array(obj) ? null : encoder,
        filter2,
        sort,
        allowDots,
        serializeDate,
        format,
        formatter,
        encodeValuesOnly,
        charset,
        valueSideChannel
      ));
    }
    return values;
  }
  function normalize_stringify_options(opts = defaults) {
    if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    }
    if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
      throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
    }
    if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
      throw new TypeError("Encoder has to be a function.");
    }
    const charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    let format = default_format;
    if (typeof opts.format !== "undefined") {
      if (!has.call(formatters, opts.format)) {
        throw new TypeError("Unknown format option provided.");
      }
      format = opts.format;
    }
    const formatter = formatters[format];
    let filter2 = defaults.filter;
    if (typeof opts.filter === "function" || is_array(opts.filter)) {
      filter2 = opts.filter;
    }
    let arrayFormat;
    if (opts.arrayFormat && opts.arrayFormat in array_prefix_generators) {
      arrayFormat = opts.arrayFormat;
    } else if ("indices" in opts) {
      arrayFormat = opts.indices ? "indices" : "repeat";
    } else {
      arrayFormat = defaults.arrayFormat;
    }
    if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
      throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    }
    const allowDots = typeof opts.allowDots === "undefined" ? !!opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
    return {
      addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
      // @ts-ignore
      allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
      arrayFormat,
      charset,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
      commaRoundTrip: !!opts.commaRoundTrip,
      delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
      encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
      encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
      encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
      encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
      filter: filter2,
      format,
      formatter,
      serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
      skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
      // @ts-ignore
      sort: typeof opts.sort === "function" ? opts.sort : null,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
    };
  }
  function stringify(object, opts = {}) {
    let obj = object;
    const options = normalize_stringify_options(opts);
    let obj_keys;
    let filter2;
    if (typeof options.filter === "function") {
      filter2 = options.filter;
      obj = filter2("", obj);
    } else if (is_array(options.filter)) {
      filter2 = options.filter;
      obj_keys = filter2;
    }
    const keys = [];
    if (typeof obj !== "object" || obj === null) {
      return "";
    }
    const generateArrayPrefix = array_prefix_generators[options.arrayFormat];
    const commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
    if (!obj_keys) {
      obj_keys = Object.keys(obj);
    }
    if (options.sort) {
      obj_keys.sort(options.sort);
    }
    const sideChannel = /* @__PURE__ */ new WeakMap();
    for (let i2 = 0; i2 < obj_keys.length; ++i2) {
      const key = obj_keys[i2];
      if (options.skipNulls && obj[key] === null) {
        continue;
      }
      push_to_array(keys, inner_stringify(
        obj[key],
        key,
        // @ts-expect-error
        generateArrayPrefix,
        commaRoundTrip,
        options.allowEmptyArrays,
        options.strictNullHandling,
        options.skipNulls,
        options.encodeDotInKeys,
        options.encode ? options.encoder : null,
        options.filter,
        options.sort,
        options.allowDots,
        options.serializeDate,
        options.format,
        options.formatter,
        options.encodeValuesOnly,
        options.charset,
        sideChannel
      ));
    }
    const joined = keys.join(options.delimiter);
    let prefix = options.addQueryPrefix === true ? "?" : "";
    if (options.charsetSentinel) {
      if (options.charset === "iso-8859-1") {
        prefix += "utf8=%26%2310003%3B&";
      } else {
        prefix += "utf8=%E2%9C%93&";
      }
    }
    return joined.length > 0 ? prefix + joined : "";
  }
  const VERSION = "4.82.0";
  let auto = false;
  let kind = void 0;
  let fetch$2 = void 0;
  let FormData$1 = void 0;
  let File$1 = void 0;
  let ReadableStream$1 = void 0;
  let getMultipartRequestOptions = void 0;
  let getDefaultAgent = void 0;
  let fileFromPath = void 0;
  let isFsReadStream = void 0;
  function setShims(shims, options = { auto: false }) {
    if (auto) {
      throw new Error(`you must \`import 'openai/shims/${shims.kind}'\` before importing anything else from openai`);
    }
    if (kind) {
      throw new Error(`can't \`import 'openai/shims/${shims.kind}'\` after \`import 'openai/shims/${kind}'\``);
    }
    auto = options.auto;
    kind = shims.kind;
    fetch$2 = shims.fetch;
    FormData$1 = shims.FormData;
    File$1 = shims.File;
    ReadableStream$1 = shims.ReadableStream;
    getMultipartRequestOptions = shims.getMultipartRequestOptions;
    getDefaultAgent = shims.getDefaultAgent;
    fileFromPath = shims.fileFromPath;
    isFsReadStream = shims.isFsReadStream;
  }
  class MultipartBody {
    constructor(body) {
      this.body = body;
    }
    get [Symbol.toStringTag]() {
      return "MultipartBody";
    }
  }
  function getRuntime({ manuallyImported } = {}) {
    const recommendation = manuallyImported ? `You may need to use polyfills` : `Add one of these imports before your first \`import … from 'openai'\`:
- \`import 'openai/shims/node'\` (if you're running on Node)
- \`import 'openai/shims/web'\` (otherwise)
`;
    let _fetch, _Request, _Response, _Headers;
    try {
      _fetch = fetch;
      _Request = Request;
      _Response = Response;
      _Headers = Headers;
    } catch (error) {
      throw new Error(`this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`);
    }
    return {
      kind: "web",
      fetch: _fetch,
      Request: _Request,
      Response: _Response,
      Headers: _Headers,
      FormData: (
        // @ts-ignore
        typeof FormData !== "undefined" ? FormData : class FormData {
          // @ts-ignore
          constructor() {
            throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);
          }
        }
      ),
      Blob: typeof Blob !== "undefined" ? Blob : class Blob {
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);
        }
      },
      File: (
        // @ts-ignore
        typeof File !== "undefined" ? File : class File {
          // @ts-ignore
          constructor() {
            throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);
          }
        }
      ),
      ReadableStream: (
        // @ts-ignore
        typeof ReadableStream !== "undefined" ? ReadableStream : class ReadableStream {
          // @ts-ignore
          constructor() {
            throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`);
          }
        }
      ),
      getMultipartRequestOptions: async (form, opts) => ({
        ...opts,
        body: new MultipartBody(form)
      }),
      getDefaultAgent: (url) => void 0,
      fileFromPath: () => {
        throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads");
      },
      isFsReadStream: (value) => false
    };
  }
  if (!kind) setShims(getRuntime(), { auto: true });
  class OpenAIError extends Error {
  }
  class APIError extends OpenAIError {
    constructor(status, error, message, headers) {
      super(`${APIError.makeMessage(status, error, message)}`);
      this.status = status;
      this.headers = headers;
      this.request_id = headers == null ? void 0 : headers["x-request-id"];
      this.error = error;
      const data = error;
      this.code = data == null ? void 0 : data["code"];
      this.param = data == null ? void 0 : data["param"];
      this.type = data == null ? void 0 : data["type"];
    }
    static makeMessage(status, error, message) {
      const msg = (error == null ? void 0 : error.message) ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
      if (status && msg) {
        return `${status} ${msg}`;
      }
      if (status) {
        return `${status} status code (no body)`;
      }
      if (msg) {
        return msg;
      }
      return "(no status code or body)";
    }
    static generate(status, errorResponse, message, headers) {
      if (!status || !headers) {
        return new APIConnectionError({ message, cause: castToError(errorResponse) });
      }
      const error = errorResponse == null ? void 0 : errorResponse["error"];
      if (status === 400) {
        return new BadRequestError(status, error, message, headers);
      }
      if (status === 401) {
        return new AuthenticationError(status, error, message, headers);
      }
      if (status === 403) {
        return new PermissionDeniedError(status, error, message, headers);
      }
      if (status === 404) {
        return new NotFoundError(status, error, message, headers);
      }
      if (status === 409) {
        return new ConflictError(status, error, message, headers);
      }
      if (status === 422) {
        return new UnprocessableEntityError(status, error, message, headers);
      }
      if (status === 429) {
        return new RateLimitError(status, error, message, headers);
      }
      if (status >= 500) {
        return new InternalServerError(status, error, message, headers);
      }
      return new APIError(status, error, message, headers);
    }
  }
  class APIUserAbortError extends APIError {
    constructor({ message } = {}) {
      super(void 0, void 0, message || "Request was aborted.", void 0);
    }
  }
  class APIConnectionError extends APIError {
    constructor({ message, cause }) {
      super(void 0, void 0, message || "Connection error.", void 0);
      if (cause)
        this.cause = cause;
    }
  }
  class APIConnectionTimeoutError extends APIConnectionError {
    constructor({ message } = {}) {
      super({ message: message ?? "Request timed out." });
    }
  }
  class BadRequestError extends APIError {
  }
  class AuthenticationError extends APIError {
  }
  class PermissionDeniedError extends APIError {
  }
  class NotFoundError extends APIError {
  }
  class ConflictError extends APIError {
  }
  class UnprocessableEntityError extends APIError {
  }
  class RateLimitError extends APIError {
  }
  class InternalServerError extends APIError {
  }
  class LengthFinishReasonError extends OpenAIError {
    constructor() {
      super(`Could not parse response content as the length limit was reached`);
    }
  }
  class ContentFilterFinishReasonError extends OpenAIError {
    constructor() {
      super(`Could not parse response content as the request was rejected by the content filter`);
    }
  }
  class LineDecoder {
    constructor() {
      this.buffer = [];
      this.trailingCR = false;
    }
    decode(chunk) {
      let text = this.decodeText(chunk);
      if (this.trailingCR) {
        text = "\r" + text;
        this.trailingCR = false;
      }
      if (text.endsWith("\r")) {
        this.trailingCR = true;
        text = text.slice(0, -1);
      }
      if (!text) {
        return [];
      }
      const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || "");
      let lines = text.split(LineDecoder.NEWLINE_REGEXP);
      if (trailingNewline) {
        lines.pop();
      }
      if (lines.length === 1 && !trailingNewline) {
        this.buffer.push(lines[0]);
        return [];
      }
      if (this.buffer.length > 0) {
        lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
        this.buffer = [];
      }
      if (!trailingNewline) {
        this.buffer = [lines.pop() || ""];
      }
      return lines;
    }
    decodeText(bytes) {
      if (bytes == null)
        return "";
      if (typeof bytes === "string")
        return bytes;
      if (typeof Buffer !== "undefined") {
        if (bytes instanceof Buffer) {
          return bytes.toString();
        }
        if (bytes instanceof Uint8Array) {
          return Buffer.from(bytes).toString();
        }
        throw new OpenAIError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
      }
      if (typeof TextDecoder !== "undefined") {
        if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
          this.textDecoder ?? (this.textDecoder = new TextDecoder("utf8"));
          return this.textDecoder.decode(bytes);
        }
        throw new OpenAIError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
      }
      throw new OpenAIError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
    }
    flush() {
      if (!this.buffer.length && !this.trailingCR) {
        return [];
      }
      const lines = [this.buffer.join("")];
      this.buffer = [];
      this.trailingCR = false;
      return lines;
    }
  }
  LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
  LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
  function ReadableStreamToAsyncIterable(stream) {
    if (stream[Symbol.asyncIterator])
      return stream;
    const reader = stream.getReader();
    return {
      async next() {
        try {
          const result = await reader.read();
          if (result == null ? void 0 : result.done)
            reader.releaseLock();
          return result;
        } catch (e) {
          reader.releaseLock();
          throw e;
        }
      },
      async return() {
        const cancelPromise = reader.cancel();
        reader.releaseLock();
        await cancelPromise;
        return { done: true, value: void 0 };
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  class Stream {
    constructor(iterator2, controller) {
      this.iterator = iterator2;
      this.controller = controller;
    }
    static fromSSEResponse(response, controller) {
      let consumed2 = false;
      async function* iterator2() {
        if (consumed2) {
          throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
        }
        consumed2 = true;
        let done = false;
        try {
          for await (const sse of _iterSSEMessages(response, controller)) {
            if (done)
              continue;
            if (sse.data.startsWith("[DONE]")) {
              done = true;
              continue;
            }
            if (sse.event === null) {
              let data;
              try {
                data = JSON.parse(sse.data);
              } catch (e) {
                console.error(`Could not parse message into JSON:`, sse.data);
                console.error(`From chunk:`, sse.raw);
                throw e;
              }
              if (data && data.error) {
                throw new APIError(void 0, data.error, void 0, void 0);
              }
              yield data;
            } else {
              let data;
              try {
                data = JSON.parse(sse.data);
              } catch (e) {
                console.error(`Could not parse message into JSON:`, sse.data);
                console.error(`From chunk:`, sse.raw);
                throw e;
              }
              if (sse.event == "error") {
                throw new APIError(void 0, data.error, data.message, void 0);
              }
              yield { event: sse.event, data };
            }
          }
          done = true;
        } catch (e) {
          if (e instanceof Error && e.name === "AbortError")
            return;
          throw e;
        } finally {
          if (!done)
            controller.abort();
        }
      }
      return new Stream(iterator2, controller);
    }
    /**
     * Generates a Stream from a newline-separated ReadableStream
     * where each item is a JSON value.
     */
    static fromReadableStream(readableStream, controller) {
      let consumed2 = false;
      async function* iterLines() {
        const lineDecoder = new LineDecoder();
        const iter = ReadableStreamToAsyncIterable(readableStream);
        for await (const chunk of iter) {
          for (const line of lineDecoder.decode(chunk)) {
            yield line;
          }
        }
        for (const line of lineDecoder.flush()) {
          yield line;
        }
      }
      async function* iterator2() {
        if (consumed2) {
          throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
        }
        consumed2 = true;
        let done = false;
        try {
          for await (const line of iterLines()) {
            if (done)
              continue;
            if (line)
              yield JSON.parse(line);
          }
          done = true;
        } catch (e) {
          if (e instanceof Error && e.name === "AbortError")
            return;
          throw e;
        } finally {
          if (!done)
            controller.abort();
        }
      }
      return new Stream(iterator2, controller);
    }
    [Symbol.asyncIterator]() {
      return this.iterator();
    }
    /**
     * Splits the stream into two streams which can be
     * independently read from at different speeds.
     */
    tee() {
      const left = [];
      const right = [];
      const iterator2 = this.iterator();
      const teeIterator = (queue2) => {
        return {
          next: () => {
            if (queue2.length === 0) {
              const result = iterator2.next();
              left.push(result);
              right.push(result);
            }
            return queue2.shift();
          }
        };
      };
      return [
        new Stream(() => teeIterator(left), this.controller),
        new Stream(() => teeIterator(right), this.controller)
      ];
    }
    /**
     * Converts this stream to a newline-separated ReadableStream of
     * JSON stringified values in the stream
     * which can be turned back into a Stream with `Stream.fromReadableStream()`.
     */
    toReadableStream() {
      const self2 = this;
      let iter;
      const encoder = new TextEncoder();
      return new ReadableStream$1({
        async start() {
          iter = self2[Symbol.asyncIterator]();
        },
        async pull(ctrl) {
          try {
            const { value, done } = await iter.next();
            if (done)
              return ctrl.close();
            const bytes = encoder.encode(JSON.stringify(value) + "\n");
            ctrl.enqueue(bytes);
          } catch (err) {
            ctrl.error(err);
          }
        },
        async cancel() {
          var _a3;
          await ((_a3 = iter.return) == null ? void 0 : _a3.call(iter));
        }
      });
    }
  }
  async function* _iterSSEMessages(response, controller) {
    if (!response.body) {
      controller.abort();
      throw new OpenAIError(`Attempted to iterate over a response with no body`);
    }
    const sseDecoder = new SSEDecoder();
    const lineDecoder = new LineDecoder();
    const iter = ReadableStreamToAsyncIterable(response.body);
    for await (const sseChunk of iterSSEChunks(iter)) {
      for (const line of lineDecoder.decode(sseChunk)) {
        const sse = sseDecoder.decode(line);
        if (sse)
          yield sse;
      }
    }
    for (const line of lineDecoder.flush()) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  async function* iterSSEChunks(iterator2) {
    let data = new Uint8Array();
    for await (const chunk of iterator2) {
      if (chunk == null) {
        continue;
      }
      const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
      let newData = new Uint8Array(data.length + binaryChunk.length);
      newData.set(data);
      newData.set(binaryChunk, data.length);
      data = newData;
      let patternIndex;
      while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
        yield data.slice(0, patternIndex);
        data = data.slice(patternIndex);
      }
    }
    if (data.length > 0) {
      yield data;
    }
  }
  function findDoubleNewlineIndex(buffer) {
    const newline = 10;
    const carriage = 13;
    for (let i2 = 0; i2 < buffer.length - 2; i2++) {
      if (buffer[i2] === newline && buffer[i2 + 1] === newline) {
        return i2 + 2;
      }
      if (buffer[i2] === carriage && buffer[i2 + 1] === carriage) {
        return i2 + 2;
      }
      if (buffer[i2] === carriage && buffer[i2 + 1] === newline && i2 + 3 < buffer.length && buffer[i2 + 2] === carriage && buffer[i2 + 3] === newline) {
        return i2 + 4;
      }
    }
    return -1;
  }
  class SSEDecoder {
    constructor() {
      this.event = null;
      this.data = [];
      this.chunks = [];
    }
    decode(line) {
      if (line.endsWith("\r")) {
        line = line.substring(0, line.length - 1);
      }
      if (!line) {
        if (!this.event && !this.data.length)
          return null;
        const sse = {
          event: this.event,
          data: this.data.join("\n"),
          raw: this.chunks
        };
        this.event = null;
        this.data = [];
        this.chunks = [];
        return sse;
      }
      this.chunks.push(line);
      if (line.startsWith(":")) {
        return null;
      }
      let [fieldname, _, value] = partition(line, ":");
      if (value.startsWith(" ")) {
        value = value.substring(1);
      }
      if (fieldname === "event") {
        this.event = value;
      } else if (fieldname === "data") {
        this.data.push(value);
      }
      return null;
    }
  }
  function partition(str2, delimiter) {
    const index = str2.indexOf(delimiter);
    if (index !== -1) {
      return [str2.substring(0, index), delimiter, str2.substring(index + delimiter.length)];
    }
    return [str2, "", ""];
  }
  const isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
  const isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
  const isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
  const isUploadable = (value) => {
    return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);
  };
  async function toFile(value, name, options) {
    var _a3;
    value = await value;
    if (isFileLike(value)) {
      return value;
    }
    if (isResponseLike(value)) {
      const blob = await value.blob();
      name || (name = new URL(value.url).pathname.split(/[\\/]/).pop() ?? "unknown_file");
      const data = isBlobLike(blob) ? [await blob.arrayBuffer()] : [blob];
      return new File$1(data, name, options);
    }
    const bits = await getBytes(value);
    name || (name = getName(value) ?? "unknown_file");
    if (!(options == null ? void 0 : options.type)) {
      const type = (_a3 = bits[0]) == null ? void 0 : _a3.type;
      if (typeof type === "string") {
        options = { ...options, type };
      }
    }
    return new File$1(bits, name, options);
  }
  async function getBytes(value) {
    var _a3;
    let parts = [];
    if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
    value instanceof ArrayBuffer) {
      parts.push(value);
    } else if (isBlobLike(value)) {
      parts.push(await value.arrayBuffer());
    } else if (isAsyncIterableIterator(value)) {
      for await (const chunk of value) {
        parts.push(chunk);
      }
    } else {
      throw new Error(`Unexpected data type: ${typeof value}; constructor: ${(_a3 = value == null ? void 0 : value.constructor) == null ? void 0 : _a3.name}; props: ${propsForError(value)}`);
    }
    return parts;
  }
  function propsForError(value) {
    const props = Object.getOwnPropertyNames(value);
    return `[${props.map((p) => `"${p}"`).join(", ")}]`;
  }
  function getName(value) {
    var _a3;
    return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream
    ((_a3 = getStringFromMaybeBuffer(value.path)) == null ? void 0 : _a3.split(/[\\/]/).pop());
  }
  const getStringFromMaybeBuffer = (x) => {
    if (typeof x === "string")
      return x;
    if (typeof Buffer !== "undefined" && x instanceof Buffer)
      return String(x);
    return void 0;
  };
  const isAsyncIterableIterator = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
  const isMultipartBody = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";
  const multipartFormRequestOptions = async (opts) => {
    const form = await createForm(opts.body);
    return getMultipartRequestOptions(form, opts);
  };
  const createForm = async (body) => {
    const form = new FormData$1();
    await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
    return form;
  };
  const addFormValue = async (form, key, value) => {
    if (value === void 0)
      return;
    if (value == null) {
      throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
    }
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      form.append(key, String(value));
    } else if (isUploadable(value)) {
      const file = await toFile(value);
      form.append(key, file);
    } else if (Array.isArray(value)) {
      await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
    } else if (typeof value === "object") {
      await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
    } else {
      throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
    }
  };
  var __classPrivateFieldSet$3 = function(receiver, state, value, kind2, f) {
    if (kind2 === "m") throw new TypeError("Private method is not writable");
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet$4 = function(receiver, state, kind2, f) {
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _AbstractPage_client;
  async function defaultParseResponse(props) {
    const { response } = props;
    if (props.options.stream) {
      debug("response", response.status, response.url, response.headers, response.body);
      if (props.options.__streamClass) {
        return props.options.__streamClass.fromSSEResponse(response, props.controller);
      }
      return Stream.fromSSEResponse(response, props.controller);
    }
    if (response.status === 204) {
      return null;
    }
    if (props.options.__binaryResponse) {
      return response;
    }
    const contentType = response.headers.get("content-type");
    const isJSON = (contentType == null ? void 0 : contentType.includes("application/json")) || (contentType == null ? void 0 : contentType.includes("application/vnd.api+json"));
    if (isJSON) {
      const json = await response.json();
      debug("response", response.status, response.url, response.headers, json);
      return _addRequestID(json, response);
    }
    const text = await response.text();
    debug("response", response.status, response.url, response.headers, text);
    return text;
  }
  function _addRequestID(value, response) {
    if (!value || typeof value !== "object" || Array.isArray(value)) {
      return value;
    }
    return Object.defineProperty(value, "_request_id", {
      value: response.headers.get("x-request-id"),
      enumerable: false
    });
  }
  class APIPromise extends Promise {
    constructor(responsePromise, parseResponse = defaultParseResponse) {
      super((resolve) => {
        resolve(null);
      });
      this.responsePromise = responsePromise;
      this.parseResponse = parseResponse;
    }
    _thenUnwrap(transform) {
      return new APIPromise(this.responsePromise, async (props) => _addRequestID(transform(await this.parseResponse(props), props), props.response));
    }
    /**
     * Gets the raw `Response` instance instead of parsing the response
     * data.
     *
     * If you want to parse the response body but still get the `Response`
     * instance, you can use {@link withResponse()}.
     *
     * 👋 Getting the wrong TypeScript type for `Response`?
     * Try setting `"moduleResolution": "NodeNext"` if you can,
     * or add one of these imports before your first `import … from 'openai'`:
     * - `import 'openai/shims/node'` (if you're running on Node)
     * - `import 'openai/shims/web'` (otherwise)
     */
    asResponse() {
      return this.responsePromise.then((p) => p.response);
    }
    /**
     * Gets the parsed response data, the raw `Response` instance and the ID of the request,
     * returned via the X-Request-ID header which is useful for debugging requests and reporting
     * issues to OpenAI.
     *
     * If you just want to get the raw `Response` instance without parsing it,
     * you can use {@link asResponse()}.
     *
     *
     * 👋 Getting the wrong TypeScript type for `Response`?
     * Try setting `"moduleResolution": "NodeNext"` if you can,
     * or add one of these imports before your first `import … from 'openai'`:
     * - `import 'openai/shims/node'` (if you're running on Node)
     * - `import 'openai/shims/web'` (otherwise)
     */
    async withResponse() {
      const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
      return { data, response, request_id: response.headers.get("x-request-id") };
    }
    parse() {
      if (!this.parsedPromise) {
        this.parsedPromise = this.responsePromise.then(this.parseResponse);
      }
      return this.parsedPromise;
    }
    then(onfulfilled, onrejected) {
      return this.parse().then(onfulfilled, onrejected);
    }
    catch(onrejected) {
      return this.parse().catch(onrejected);
    }
    finally(onfinally) {
      return this.parse().finally(onfinally);
    }
  }
  class APIClient {
    constructor({
      baseURL,
      maxRetries = 2,
      timeout: timeout2 = 6e5,
      // 10 minutes
      httpAgent,
      fetch: overriddenFetch
    }) {
      this.baseURL = baseURL;
      this.maxRetries = validatePositiveInteger("maxRetries", maxRetries);
      this.timeout = validatePositiveInteger("timeout", timeout2);
      this.httpAgent = httpAgent;
      this.fetch = overriddenFetch ?? fetch$2;
    }
    authHeaders(opts) {
      return {};
    }
    /**
     * Override this to add your own default headers, for example:
     *
     *  {
     *    ...super.defaultHeaders(),
     *    Authorization: 'Bearer 123',
     *  }
     */
    defaultHeaders(opts) {
      return {
        Accept: "application/json",
        "Content-Type": "application/json",
        "User-Agent": this.getUserAgent(),
        ...getPlatformHeaders(),
        ...this.authHeaders(opts)
      };
    }
    /**
     * Override this to add your own headers validation:
     */
    validateHeaders(headers, customHeaders) {
    }
    defaultIdempotencyKey() {
      return `stainless-node-retry-${uuid4()}`;
    }
    get(path, opts) {
      return this.methodRequest("get", path, opts);
    }
    post(path, opts) {
      return this.methodRequest("post", path, opts);
    }
    patch(path, opts) {
      return this.methodRequest("patch", path, opts);
    }
    put(path, opts) {
      return this.methodRequest("put", path, opts);
    }
    delete(path, opts) {
      return this.methodRequest("delete", path, opts);
    }
    methodRequest(method, path, opts) {
      return this.request(Promise.resolve(opts).then(async (opts2) => {
        const body = opts2 && isBlobLike(opts2 == null ? void 0 : opts2.body) ? new DataView(await opts2.body.arrayBuffer()) : (opts2 == null ? void 0 : opts2.body) instanceof DataView ? opts2.body : (opts2 == null ? void 0 : opts2.body) instanceof ArrayBuffer ? new DataView(opts2.body) : opts2 && ArrayBuffer.isView(opts2 == null ? void 0 : opts2.body) ? new DataView(opts2.body.buffer) : opts2 == null ? void 0 : opts2.body;
        return { method, path, ...opts2, body };
      }));
    }
    getAPIList(path, Page2, opts) {
      return this.requestAPIList(Page2, { method: "get", path, ...opts });
    }
    calculateContentLength(body) {
      if (typeof body === "string") {
        if (typeof Buffer !== "undefined") {
          return Buffer.byteLength(body, "utf8").toString();
        }
        if (typeof TextEncoder !== "undefined") {
          const encoder = new TextEncoder();
          const encoded = encoder.encode(body);
          return encoded.length.toString();
        }
      } else if (ArrayBuffer.isView(body)) {
        return body.byteLength.toString();
      }
      return null;
    }
    buildRequest(options, { retryCount = 0 } = {}) {
      var _a3;
      const { method, path, query, headers = {} } = options;
      const body = ArrayBuffer.isView(options.body) || options.__binaryRequest && typeof options.body === "string" ? options.body : isMultipartBody(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
      const contentLength = this.calculateContentLength(body);
      const url = this.buildURL(path, query);
      if ("timeout" in options)
        validatePositiveInteger("timeout", options.timeout);
      const timeout2 = options.timeout ?? this.timeout;
      const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);
      const minAgentTimeout = timeout2 + 1e3;
      if (typeof ((_a3 = httpAgent == null ? void 0 : httpAgent.options) == null ? void 0 : _a3.timeout) === "number" && minAgentTimeout > (httpAgent.options.timeout ?? 0)) {
        httpAgent.options.timeout = minAgentTimeout;
      }
      if (this.idempotencyHeader && method !== "get") {
        if (!options.idempotencyKey)
          options.idempotencyKey = this.defaultIdempotencyKey();
        headers[this.idempotencyHeader] = options.idempotencyKey;
      }
      const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });
      const req = {
        method,
        ...body && { body },
        headers: reqHeaders,
        ...httpAgent && { agent: httpAgent },
        // @ts-ignore node-fetch uses a custom AbortSignal type that is
        // not compatible with standard web types
        signal: options.signal ?? null
      };
      return { req, url, timeout: timeout2 };
    }
    buildHeaders({ options, headers, contentLength, retryCount }) {
      const reqHeaders = {};
      if (contentLength) {
        reqHeaders["content-length"] = contentLength;
      }
      const defaultHeaders = this.defaultHeaders(options);
      applyHeadersMut(reqHeaders, defaultHeaders);
      applyHeadersMut(reqHeaders, headers);
      if (isMultipartBody(options.body) && kind !== "node") {
        delete reqHeaders["content-type"];
      }
      if (getHeader(defaultHeaders, "x-stainless-retry-count") === void 0 && getHeader(headers, "x-stainless-retry-count") === void 0) {
        reqHeaders["x-stainless-retry-count"] = String(retryCount);
      }
      this.validateHeaders(reqHeaders, headers);
      return reqHeaders;
    }
    /**
     * Used as a callback for mutating the given `FinalRequestOptions` object.
     */
    async prepareOptions(options) {
    }
    /**
     * Used as a callback for mutating the given `RequestInit` object.
     *
     * This is useful for cases where you want to add certain headers based off of
     * the request properties, e.g. `method` or `url`.
     */
    async prepareRequest(request, { url, options }) {
    }
    parseHeaders(headers) {
      return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
    }
    makeStatusError(status, error, message, headers) {
      return APIError.generate(status, error, message, headers);
    }
    request(options, remainingRetries = null) {
      return new APIPromise(this.makeRequest(options, remainingRetries));
    }
    async makeRequest(optionsInput, retriesRemaining) {
      var _a3, _b2;
      const options = await optionsInput;
      const maxRetries = options.maxRetries ?? this.maxRetries;
      if (retriesRemaining == null) {
        retriesRemaining = maxRetries;
      }
      await this.prepareOptions(options);
      const { req, url, timeout: timeout2 } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });
      await this.prepareRequest(req, { url, options });
      debug("request", url, options, req.headers);
      if ((_a3 = options.signal) == null ? void 0 : _a3.aborted) {
        throw new APIUserAbortError();
      }
      const controller = new AbortController();
      const response = await this.fetchWithTimeout(url, req, timeout2, controller).catch(castToError);
      if (response instanceof Error) {
        if ((_b2 = options.signal) == null ? void 0 : _b2.aborted) {
          throw new APIUserAbortError();
        }
        if (retriesRemaining) {
          return this.retryRequest(options, retriesRemaining);
        }
        if (response.name === "AbortError") {
          throw new APIConnectionTimeoutError();
        }
        throw new APIConnectionError({ cause: response });
      }
      const responseHeaders = createResponseHeaders(response.headers);
      if (!response.ok) {
        if (retriesRemaining && this.shouldRetry(response)) {
          const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
          debug(`response (error; ${retryMessage2})`, response.status, url, responseHeaders);
          return this.retryRequest(options, retriesRemaining, responseHeaders);
        }
        const errText = await response.text().catch((e) => castToError(e).message);
        const errJSON = safeJSON(errText);
        const errMessage = errJSON ? void 0 : errText;
        const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;
        debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);
        const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
        throw err;
      }
      return { response, options, controller };
    }
    requestAPIList(Page2, options) {
      const request = this.makeRequest(options, null);
      return new PagePromise(this, request, Page2);
    }
    buildURL(path, query) {
      const url = isAbsoluteURL(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path.startsWith("/") ? path.slice(1) : path));
      const defaultQuery = this.defaultQuery();
      if (!isEmptyObj$1(defaultQuery)) {
        query = { ...defaultQuery, ...query };
      }
      if (typeof query === "object" && query && !Array.isArray(query)) {
        url.search = this.stringifyQuery(query);
      }
      return url.toString();
    }
    stringifyQuery(query) {
      return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
        if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
          return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
        }
        if (value === null) {
          return `${encodeURIComponent(key)}=`;
        }
        throw new OpenAIError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
      }).join("&");
    }
    async fetchWithTimeout(url, init, ms2, controller) {
      const { signal, ...options } = init || {};
      if (signal)
        signal.addEventListener("abort", () => controller.abort());
      const timeout2 = setTimeout(() => controller.abort(), ms2);
      const fetchOptions = {
        signal: controller.signal,
        ...options
      };
      if (fetchOptions.method) {
        fetchOptions.method = fetchOptions.method.toUpperCase();
      }
      return (
        // use undefined this binding; fetch errors if bound to something else in browser/cloudflare
        this.fetch.call(void 0, url, fetchOptions).finally(() => {
          clearTimeout(timeout2);
        })
      );
    }
    shouldRetry(response) {
      const shouldRetryHeader = response.headers.get("x-should-retry");
      if (shouldRetryHeader === "true")
        return true;
      if (shouldRetryHeader === "false")
        return false;
      if (response.status === 408)
        return true;
      if (response.status === 409)
        return true;
      if (response.status === 429)
        return true;
      if (response.status >= 500)
        return true;
      return false;
    }
    async retryRequest(options, retriesRemaining, responseHeaders) {
      let timeoutMillis;
      const retryAfterMillisHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after-ms"];
      if (retryAfterMillisHeader) {
        const timeoutMs = parseFloat(retryAfterMillisHeader);
        if (!Number.isNaN(timeoutMs)) {
          timeoutMillis = timeoutMs;
        }
      }
      const retryAfterHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after"];
      if (retryAfterHeader && !timeoutMillis) {
        const timeoutSeconds = parseFloat(retryAfterHeader);
        if (!Number.isNaN(timeoutSeconds)) {
          timeoutMillis = timeoutSeconds * 1e3;
        } else {
          timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
        }
      }
      if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
        const maxRetries = options.maxRetries ?? this.maxRetries;
        timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
      }
      await sleep(timeoutMillis);
      return this.makeRequest(options, retriesRemaining - 1);
    }
    calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
      const initialRetryDelay = 0.5;
      const maxRetryDelay = 8;
      const numRetries = maxRetries - retriesRemaining;
      const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
      const jitter = 1 - Math.random() * 0.25;
      return sleepSeconds * jitter * 1e3;
    }
    getUserAgent() {
      return `${this.constructor.name}/JS ${VERSION}`;
    }
  }
  class AbstractPage {
    constructor(client2, response, body, options) {
      _AbstractPage_client.set(this, void 0);
      __classPrivateFieldSet$3(this, _AbstractPage_client, client2, "f");
      this.options = options;
      this.response = response;
      this.body = body;
    }
    hasNextPage() {
      const items = this.getPaginatedItems();
      if (!items.length)
        return false;
      return this.nextPageInfo() != null;
    }
    async getNextPage() {
      const nextInfo = this.nextPageInfo();
      if (!nextInfo) {
        throw new OpenAIError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
      }
      const nextOptions = { ...this.options };
      if ("params" in nextInfo && typeof nextOptions.query === "object") {
        nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
      } else if ("url" in nextInfo) {
        const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
        for (const [key, value] of params) {
          nextInfo.url.searchParams.set(key, value);
        }
        nextOptions.query = void 0;
        nextOptions.path = nextInfo.url.toString();
      }
      return await __classPrivateFieldGet$4(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
    }
    async *iterPages() {
      let page = this;
      yield page;
      while (page.hasNextPage()) {
        page = await page.getNextPage();
        yield page;
      }
    }
    async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
      for await (const page of this.iterPages()) {
        for (const item of page.getPaginatedItems()) {
          yield item;
        }
      }
    }
  }
  class PagePromise extends APIPromise {
    constructor(client2, request, Page2) {
      super(request, async (props) => new Page2(client2, props.response, await defaultParseResponse(props), props.options));
    }
    /**
     * Allow auto-paginating iteration on an unawaited list call, eg:
     *
     *    for await (const item of client.items.list()) {
     *      console.log(item)
     *    }
     */
    async *[Symbol.asyncIterator]() {
      const page = await this;
      for await (const item of page) {
        yield item;
      }
    }
  }
  const createResponseHeaders = (headers) => {
    return new Proxy(Object.fromEntries(
      // @ts-ignore
      headers.entries()
    ), {
      get(target, name) {
        const key = name.toString();
        return target[key.toLowerCase()] || target[key];
      }
    });
  };
  const requestOptionsKeys = {
    method: true,
    path: true,
    query: true,
    body: true,
    headers: true,
    maxRetries: true,
    stream: true,
    timeout: true,
    httpAgent: true,
    signal: true,
    idempotencyKey: true,
    __binaryRequest: true,
    __binaryResponse: true,
    __streamClass: true
  };
  const isRequestOptions = (obj) => {
    return typeof obj === "object" && obj !== null && !isEmptyObj$1(obj) && Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k));
  };
  const getPlatformProperties = () => {
    var _a3;
    if (typeof Deno !== "undefined" && Deno.build != null) {
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION,
        "X-Stainless-OS": normalizePlatform(Deno.build.os),
        "X-Stainless-Arch": normalizeArch(Deno.build.arch),
        "X-Stainless-Runtime": "deno",
        "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : ((_a3 = Deno.version) == null ? void 0 : _a3.deno) ?? "unknown"
      };
    }
    if (typeof EdgeRuntime !== "undefined") {
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION,
        "X-Stainless-OS": "Unknown",
        "X-Stainless-Arch": `other:${EdgeRuntime}`,
        "X-Stainless-Runtime": "edge",
        "X-Stainless-Runtime-Version": process.version
      };
    }
    if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION,
        "X-Stainless-OS": normalizePlatform(process.platform),
        "X-Stainless-Arch": normalizeArch(process.arch),
        "X-Stainless-Runtime": "node",
        "X-Stainless-Runtime-Version": process.version
      };
    }
    const browserInfo = getBrowserInfo();
    if (browserInfo) {
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION,
        "X-Stainless-OS": "Unknown",
        "X-Stainless-Arch": "unknown",
        "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
        "X-Stainless-Runtime-Version": browserInfo.version
      };
    }
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": "unknown",
      "X-Stainless-Runtime-Version": "unknown"
    };
  };
  function getBrowserInfo() {
    if (typeof navigator === "undefined" || !navigator) {
      return null;
    }
    const browserPatterns = [
      { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
    ];
    for (const { key, pattern } of browserPatterns) {
      const match = pattern.exec(navigator.userAgent);
      if (match) {
        const major = match[1] || 0;
        const minor = match[2] || 0;
        const patch = match[3] || 0;
        return { browser: key, version: `${major}.${minor}.${patch}` };
      }
    }
    return null;
  }
  const normalizeArch = (arch) => {
    if (arch === "x32")
      return "x32";
    if (arch === "x86_64" || arch === "x64")
      return "x64";
    if (arch === "arm")
      return "arm";
    if (arch === "aarch64" || arch === "arm64")
      return "arm64";
    if (arch)
      return `other:${arch}`;
    return "unknown";
  };
  const normalizePlatform = (platform) => {
    platform = platform.toLowerCase();
    if (platform.includes("ios"))
      return "iOS";
    if (platform === "android")
      return "Android";
    if (platform === "darwin")
      return "MacOS";
    if (platform === "win32")
      return "Windows";
    if (platform === "freebsd")
      return "FreeBSD";
    if (platform === "openbsd")
      return "OpenBSD";
    if (platform === "linux")
      return "Linux";
    if (platform)
      return `Other:${platform}`;
    return "Unknown";
  };
  let _platformHeaders;
  const getPlatformHeaders = () => {
    return _platformHeaders ?? (_platformHeaders = getPlatformProperties());
  };
  const safeJSON = (text) => {
    try {
      return JSON.parse(text);
    } catch (err) {
      return void 0;
    }
  };
  const startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
  const isAbsoluteURL = (url) => {
    return startsWithSchemeRegexp.test(url);
  };
  const sleep = (ms2) => new Promise((resolve) => setTimeout(resolve, ms2));
  const validatePositiveInteger = (name, n) => {
    if (typeof n !== "number" || !Number.isInteger(n)) {
      throw new OpenAIError(`${name} must be an integer`);
    }
    if (n < 0) {
      throw new OpenAIError(`${name} must be a positive integer`);
    }
    return n;
  };
  const castToError = (err) => {
    if (err instanceof Error)
      return err;
    if (typeof err === "object" && err !== null) {
      try {
        return new Error(JSON.stringify(err));
      } catch {
      }
    }
    return new Error(err);
  };
  const readEnv = (env) => {
    var _a3, _b2, _c2, _d2, _e2;
    if (typeof process !== "undefined") {
      return ((_b2 = (_a3 = process.env) == null ? void 0 : _a3[env]) == null ? void 0 : _b2.trim()) ?? void 0;
    }
    if (typeof Deno !== "undefined") {
      return (_e2 = (_d2 = (_c2 = Deno.env) == null ? void 0 : _c2.get) == null ? void 0 : _d2.call(_c2, env)) == null ? void 0 : _e2.trim();
    }
    return void 0;
  };
  function isEmptyObj$1(obj) {
    if (!obj)
      return true;
    for (const _k2 in obj)
      return false;
    return true;
  }
  function hasOwn(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  function applyHeadersMut(targetHeaders, newHeaders) {
    for (const k in newHeaders) {
      if (!hasOwn(newHeaders, k))
        continue;
      const lowerKey = k.toLowerCase();
      if (!lowerKey)
        continue;
      const val = newHeaders[k];
      if (val === null) {
        delete targetHeaders[lowerKey];
      } else if (val !== void 0) {
        targetHeaders[lowerKey] = val;
      }
    }
  }
  const SENSITIVE_HEADERS = /* @__PURE__ */ new Set(["authorization", "api-key"]);
  function debug(action, ...args) {
    var _a3;
    if (typeof process !== "undefined" && ((_a3 = process == null ? void 0 : process.env) == null ? void 0 : _a3["DEBUG"]) === "true") {
      const modifiedArgs = args.map((arg) => {
        if (!arg) {
          return arg;
        }
        if (arg["headers"]) {
          const modifiedArg2 = { ...arg, headers: { ...arg["headers"] } };
          for (const header in arg["headers"]) {
            if (SENSITIVE_HEADERS.has(header.toLowerCase())) {
              modifiedArg2["headers"][header] = "REDACTED";
            }
          }
          return modifiedArg2;
        }
        let modifiedArg = null;
        for (const header in arg) {
          if (SENSITIVE_HEADERS.has(header.toLowerCase())) {
            modifiedArg ?? (modifiedArg = { ...arg });
            modifiedArg[header] = "REDACTED";
          }
        }
        return modifiedArg ?? arg;
      });
      console.log(`OpenAI:DEBUG:${action}`, ...modifiedArgs);
    }
  }
  const uuid4 = () => {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  };
  const isRunningInBrowser = () => {
    return (
      // @ts-ignore
      typeof window !== "undefined" && // @ts-ignore
      typeof window.document !== "undefined" && // @ts-ignore
      typeof navigator !== "undefined"
    );
  };
  const isHeadersProtocol = (headers) => {
    return typeof (headers == null ? void 0 : headers.get) === "function";
  };
  const getHeader = (headers, header) => {
    var _a3;
    const lowerCasedHeader = header.toLowerCase();
    if (isHeadersProtocol(headers)) {
      const intercapsHeader = ((_a3 = header[0]) == null ? void 0 : _a3.toUpperCase()) + header.substring(1).replace(/([^\w])(\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());
      for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {
        const value = headers.get(key);
        if (value) {
          return value;
        }
      }
    }
    for (const [key, value] of Object.entries(headers)) {
      if (key.toLowerCase() === lowerCasedHeader) {
        if (Array.isArray(value)) {
          if (value.length <= 1)
            return value[0];
          console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);
          return value[0];
        }
        return value;
      }
    }
    return void 0;
  };
  function isObj(obj) {
    return obj != null && typeof obj === "object" && !Array.isArray(obj);
  }
  class Page extends AbstractPage {
    constructor(client2, response, body, options) {
      super(client2, response, body, options);
      this.data = body.data || [];
      this.object = body.object;
    }
    getPaginatedItems() {
      return this.data ?? [];
    }
    // @deprecated Please use `nextPageInfo()` instead
    /**
     * This page represents a response that isn't actually paginated at the API level
     * so there will never be any next page params.
     */
    nextPageParams() {
      return null;
    }
    nextPageInfo() {
      return null;
    }
  }
  class CursorPage extends AbstractPage {
    constructor(client2, response, body, options) {
      super(client2, response, body, options);
      this.data = body.data || [];
    }
    getPaginatedItems() {
      return this.data ?? [];
    }
    // @deprecated Please use `nextPageInfo()` instead
    nextPageParams() {
      const info = this.nextPageInfo();
      if (!info)
        return null;
      if ("params" in info)
        return info.params;
      const params = Object.fromEntries(info.url.searchParams);
      if (!Object.keys(params).length)
        return null;
      return params;
    }
    nextPageInfo() {
      var _a3;
      const data = this.getPaginatedItems();
      if (!data.length) {
        return null;
      }
      const id = (_a3 = data[data.length - 1]) == null ? void 0 : _a3.id;
      if (!id) {
        return null;
      }
      return { params: { after: id } };
    }
  }
  class APIResource {
    constructor(client2) {
      this._client = client2;
    }
  }
  let Completions$2 = class Completions extends APIResource {
    create(body, options) {
      return this._client.post("/chat/completions", { body, ...options, stream: body.stream ?? false });
    }
  };
  let Chat$1 = class Chat extends APIResource {
    constructor() {
      super(...arguments);
      this.completions = new Completions$2(this._client);
    }
  };
  Chat$1.Completions = Completions$2;
  class Speech extends APIResource {
    /**
     * Generates audio from the input text.
     */
    create(body, options) {
      return this._client.post("/audio/speech", {
        body,
        ...options,
        headers: { Accept: "application/octet-stream", ...options == null ? void 0 : options.headers },
        __binaryResponse: true
      });
    }
  }
  class Transcriptions extends APIResource {
    create(body, options) {
      return this._client.post("/audio/transcriptions", multipartFormRequestOptions({ body, ...options }));
    }
  }
  class Translations extends APIResource {
    create(body, options) {
      return this._client.post("/audio/translations", multipartFormRequestOptions({ body, ...options }));
    }
  }
  class Audio extends APIResource {
    constructor() {
      super(...arguments);
      this.transcriptions = new Transcriptions(this._client);
      this.translations = new Translations(this._client);
      this.speech = new Speech(this._client);
    }
  }
  Audio.Transcriptions = Transcriptions;
  Audio.Translations = Translations;
  Audio.Speech = Speech;
  class Batches extends APIResource {
    /**
     * Creates and executes a batch from an uploaded file of requests
     */
    create(body, options) {
      return this._client.post("/batches", { body, ...options });
    }
    /**
     * Retrieves a batch.
     */
    retrieve(batchId, options) {
      return this._client.get(`/batches/${batchId}`, options);
    }
    list(query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list({}, query);
      }
      return this._client.getAPIList("/batches", BatchesPage, { query, ...options });
    }
    /**
     * Cancels an in-progress batch. The batch will be in status `cancelling` for up to
     * 10 minutes, before changing to `cancelled`, where it will have partial results
     * (if any) available in the output file.
     */
    cancel(batchId, options) {
      return this._client.post(`/batches/${batchId}/cancel`, options);
    }
  }
  class BatchesPage extends CursorPage {
  }
  Batches.BatchesPage = BatchesPage;
  class Assistants extends APIResource {
    /**
     * Create an assistant with a model and instructions.
     */
    create(body, options) {
      return this._client.post("/assistants", {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Retrieves an assistant.
     */
    retrieve(assistantId, options) {
      return this._client.get(`/assistants/${assistantId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Modifies an assistant.
     */
    update(assistantId, body, options) {
      return this._client.post(`/assistants/${assistantId}`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    list(query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list({}, query);
      }
      return this._client.getAPIList("/assistants", AssistantsPage, {
        query,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Delete an assistant.
     */
    del(assistantId, options) {
      return this._client.delete(`/assistants/${assistantId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
  }
  class AssistantsPage extends CursorPage {
  }
  Assistants.AssistantsPage = AssistantsPage;
  function isRunnableFunctionWithParse(fn) {
    return typeof fn.parse === "function";
  }
  const isAssistantMessage = (message) => {
    return (message == null ? void 0 : message.role) === "assistant";
  };
  const isFunctionMessage = (message) => {
    return (message == null ? void 0 : message.role) === "function";
  };
  const isToolMessage = (message) => {
    return (message == null ? void 0 : message.role) === "tool";
  };
  var __classPrivateFieldSet$2 = function(receiver, state, value, kind2, f) {
    if (kind2 === "m") throw new TypeError("Private method is not writable");
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet$3 = function(receiver, state, kind2, f) {
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _EventStream_instances, _EventStream_connectedPromise, _EventStream_resolveConnectedPromise, _EventStream_rejectConnectedPromise, _EventStream_endPromise, _EventStream_resolveEndPromise, _EventStream_rejectEndPromise, _EventStream_listeners, _EventStream_ended, _EventStream_errored, _EventStream_aborted, _EventStream_catchingPromiseCreated, _EventStream_handleError;
  class EventStream {
    constructor() {
      _EventStream_instances.add(this);
      this.controller = new AbortController();
      _EventStream_connectedPromise.set(this, void 0);
      _EventStream_resolveConnectedPromise.set(this, () => {
      });
      _EventStream_rejectConnectedPromise.set(this, () => {
      });
      _EventStream_endPromise.set(this, void 0);
      _EventStream_resolveEndPromise.set(this, () => {
      });
      _EventStream_rejectEndPromise.set(this, () => {
      });
      _EventStream_listeners.set(this, {});
      _EventStream_ended.set(this, false);
      _EventStream_errored.set(this, false);
      _EventStream_aborted.set(this, false);
      _EventStream_catchingPromiseCreated.set(this, false);
      __classPrivateFieldSet$2(this, _EventStream_connectedPromise, new Promise((resolve, reject) => {
        __classPrivateFieldSet$2(this, _EventStream_resolveConnectedPromise, resolve, "f");
        __classPrivateFieldSet$2(this, _EventStream_rejectConnectedPromise, reject, "f");
      }), "f");
      __classPrivateFieldSet$2(this, _EventStream_endPromise, new Promise((resolve, reject) => {
        __classPrivateFieldSet$2(this, _EventStream_resolveEndPromise, resolve, "f");
        __classPrivateFieldSet$2(this, _EventStream_rejectEndPromise, reject, "f");
      }), "f");
      __classPrivateFieldGet$3(this, _EventStream_connectedPromise, "f").catch(() => {
      });
      __classPrivateFieldGet$3(this, _EventStream_endPromise, "f").catch(() => {
      });
    }
    _run(executor) {
      setTimeout(() => {
        executor().then(() => {
          this._emitFinal();
          this._emit("end");
        }, __classPrivateFieldGet$3(this, _EventStream_instances, "m", _EventStream_handleError).bind(this));
      }, 0);
    }
    _connected() {
      if (this.ended)
        return;
      __classPrivateFieldGet$3(this, _EventStream_resolveConnectedPromise, "f").call(this);
      this._emit("connect");
    }
    get ended() {
      return __classPrivateFieldGet$3(this, _EventStream_ended, "f");
    }
    get errored() {
      return __classPrivateFieldGet$3(this, _EventStream_errored, "f");
    }
    get aborted() {
      return __classPrivateFieldGet$3(this, _EventStream_aborted, "f");
    }
    abort() {
      this.controller.abort();
    }
    /**
     * Adds the listener function to the end of the listeners array for the event.
     * No checks are made to see if the listener has already been added. Multiple calls passing
     * the same combination of event and listener will result in the listener being added, and
     * called, multiple times.
     * @returns this ChatCompletionStream, so that calls can be chained
     */
    on(event, listener) {
      const listeners = __classPrivateFieldGet$3(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet$3(this, _EventStream_listeners, "f")[event] = []);
      listeners.push({ listener });
      return this;
    }
    /**
     * Removes the specified listener from the listener array for the event.
     * off() will remove, at most, one instance of a listener from the listener array. If any single
     * listener has been added multiple times to the listener array for the specified event, then
     * off() must be called multiple times to remove each instance.
     * @returns this ChatCompletionStream, so that calls can be chained
     */
    off(event, listener) {
      const listeners = __classPrivateFieldGet$3(this, _EventStream_listeners, "f")[event];
      if (!listeners)
        return this;
      const index = listeners.findIndex((l) => l.listener === listener);
      if (index >= 0)
        listeners.splice(index, 1);
      return this;
    }
    /**
     * Adds a one-time listener function for the event. The next time the event is triggered,
     * this listener is removed and then invoked.
     * @returns this ChatCompletionStream, so that calls can be chained
     */
    once(event, listener) {
      const listeners = __classPrivateFieldGet$3(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet$3(this, _EventStream_listeners, "f")[event] = []);
      listeners.push({ listener, once: true });
      return this;
    }
    /**
     * This is similar to `.once()`, but returns a Promise that resolves the next time
     * the event is triggered, instead of calling a listener callback.
     * @returns a Promise that resolves the next time given event is triggered,
     * or rejects if an error is emitted.  (If you request the 'error' event,
     * returns a promise that resolves with the error).
     *
     * Example:
     *
     *   const message = await stream.emitted('message') // rejects if the stream errors
     */
    emitted(event) {
      return new Promise((resolve, reject) => {
        __classPrivateFieldSet$2(this, _EventStream_catchingPromiseCreated, true, "f");
        if (event !== "error")
          this.once("error", reject);
        this.once(event, resolve);
      });
    }
    async done() {
      __classPrivateFieldSet$2(this, _EventStream_catchingPromiseCreated, true, "f");
      await __classPrivateFieldGet$3(this, _EventStream_endPromise, "f");
    }
    _emit(event, ...args) {
      if (__classPrivateFieldGet$3(this, _EventStream_ended, "f")) {
        return;
      }
      if (event === "end") {
        __classPrivateFieldSet$2(this, _EventStream_ended, true, "f");
        __classPrivateFieldGet$3(this, _EventStream_resolveEndPromise, "f").call(this);
      }
      const listeners = __classPrivateFieldGet$3(this, _EventStream_listeners, "f")[event];
      if (listeners) {
        __classPrivateFieldGet$3(this, _EventStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
        listeners.forEach(({ listener }) => listener(...args));
      }
      if (event === "abort") {
        const error = args[0];
        if (!__classPrivateFieldGet$3(this, _EventStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
          Promise.reject(error);
        }
        __classPrivateFieldGet$3(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
        __classPrivateFieldGet$3(this, _EventStream_rejectEndPromise, "f").call(this, error);
        this._emit("end");
        return;
      }
      if (event === "error") {
        const error = args[0];
        if (!__classPrivateFieldGet$3(this, _EventStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
          Promise.reject(error);
        }
        __classPrivateFieldGet$3(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
        __classPrivateFieldGet$3(this, _EventStream_rejectEndPromise, "f").call(this, error);
        this._emit("end");
      }
    }
    _emitFinal() {
    }
  }
  _EventStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_endPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_listeners = /* @__PURE__ */ new WeakMap(), _EventStream_ended = /* @__PURE__ */ new WeakMap(), _EventStream_errored = /* @__PURE__ */ new WeakMap(), _EventStream_aborted = /* @__PURE__ */ new WeakMap(), _EventStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _EventStream_instances = /* @__PURE__ */ new WeakSet(), _EventStream_handleError = function _EventStream_handleError2(error) {
    __classPrivateFieldSet$2(this, _EventStream_errored, true, "f");
    if (error instanceof Error && error.name === "AbortError") {
      error = new APIUserAbortError();
    }
    if (error instanceof APIUserAbortError) {
      __classPrivateFieldSet$2(this, _EventStream_aborted, true, "f");
      return this._emit("abort", error);
    }
    if (error instanceof OpenAIError) {
      return this._emit("error", error);
    }
    if (error instanceof Error) {
      const openAIError = new OpenAIError(error.message);
      openAIError.cause = error;
      return this._emit("error", openAIError);
    }
    return this._emit("error", new OpenAIError(String(error)));
  };
  function makeParseableResponseFormat(response_format, parser) {
    const obj = { ...response_format };
    Object.defineProperties(obj, {
      $brand: {
        value: "auto-parseable-response-format",
        enumerable: false
      },
      $parseRaw: {
        value: parser,
        enumerable: false
      }
    });
    return obj;
  }
  function isAutoParsableResponseFormat(response_format) {
    return (response_format == null ? void 0 : response_format["$brand"]) === "auto-parseable-response-format";
  }
  function makeParseableTool(tool, { parser, callback }) {
    const obj = { ...tool };
    Object.defineProperties(obj, {
      $brand: {
        value: "auto-parseable-tool",
        enumerable: false
      },
      $parseRaw: {
        value: parser,
        enumerable: false
      },
      $callback: {
        value: callback,
        enumerable: false
      }
    });
    return obj;
  }
  function isAutoParsableTool(tool) {
    return (tool == null ? void 0 : tool["$brand"]) === "auto-parseable-tool";
  }
  function maybeParseChatCompletion(completion, params) {
    if (!params || !hasAutoParseableInput(params)) {
      return {
        ...completion,
        choices: completion.choices.map((choice) => ({
          ...choice,
          message: { ...choice.message, parsed: null, tool_calls: choice.message.tool_calls ?? [] }
        }))
      };
    }
    return parseChatCompletion(completion, params);
  }
  function parseChatCompletion(completion, params) {
    const choices = completion.choices.map((choice) => {
      var _a3;
      if (choice.finish_reason === "length") {
        throw new LengthFinishReasonError();
      }
      if (choice.finish_reason === "content_filter") {
        throw new ContentFilterFinishReasonError();
      }
      return {
        ...choice,
        message: {
          ...choice.message,
          tool_calls: ((_a3 = choice.message.tool_calls) == null ? void 0 : _a3.map((toolCall) => parseToolCall(params, toolCall))) ?? [],
          parsed: choice.message.content && !choice.message.refusal ? parseResponseFormat(params, choice.message.content) : null
        }
      };
    });
    return { ...completion, choices };
  }
  function parseResponseFormat(params, content) {
    var _a3, _b2;
    if (((_a3 = params.response_format) == null ? void 0 : _a3.type) !== "json_schema") {
      return null;
    }
    if (((_b2 = params.response_format) == null ? void 0 : _b2.type) === "json_schema") {
      if ("$parseRaw" in params.response_format) {
        const response_format = params.response_format;
        return response_format.$parseRaw(content);
      }
      return JSON.parse(content);
    }
    return null;
  }
  function parseToolCall(params, toolCall) {
    var _a3;
    const inputTool = (_a3 = params.tools) == null ? void 0 : _a3.find((inputTool2) => {
      var _a4;
      return ((_a4 = inputTool2.function) == null ? void 0 : _a4.name) === toolCall.function.name;
    });
    return {
      ...toolCall,
      function: {
        ...toolCall.function,
        parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments) : (inputTool == null ? void 0 : inputTool.function.strict) ? JSON.parse(toolCall.function.arguments) : null
      }
    };
  }
  function shouldParseToolCall(params, toolCall) {
    var _a3;
    if (!params) {
      return false;
    }
    const inputTool = (_a3 = params.tools) == null ? void 0 : _a3.find((inputTool2) => {
      var _a4;
      return ((_a4 = inputTool2.function) == null ? void 0 : _a4.name) === toolCall.function.name;
    });
    return isAutoParsableTool(inputTool) || (inputTool == null ? void 0 : inputTool.function.strict) || false;
  }
  function hasAutoParseableInput(params) {
    var _a3;
    if (isAutoParsableResponseFormat(params.response_format)) {
      return true;
    }
    return ((_a3 = params.tools) == null ? void 0 : _a3.some((t) => isAutoParsableTool(t) || t.type === "function" && t.function.strict === true)) ?? false;
  }
  function validateInputTools(tools) {
    for (const tool of tools ?? []) {
      if (tool.type !== "function") {
        throw new OpenAIError(`Currently only \`function\` tool types support auto-parsing; Received \`${tool.type}\``);
      }
      if (tool.function.strict !== true) {
        throw new OpenAIError(`The \`${tool.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
      }
    }
  }
  var __classPrivateFieldGet$2 = function(receiver, state, kind2, f) {
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _AbstractChatCompletionRunner_instances, _AbstractChatCompletionRunner_getFinalContent, _AbstractChatCompletionRunner_getFinalMessage, _AbstractChatCompletionRunner_getFinalFunctionCall, _AbstractChatCompletionRunner_getFinalFunctionCallResult, _AbstractChatCompletionRunner_calculateTotalUsage, _AbstractChatCompletionRunner_validateParams, _AbstractChatCompletionRunner_stringifyFunctionCallResult;
  const DEFAULT_MAX_CHAT_COMPLETIONS = 10;
  class AbstractChatCompletionRunner extends EventStream {
    constructor() {
      super(...arguments);
      _AbstractChatCompletionRunner_instances.add(this);
      this._chatCompletions = [];
      this.messages = [];
    }
    _addChatCompletion(chatCompletion) {
      var _a3;
      this._chatCompletions.push(chatCompletion);
      this._emit("chatCompletion", chatCompletion);
      const message = (_a3 = chatCompletion.choices[0]) == null ? void 0 : _a3.message;
      if (message)
        this._addMessage(message);
      return chatCompletion;
    }
    _addMessage(message, emit = true) {
      if (!("content" in message))
        message.content = null;
      this.messages.push(message);
      if (emit) {
        this._emit("message", message);
        if ((isFunctionMessage(message) || isToolMessage(message)) && message.content) {
          this._emit("functionCallResult", message.content);
        } else if (isAssistantMessage(message) && message.function_call) {
          this._emit("functionCall", message.function_call);
        } else if (isAssistantMessage(message) && message.tool_calls) {
          for (const tool_call of message.tool_calls) {
            if (tool_call.type === "function") {
              this._emit("functionCall", tool_call.function);
            }
          }
        }
      }
    }
    /**
     * @returns a promise that resolves with the final ChatCompletion, or rejects
     * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
     */
    async finalChatCompletion() {
      await this.done();
      const completion = this._chatCompletions[this._chatCompletions.length - 1];
      if (!completion)
        throw new OpenAIError("stream ended without producing a ChatCompletion");
      return completion;
    }
    /**
     * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
     * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
     */
    async finalContent() {
      await this.done();
      return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
    }
    /**
     * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
     * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
     */
    async finalMessage() {
      await this.done();
      return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
    }
    /**
     * @returns a promise that resolves with the content of the final FunctionCall, or rejects
     * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
     */
    async finalFunctionCall() {
      await this.done();
      return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
    }
    async finalFunctionCallResult() {
      await this.done();
      return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
    }
    async totalUsage() {
      await this.done();
      return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);
    }
    allChatCompletions() {
      return [...this._chatCompletions];
    }
    _emitFinal() {
      const completion = this._chatCompletions[this._chatCompletions.length - 1];
      if (completion)
        this._emit("finalChatCompletion", completion);
      const finalMessage = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
      if (finalMessage)
        this._emit("finalMessage", finalMessage);
      const finalContent = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
      if (finalContent)
        this._emit("finalContent", finalContent);
      const finalFunctionCall = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
      if (finalFunctionCall)
        this._emit("finalFunctionCall", finalFunctionCall);
      const finalFunctionCallResult = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
      if (finalFunctionCallResult != null)
        this._emit("finalFunctionCallResult", finalFunctionCallResult);
      if (this._chatCompletions.some((c) => c.usage)) {
        this._emit("totalUsage", __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));
      }
    }
    async _createChatCompletion(client2, params, options) {
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_validateParams).call(this, params);
      const chatCompletion = await client2.chat.completions.create({ ...params, stream: false }, { ...options, signal: this.controller.signal });
      this._connected();
      return this._addChatCompletion(parseChatCompletion(chatCompletion, params));
    }
    async _runChatCompletion(client2, params, options) {
      for (const message of params.messages) {
        this._addMessage(message, false);
      }
      return await this._createChatCompletion(client2, params, options);
    }
    async _runFunctions(client2, params, options) {
      var _a3;
      const role = "function";
      const { function_call = "auto", stream, ...restParams } = params;
      const singleFunctionToCall = typeof function_call !== "string" && (function_call == null ? void 0 : function_call.name);
      const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
      const functionsByName = {};
      for (const f of params.functions) {
        functionsByName[f.name || f.function.name] = f;
      }
      const functions = params.functions.map((f) => ({
        name: f.name || f.function.name,
        parameters: f.parameters,
        description: f.description
      }));
      for (const message of params.messages) {
        this._addMessage(message, false);
      }
      for (let i2 = 0; i2 < maxChatCompletions; ++i2) {
        const chatCompletion = await this._createChatCompletion(client2, {
          ...restParams,
          function_call,
          functions,
          messages: [...this.messages]
        }, options);
        const message = (_a3 = chatCompletion.choices[0]) == null ? void 0 : _a3.message;
        if (!message) {
          throw new OpenAIError(`missing message in ChatCompletion response`);
        }
        if (!message.function_call)
          return;
        const { name, arguments: args } = message.function_call;
        const fn = functionsByName[name];
        if (!fn) {
          const content2 = `Invalid function_call: ${JSON.stringify(name)}. Available options are: ${functions.map((f) => JSON.stringify(f.name)).join(", ")}. Please try again`;
          this._addMessage({ role, name, content: content2 });
          continue;
        } else if (singleFunctionToCall && singleFunctionToCall !== name) {
          const content2 = `Invalid function_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
          this._addMessage({ role, name, content: content2 });
          continue;
        }
        let parsed;
        try {
          parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
        } catch (error) {
          this._addMessage({
            role,
            name,
            content: error instanceof Error ? error.message : String(error)
          });
          continue;
        }
        const rawContent = await fn.function(parsed, this);
        const content = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
        this._addMessage({ role, name, content });
        if (singleFunctionToCall)
          return;
      }
    }
    async _runTools(client2, params, options) {
      var _a3, _b2, _c2;
      const role = "tool";
      const { tool_choice = "auto", stream, ...restParams } = params;
      const singleFunctionToCall = typeof tool_choice !== "string" && ((_a3 = tool_choice == null ? void 0 : tool_choice.function) == null ? void 0 : _a3.name);
      const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
      const inputTools = params.tools.map((tool) => {
        if (isAutoParsableTool(tool)) {
          if (!tool.$callback) {
            throw new OpenAIError("Tool given to `.runTools()` that does not have an associated function");
          }
          return {
            type: "function",
            function: {
              function: tool.$callback,
              name: tool.function.name,
              description: tool.function.description || "",
              parameters: tool.function.parameters,
              parse: tool.$parseRaw,
              strict: true
            }
          };
        }
        return tool;
      });
      const functionsByName = {};
      for (const f of inputTools) {
        if (f.type === "function") {
          functionsByName[f.function.name || f.function.function.name] = f.function;
        }
      }
      const tools = "tools" in params ? inputTools.map((t) => t.type === "function" ? {
        type: "function",
        function: {
          name: t.function.name || t.function.function.name,
          parameters: t.function.parameters,
          description: t.function.description,
          strict: t.function.strict
        }
      } : t) : void 0;
      for (const message of params.messages) {
        this._addMessage(message, false);
      }
      for (let i2 = 0; i2 < maxChatCompletions; ++i2) {
        const chatCompletion = await this._createChatCompletion(client2, {
          ...restParams,
          tool_choice,
          tools,
          messages: [...this.messages]
        }, options);
        const message = (_b2 = chatCompletion.choices[0]) == null ? void 0 : _b2.message;
        if (!message) {
          throw new OpenAIError(`missing message in ChatCompletion response`);
        }
        if (!((_c2 = message.tool_calls) == null ? void 0 : _c2.length)) {
          return;
        }
        for (const tool_call of message.tool_calls) {
          if (tool_call.type !== "function")
            continue;
          const tool_call_id = tool_call.id;
          const { name, arguments: args } = tool_call.function;
          const fn = functionsByName[name];
          if (!fn) {
            const content2 = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName).map((name2) => JSON.stringify(name2)).join(", ")}. Please try again`;
            this._addMessage({ role, tool_call_id, content: content2 });
            continue;
          } else if (singleFunctionToCall && singleFunctionToCall !== name) {
            const content2 = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
            this._addMessage({ role, tool_call_id, content: content2 });
            continue;
          }
          let parsed;
          try {
            parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
          } catch (error) {
            const content2 = error instanceof Error ? error.message : String(error);
            this._addMessage({ role, tool_call_id, content: content2 });
            continue;
          }
          const rawContent = await fn.function(parsed, this);
          const content = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
          this._addMessage({ role, tool_call_id, content });
          if (singleFunctionToCall) {
            return;
          }
        }
      }
      return;
    }
  }
  _AbstractChatCompletionRunner_instances = /* @__PURE__ */ new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent2() {
    return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this).content ?? null;
  }, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage2() {
    let i2 = this.messages.length;
    while (i2-- > 0) {
      const message = this.messages[i2];
      if (isAssistantMessage(message)) {
        const { function_call, ...rest } = message;
        const ret = {
          ...rest,
          content: message.content ?? null,
          refusal: message.refusal ?? null
        };
        if (function_call) {
          ret.function_call = function_call;
        }
        return ret;
      }
    }
    throw new OpenAIError("stream ended without producing a ChatCompletionMessage with role=assistant");
  }, _AbstractChatCompletionRunner_getFinalFunctionCall = function _AbstractChatCompletionRunner_getFinalFunctionCall2() {
    var _a3, _b2;
    for (let i2 = this.messages.length - 1; i2 >= 0; i2--) {
      const message = this.messages[i2];
      if (isAssistantMessage(message) && (message == null ? void 0 : message.function_call)) {
        return message.function_call;
      }
      if (isAssistantMessage(message) && ((_a3 = message == null ? void 0 : message.tool_calls) == null ? void 0 : _a3.length)) {
        return (_b2 = message.tool_calls.at(-1)) == null ? void 0 : _b2.function;
      }
    }
    return;
  }, _AbstractChatCompletionRunner_getFinalFunctionCallResult = function _AbstractChatCompletionRunner_getFinalFunctionCallResult2() {
    for (let i2 = this.messages.length - 1; i2 >= 0; i2--) {
      const message = this.messages[i2];
      if (isFunctionMessage(message) && message.content != null) {
        return message.content;
      }
      if (isToolMessage(message) && message.content != null && typeof message.content === "string" && this.messages.some((x) => {
        var _a3;
        return x.role === "assistant" && ((_a3 = x.tool_calls) == null ? void 0 : _a3.some((y) => y.type === "function" && y.id === message.tool_call_id));
      })) {
        return message.content;
      }
    }
    return;
  }, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage2() {
    const total = {
      completion_tokens: 0,
      prompt_tokens: 0,
      total_tokens: 0
    };
    for (const { usage } of this._chatCompletions) {
      if (usage) {
        total.completion_tokens += usage.completion_tokens;
        total.prompt_tokens += usage.prompt_tokens;
        total.total_tokens += usage.total_tokens;
      }
    }
    return total;
  }, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams2(params) {
    if (params.n != null && params.n > 1) {
      throw new OpenAIError("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
    }
  }, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult2(rawContent) {
    return typeof rawContent === "string" ? rawContent : rawContent === void 0 ? "undefined" : JSON.stringify(rawContent);
  };
  class ChatCompletionRunner extends AbstractChatCompletionRunner {
    /** @deprecated - please use `runTools` instead. */
    static runFunctions(client2, params, options) {
      const runner = new ChatCompletionRunner();
      const opts = {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runFunctions" }
      };
      runner._run(() => runner._runFunctions(client2, params, opts));
      return runner;
    }
    static runTools(client2, params, options) {
      const runner = new ChatCompletionRunner();
      const opts = {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runTools" }
      };
      runner._run(() => runner._runTools(client2, params, opts));
      return runner;
    }
    _addMessage(message, emit = true) {
      super._addMessage(message, emit);
      if (isAssistantMessage(message) && message.content) {
        this._emit("content", message.content);
      }
    }
  }
  const STR = 1;
  const NUM = 2;
  const ARR = 4;
  const OBJ = 8;
  const NULL = 16;
  const BOOL = 32;
  const NAN = 64;
  const INFINITY = 128;
  const MINUS_INFINITY = 256;
  const INF = INFINITY | MINUS_INFINITY;
  const SPECIAL = NULL | BOOL | INF | NAN;
  const ATOM = STR | NUM | SPECIAL;
  const COLLECTION = ARR | OBJ;
  const ALL = ATOM | COLLECTION;
  const Allow = {
    STR,
    NUM,
    ARR,
    OBJ,
    NULL,
    BOOL,
    NAN,
    INFINITY,
    MINUS_INFINITY,
    INF,
    SPECIAL,
    ATOM,
    COLLECTION,
    ALL
  };
  class PartialJSON extends Error {
  }
  class MalformedJSON extends Error {
  }
  function parseJSON$1(jsonString, allowPartial = Allow.ALL) {
    if (typeof jsonString !== "string") {
      throw new TypeError(`expecting str, got ${typeof jsonString}`);
    }
    if (!jsonString.trim()) {
      throw new Error(`${jsonString} is empty`);
    }
    return _parseJSON(jsonString.trim(), allowPartial);
  }
  const _parseJSON = (jsonString, allow) => {
    const length = jsonString.length;
    let index = 0;
    const markPartialJSON = (msg) => {
      throw new PartialJSON(`${msg} at position ${index}`);
    };
    const throwMalformedError = (msg) => {
      throw new MalformedJSON(`${msg} at position ${index}`);
    };
    const parseAny = () => {
      skipBlank();
      if (index >= length)
        markPartialJSON("Unexpected end of input");
      if (jsonString[index] === '"')
        return parseStr();
      if (jsonString[index] === "{")
        return parseObj();
      if (jsonString[index] === "[")
        return parseArr();
      if (jsonString.substring(index, index + 4) === "null" || Allow.NULL & allow && length - index < 4 && "null".startsWith(jsonString.substring(index))) {
        index += 4;
        return null;
      }
      if (jsonString.substring(index, index + 4) === "true" || Allow.BOOL & allow && length - index < 4 && "true".startsWith(jsonString.substring(index))) {
        index += 4;
        return true;
      }
      if (jsonString.substring(index, index + 5) === "false" || Allow.BOOL & allow && length - index < 5 && "false".startsWith(jsonString.substring(index))) {
        index += 5;
        return false;
      }
      if (jsonString.substring(index, index + 8) === "Infinity" || Allow.INFINITY & allow && length - index < 8 && "Infinity".startsWith(jsonString.substring(index))) {
        index += 8;
        return Infinity;
      }
      if (jsonString.substring(index, index + 9) === "-Infinity" || Allow.MINUS_INFINITY & allow && 1 < length - index && length - index < 9 && "-Infinity".startsWith(jsonString.substring(index))) {
        index += 9;
        return -Infinity;
      }
      if (jsonString.substring(index, index + 3) === "NaN" || Allow.NAN & allow && length - index < 3 && "NaN".startsWith(jsonString.substring(index))) {
        index += 3;
        return NaN;
      }
      return parseNum();
    };
    const parseStr = () => {
      const start = index;
      let escape2 = false;
      index++;
      while (index < length && (jsonString[index] !== '"' || escape2 && jsonString[index - 1] === "\\")) {
        escape2 = jsonString[index] === "\\" ? !escape2 : false;
        index++;
      }
      if (jsonString.charAt(index) == '"') {
        try {
          return JSON.parse(jsonString.substring(start, ++index - Number(escape2)));
        } catch (e) {
          throwMalformedError(String(e));
        }
      } else if (Allow.STR & allow) {
        try {
          return JSON.parse(jsonString.substring(start, index - Number(escape2)) + '"');
        } catch (e) {
          return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("\\")) + '"');
        }
      }
      markPartialJSON("Unterminated string literal");
    };
    const parseObj = () => {
      index++;
      skipBlank();
      const obj = {};
      try {
        while (jsonString[index] !== "}") {
          skipBlank();
          if (index >= length && Allow.OBJ & allow)
            return obj;
          const key = parseStr();
          skipBlank();
          index++;
          try {
            const value = parseAny();
            Object.defineProperty(obj, key, { value, writable: true, enumerable: true, configurable: true });
          } catch (e) {
            if (Allow.OBJ & allow)
              return obj;
            else
              throw e;
          }
          skipBlank();
          if (jsonString[index] === ",")
            index++;
        }
      } catch (e) {
        if (Allow.OBJ & allow)
          return obj;
        else
          markPartialJSON("Expected '}' at end of object");
      }
      index++;
      return obj;
    };
    const parseArr = () => {
      index++;
      const arr2 = [];
      try {
        while (jsonString[index] !== "]") {
          arr2.push(parseAny());
          skipBlank();
          if (jsonString[index] === ",") {
            index++;
          }
        }
      } catch (e) {
        if (Allow.ARR & allow) {
          return arr2;
        }
        markPartialJSON("Expected ']' at end of array");
      }
      index++;
      return arr2;
    };
    const parseNum = () => {
      if (index === 0) {
        if (jsonString === "-" && Allow.NUM & allow)
          markPartialJSON("Not sure what '-' is");
        try {
          return JSON.parse(jsonString);
        } catch (e) {
          if (Allow.NUM & allow) {
            try {
              if ("." === jsonString[jsonString.length - 1])
                return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf(".")));
              return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf("e")));
            } catch (e2) {
            }
          }
          throwMalformedError(String(e));
        }
      }
      const start = index;
      if (jsonString[index] === "-")
        index++;
      while (jsonString[index] && !",]}".includes(jsonString[index]))
        index++;
      if (index == length && !(Allow.NUM & allow))
        markPartialJSON("Unterminated number literal");
      try {
        return JSON.parse(jsonString.substring(start, index));
      } catch (e) {
        if (jsonString.substring(start, index) === "-" && Allow.NUM & allow)
          markPartialJSON("Not sure what '-' is");
        try {
          return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("e")));
        } catch (e2) {
          throwMalformedError(String(e2));
        }
      }
    };
    const skipBlank = () => {
      while (index < length && " \n\r	".includes(jsonString[index])) {
        index++;
      }
    };
    return parseAny();
  };
  const partialParse = (input) => parseJSON$1(input, Allow.ALL ^ Allow.NUM);
  var __classPrivateFieldSet$1 = function(receiver, state, value, kind2, f) {
    if (kind2 === "m") throw new TypeError("Private method is not writable");
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet$1 = function(receiver, state, kind2, f) {
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _ChatCompletionStream_instances, _ChatCompletionStream_params, _ChatCompletionStream_choiceEventStates, _ChatCompletionStream_currentChatCompletionSnapshot, _ChatCompletionStream_beginRequest, _ChatCompletionStream_getChoiceEventState, _ChatCompletionStream_addChunk, _ChatCompletionStream_emitToolCallDoneEvent, _ChatCompletionStream_emitContentDoneEvents, _ChatCompletionStream_endRequest, _ChatCompletionStream_getAutoParseableResponseFormat, _ChatCompletionStream_accumulateChatCompletion;
  class ChatCompletionStream extends AbstractChatCompletionRunner {
    constructor(params) {
      super();
      _ChatCompletionStream_instances.add(this);
      _ChatCompletionStream_params.set(this, void 0);
      _ChatCompletionStream_choiceEventStates.set(this, void 0);
      _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);
      __classPrivateFieldSet$1(this, _ChatCompletionStream_params, params, "f");
      __classPrivateFieldSet$1(this, _ChatCompletionStream_choiceEventStates, [], "f");
    }
    get currentChatCompletionSnapshot() {
      return __classPrivateFieldGet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    }
    /**
     * Intended for use on the frontend, consuming a stream produced with
     * `.toReadableStream()` on the backend.
     *
     * Note that messages sent to the model do not appear in `.on('message')`
     * in this context.
     */
    static fromReadableStream(stream) {
      const runner = new ChatCompletionStream(null);
      runner._run(() => runner._fromReadableStream(stream));
      return runner;
    }
    static createChatCompletion(client2, params, options) {
      const runner = new ChatCompletionStream(params);
      runner._run(() => runner._runChatCompletion(client2, { ...params, stream: true }, { ...options, headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" } }));
      return runner;
    }
    async _createChatCompletion(client2, params, options) {
      var _a3;
      super._createChatCompletion;
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
      const stream = await client2.chat.completions.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
      this._connected();
      for await (const chunk of stream) {
        __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
      }
      if ((_a3 = stream.controller.signal) == null ? void 0 : _a3.aborted) {
        throw new APIUserAbortError();
      }
      return this._addChatCompletion(__classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
    }
    async _fromReadableStream(readableStream, options) {
      var _a3;
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
      this._connected();
      const stream = Stream.fromReadableStream(readableStream, this.controller);
      let chatId;
      for await (const chunk of stream) {
        if (chatId && chatId !== chunk.id) {
          this._addChatCompletion(__classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
        }
        __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
        chatId = chunk.id;
      }
      if ((_a3 = stream.controller.signal) == null ? void 0 : _a3.aborted) {
        throw new APIUserAbortError();
      }
      return this._addChatCompletion(__classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
    }
    [(_ChatCompletionStream_params = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_choiceEventStates = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_currentChatCompletionSnapshot = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_instances = /* @__PURE__ */ new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest2() {
      if (this.ended)
        return;
      __classPrivateFieldSet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
    }, _ChatCompletionStream_getChoiceEventState = function _ChatCompletionStream_getChoiceEventState2(choice) {
      let state = __classPrivateFieldGet$1(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index];
      if (state) {
        return state;
      }
      state = {
        content_done: false,
        refusal_done: false,
        logprobs_content_done: false,
        logprobs_refusal_done: false,
        done_tool_calls: /* @__PURE__ */ new Set(),
        current_tool_call_index: null
      };
      __classPrivateFieldGet$1(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index] = state;
      return state;
    }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk2(chunk) {
      var _a3, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2, _k2, _l, _m, _n, _o;
      if (this.ended)
        return;
      const completion = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);
      this._emit("chunk", chunk, completion);
      for (const choice of chunk.choices) {
        const choiceSnapshot = completion.choices[choice.index];
        if (choice.delta.content != null && ((_a3 = choiceSnapshot.message) == null ? void 0 : _a3.role) === "assistant" && ((_b2 = choiceSnapshot.message) == null ? void 0 : _b2.content)) {
          this._emit("content", choice.delta.content, choiceSnapshot.message.content);
          this._emit("content.delta", {
            delta: choice.delta.content,
            snapshot: choiceSnapshot.message.content,
            parsed: choiceSnapshot.message.parsed
          });
        }
        if (choice.delta.refusal != null && ((_c2 = choiceSnapshot.message) == null ? void 0 : _c2.role) === "assistant" && ((_d2 = choiceSnapshot.message) == null ? void 0 : _d2.refusal)) {
          this._emit("refusal.delta", {
            delta: choice.delta.refusal,
            snapshot: choiceSnapshot.message.refusal
          });
        }
        if (((_e2 = choice.logprobs) == null ? void 0 : _e2.content) != null && ((_f2 = choiceSnapshot.message) == null ? void 0 : _f2.role) === "assistant") {
          this._emit("logprobs.content.delta", {
            content: (_g2 = choice.logprobs) == null ? void 0 : _g2.content,
            snapshot: ((_h2 = choiceSnapshot.logprobs) == null ? void 0 : _h2.content) ?? []
          });
        }
        if (((_i2 = choice.logprobs) == null ? void 0 : _i2.refusal) != null && ((_j2 = choiceSnapshot.message) == null ? void 0 : _j2.role) === "assistant") {
          this._emit("logprobs.refusal.delta", {
            refusal: (_k2 = choice.logprobs) == null ? void 0 : _k2.refusal,
            snapshot: ((_l = choiceSnapshot.logprobs) == null ? void 0 : _l.refusal) ?? []
          });
        }
        const state = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
        if (choiceSnapshot.finish_reason) {
          __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
          if (state.current_tool_call_index != null) {
            __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
          }
        }
        for (const toolCall of choice.delta.tool_calls ?? []) {
          if (state.current_tool_call_index !== toolCall.index) {
            __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
            if (state.current_tool_call_index != null) {
              __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
            }
          }
          state.current_tool_call_index = toolCall.index;
        }
        for (const toolCallDelta of choice.delta.tool_calls ?? []) {
          const toolCallSnapshot = (_m = choiceSnapshot.message.tool_calls) == null ? void 0 : _m[toolCallDelta.index];
          if (!(toolCallSnapshot == null ? void 0 : toolCallSnapshot.type)) {
            continue;
          }
          if ((toolCallSnapshot == null ? void 0 : toolCallSnapshot.type) === "function") {
            this._emit("tool_calls.function.arguments.delta", {
              name: (_n = toolCallSnapshot.function) == null ? void 0 : _n.name,
              index: toolCallDelta.index,
              arguments: toolCallSnapshot.function.arguments,
              parsed_arguments: toolCallSnapshot.function.parsed_arguments,
              arguments_delta: ((_o = toolCallDelta.function) == null ? void 0 : _o.arguments) ?? ""
            });
          } else {
            assertNever(toolCallSnapshot == null ? void 0 : toolCallSnapshot.type);
          }
        }
      }
    }, _ChatCompletionStream_emitToolCallDoneEvent = function _ChatCompletionStream_emitToolCallDoneEvent2(choiceSnapshot, toolCallIndex) {
      var _a3, _b2, _c2;
      const state = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
      if (state.done_tool_calls.has(toolCallIndex)) {
        return;
      }
      const toolCallSnapshot = (_a3 = choiceSnapshot.message.tool_calls) == null ? void 0 : _a3[toolCallIndex];
      if (!toolCallSnapshot) {
        throw new Error("no tool call snapshot");
      }
      if (!toolCallSnapshot.type) {
        throw new Error("tool call snapshot missing `type`");
      }
      if (toolCallSnapshot.type === "function") {
        const inputTool = (_c2 = (_b2 = __classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f")) == null ? void 0 : _b2.tools) == null ? void 0 : _c2.find((tool) => tool.type === "function" && tool.function.name === toolCallSnapshot.function.name);
        this._emit("tool_calls.function.arguments.done", {
          name: toolCallSnapshot.function.name,
          index: toolCallIndex,
          arguments: toolCallSnapshot.function.arguments,
          parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments) : (inputTool == null ? void 0 : inputTool.function.strict) ? JSON.parse(toolCallSnapshot.function.arguments) : null
        });
      } else {
        assertNever(toolCallSnapshot.type);
      }
    }, _ChatCompletionStream_emitContentDoneEvents = function _ChatCompletionStream_emitContentDoneEvents2(choiceSnapshot) {
      var _a3, _b2;
      const state = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
      if (choiceSnapshot.message.content && !state.content_done) {
        state.content_done = true;
        const responseFormat = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this);
        this._emit("content.done", {
          content: choiceSnapshot.message.content,
          parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null
        });
      }
      if (choiceSnapshot.message.refusal && !state.refusal_done) {
        state.refusal_done = true;
        this._emit("refusal.done", { refusal: choiceSnapshot.message.refusal });
      }
      if (((_a3 = choiceSnapshot.logprobs) == null ? void 0 : _a3.content) && !state.logprobs_content_done) {
        state.logprobs_content_done = true;
        this._emit("logprobs.content.done", { content: choiceSnapshot.logprobs.content });
      }
      if (((_b2 = choiceSnapshot.logprobs) == null ? void 0 : _b2.refusal) && !state.logprobs_refusal_done) {
        state.logprobs_refusal_done = true;
        this._emit("logprobs.refusal.done", { refusal: choiceSnapshot.logprobs.refusal });
      }
    }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest2() {
      if (this.ended) {
        throw new OpenAIError(`stream has ended, this shouldn't happen`);
      }
      const snapshot = __classPrivateFieldGet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
      if (!snapshot) {
        throw new OpenAIError(`request ended without sending any chunks`);
      }
      __classPrivateFieldSet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
      __classPrivateFieldSet$1(this, _ChatCompletionStream_choiceEventStates, [], "f");
      return finalizeChatCompletion(snapshot, __classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f"));
    }, _ChatCompletionStream_getAutoParseableResponseFormat = function _ChatCompletionStream_getAutoParseableResponseFormat2() {
      var _a3;
      const responseFormat = (_a3 = __classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f")) == null ? void 0 : _a3.response_format;
      if (isAutoParsableResponseFormat(responseFormat)) {
        return responseFormat;
      }
      return null;
    }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion2(chunk) {
      var _a3, _b2, _c2, _d2;
      let snapshot = __classPrivateFieldGet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
      const { choices, ...rest } = chunk;
      if (!snapshot) {
        snapshot = __classPrivateFieldSet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, {
          ...rest,
          choices: []
        }, "f");
      } else {
        Object.assign(snapshot, rest);
      }
      for (const { delta, finish_reason, index, logprobs = null, ...other } of chunk.choices) {
        let choice = snapshot.choices[index];
        if (!choice) {
          choice = snapshot.choices[index] = { finish_reason, index, message: {}, logprobs, ...other };
        }
        if (logprobs) {
          if (!choice.logprobs) {
            choice.logprobs = Object.assign({}, logprobs);
          } else {
            const { content: content2, refusal: refusal2, ...rest3 } = logprobs;
            Object.assign(choice.logprobs, rest3);
            if (content2) {
              (_a3 = choice.logprobs).content ?? (_a3.content = []);
              choice.logprobs.content.push(...content2);
            }
            if (refusal2) {
              (_b2 = choice.logprobs).refusal ?? (_b2.refusal = []);
              choice.logprobs.refusal.push(...refusal2);
            }
          }
        }
        if (finish_reason) {
          choice.finish_reason = finish_reason;
          if (__classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f") && hasAutoParseableInput(__classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f"))) {
            if (finish_reason === "length") {
              throw new LengthFinishReasonError();
            }
            if (finish_reason === "content_filter") {
              throw new ContentFilterFinishReasonError();
            }
          }
        }
        Object.assign(choice, other);
        if (!delta)
          continue;
        const { content, refusal, function_call, role, tool_calls, ...rest2 } = delta;
        Object.assign(choice.message, rest2);
        if (refusal) {
          choice.message.refusal = (choice.message.refusal || "") + refusal;
        }
        if (role)
          choice.message.role = role;
        if (function_call) {
          if (!choice.message.function_call) {
            choice.message.function_call = function_call;
          } else {
            if (function_call.name)
              choice.message.function_call.name = function_call.name;
            if (function_call.arguments) {
              (_c2 = choice.message.function_call).arguments ?? (_c2.arguments = "");
              choice.message.function_call.arguments += function_call.arguments;
            }
          }
        }
        if (content) {
          choice.message.content = (choice.message.content || "") + content;
          if (!choice.message.refusal && __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this)) {
            choice.message.parsed = partialParse(choice.message.content);
          }
        }
        if (tool_calls) {
          if (!choice.message.tool_calls)
            choice.message.tool_calls = [];
          for (const { index: index2, id, type, function: fn, ...rest3 } of tool_calls) {
            const tool_call = (_d2 = choice.message.tool_calls)[index2] ?? (_d2[index2] = {});
            Object.assign(tool_call, rest3);
            if (id)
              tool_call.id = id;
            if (type)
              tool_call.type = type;
            if (fn)
              tool_call.function ?? (tool_call.function = { name: fn.name ?? "", arguments: "" });
            if (fn == null ? void 0 : fn.name)
              tool_call.function.name = fn.name;
            if (fn == null ? void 0 : fn.arguments) {
              tool_call.function.arguments += fn.arguments;
              if (shouldParseToolCall(__classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f"), tool_call)) {
                tool_call.function.parsed_arguments = partialParse(tool_call.function.arguments);
              }
            }
          }
        }
      }
      return snapshot;
    }, Symbol.asyncIterator)]() {
      const pushQueue = [];
      const readQueue = [];
      let done = false;
      this.on("chunk", (chunk) => {
        const reader = readQueue.shift();
        if (reader) {
          reader.resolve(chunk);
        } else {
          pushQueue.push(chunk);
        }
      });
      this.on("end", () => {
        done = true;
        for (const reader of readQueue) {
          reader.resolve(void 0);
        }
        readQueue.length = 0;
      });
      this.on("abort", (err) => {
        done = true;
        for (const reader of readQueue) {
          reader.reject(err);
        }
        readQueue.length = 0;
      });
      this.on("error", (err) => {
        done = true;
        for (const reader of readQueue) {
          reader.reject(err);
        }
        readQueue.length = 0;
      });
      return {
        next: async () => {
          if (!pushQueue.length) {
            if (done) {
              return { value: void 0, done: true };
            }
            return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
          }
          const chunk = pushQueue.shift();
          return { value: chunk, done: false };
        },
        return: async () => {
          this.abort();
          return { value: void 0, done: true };
        }
      };
    }
    toReadableStream() {
      const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
      return stream.toReadableStream();
    }
  }
  function finalizeChatCompletion(snapshot, params) {
    const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;
    const completion = {
      ...rest,
      id,
      choices: choices.map(({ message, finish_reason, index, logprobs, ...choiceRest }) => {
        if (!finish_reason) {
          throw new OpenAIError(`missing finish_reason for choice ${index}`);
        }
        const { content = null, function_call, tool_calls, ...messageRest } = message;
        const role = message.role;
        if (!role) {
          throw new OpenAIError(`missing role for choice ${index}`);
        }
        if (function_call) {
          const { arguments: args, name } = function_call;
          if (args == null) {
            throw new OpenAIError(`missing function_call.arguments for choice ${index}`);
          }
          if (!name) {
            throw new OpenAIError(`missing function_call.name for choice ${index}`);
          }
          return {
            ...choiceRest,
            message: {
              content,
              function_call: { arguments: args, name },
              role,
              refusal: message.refusal ?? null
            },
            finish_reason,
            index,
            logprobs
          };
        }
        if (tool_calls) {
          return {
            ...choiceRest,
            index,
            finish_reason,
            logprobs,
            message: {
              ...messageRest,
              role,
              content,
              refusal: message.refusal ?? null,
              tool_calls: tool_calls.map((tool_call, i2) => {
                const { function: fn, type, id: id2, ...toolRest } = tool_call;
                const { arguments: args, name, ...fnRest } = fn || {};
                if (id2 == null) {
                  throw new OpenAIError(`missing choices[${index}].tool_calls[${i2}].id
${str(snapshot)}`);
                }
                if (type == null) {
                  throw new OpenAIError(`missing choices[${index}].tool_calls[${i2}].type
${str(snapshot)}`);
                }
                if (name == null) {
                  throw new OpenAIError(`missing choices[${index}].tool_calls[${i2}].function.name
${str(snapshot)}`);
                }
                if (args == null) {
                  throw new OpenAIError(`missing choices[${index}].tool_calls[${i2}].function.arguments
${str(snapshot)}`);
                }
                return { ...toolRest, id: id2, type, function: { ...fnRest, name, arguments: args } };
              })
            }
          };
        }
        return {
          ...choiceRest,
          message: { ...messageRest, content, role, refusal: message.refusal ?? null },
          finish_reason,
          index,
          logprobs
        };
      }),
      created,
      model,
      object: "chat.completion",
      ...system_fingerprint ? { system_fingerprint } : {}
    };
    return maybeParseChatCompletion(completion, params);
  }
  function str(x) {
    return JSON.stringify(x);
  }
  function assertNever(_x2) {
  }
  class ChatCompletionStreamingRunner extends ChatCompletionStream {
    static fromReadableStream(stream) {
      const runner = new ChatCompletionStreamingRunner(null);
      runner._run(() => runner._fromReadableStream(stream));
      return runner;
    }
    /** @deprecated - please use `runTools` instead. */
    static runFunctions(client2, params, options) {
      const runner = new ChatCompletionStreamingRunner(null);
      const opts = {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runFunctions" }
      };
      runner._run(() => runner._runFunctions(client2, params, opts));
      return runner;
    }
    static runTools(client2, params, options) {
      const runner = new ChatCompletionStreamingRunner(
        // @ts-expect-error TODO these types are incompatible
        params
      );
      const opts = {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runTools" }
      };
      runner._run(() => runner._runTools(client2, params, opts));
      return runner;
    }
  }
  let Completions$1 = class Completions extends APIResource {
    parse(body, options) {
      validateInputTools(body.tools);
      return this._client.chat.completions.create(body, {
        ...options,
        headers: {
          ...options == null ? void 0 : options.headers,
          "X-Stainless-Helper-Method": "beta.chat.completions.parse"
        }
      })._thenUnwrap((completion) => parseChatCompletion(completion, body));
    }
    runFunctions(body, options) {
      if (body.stream) {
        return ChatCompletionStreamingRunner.runFunctions(this._client, body, options);
      }
      return ChatCompletionRunner.runFunctions(this._client, body, options);
    }
    runTools(body, options) {
      if (body.stream) {
        return ChatCompletionStreamingRunner.runTools(this._client, body, options);
      }
      return ChatCompletionRunner.runTools(this._client, body, options);
    }
    /**
     * Creates a chat completion stream
     */
    stream(body, options) {
      return ChatCompletionStream.createChatCompletion(this._client, body, options);
    }
  };
  class Chat extends APIResource {
    constructor() {
      super(...arguments);
      this.completions = new Completions$1(this._client);
    }
  }
  (function(Chat2) {
    Chat2.Completions = Completions$1;
  })(Chat || (Chat = {}));
  class Sessions extends APIResource {
    /**
     * Create an ephemeral API token for use in client-side applications with the
     * Realtime API. Can be configured with the same session parameters as the
     * `session.update` client event.
     *
     * It responds with a session object, plus a `client_secret` key which contains a
     * usable ephemeral API token that can be used to authenticate browser clients for
     * the Realtime API.
     */
    create(body, options) {
      return this._client.post("/realtime/sessions", {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
  }
  class Realtime extends APIResource {
    constructor() {
      super(...arguments);
      this.sessions = new Sessions(this._client);
    }
  }
  Realtime.Sessions = Sessions;
  var __classPrivateFieldGet = function(receiver, state, kind2, f) {
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __classPrivateFieldSet = function(receiver, state, value, kind2, f) {
    if (kind2 === "m") throw new TypeError("Private method is not writable");
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var _AssistantStream_instances, _AssistantStream_events, _AssistantStream_runStepSnapshots, _AssistantStream_messageSnapshots, _AssistantStream_messageSnapshot, _AssistantStream_finalRun, _AssistantStream_currentContentIndex, _AssistantStream_currentContent, _AssistantStream_currentToolCallIndex, _AssistantStream_currentToolCall, _AssistantStream_currentEvent, _AssistantStream_currentRunSnapshot, _AssistantStream_currentRunStepSnapshot, _AssistantStream_addEvent, _AssistantStream_endRequest, _AssistantStream_handleMessage, _AssistantStream_handleRunStep, _AssistantStream_handleEvent, _AssistantStream_accumulateRunStep, _AssistantStream_accumulateMessage, _AssistantStream_accumulateContent, _AssistantStream_handleRun;
  class AssistantStream extends EventStream {
    constructor() {
      super(...arguments);
      _AssistantStream_instances.add(this);
      _AssistantStream_events.set(this, []);
      _AssistantStream_runStepSnapshots.set(this, {});
      _AssistantStream_messageSnapshots.set(this, {});
      _AssistantStream_messageSnapshot.set(this, void 0);
      _AssistantStream_finalRun.set(this, void 0);
      _AssistantStream_currentContentIndex.set(this, void 0);
      _AssistantStream_currentContent.set(this, void 0);
      _AssistantStream_currentToolCallIndex.set(this, void 0);
      _AssistantStream_currentToolCall.set(this, void 0);
      _AssistantStream_currentEvent.set(this, void 0);
      _AssistantStream_currentRunSnapshot.set(this, void 0);
      _AssistantStream_currentRunStepSnapshot.set(this, void 0);
    }
    [(_AssistantStream_events = /* @__PURE__ */ new WeakMap(), _AssistantStream_runStepSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_finalRun = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContentIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCallIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCall = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentEvent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunStepSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_instances = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
      const pushQueue = [];
      const readQueue = [];
      let done = false;
      this.on("event", (event) => {
        const reader = readQueue.shift();
        if (reader) {
          reader.resolve(event);
        } else {
          pushQueue.push(event);
        }
      });
      this.on("end", () => {
        done = true;
        for (const reader of readQueue) {
          reader.resolve(void 0);
        }
        readQueue.length = 0;
      });
      this.on("abort", (err) => {
        done = true;
        for (const reader of readQueue) {
          reader.reject(err);
        }
        readQueue.length = 0;
      });
      this.on("error", (err) => {
        done = true;
        for (const reader of readQueue) {
          reader.reject(err);
        }
        readQueue.length = 0;
      });
      return {
        next: async () => {
          if (!pushQueue.length) {
            if (done) {
              return { value: void 0, done: true };
            }
            return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
          }
          const chunk = pushQueue.shift();
          return { value: chunk, done: false };
        },
        return: async () => {
          this.abort();
          return { value: void 0, done: true };
        }
      };
    }
    static fromReadableStream(stream) {
      const runner = new AssistantStream();
      runner._run(() => runner._fromReadableStream(stream));
      return runner;
    }
    async _fromReadableStream(readableStream, options) {
      var _a3;
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      this._connected();
      const stream = Stream.fromReadableStream(readableStream, this.controller);
      for await (const event of stream) {
        __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
      }
      if ((_a3 = stream.controller.signal) == null ? void 0 : _a3.aborted) {
        throw new APIUserAbortError();
      }
      return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
    }
    toReadableStream() {
      const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
      return stream.toReadableStream();
    }
    static createToolAssistantStream(threadId, runId, runs, params, options) {
      const runner = new AssistantStream();
      runner._run(() => runner._runToolAssistantStream(threadId, runId, runs, params, {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
      }));
      return runner;
    }
    async _createToolAssistantStream(run, threadId, runId, params, options) {
      var _a3;
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      const body = { ...params, stream: true };
      const stream = await run.submitToolOutputs(threadId, runId, body, {
        ...options,
        signal: this.controller.signal
      });
      this._connected();
      for await (const event of stream) {
        __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
      }
      if ((_a3 = stream.controller.signal) == null ? void 0 : _a3.aborted) {
        throw new APIUserAbortError();
      }
      return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
    }
    static createThreadAssistantStream(params, thread, options) {
      const runner = new AssistantStream();
      runner._run(() => runner._threadAssistantStream(params, thread, {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
      }));
      return runner;
    }
    static createAssistantStream(threadId, runs, params, options) {
      const runner = new AssistantStream();
      runner._run(() => runner._runAssistantStream(threadId, runs, params, {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
      }));
      return runner;
    }
    currentEvent() {
      return __classPrivateFieldGet(this, _AssistantStream_currentEvent, "f");
    }
    currentRun() {
      return __classPrivateFieldGet(this, _AssistantStream_currentRunSnapshot, "f");
    }
    currentMessageSnapshot() {
      return __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f");
    }
    currentRunStepSnapshot() {
      return __classPrivateFieldGet(this, _AssistantStream_currentRunStepSnapshot, "f");
    }
    async finalRunSteps() {
      await this.done();
      return Object.values(__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f"));
    }
    async finalMessages() {
      await this.done();
      return Object.values(__classPrivateFieldGet(this, _AssistantStream_messageSnapshots, "f"));
    }
    async finalRun() {
      await this.done();
      if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, "f"))
        throw Error("Final run was not received.");
      return __classPrivateFieldGet(this, _AssistantStream_finalRun, "f");
    }
    async _createThreadAssistantStream(thread, params, options) {
      var _a3;
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      const body = { ...params, stream: true };
      const stream = await thread.createAndRun(body, { ...options, signal: this.controller.signal });
      this._connected();
      for await (const event of stream) {
        __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
      }
      if ((_a3 = stream.controller.signal) == null ? void 0 : _a3.aborted) {
        throw new APIUserAbortError();
      }
      return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
    }
    async _createAssistantStream(run, threadId, params, options) {
      var _a3;
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      const body = { ...params, stream: true };
      const stream = await run.create(threadId, body, { ...options, signal: this.controller.signal });
      this._connected();
      for await (const event of stream) {
        __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
      }
      if ((_a3 = stream.controller.signal) == null ? void 0 : _a3.aborted) {
        throw new APIUserAbortError();
      }
      return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
    }
    static accumulateDelta(acc, delta) {
      for (const [key, deltaValue] of Object.entries(delta)) {
        if (!acc.hasOwnProperty(key)) {
          acc[key] = deltaValue;
          continue;
        }
        let accValue = acc[key];
        if (accValue === null || accValue === void 0) {
          acc[key] = deltaValue;
          continue;
        }
        if (key === "index" || key === "type") {
          acc[key] = deltaValue;
          continue;
        }
        if (typeof accValue === "string" && typeof deltaValue === "string") {
          accValue += deltaValue;
        } else if (typeof accValue === "number" && typeof deltaValue === "number") {
          accValue += deltaValue;
        } else if (isObj(accValue) && isObj(deltaValue)) {
          accValue = this.accumulateDelta(accValue, deltaValue);
        } else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {
          if (accValue.every((x) => typeof x === "string" || typeof x === "number")) {
            accValue.push(...deltaValue);
            continue;
          }
          for (const deltaEntry of deltaValue) {
            if (!isObj(deltaEntry)) {
              throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);
            }
            const index = deltaEntry["index"];
            if (index == null) {
              console.error(deltaEntry);
              throw new Error("Expected array delta entry to have an `index` property");
            }
            if (typeof index !== "number") {
              throw new Error(`Expected array delta entry \`index\` property to be a number but got ${index}`);
            }
            const accEntry = accValue[index];
            if (accEntry == null) {
              accValue.push(deltaEntry);
            } else {
              accValue[index] = this.accumulateDelta(accEntry, deltaEntry);
            }
          }
          continue;
        } else {
          throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);
        }
        acc[key] = accValue;
      }
      return acc;
    }
    _addRun(run) {
      return run;
    }
    async _threadAssistantStream(params, thread, options) {
      return await this._createThreadAssistantStream(thread, params, options);
    }
    async _runAssistantStream(threadId, runs, params, options) {
      return await this._createAssistantStream(runs, threadId, params, options);
    }
    async _runToolAssistantStream(threadId, runId, runs, params, options) {
      return await this._createToolAssistantStream(runs, threadId, runId, params, options);
    }
  }
  _AssistantStream_addEvent = function _AssistantStream_addEvent2(event) {
    if (this.ended)
      return;
    __classPrivateFieldSet(this, _AssistantStream_currentEvent, event, "f");
    __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleEvent).call(this, event);
    switch (event.event) {
      case "thread.created":
        break;
      case "thread.run.created":
      case "thread.run.queued":
      case "thread.run.in_progress":
      case "thread.run.requires_action":
      case "thread.run.completed":
      case "thread.run.failed":
      case "thread.run.cancelling":
      case "thread.run.cancelled":
      case "thread.run.expired":
        __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleRun).call(this, event);
        break;
      case "thread.run.step.created":
      case "thread.run.step.in_progress":
      case "thread.run.step.delta":
      case "thread.run.step.completed":
      case "thread.run.step.failed":
      case "thread.run.step.cancelled":
      case "thread.run.step.expired":
        __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleRunStep).call(this, event);
        break;
      case "thread.message.created":
      case "thread.message.in_progress":
      case "thread.message.delta":
      case "thread.message.completed":
      case "thread.message.incomplete":
        __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleMessage).call(this, event);
        break;
      case "error":
        throw new Error("Encountered an error event in event processing - errors should be processed earlier");
    }
  }, _AssistantStream_endRequest = function _AssistantStream_endRequest2() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, "f"))
      throw Error("Final run has not been received");
    return __classPrivateFieldGet(this, _AssistantStream_finalRun, "f");
  }, _AssistantStream_handleMessage = function _AssistantStream_handleMessage2(event) {
    const [accumulatedMessage, newContent] = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateMessage).call(this, event, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
    __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, accumulatedMessage, "f");
    __classPrivateFieldGet(this, _AssistantStream_messageSnapshots, "f")[accumulatedMessage.id] = accumulatedMessage;
    for (const content of newContent) {
      const snapshotContent = accumulatedMessage.content[content.index];
      if ((snapshotContent == null ? void 0 : snapshotContent.type) == "text") {
        this._emit("textCreated", snapshotContent.text);
      }
    }
    switch (event.event) {
      case "thread.message.created":
        this._emit("messageCreated", event.data);
        break;
      case "thread.message.in_progress":
        break;
      case "thread.message.delta":
        this._emit("messageDelta", event.data.delta, accumulatedMessage);
        if (event.data.delta.content) {
          for (const content of event.data.delta.content) {
            if (content.type == "text" && content.text) {
              let textDelta = content.text;
              let snapshot = accumulatedMessage.content[content.index];
              if (snapshot && snapshot.type == "text") {
                this._emit("textDelta", textDelta, snapshot.text);
              } else {
                throw Error("The snapshot associated with this text delta is not text or missing");
              }
            }
            if (content.index != __classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f")) {
              if (__classPrivateFieldGet(this, _AssistantStream_currentContent, "f")) {
                switch (__classPrivateFieldGet(this, _AssistantStream_currentContent, "f").type) {
                  case "text":
                    this._emit("textDone", __classPrivateFieldGet(this, _AssistantStream_currentContent, "f").text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                    break;
                  case "image_file":
                    this._emit("imageFileDone", __classPrivateFieldGet(this, _AssistantStream_currentContent, "f").image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                    break;
                }
              }
              __classPrivateFieldSet(this, _AssistantStream_currentContentIndex, content.index, "f");
            }
            __classPrivateFieldSet(this, _AssistantStream_currentContent, accumulatedMessage.content[content.index], "f");
          }
        }
        break;
      case "thread.message.completed":
      case "thread.message.incomplete":
        if (__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f") !== void 0) {
          const currentContent = event.data.content[__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f")];
          if (currentContent) {
            switch (currentContent.type) {
              case "image_file":
                this._emit("imageFileDone", currentContent.image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                break;
              case "text":
                this._emit("textDone", currentContent.text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                break;
            }
          }
        }
        if (__classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f")) {
          this._emit("messageDone", event.data);
        }
        __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, void 0, "f");
    }
  }, _AssistantStream_handleRunStep = function _AssistantStream_handleRunStep2(event) {
    const accumulatedRunStep = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateRunStep).call(this, event);
    __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, accumulatedRunStep, "f");
    switch (event.event) {
      case "thread.run.step.created":
        this._emit("runStepCreated", event.data);
        break;
      case "thread.run.step.delta":
        const delta = event.data.delta;
        if (delta.step_details && delta.step_details.type == "tool_calls" && delta.step_details.tool_calls && accumulatedRunStep.step_details.type == "tool_calls") {
          for (const toolCall of delta.step_details.tool_calls) {
            if (toolCall.index == __classPrivateFieldGet(this, _AssistantStream_currentToolCallIndex, "f")) {
              this._emit("toolCallDelta", toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);
            } else {
              if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
                this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
              }
              __classPrivateFieldSet(this, _AssistantStream_currentToolCallIndex, toolCall.index, "f");
              __classPrivateFieldSet(this, _AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index], "f");
              if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"))
                this._emit("toolCallCreated", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
            }
          }
        }
        this._emit("runStepDelta", event.data.delta, accumulatedRunStep);
        break;
      case "thread.run.step.completed":
      case "thread.run.step.failed":
      case "thread.run.step.cancelled":
      case "thread.run.step.expired":
        __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, void 0, "f");
        const details = event.data.step_details;
        if (details.type == "tool_calls") {
          if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
            this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
            __classPrivateFieldSet(this, _AssistantStream_currentToolCall, void 0, "f");
          }
        }
        this._emit("runStepDone", event.data, accumulatedRunStep);
        break;
    }
  }, _AssistantStream_handleEvent = function _AssistantStream_handleEvent2(event) {
    __classPrivateFieldGet(this, _AssistantStream_events, "f").push(event);
    this._emit("event", event);
  }, _AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep2(event) {
    switch (event.event) {
      case "thread.run.step.created":
        __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
        return event.data;
      case "thread.run.step.delta":
        let snapshot = __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
        if (!snapshot) {
          throw Error("Received a RunStepDelta before creation of a snapshot");
        }
        let data = event.data;
        if (data.delta) {
          const accumulated = AssistantStream.accumulateDelta(snapshot, data.delta);
          __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = accumulated;
        }
        return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
      case "thread.run.step.completed":
      case "thread.run.step.failed":
      case "thread.run.step.cancelled":
      case "thread.run.step.expired":
      case "thread.run.step.in_progress":
        __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
        break;
    }
    if (__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id])
      return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
    throw new Error("No snapshot available");
  }, _AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage2(event, snapshot) {
    let newContent = [];
    switch (event.event) {
      case "thread.message.created":
        return [event.data, newContent];
      case "thread.message.delta":
        if (!snapshot) {
          throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
        }
        let data = event.data;
        if (data.delta.content) {
          for (const contentElement of data.delta.content) {
            if (contentElement.index in snapshot.content) {
              let currentContent = snapshot.content[contentElement.index];
              snapshot.content[contentElement.index] = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateContent).call(this, contentElement, currentContent);
            } else {
              snapshot.content[contentElement.index] = contentElement;
              newContent.push(contentElement);
            }
          }
        }
        return [snapshot, newContent];
      case "thread.message.in_progress":
      case "thread.message.completed":
      case "thread.message.incomplete":
        if (snapshot) {
          return [snapshot, newContent];
        } else {
          throw Error("Received thread message event with no existing snapshot");
        }
    }
    throw Error("Tried to accumulate a non-message event");
  }, _AssistantStream_accumulateContent = function _AssistantStream_accumulateContent2(contentElement, currentContent) {
    return AssistantStream.accumulateDelta(currentContent, contentElement);
  }, _AssistantStream_handleRun = function _AssistantStream_handleRun2(event) {
    __classPrivateFieldSet(this, _AssistantStream_currentRunSnapshot, event.data, "f");
    switch (event.event) {
      case "thread.run.created":
        break;
      case "thread.run.queued":
        break;
      case "thread.run.in_progress":
        break;
      case "thread.run.requires_action":
      case "thread.run.cancelled":
      case "thread.run.failed":
      case "thread.run.completed":
      case "thread.run.expired":
        __classPrivateFieldSet(this, _AssistantStream_finalRun, event.data, "f");
        if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
          this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
          __classPrivateFieldSet(this, _AssistantStream_currentToolCall, void 0, "f");
        }
        break;
    }
  };
  class Messages extends APIResource {
    /**
     * Create a message.
     */
    create(threadId, body, options) {
      return this._client.post(`/threads/${threadId}/messages`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Retrieve a message.
     */
    retrieve(threadId, messageId, options) {
      return this._client.get(`/threads/${threadId}/messages/${messageId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Modifies a message.
     */
    update(threadId, messageId, body, options) {
      return this._client.post(`/threads/${threadId}/messages/${messageId}`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    list(threadId, query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list(threadId, {}, query);
      }
      return this._client.getAPIList(`/threads/${threadId}/messages`, MessagesPage, {
        query,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Deletes a message.
     */
    del(threadId, messageId, options) {
      return this._client.delete(`/threads/${threadId}/messages/${messageId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
  }
  class MessagesPage extends CursorPage {
  }
  Messages.MessagesPage = MessagesPage;
  class Steps extends APIResource {
    retrieve(threadId, runId, stepId, query = {}, options) {
      if (isRequestOptions(query)) {
        return this.retrieve(threadId, runId, stepId, {}, query);
      }
      return this._client.get(`/threads/${threadId}/runs/${runId}/steps/${stepId}`, {
        query,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    list(threadId, runId, query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list(threadId, runId, {}, query);
      }
      return this._client.getAPIList(`/threads/${threadId}/runs/${runId}/steps`, RunStepsPage, {
        query,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
  }
  class RunStepsPage extends CursorPage {
  }
  Steps.RunStepsPage = RunStepsPage;
  class Runs extends APIResource {
    constructor() {
      super(...arguments);
      this.steps = new Steps(this._client);
    }
    create(threadId, params, options) {
      const { include, ...body } = params;
      return this._client.post(`/threads/${threadId}/runs`, {
        query: { include },
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers },
        stream: params.stream ?? false
      });
    }
    /**
     * Retrieves a run.
     */
    retrieve(threadId, runId, options) {
      return this._client.get(`/threads/${threadId}/runs/${runId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Modifies a run.
     */
    update(threadId, runId, body, options) {
      return this._client.post(`/threads/${threadId}/runs/${runId}`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    list(threadId, query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list(threadId, {}, query);
      }
      return this._client.getAPIList(`/threads/${threadId}/runs`, RunsPage, {
        query,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Cancels a run that is `in_progress`.
     */
    cancel(threadId, runId, options) {
      return this._client.post(`/threads/${threadId}/runs/${runId}/cancel`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * A helper to create a run an poll for a terminal state. More information on Run
     * lifecycles can be found here:
     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
     */
    async createAndPoll(threadId, body, options) {
      const run = await this.create(threadId, body, options);
      return await this.poll(threadId, run.id, options);
    }
    /**
     * Create a Run stream
     *
     * @deprecated use `stream` instead
     */
    createAndStream(threadId, body, options) {
      return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
    }
    /**
     * A helper to poll a run status until it reaches a terminal state. More
     * information on Run lifecycles can be found here:
     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
     */
    async poll(threadId, runId, options) {
      const headers = { ...options == null ? void 0 : options.headers, "X-Stainless-Poll-Helper": "true" };
      if (options == null ? void 0 : options.pollIntervalMs) {
        headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
      }
      while (true) {
        const { data: run, response } = await this.retrieve(threadId, runId, {
          ...options,
          headers: { ...options == null ? void 0 : options.headers, ...headers }
        }).withResponse();
        switch (run.status) {
          //If we are in any sort of intermediate state we poll
          case "queued":
          case "in_progress":
          case "cancelling":
            let sleepInterval = 5e3;
            if (options == null ? void 0 : options.pollIntervalMs) {
              sleepInterval = options.pollIntervalMs;
            } else {
              const headerInterval = response.headers.get("openai-poll-after-ms");
              if (headerInterval) {
                const headerIntervalMs = parseInt(headerInterval);
                if (!isNaN(headerIntervalMs)) {
                  sleepInterval = headerIntervalMs;
                }
              }
            }
            await sleep(sleepInterval);
            break;
          //We return the run in any terminal state.
          case "requires_action":
          case "incomplete":
          case "cancelled":
          case "completed":
          case "failed":
          case "expired":
            return run;
        }
      }
    }
    /**
     * Create a Run stream
     */
    stream(threadId, body, options) {
      return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
    }
    submitToolOutputs(threadId, runId, body, options) {
      return this._client.post(`/threads/${threadId}/runs/${runId}/submit_tool_outputs`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers },
        stream: body.stream ?? false
      });
    }
    /**
     * A helper to submit a tool output to a run and poll for a terminal run state.
     * More information on Run lifecycles can be found here:
     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
     */
    async submitToolOutputsAndPoll(threadId, runId, body, options) {
      const run = await this.submitToolOutputs(threadId, runId, body, options);
      return await this.poll(threadId, run.id, options);
    }
    /**
     * Submit the tool outputs from a previous run and stream the run to a terminal
     * state. More information on Run lifecycles can be found here:
     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
     */
    submitToolOutputsStream(threadId, runId, body, options) {
      return AssistantStream.createToolAssistantStream(threadId, runId, this._client.beta.threads.runs, body, options);
    }
  }
  class RunsPage extends CursorPage {
  }
  Runs.RunsPage = RunsPage;
  Runs.Steps = Steps;
  Runs.RunStepsPage = RunStepsPage;
  class Threads extends APIResource {
    constructor() {
      super(...arguments);
      this.runs = new Runs(this._client);
      this.messages = new Messages(this._client);
    }
    create(body = {}, options) {
      if (isRequestOptions(body)) {
        return this.create({}, body);
      }
      return this._client.post("/threads", {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Retrieves a thread.
     */
    retrieve(threadId, options) {
      return this._client.get(`/threads/${threadId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Modifies a thread.
     */
    update(threadId, body, options) {
      return this._client.post(`/threads/${threadId}`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Delete a thread.
     */
    del(threadId, options) {
      return this._client.delete(`/threads/${threadId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    createAndRun(body, options) {
      return this._client.post("/threads/runs", {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers },
        stream: body.stream ?? false
      });
    }
    /**
     * A helper to create a thread, start a run and then poll for a terminal state.
     * More information on Run lifecycles can be found here:
     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
     */
    async createAndRunPoll(body, options) {
      const run = await this.createAndRun(body, options);
      return await this.runs.poll(run.thread_id, run.id, options);
    }
    /**
     * Create a thread and stream the run back
     */
    createAndRunStream(body, options) {
      return AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options);
    }
  }
  Threads.Runs = Runs;
  Threads.RunsPage = RunsPage;
  Threads.Messages = Messages;
  Threads.MessagesPage = MessagesPage;
  const allSettledWithThrow = async (promises) => {
    const results = await Promise.allSettled(promises);
    const rejected = results.filter((result) => result.status === "rejected");
    if (rejected.length) {
      for (const result of rejected) {
        console.error(result.reason);
      }
      throw new Error(`${rejected.length} promise(s) failed - see the above errors`);
    }
    const values = [];
    for (const result of results) {
      if (result.status === "fulfilled") {
        values.push(result.value);
      }
    }
    return values;
  };
  let Files$1 = class Files extends APIResource {
    /**
     * Create a vector store file by attaching a
     * [File](https://platform.openai.com/docs/api-reference/files) to a
     * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
     */
    create(vectorStoreId, body, options) {
      return this._client.post(`/vector_stores/${vectorStoreId}/files`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Retrieves a vector store file.
     */
    retrieve(vectorStoreId, fileId, options) {
      return this._client.get(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    list(vectorStoreId, query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list(vectorStoreId, {}, query);
      }
      return this._client.getAPIList(`/vector_stores/${vectorStoreId}/files`, VectorStoreFilesPage, {
        query,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Delete a vector store file. This will remove the file from the vector store but
     * the file itself will not be deleted. To delete the file, use the
     * [delete file](https://platform.openai.com/docs/api-reference/files/delete)
     * endpoint.
     */
    del(vectorStoreId, fileId, options) {
      return this._client.delete(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Attach a file to the given vector store and wait for it to be processed.
     */
    async createAndPoll(vectorStoreId, body, options) {
      const file = await this.create(vectorStoreId, body, options);
      return await this.poll(vectorStoreId, file.id, options);
    }
    /**
     * Wait for the vector store file to finish processing.
     *
     * Note: this will return even if the file failed to process, you need to check
     * file.last_error and file.status to handle these cases
     */
    async poll(vectorStoreId, fileId, options) {
      const headers = { ...options == null ? void 0 : options.headers, "X-Stainless-Poll-Helper": "true" };
      if (options == null ? void 0 : options.pollIntervalMs) {
        headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
      }
      while (true) {
        const fileResponse = await this.retrieve(vectorStoreId, fileId, {
          ...options,
          headers
        }).withResponse();
        const file = fileResponse.data;
        switch (file.status) {
          case "in_progress":
            let sleepInterval = 5e3;
            if (options == null ? void 0 : options.pollIntervalMs) {
              sleepInterval = options.pollIntervalMs;
            } else {
              const headerInterval = fileResponse.response.headers.get("openai-poll-after-ms");
              if (headerInterval) {
                const headerIntervalMs = parseInt(headerInterval);
                if (!isNaN(headerIntervalMs)) {
                  sleepInterval = headerIntervalMs;
                }
              }
            }
            await sleep(sleepInterval);
            break;
          case "failed":
          case "completed":
            return file;
        }
      }
    }
    /**
     * Upload a file to the `files` API and then attach it to the given vector store.
     *
     * Note the file will be asynchronously processed (you can use the alternative
     * polling helper method to wait for processing to complete).
     */
    async upload(vectorStoreId, file, options) {
      const fileInfo = await this._client.files.create({ file, purpose: "assistants" }, options);
      return this.create(vectorStoreId, { file_id: fileInfo.id }, options);
    }
    /**
     * Add a file to a vector store and poll until processing is complete.
     */
    async uploadAndPoll(vectorStoreId, file, options) {
      const fileInfo = await this.upload(vectorStoreId, file, options);
      return await this.poll(vectorStoreId, fileInfo.id, options);
    }
  };
  class VectorStoreFilesPage extends CursorPage {
  }
  Files$1.VectorStoreFilesPage = VectorStoreFilesPage;
  class FileBatches extends APIResource {
    /**
     * Create a vector store file batch.
     */
    create(vectorStoreId, body, options) {
      return this._client.post(`/vector_stores/${vectorStoreId}/file_batches`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Retrieves a vector store file batch.
     */
    retrieve(vectorStoreId, batchId, options) {
      return this._client.get(`/vector_stores/${vectorStoreId}/file_batches/${batchId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Cancel a vector store file batch. This attempts to cancel the processing of
     * files in this batch as soon as possible.
     */
    cancel(vectorStoreId, batchId, options) {
      return this._client.post(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/cancel`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Create a vector store batch and poll until all files have been processed.
     */
    async createAndPoll(vectorStoreId, body, options) {
      const batch = await this.create(vectorStoreId, body);
      return await this.poll(vectorStoreId, batch.id, options);
    }
    listFiles(vectorStoreId, batchId, query = {}, options) {
      if (isRequestOptions(query)) {
        return this.listFiles(vectorStoreId, batchId, {}, query);
      }
      return this._client.getAPIList(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/files`, VectorStoreFilesPage, { query, ...options, headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers } });
    }
    /**
     * Wait for the given file batch to be processed.
     *
     * Note: this will return even if one of the files failed to process, you need to
     * check batch.file_counts.failed_count to handle this case.
     */
    async poll(vectorStoreId, batchId, options) {
      const headers = { ...options == null ? void 0 : options.headers, "X-Stainless-Poll-Helper": "true" };
      if (options == null ? void 0 : options.pollIntervalMs) {
        headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
      }
      while (true) {
        const { data: batch, response } = await this.retrieve(vectorStoreId, batchId, {
          ...options,
          headers
        }).withResponse();
        switch (batch.status) {
          case "in_progress":
            let sleepInterval = 5e3;
            if (options == null ? void 0 : options.pollIntervalMs) {
              sleepInterval = options.pollIntervalMs;
            } else {
              const headerInterval = response.headers.get("openai-poll-after-ms");
              if (headerInterval) {
                const headerIntervalMs = parseInt(headerInterval);
                if (!isNaN(headerIntervalMs)) {
                  sleepInterval = headerIntervalMs;
                }
              }
            }
            await sleep(sleepInterval);
            break;
          case "failed":
          case "cancelled":
          case "completed":
            return batch;
        }
      }
    }
    /**
     * Uploads the given files concurrently and then creates a vector store file batch.
     *
     * The concurrency limit is configurable using the `maxConcurrency` parameter.
     */
    async uploadAndPoll(vectorStoreId, { files, fileIds = [] }, options) {
      if (files == null || files.length == 0) {
        throw new Error(`No \`files\` provided to process. If you've already uploaded files you should use \`.createAndPoll()\` instead`);
      }
      const configuredConcurrency = (options == null ? void 0 : options.maxConcurrency) ?? 5;
      const concurrencyLimit = Math.min(configuredConcurrency, files.length);
      const client2 = this._client;
      const fileIterator = files.values();
      const allFileIds = [...fileIds];
      async function processFiles(iterator2) {
        for (let item of iterator2) {
          const fileObj = await client2.files.create({ file: item, purpose: "assistants" }, options);
          allFileIds.push(fileObj.id);
        }
      }
      const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);
      await allSettledWithThrow(workers);
      return await this.createAndPoll(vectorStoreId, {
        file_ids: allFileIds
      });
    }
  }
  class VectorStores extends APIResource {
    constructor() {
      super(...arguments);
      this.files = new Files$1(this._client);
      this.fileBatches = new FileBatches(this._client);
    }
    /**
     * Create a vector store.
     */
    create(body, options) {
      return this._client.post("/vector_stores", {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Retrieves a vector store.
     */
    retrieve(vectorStoreId, options) {
      return this._client.get(`/vector_stores/${vectorStoreId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Modifies a vector store.
     */
    update(vectorStoreId, body, options) {
      return this._client.post(`/vector_stores/${vectorStoreId}`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    list(query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list({}, query);
      }
      return this._client.getAPIList("/vector_stores", VectorStoresPage, {
        query,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Delete a vector store.
     */
    del(vectorStoreId, options) {
      return this._client.delete(`/vector_stores/${vectorStoreId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
  }
  class VectorStoresPage extends CursorPage {
  }
  VectorStores.VectorStoresPage = VectorStoresPage;
  VectorStores.Files = Files$1;
  VectorStores.VectorStoreFilesPage = VectorStoreFilesPage;
  VectorStores.FileBatches = FileBatches;
  class Beta extends APIResource {
    constructor() {
      super(...arguments);
      this.realtime = new Realtime(this._client);
      this.vectorStores = new VectorStores(this._client);
      this.chat = new Chat(this._client);
      this.assistants = new Assistants(this._client);
      this.threads = new Threads(this._client);
    }
  }
  Beta.Realtime = Realtime;
  Beta.VectorStores = VectorStores;
  Beta.VectorStoresPage = VectorStoresPage;
  Beta.Assistants = Assistants;
  Beta.AssistantsPage = AssistantsPage;
  Beta.Threads = Threads;
  class Completions extends APIResource {
    create(body, options) {
      return this._client.post("/completions", { body, ...options, stream: body.stream ?? false });
    }
  }
  class Embeddings extends APIResource {
    /**
     * Creates an embedding vector representing the input text.
     */
    create(body, options) {
      return this._client.post("/embeddings", { body, ...options });
    }
  }
  class Files extends APIResource {
    /**
     * Upload a file that can be used across various endpoints. Individual files can be
     * up to 512 MB, and the size of all files uploaded by one organization can be up
     * to 100 GB.
     *
     * The Assistants API supports files up to 2 million tokens and of specific file
     * types. See the
     * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) for
     * details.
     *
     * The Fine-tuning API only supports `.jsonl` files. The input also has certain
     * required formats for fine-tuning
     * [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or
     * [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
     * models.
     *
     * The Batch API only supports `.jsonl` files up to 200 MB in size. The input also
     * has a specific required
     * [format](https://platform.openai.com/docs/api-reference/batch/request-input).
     *
     * Please [contact us](https://help.openai.com/) if you need to increase these
     * storage limits.
     */
    create(body, options) {
      return this._client.post("/files", multipartFormRequestOptions({ body, ...options }));
    }
    /**
     * Returns information about a specific file.
     */
    retrieve(fileId, options) {
      return this._client.get(`/files/${fileId}`, options);
    }
    list(query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list({}, query);
      }
      return this._client.getAPIList("/files", FileObjectsPage, { query, ...options });
    }
    /**
     * Delete a file.
     */
    del(fileId, options) {
      return this._client.delete(`/files/${fileId}`, options);
    }
    /**
     * Returns the contents of the specified file.
     */
    content(fileId, options) {
      return this._client.get(`/files/${fileId}/content`, {
        ...options,
        headers: { Accept: "application/binary", ...options == null ? void 0 : options.headers },
        __binaryResponse: true
      });
    }
    /**
     * Returns the contents of the specified file.
     *
     * @deprecated The `.content()` method should be used instead
     */
    retrieveContent(fileId, options) {
      return this._client.get(`/files/${fileId}/content`, options);
    }
    /**
     * Waits for the given file to be processed, default timeout is 30 mins.
     */
    async waitForProcessing(id, { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}) {
      const TERMINAL_STATES = /* @__PURE__ */ new Set(["processed", "error", "deleted"]);
      const start = Date.now();
      let file = await this.retrieve(id);
      while (!file.status || !TERMINAL_STATES.has(file.status)) {
        await sleep(pollInterval);
        file = await this.retrieve(id);
        if (Date.now() - start > maxWait) {
          throw new APIConnectionTimeoutError({
            message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
          });
        }
      }
      return file;
    }
  }
  class FileObjectsPage extends CursorPage {
  }
  Files.FileObjectsPage = FileObjectsPage;
  class Checkpoints extends APIResource {
    list(fineTuningJobId, query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list(fineTuningJobId, {}, query);
      }
      return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/checkpoints`, FineTuningJobCheckpointsPage, { query, ...options });
    }
  }
  class FineTuningJobCheckpointsPage extends CursorPage {
  }
  Checkpoints.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;
  class Jobs extends APIResource {
    constructor() {
      super(...arguments);
      this.checkpoints = new Checkpoints(this._client);
    }
    /**
     * Creates a fine-tuning job which begins the process of creating a new model from
     * a given dataset.
     *
     * Response includes details of the enqueued job including job status and the name
     * of the fine-tuned models once complete.
     *
     * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
     */
    create(body, options) {
      return this._client.post("/fine_tuning/jobs", { body, ...options });
    }
    /**
     * Get info about a fine-tuning job.
     *
     * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
     */
    retrieve(fineTuningJobId, options) {
      return this._client.get(`/fine_tuning/jobs/${fineTuningJobId}`, options);
    }
    list(query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list({}, query);
      }
      return this._client.getAPIList("/fine_tuning/jobs", FineTuningJobsPage, { query, ...options });
    }
    /**
     * Immediately cancel a fine-tune job.
     */
    cancel(fineTuningJobId, options) {
      return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`, options);
    }
    listEvents(fineTuningJobId, query = {}, options) {
      if (isRequestOptions(query)) {
        return this.listEvents(fineTuningJobId, {}, query);
      }
      return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/events`, FineTuningJobEventsPage, {
        query,
        ...options
      });
    }
  }
  class FineTuningJobsPage extends CursorPage {
  }
  class FineTuningJobEventsPage extends CursorPage {
  }
  Jobs.FineTuningJobsPage = FineTuningJobsPage;
  Jobs.FineTuningJobEventsPage = FineTuningJobEventsPage;
  Jobs.Checkpoints = Checkpoints;
  Jobs.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;
  class FineTuning extends APIResource {
    constructor() {
      super(...arguments);
      this.jobs = new Jobs(this._client);
    }
  }
  FineTuning.Jobs = Jobs;
  FineTuning.FineTuningJobsPage = FineTuningJobsPage;
  FineTuning.FineTuningJobEventsPage = FineTuningJobEventsPage;
  class Images extends APIResource {
    /**
     * Creates a variation of a given image.
     */
    createVariation(body, options) {
      return this._client.post("/images/variations", multipartFormRequestOptions({ body, ...options }));
    }
    /**
     * Creates an edited or extended image given an original image and a prompt.
     */
    edit(body, options) {
      return this._client.post("/images/edits", multipartFormRequestOptions({ body, ...options }));
    }
    /**
     * Creates an image given a prompt.
     */
    generate(body, options) {
      return this._client.post("/images/generations", { body, ...options });
    }
  }
  class Models extends APIResource {
    /**
     * Retrieves a model instance, providing basic information about the model such as
     * the owner and permissioning.
     */
    retrieve(model, options) {
      return this._client.get(`/models/${model}`, options);
    }
    /**
     * Lists the currently available models, and provides basic information about each
     * one such as the owner and availability.
     */
    list(options) {
      return this._client.getAPIList("/models", ModelsPage, options);
    }
    /**
     * Delete a fine-tuned model. You must have the Owner role in your organization to
     * delete a model.
     */
    del(model, options) {
      return this._client.delete(`/models/${model}`, options);
    }
  }
  class ModelsPage extends Page {
  }
  Models.ModelsPage = ModelsPage;
  class Moderations extends APIResource {
    /**
     * Classifies if text and/or image inputs are potentially harmful. Learn more in
     * the [moderation guide](https://platform.openai.com/docs/guides/moderation).
     */
    create(body, options) {
      return this._client.post("/moderations", { body, ...options });
    }
  }
  class Parts extends APIResource {
    /**
     * Adds a
     * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an
     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.
     * A Part represents a chunk of bytes from the file you are trying to upload.
     *
     * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload
     * maximum of 8 GB.
     *
     * It is possible to add multiple Parts in parallel. You can decide the intended
     * order of the Parts when you
     * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).
     */
    create(uploadId, body, options) {
      return this._client.post(`/uploads/${uploadId}/parts`, multipartFormRequestOptions({ body, ...options }));
    }
  }
  class Uploads extends APIResource {
    constructor() {
      super(...arguments);
      this.parts = new Parts(this._client);
    }
    /**
     * Creates an intermediate
     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object
     * that you can add
     * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.
     * Currently, an Upload can accept at most 8 GB in total and expires after an hour
     * after you create it.
     *
     * Once you complete the Upload, we will create a
     * [File](https://platform.openai.com/docs/api-reference/files/object) object that
     * contains all the parts you uploaded. This File is usable in the rest of our
     * platform as a regular File object.
     *
     * For certain `purpose`s, the correct `mime_type` must be specified. Please refer
     * to documentation for the supported MIME types for your use case:
     *
     * - [Assistants](https://platform.openai.com/docs/assistants/tools/file-search#supported-files)
     *
     * For guidance on the proper filename extensions for each purpose, please follow
     * the documentation on
     * [creating a File](https://platform.openai.com/docs/api-reference/files/create).
     */
    create(body, options) {
      return this._client.post("/uploads", { body, ...options });
    }
    /**
     * Cancels the Upload. No Parts may be added after an Upload is cancelled.
     */
    cancel(uploadId, options) {
      return this._client.post(`/uploads/${uploadId}/cancel`, options);
    }
    /**
     * Completes the
     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).
     *
     * Within the returned Upload object, there is a nested
     * [File](https://platform.openai.com/docs/api-reference/files/object) object that
     * is ready to use in the rest of the platform.
     *
     * You can specify the order of the Parts by passing in an ordered list of the Part
     * IDs.
     *
     * The number of bytes uploaded upon completion must match the number of bytes
     * initially specified when creating the Upload object. No Parts may be added after
     * an Upload is completed.
     */
    complete(uploadId, body, options) {
      return this._client.post(`/uploads/${uploadId}/complete`, { body, ...options });
    }
  }
  Uploads.Parts = Parts;
  var _a$2;
  let OpenAI$1 = class OpenAI extends APIClient {
    /**
     * API Client for interfacing with the OpenAI API.
     *
     * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
     * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
     * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]
     * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
     * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
     * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
     * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
     * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
     * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
     * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
     * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
     */
    constructor({ baseURL = readEnv("OPENAI_BASE_URL"), apiKey = readEnv("OPENAI_API_KEY"), organization = readEnv("OPENAI_ORG_ID") ?? null, project = readEnv("OPENAI_PROJECT_ID") ?? null, ...opts } = {}) {
      if (apiKey === void 0) {
        throw new OpenAIError("The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).");
      }
      const options = {
        apiKey,
        organization,
        project,
        ...opts,
        baseURL: baseURL || `https://api.openai.com/v1`
      };
      if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
        throw new OpenAIError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n");
      }
      super({
        baseURL: options.baseURL,
        timeout: options.timeout ?? 6e5,
        httpAgent: options.httpAgent,
        maxRetries: options.maxRetries,
        fetch: options.fetch
      });
      this.completions = new Completions(this);
      this.chat = new Chat$1(this);
      this.embeddings = new Embeddings(this);
      this.files = new Files(this);
      this.images = new Images(this);
      this.audio = new Audio(this);
      this.moderations = new Moderations(this);
      this.models = new Models(this);
      this.fineTuning = new FineTuning(this);
      this.beta = new Beta(this);
      this.batches = new Batches(this);
      this.uploads = new Uploads(this);
      this._options = options;
      this.apiKey = apiKey;
      this.organization = organization;
      this.project = project;
    }
    defaultQuery() {
      return this._options.defaultQuery;
    }
    defaultHeaders(opts) {
      return {
        ...super.defaultHeaders(opts),
        "OpenAI-Organization": this.organization,
        "OpenAI-Project": this.project,
        ...this._options.defaultHeaders
      };
    }
    authHeaders(opts) {
      return { Authorization: `Bearer ${this.apiKey}` };
    }
    stringifyQuery(query) {
      return stringify(query, { arrayFormat: "brackets" });
    }
  };
  _a$2 = OpenAI$1;
  OpenAI$1.OpenAI = _a$2;
  OpenAI$1.DEFAULT_TIMEOUT = 6e5;
  OpenAI$1.OpenAIError = OpenAIError;
  OpenAI$1.APIError = APIError;
  OpenAI$1.APIConnectionError = APIConnectionError;
  OpenAI$1.APIConnectionTimeoutError = APIConnectionTimeoutError;
  OpenAI$1.APIUserAbortError = APIUserAbortError;
  OpenAI$1.NotFoundError = NotFoundError;
  OpenAI$1.ConflictError = ConflictError;
  OpenAI$1.RateLimitError = RateLimitError;
  OpenAI$1.BadRequestError = BadRequestError;
  OpenAI$1.AuthenticationError = AuthenticationError;
  OpenAI$1.InternalServerError = InternalServerError;
  OpenAI$1.PermissionDeniedError = PermissionDeniedError;
  OpenAI$1.UnprocessableEntityError = UnprocessableEntityError;
  OpenAI$1.toFile = toFile;
  OpenAI$1.fileFromPath = fileFromPath;
  OpenAI$1.Completions = Completions;
  OpenAI$1.Chat = Chat$1;
  OpenAI$1.Embeddings = Embeddings;
  OpenAI$1.Files = Files;
  OpenAI$1.FileObjectsPage = FileObjectsPage;
  OpenAI$1.Images = Images;
  OpenAI$1.Audio = Audio;
  OpenAI$1.Moderations = Moderations;
  OpenAI$1.Models = Models;
  OpenAI$1.ModelsPage = ModelsPage;
  OpenAI$1.FineTuning = FineTuning;
  OpenAI$1.Beta = Beta;
  OpenAI$1.Batches = Batches;
  OpenAI$1.BatchesPage = BatchesPage;
  OpenAI$1.Uploads = Uploads;
  const ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
  const defaultOptions = {
    name: void 0,
    $refStrategy: "root",
    effectStrategy: "input",
    pipeStrategy: "all",
    dateStrategy: "format:date-time",
    mapStrategy: "entries",
    nullableStrategy: "from-target",
    removeAdditionalStrategy: "passthrough",
    definitionPath: "definitions",
    target: "jsonSchema7",
    strictUnions: false,
    errorMessages: false,
    markdownDescription: false,
    patternStrategy: "escape",
    applyRegexFlags: false,
    emailStrategy: "format:email",
    base64Strategy: "contentEncoding:base64",
    nameStrategy: "ref"
  };
  const getDefaultOptions = (options) => {
    return typeof options === "string" ? {
      ...defaultOptions,
      basePath: ["#"],
      definitions: {},
      name: options
    } : {
      ...defaultOptions,
      basePath: ["#"],
      definitions: {},
      ...options
    };
  };
  const zodDef = (zodSchema) => {
    return "_def" in zodSchema ? zodSchema._def : zodSchema;
  };
  function isEmptyObj(obj) {
    if (!obj)
      return true;
    for (const _k2 in obj)
      return false;
    return true;
  }
  const getRefs = (options) => {
    const _options = getDefaultOptions(options);
    const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
    return {
      ..._options,
      currentPath,
      propertyPath: void 0,
      seenRefs: /* @__PURE__ */ new Set(),
      seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [
        zodDef(def),
        {
          def: zodDef(def),
          path: [..._options.basePath, _options.definitionPath, name],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ]))
    };
  };
  function addErrorMessage(res, key, errorMessage, refs) {
    if (!(refs == null ? void 0 : refs.errorMessages))
      return;
    if (errorMessage) {
      res.errorMessage = {
        ...res.errorMessage,
        [key]: errorMessage
      };
    }
  }
  function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
    res[key] = value;
    addErrorMessage(res, key, errorMessage, refs);
  }
  function parseAnyDef() {
    return {};
  }
  function parseArrayDef(def, refs) {
    var _a3, _b2;
    const res = {
      type: "array"
    };
    if (((_b2 = (_a3 = def.type) == null ? void 0 : _a3._def) == null ? void 0 : _b2.typeName) !== ZodFirstPartyTypeKind.ZodAny) {
      res.items = parseDef(def.type._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items"]
      });
    }
    if (def.minLength) {
      setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
    }
    if (def.maxLength) {
      setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
    }
    if (def.exactLength) {
      setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
      setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
    }
    return res;
  }
  function parseBigintDef(def, refs) {
    const res = {
      type: "integer",
      format: "int64"
    };
    if (!def.checks)
      return res;
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          if (refs.target === "jsonSchema7") {
            if (check.inclusive) {
              setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
            } else {
              setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
            }
          } else {
            if (!check.inclusive) {
              res.exclusiveMinimum = true;
            }
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          }
          break;
        case "max":
          if (refs.target === "jsonSchema7") {
            if (check.inclusive) {
              setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
            } else {
              setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
            }
          } else {
            if (!check.inclusive) {
              res.exclusiveMaximum = true;
            }
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          }
          break;
        case "multipleOf":
          setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
          break;
      }
    }
    return res;
  }
  function parseBooleanDef() {
    return {
      type: "boolean"
    };
  }
  function parseBrandedDef(_def, refs) {
    return parseDef(_def.type._def, refs);
  }
  const parseCatchDef = (def, refs) => {
    return parseDef(def.innerType._def, refs);
  };
  function parseDateDef(def, refs, overrideDateStrategy) {
    const strategy = overrideDateStrategy ?? refs.dateStrategy;
    if (Array.isArray(strategy)) {
      return {
        anyOf: strategy.map((item, i2) => parseDateDef(def, refs, item))
      };
    }
    switch (strategy) {
      case "string":
      case "format:date-time":
        return {
          type: "string",
          format: "date-time"
        };
      case "format:date":
        return {
          type: "string",
          format: "date"
        };
      case "integer":
        return integerDateParser(def, refs);
    }
  }
  const integerDateParser = (def, refs) => {
    const res = {
      type: "integer",
      format: "unix-time"
    };
    if (refs.target === "openApi3") {
      return res;
    }
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors(
            res,
            "minimum",
            check.value,
            // This is in milliseconds
            check.message,
            refs
          );
          break;
        case "max":
          setResponseValueAndErrors(
            res,
            "maximum",
            check.value,
            // This is in milliseconds
            check.message,
            refs
          );
          break;
      }
    }
    return res;
  };
  function parseDefaultDef(_def, refs) {
    return {
      ...parseDef(_def.innerType._def, refs),
      default: _def.defaultValue()
    };
  }
  function parseEffectsDef(_def, refs, forceResolution) {
    return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs, forceResolution) : {};
  }
  function parseEnumDef(def) {
    return {
      type: "string",
      enum: [...def.values]
    };
  }
  const isJsonSchema7AllOfType = (type) => {
    if ("type" in type && type.type === "string")
      return false;
    return "allOf" in type;
  };
  function parseIntersectionDef(def, refs) {
    const allOf = [
      parseDef(def.left._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", "0"]
      }),
      parseDef(def.right._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", "1"]
      })
    ].filter((x) => !!x);
    let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
    const mergedAllOf = [];
    allOf.forEach((schema) => {
      if (isJsonSchema7AllOfType(schema)) {
        mergedAllOf.push(...schema.allOf);
        if (schema.unevaluatedProperties === void 0) {
          unevaluatedProperties = void 0;
        }
      } else {
        let nestedSchema = schema;
        if ("additionalProperties" in schema && schema.additionalProperties === false) {
          const { additionalProperties, ...rest } = schema;
          nestedSchema = rest;
        } else {
          unevaluatedProperties = void 0;
        }
        mergedAllOf.push(nestedSchema);
      }
    });
    return mergedAllOf.length ? {
      allOf: mergedAllOf,
      ...unevaluatedProperties
    } : void 0;
  }
  function parseLiteralDef(def, refs) {
    const parsedType = typeof def.value;
    if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
      return {
        type: Array.isArray(def.value) ? "array" : "object"
      };
    }
    if (refs.target === "openApi3") {
      return {
        type: parsedType === "bigint" ? "integer" : parsedType,
        enum: [def.value]
      };
    }
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      const: def.value
    };
  }
  let emojiRegex;
  const zodPatterns = {
    /**
     * `c` was changed to `[cC]` to replicate /i flag
     */
    cuid: /^[cC][^\s-]{8,}$/,
    cuid2: /^[0-9a-z]+$/,
    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
    /**
     * `a-z` was added to replicate /i flag
     */
    email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
    /**
     * Constructed a valid Unicode RegExp
     *
     * Lazily instantiate since this type of regex isn't supported
     * in all envs (e.g. React Native).
     *
     * See:
     * https://github.com/colinhacks/zod/issues/2433
     * Fix in Zod:
     * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
     */
    emoji: () => {
      if (emojiRegex === void 0) {
        emojiRegex = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
      }
      return emojiRegex;
    },
    /**
     * Unused
     */
    uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
    /**
     * Unused
     */
    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    /**
     * Unused
     */
    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
    nanoid: /^[a-zA-Z0-9_-]{21}$/
  };
  function parseStringDef(def, refs) {
    const res = {
      type: "string"
    };
    function processPattern(value) {
      return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(value) : value;
    }
    if (def.checks) {
      for (const check of def.checks) {
        switch (check.kind) {
          case "min":
            setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
            break;
          case "max":
            setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
            break;
          case "email":
            switch (refs.emailStrategy) {
              case "format:email":
                addFormat(res, "email", check.message, refs);
                break;
              case "format:idn-email":
                addFormat(res, "idn-email", check.message, refs);
                break;
              case "pattern:zod":
                addPattern(res, zodPatterns.email, check.message, refs);
                break;
            }
            break;
          case "url":
            addFormat(res, "uri", check.message, refs);
            break;
          case "uuid":
            addFormat(res, "uuid", check.message, refs);
            break;
          case "regex":
            addPattern(res, check.regex, check.message, refs);
            break;
          case "cuid":
            addPattern(res, zodPatterns.cuid, check.message, refs);
            break;
          case "cuid2":
            addPattern(res, zodPatterns.cuid2, check.message, refs);
            break;
          case "startsWith":
            addPattern(res, RegExp(`^${processPattern(check.value)}`), check.message, refs);
            break;
          case "endsWith":
            addPattern(res, RegExp(`${processPattern(check.value)}$`), check.message, refs);
            break;
          case "datetime":
            addFormat(res, "date-time", check.message, refs);
            break;
          case "date":
            addFormat(res, "date", check.message, refs);
            break;
          case "time":
            addFormat(res, "time", check.message, refs);
            break;
          case "duration":
            addFormat(res, "duration", check.message, refs);
            break;
          case "length":
            setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
            setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
            break;
          case "includes": {
            addPattern(res, RegExp(processPattern(check.value)), check.message, refs);
            break;
          }
          case "ip": {
            if (check.version !== "v6") {
              addFormat(res, "ipv4", check.message, refs);
            }
            if (check.version !== "v4") {
              addFormat(res, "ipv6", check.message, refs);
            }
            break;
          }
          case "emoji":
            addPattern(res, zodPatterns.emoji, check.message, refs);
            break;
          case "ulid": {
            addPattern(res, zodPatterns.ulid, check.message, refs);
            break;
          }
          case "base64": {
            switch (refs.base64Strategy) {
              case "format:binary": {
                addFormat(res, "binary", check.message, refs);
                break;
              }
              case "contentEncoding:base64": {
                setResponseValueAndErrors(res, "contentEncoding", "base64", check.message, refs);
                break;
              }
              case "pattern:zod": {
                addPattern(res, zodPatterns.base64, check.message, refs);
                break;
              }
            }
            break;
          }
          case "nanoid": {
            addPattern(res, zodPatterns.nanoid, check.message, refs);
          }
        }
      }
    }
    return res;
  }
  const escapeNonAlphaNumeric = (value) => Array.from(value).map((c) => /[a-zA-Z0-9]/.test(c) ? c : `\\${c}`).join("");
  const addFormat = (schema, value, message, refs) => {
    var _a3;
    if (schema.format || ((_a3 = schema.anyOf) == null ? void 0 : _a3.some((x) => x.format))) {
      if (!schema.anyOf) {
        schema.anyOf = [];
      }
      if (schema.format) {
        schema.anyOf.push({
          format: schema.format,
          ...schema.errorMessage && refs.errorMessages && {
            errorMessage: { format: schema.errorMessage.format }
          }
        });
        delete schema.format;
        if (schema.errorMessage) {
          delete schema.errorMessage.format;
          if (Object.keys(schema.errorMessage).length === 0) {
            delete schema.errorMessage;
          }
        }
      }
      schema.anyOf.push({
        format: value,
        ...message && refs.errorMessages && { errorMessage: { format: message } }
      });
    } else {
      setResponseValueAndErrors(schema, "format", value, message, refs);
    }
  };
  const addPattern = (schema, regex, message, refs) => {
    var _a3;
    if (schema.pattern || ((_a3 = schema.allOf) == null ? void 0 : _a3.some((x) => x.pattern))) {
      if (!schema.allOf) {
        schema.allOf = [];
      }
      if (schema.pattern) {
        schema.allOf.push({
          pattern: schema.pattern,
          ...schema.errorMessage && refs.errorMessages && {
            errorMessage: { pattern: schema.errorMessage.pattern }
          }
        });
        delete schema.pattern;
        if (schema.errorMessage) {
          delete schema.errorMessage.pattern;
          if (Object.keys(schema.errorMessage).length === 0) {
            delete schema.errorMessage;
          }
        }
      }
      schema.allOf.push({
        pattern: processRegExp(regex, refs),
        ...message && refs.errorMessages && { errorMessage: { pattern: message } }
      });
    } else {
      setResponseValueAndErrors(schema, "pattern", processRegExp(regex, refs), message, refs);
    }
  };
  const processRegExp = (regexOrFunction, refs) => {
    var _a3;
    const regex = typeof regexOrFunction === "function" ? regexOrFunction() : regexOrFunction;
    if (!refs.applyRegexFlags || !regex.flags)
      return regex.source;
    const flags = {
      i: regex.flags.includes("i"),
      m: regex.flags.includes("m"),
      s: regex.flags.includes("s")
      // `.` matches newlines
    };
    const source2 = flags.i ? regex.source.toLowerCase() : regex.source;
    let pattern = "";
    let isEscaped = false;
    let inCharGroup = false;
    let inCharRange = false;
    for (let i2 = 0; i2 < source2.length; i2++) {
      if (isEscaped) {
        pattern += source2[i2];
        isEscaped = false;
        continue;
      }
      if (flags.i) {
        if (inCharGroup) {
          if (source2[i2].match(/[a-z]/)) {
            if (inCharRange) {
              pattern += source2[i2];
              pattern += `${source2[i2 - 2]}-${source2[i2]}`.toUpperCase();
              inCharRange = false;
            } else if (source2[i2 + 1] === "-" && ((_a3 = source2[i2 + 2]) == null ? void 0 : _a3.match(/[a-z]/))) {
              pattern += source2[i2];
              inCharRange = true;
            } else {
              pattern += `${source2[i2]}${source2[i2].toUpperCase()}`;
            }
            continue;
          }
        } else if (source2[i2].match(/[a-z]/)) {
          pattern += `[${source2[i2]}${source2[i2].toUpperCase()}]`;
          continue;
        }
      }
      if (flags.m) {
        if (source2[i2] === "^") {
          pattern += `(^|(?<=[\r
]))`;
          continue;
        } else if (source2[i2] === "$") {
          pattern += `($|(?=[\r
]))`;
          continue;
        }
      }
      if (flags.s && source2[i2] === ".") {
        pattern += inCharGroup ? `${source2[i2]}\r
` : `[${source2[i2]}\r
]`;
        continue;
      }
      pattern += source2[i2];
      if (source2[i2] === "\\") {
        isEscaped = true;
      } else if (inCharGroup && source2[i2] === "]") {
        inCharGroup = false;
      } else if (!inCharGroup && source2[i2] === "[") {
        inCharGroup = true;
      }
    }
    try {
      const regexTest = new RegExp(pattern);
    } catch {
      console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
      return regex.source;
    }
    return pattern;
  };
  function parseRecordDef(def, refs) {
    var _a3, _b2, _c2, _d2;
    if (refs.target === "openApi3" && ((_a3 = def.keyType) == null ? void 0 : _a3._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {
      return {
        type: "object",
        required: def.keyType._def.values,
        properties: def.keyType._def.values.reduce((acc, key) => ({
          ...acc,
          [key]: parseDef(def.valueType._def, {
            ...refs,
            currentPath: [...refs.currentPath, "properties", key]
          }) ?? {}
        }), {}),
        additionalProperties: false
      };
    }
    const schema = {
      type: "object",
      additionalProperties: parseDef(def.valueType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalProperties"]
      }) ?? {}
    };
    if (refs.target === "openApi3") {
      return schema;
    }
    if (((_b2 = def.keyType) == null ? void 0 : _b2._def.typeName) === ZodFirstPartyTypeKind.ZodString && ((_c2 = def.keyType._def.checks) == null ? void 0 : _c2.length)) {
      const keyType = Object.entries(parseStringDef(def.keyType._def, refs)).reduce((acc, [key, value]) => key === "type" ? acc : { ...acc, [key]: value }, {});
      return {
        ...schema,
        propertyNames: keyType
      };
    } else if (((_d2 = def.keyType) == null ? void 0 : _d2._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {
      return {
        ...schema,
        propertyNames: {
          enum: def.keyType._def.values
        }
      };
    }
    return schema;
  }
  function parseMapDef(def, refs) {
    if (refs.mapStrategy === "record") {
      return parseRecordDef(def, refs);
    }
    const keys = parseDef(def.keyType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items", "items", "0"]
    }) || {};
    const values = parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items", "items", "1"]
    }) || {};
    return {
      type: "array",
      maxItems: 125,
      items: {
        type: "array",
        items: [keys, values],
        minItems: 2,
        maxItems: 2
      }
    };
  }
  function parseNativeEnumDef(def) {
    const object = def.values;
    const actualKeys = Object.keys(def.values).filter((key) => {
      return typeof object[object[key]] !== "number";
    });
    const actualValues = actualKeys.map((key) => object[key]);
    const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
    return {
      type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
      enum: actualValues
    };
  }
  function parseNeverDef() {
    return {
      not: {}
    };
  }
  function parseNullDef(refs) {
    return refs.target === "openApi3" ? {
      enum: ["null"],
      nullable: true
    } : {
      type: "null"
    };
  }
  const primitiveMappings = {
    ZodString: "string",
    ZodNumber: "number",
    ZodBigInt: "integer",
    ZodBoolean: "boolean",
    ZodNull: "null"
  };
  function parseUnionDef(def, refs) {
    if (refs.target === "openApi3")
      return asAnyOf(def, refs);
    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
    if (options.every((x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))) {
      const types = options.reduce((types2, x) => {
        const type = primitiveMappings[x._def.typeName];
        return type && !types2.includes(type) ? [...types2, type] : types2;
      }, []);
      return {
        type: types.length > 1 ? types : types[0]
      };
    } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
      const types = options.reduce((acc, x) => {
        const type = typeof x._def.value;
        switch (type) {
          case "string":
          case "number":
          case "boolean":
            return [...acc, type];
          case "bigint":
            return [...acc, "integer"];
          case "object":
            if (x._def.value === null)
              return [...acc, "null"];
          case "symbol":
          case "undefined":
          case "function":
          default:
            return acc;
        }
      }, []);
      if (types.length === options.length) {
        const uniqueTypes = types.filter((x, i2, a) => a.indexOf(x) === i2);
        return {
          type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
          enum: options.reduce((acc, x) => {
            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
          }, [])
        };
      }
    } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
      return {
        type: "string",
        enum: options.reduce((acc, x) => [...acc, ...x._def.values.filter((x2) => !acc.includes(x2))], [])
      };
    }
    return asAnyOf(def, refs);
  }
  const asAnyOf = (def, refs) => {
    const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i2) => parseDef(x._def, {
      ...refs,
      currentPath: [...refs.currentPath, "anyOf", `${i2}`]
    })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
    return anyOf.length ? { anyOf } : void 0;
  };
  function parseNullableDef(def, refs) {
    if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
      if (refs.target === "openApi3" || refs.nullableStrategy === "property") {
        return {
          type: primitiveMappings[def.innerType._def.typeName],
          nullable: true
        };
      }
      return {
        type: [primitiveMappings[def.innerType._def.typeName], "null"]
      };
    }
    if (refs.target === "openApi3") {
      const base2 = parseDef(def.innerType._def, {
        ...refs,
        currentPath: [...refs.currentPath]
      });
      if (base2 && "$ref" in base2)
        return { allOf: [base2], nullable: true };
      return base2 && { ...base2, nullable: true };
    }
    const base = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "anyOf", "0"]
    });
    return base && { anyOf: [base, { type: "null" }] };
  }
  function parseNumberDef(def, refs) {
    const res = {
      type: "number"
    };
    if (!def.checks)
      return res;
    for (const check of def.checks) {
      switch (check.kind) {
        case "int":
          res.type = "integer";
          addErrorMessage(res, "type", check.message, refs);
          break;
        case "min":
          if (refs.target === "jsonSchema7") {
            if (check.inclusive) {
              setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
            } else {
              setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
            }
          } else {
            if (!check.inclusive) {
              res.exclusiveMinimum = true;
            }
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          }
          break;
        case "max":
          if (refs.target === "jsonSchema7") {
            if (check.inclusive) {
              setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
            } else {
              setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
            }
          } else {
            if (!check.inclusive) {
              res.exclusiveMaximum = true;
            }
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          }
          break;
        case "multipleOf":
          setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
          break;
      }
    }
    return res;
  }
  function decideAdditionalProperties(def, refs) {
    if (refs.removeAdditionalStrategy === "strict") {
      return def.catchall._def.typeName === "ZodNever" ? def.unknownKeys !== "strict" : parseDef(def.catchall._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalProperties"]
      }) ?? true;
    } else {
      return def.catchall._def.typeName === "ZodNever" ? def.unknownKeys === "passthrough" : parseDef(def.catchall._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalProperties"]
      }) ?? true;
    }
  }
  function parseObjectDef(def, refs) {
    const result = {
      type: "object",
      ...Object.entries(def.shape()).reduce((acc, [propName, propDef]) => {
        if (propDef === void 0 || propDef._def === void 0)
          return acc;
        const parsedDef = parseDef(propDef._def, {
          ...refs,
          currentPath: [...refs.currentPath, "properties", propName],
          propertyPath: [...refs.currentPath, "properties", propName]
        });
        if (parsedDef === void 0)
          return acc;
        return {
          properties: {
            ...acc.properties,
            [propName]: parsedDef
          },
          required: propDef.isOptional() && !refs.openaiStrictMode ? acc.required : [...acc.required, propName]
        };
      }, { properties: {}, required: [] }),
      additionalProperties: decideAdditionalProperties(def, refs)
    };
    if (!result.required.length)
      delete result.required;
    return result;
  }
  const parseOptionalDef = (def, refs) => {
    var _a3;
    if (refs.currentPath.toString() === ((_a3 = refs.propertyPath) == null ? void 0 : _a3.toString())) {
      return parseDef(def.innerType._def, refs);
    }
    const innerSchema = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "anyOf", "1"]
    });
    return innerSchema ? {
      anyOf: [
        {
          not: {}
        },
        innerSchema
      ]
    } : {};
  };
  const parsePipelineDef = (def, refs) => {
    if (refs.pipeStrategy === "input") {
      return parseDef(def.in._def, refs);
    } else if (refs.pipeStrategy === "output") {
      return parseDef(def.out._def, refs);
    }
    const a = parseDef(def.in._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    });
    const b = parseDef(def.out._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
    });
    return {
      allOf: [a, b].filter((x) => x !== void 0)
    };
  };
  function parsePromiseDef(def, refs) {
    return parseDef(def.type._def, refs);
  }
  function parseSetDef(def, refs) {
    const items = parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
    const schema = {
      type: "array",
      uniqueItems: true,
      items
    };
    if (def.minSize) {
      setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
    }
    if (def.maxSize) {
      setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
    }
    return schema;
  }
  function parseTupleDef(def, refs) {
    if (def.rest) {
      return {
        type: "array",
        minItems: def.items.length,
        items: def.items.map((x, i2) => parseDef(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i2}`]
        })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
        additionalItems: parseDef(def.rest._def, {
          ...refs,
          currentPath: [...refs.currentPath, "additionalItems"]
        })
      };
    } else {
      return {
        type: "array",
        minItems: def.items.length,
        maxItems: def.items.length,
        items: def.items.map((x, i2) => parseDef(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i2}`]
        })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
      };
    }
  }
  function parseUndefinedDef() {
    return {
      not: {}
    };
  }
  function parseUnknownDef() {
    return {};
  }
  const parseReadonlyDef = (def, refs) => {
    return parseDef(def.innerType._def, refs);
  };
  function parseDef(def, refs, forceResolution = false) {
    var _a3;
    const seenItem = refs.seen.get(def);
    if (refs.override) {
      const overrideResult = (_a3 = refs.override) == null ? void 0 : _a3.call(refs, def, refs, seenItem, forceResolution);
      if (overrideResult !== ignoreOverride) {
        return overrideResult;
      }
    }
    if (seenItem && !forceResolution) {
      const seenSchema = get$ref(seenItem, refs);
      if (seenSchema !== void 0) {
        if ("$ref" in seenSchema) {
          refs.seenRefs.add(seenSchema.$ref);
        }
        return seenSchema;
      }
    }
    const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
    refs.seen.set(def, newItem);
    const jsonSchema = selectParser(def, def.typeName, refs, forceResolution);
    if (jsonSchema) {
      addMeta(def, refs, jsonSchema);
    }
    newItem.jsonSchema = jsonSchema;
    return jsonSchema;
  }
  const get$ref = (item, refs) => {
    switch (refs.$refStrategy) {
      case "root":
        return { $ref: item.path.join("/") };
      // this case is needed as OpenAI strict mode doesn't support top-level `$ref`s, i.e.
      // the top-level schema *must* be `{"type": "object", "properties": {...}}` but if we ever
      // need to define a `$ref`, relative `$ref`s aren't supported, so we need to extract
      // the schema to `#/definitions/` and reference that.
      //
      // e.g. if we need to reference a schema at
      // `["#","definitions","contactPerson","properties","person1","properties","name"]`
      // then we'll extract it out to `contactPerson_properties_person1_properties_name`
      case "extract-to-root":
        const name = item.path.slice(refs.basePath.length + 1).join("_");
        if (name !== refs.name && refs.nameStrategy === "duplicate-ref") {
          refs.definitions[name] = item.def;
        }
        return { $ref: [...refs.basePath, refs.definitionPath, name].join("/") };
      case "relative":
        return { $ref: getRelativePath(refs.currentPath, item.path) };
      case "none":
      case "seen": {
        if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
          console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
          return {};
        }
        return refs.$refStrategy === "seen" ? {} : void 0;
      }
    }
  };
  const getRelativePath = (pathA, pathB) => {
    let i2 = 0;
    for (; i2 < pathA.length && i2 < pathB.length; i2++) {
      if (pathA[i2] !== pathB[i2])
        break;
    }
    return [(pathA.length - i2).toString(), ...pathB.slice(i2)].join("/");
  };
  const selectParser = (def, typeName, refs, forceResolution) => {
    switch (typeName) {
      case ZodFirstPartyTypeKind.ZodString:
        return parseStringDef(def, refs);
      case ZodFirstPartyTypeKind.ZodNumber:
        return parseNumberDef(def, refs);
      case ZodFirstPartyTypeKind.ZodObject:
        return parseObjectDef(def, refs);
      case ZodFirstPartyTypeKind.ZodBigInt:
        return parseBigintDef(def, refs);
      case ZodFirstPartyTypeKind.ZodBoolean:
        return parseBooleanDef();
      case ZodFirstPartyTypeKind.ZodDate:
        return parseDateDef(def, refs);
      case ZodFirstPartyTypeKind.ZodUndefined:
        return parseUndefinedDef();
      case ZodFirstPartyTypeKind.ZodNull:
        return parseNullDef(refs);
      case ZodFirstPartyTypeKind.ZodArray:
        return parseArrayDef(def, refs);
      case ZodFirstPartyTypeKind.ZodUnion:
      case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
        return parseUnionDef(def, refs);
      case ZodFirstPartyTypeKind.ZodIntersection:
        return parseIntersectionDef(def, refs);
      case ZodFirstPartyTypeKind.ZodTuple:
        return parseTupleDef(def, refs);
      case ZodFirstPartyTypeKind.ZodRecord:
        return parseRecordDef(def, refs);
      case ZodFirstPartyTypeKind.ZodLiteral:
        return parseLiteralDef(def, refs);
      case ZodFirstPartyTypeKind.ZodEnum:
        return parseEnumDef(def);
      case ZodFirstPartyTypeKind.ZodNativeEnum:
        return parseNativeEnumDef(def);
      case ZodFirstPartyTypeKind.ZodNullable:
        return parseNullableDef(def, refs);
      case ZodFirstPartyTypeKind.ZodOptional:
        return parseOptionalDef(def, refs);
      case ZodFirstPartyTypeKind.ZodMap:
        return parseMapDef(def, refs);
      case ZodFirstPartyTypeKind.ZodSet:
        return parseSetDef(def, refs);
      case ZodFirstPartyTypeKind.ZodLazy:
        return parseDef(def.getter()._def, refs);
      case ZodFirstPartyTypeKind.ZodPromise:
        return parsePromiseDef(def, refs);
      case ZodFirstPartyTypeKind.ZodNaN:
      case ZodFirstPartyTypeKind.ZodNever:
        return parseNeverDef();
      case ZodFirstPartyTypeKind.ZodEffects:
        return parseEffectsDef(def, refs, forceResolution);
      case ZodFirstPartyTypeKind.ZodAny:
        return parseAnyDef();
      case ZodFirstPartyTypeKind.ZodUnknown:
        return parseUnknownDef();
      case ZodFirstPartyTypeKind.ZodDefault:
        return parseDefaultDef(def, refs);
      case ZodFirstPartyTypeKind.ZodBranded:
        return parseBrandedDef(def, refs);
      case ZodFirstPartyTypeKind.ZodReadonly:
        return parseReadonlyDef(def, refs);
      case ZodFirstPartyTypeKind.ZodCatch:
        return parseCatchDef(def, refs);
      case ZodFirstPartyTypeKind.ZodPipeline:
        return parsePipelineDef(def, refs);
      case ZodFirstPartyTypeKind.ZodFunction:
      case ZodFirstPartyTypeKind.ZodVoid:
      case ZodFirstPartyTypeKind.ZodSymbol:
        return void 0;
      default:
        return /* @__PURE__ */ ((_) => void 0)();
    }
  };
  const addMeta = (def, refs, jsonSchema) => {
    if (def.description) {
      jsonSchema.description = def.description;
      if (refs.markdownDescription) {
        jsonSchema.markdownDescription = def.description;
      }
    }
    return jsonSchema;
  };
  const zodToJsonSchema$1 = (schema, options) => {
    const refs = getRefs(options);
    const name = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
    const main = parseDef(schema._def, name === void 0 ? refs : {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name]
    }, false) ?? {};
    const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
    if (title !== void 0) {
      main.title = title;
    }
    const definitions = (() => {
      if (isEmptyObj(refs.definitions)) {
        return void 0;
      }
      const definitions2 = {};
      const processedDefinitions = /* @__PURE__ */ new Set();
      for (let i2 = 0; i2 < 500; i2++) {
        const newDefinitions = Object.entries(refs.definitions).filter(([key]) => !processedDefinitions.has(key));
        if (newDefinitions.length === 0)
          break;
        for (const [key, schema2] of newDefinitions) {
          definitions2[key] = parseDef(zodDef(schema2), { ...refs, currentPath: [...refs.basePath, refs.definitionPath, key] }, true) ?? {};
          processedDefinitions.add(key);
        }
      }
      return definitions2;
    })();
    const combined = name === void 0 ? definitions ? {
      ...main,
      [refs.definitionPath]: definitions
    } : main : refs.nameStrategy === "duplicate-ref" ? {
      ...main,
      ...definitions || refs.seenRefs.size ? {
        [refs.definitionPath]: {
          ...definitions,
          // only actually duplicate the schema definition if it was ever referenced
          // otherwise the duplication is completely pointless
          ...refs.seenRefs.size ? { [name]: main } : void 0
        }
      } : void 0
    } : {
      $ref: [...refs.$refStrategy === "relative" ? [] : refs.basePath, refs.definitionPath, name].join("/"),
      [refs.definitionPath]: {
        ...definitions,
        [name]: main
      }
    };
    if (refs.target === "jsonSchema7") {
      combined.$schema = "http://json-schema.org/draft-07/schema#";
    } else if (refs.target === "jsonSchema2019-09") {
      combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
    }
    return combined;
  };
  function zodToJsonSchema(schema, options) {
    return zodToJsonSchema$1(schema, {
      openaiStrictMode: true,
      name: options.name,
      nameStrategy: "duplicate-ref",
      $refStrategy: "extract-to-root",
      nullableStrategy: "property"
    });
  }
  function zodResponseFormat(zodObject, name, props) {
    return makeParseableResponseFormat({
      type: "json_schema",
      json_schema: {
        ...props,
        name,
        strict: true,
        schema: zodToJsonSchema(zodObject, { name })
      }
    }, (content) => zodObject.parse(JSON.parse(content)));
  }
  function zodFunction(options) {
    return makeParseableTool({
      type: "function",
      function: {
        name: options.name,
        parameters: zodToJsonSchema(options.parameters, { name: options.name }),
        strict: true,
        ...options.description ? { description: options.description } : void 0
      }
    }, {
      callback: options.function,
      parser: (args) => options.parameters.parse(JSON.parse(args))
    });
  }
  function getEndpoint(config2) {
    const { azureOpenAIApiDeploymentName, azureOpenAIApiInstanceName, azureOpenAIApiKey, azureOpenAIBasePath, baseURL, azureADTokenProvider, azureOpenAIEndpoint } = config2;
    if ((azureOpenAIApiKey || azureADTokenProvider) && azureOpenAIBasePath && azureOpenAIApiDeploymentName) {
      return `${azureOpenAIBasePath}/${azureOpenAIApiDeploymentName}`;
    }
    if ((azureOpenAIApiKey || azureADTokenProvider) && azureOpenAIEndpoint && azureOpenAIApiDeploymentName) {
      return `${azureOpenAIEndpoint}/openai/deployments/${azureOpenAIApiDeploymentName}`;
    }
    if (azureOpenAIApiKey || azureADTokenProvider) {
      if (!azureOpenAIApiInstanceName) {
        throw new Error("azureOpenAIApiInstanceName is required when using azureOpenAIApiKey");
      }
      if (!azureOpenAIApiDeploymentName) {
        throw new Error("azureOpenAIApiDeploymentName is a required parameter when using azureOpenAIApiKey");
      }
      return `https://${azureOpenAIApiInstanceName}.openai.azure.com/openai/deployments/${azureOpenAIApiDeploymentName}`;
    }
    return baseURL;
  }
  function addLangChainErrorFields(error, lc_error_code) {
    error.lc_error_code = lc_error_code;
    error.message = `${error.message}

Troubleshooting URL: https://js.langchain.com/docs/troubleshooting/errors/${lc_error_code}/
`;
    return error;
  }
  function wrapOpenAIClientError(e) {
    let error;
    if (e.constructor.name === APIConnectionTimeoutError.name) {
      error = new Error(e.message);
      error.name = "TimeoutError";
    } else if (e.constructor.name === APIUserAbortError.name) {
      error = new Error(e.message);
      error.name = "AbortError";
    } else if (e.status === 400 && e.message.includes("tool_calls")) {
      error = addLangChainErrorFields(e, "INVALID_TOOL_RESULTS");
    } else if (e.status === 401) {
      error = addLangChainErrorFields(e, "MODEL_AUTHENTICATION");
    } else if (e.status === 429) {
      error = addLangChainErrorFields(e, "MODEL_RATE_LIMIT");
    } else if (e.status === 404) {
      error = addLangChainErrorFields(e, "MODEL_NOT_FOUND");
    } else {
      error = e;
    }
    return error;
  }
  function formatToOpenAIToolChoice(toolChoice) {
    if (!toolChoice) {
      return void 0;
    } else if (toolChoice === "any" || toolChoice === "required") {
      return "required";
    } else if (toolChoice === "auto") {
      return "auto";
    } else if (toolChoice === "none") {
      return "none";
    } else if (typeof toolChoice === "string") {
      return {
        type: "function",
        function: {
          name: toolChoice
        }
      };
    } else {
      return toolChoice;
    }
  }
  function isAnyOfProp(prop) {
    return prop.anyOf !== void 0 && Array.isArray(prop.anyOf);
  }
  function formatFunctionDefinitions(functions) {
    const lines = ["namespace functions {", ""];
    for (const f of functions) {
      if (f.description) {
        lines.push(`// ${f.description}`);
      }
      if (Object.keys(f.parameters.properties ?? {}).length > 0) {
        lines.push(`type ${f.name} = (_: {`);
        lines.push(formatObjectProperties(f.parameters, 0));
        lines.push("}) => any;");
      } else {
        lines.push(`type ${f.name} = () => any;`);
      }
      lines.push("");
    }
    lines.push("} // namespace functions");
    return lines.join("\n");
  }
  function formatObjectProperties(obj, indent) {
    var _a3;
    const lines = [];
    for (const [name, param] of Object.entries(obj.properties ?? {})) {
      if (param.description && indent < 2) {
        lines.push(`// ${param.description}`);
      }
      if ((_a3 = obj.required) == null ? void 0 : _a3.includes(name)) {
        lines.push(`${name}: ${formatType(param, indent)},`);
      } else {
        lines.push(`${name}?: ${formatType(param, indent)},`);
      }
    }
    return lines.map((line) => " ".repeat(indent) + line).join("\n");
  }
  function formatType(param, indent) {
    if (isAnyOfProp(param)) {
      return param.anyOf.map((v) => formatType(v, indent)).join(" | ");
    }
    switch (param.type) {
      case "string":
        if (param.enum) {
          return param.enum.map((v) => `"${v}"`).join(" | ");
        }
        return "string";
      case "number":
        if (param.enum) {
          return param.enum.map((v) => `${v}`).join(" | ");
        }
        return "number";
      case "integer":
        if (param.enum) {
          return param.enum.map((v) => `${v}`).join(" | ");
        }
        return "number";
      case "boolean":
        return "boolean";
      case "null":
        return "null";
      case "object":
        return ["{", formatObjectProperties(param, indent + 2), "}"].join("\n");
      case "array":
        if (param.items) {
          return `${formatType(param.items, indent)}[]`;
        }
        return "any[]";
      default:
        return "";
    }
  }
  function _convertToOpenAITool(tool, fields) {
    let toolDef;
    if (isLangChainTool(tool)) {
      const oaiToolDef = zodFunction({
        name: tool.name,
        parameters: tool.schema,
        description: tool.description
      });
      if (!oaiToolDef.function.parameters) {
        toolDef = {
          type: "function",
          function: convertToOpenAIFunction(tool, fields)
        };
      } else {
        toolDef = {
          type: oaiToolDef.type,
          function: {
            name: oaiToolDef.function.name,
            description: oaiToolDef.function.description,
            parameters: oaiToolDef.function.parameters,
            ...(fields == null ? void 0 : fields.strict) !== void 0 ? { strict: fields.strict } : {}
          }
        };
      }
    } else {
      toolDef = tool;
    }
    if ((fields == null ? void 0 : fields.strict) !== void 0) {
      toolDef.function.strict = fields.strict;
    }
    return toolDef;
  }
  function extractGenericMessageCustomRole(message) {
    if (message.role !== "system" && message.role !== "developer" && message.role !== "assistant" && message.role !== "user" && message.role !== "function" && message.role !== "tool") {
      console.warn(`Unknown message role: ${message.role}`);
    }
    return message.role;
  }
  function messageToOpenAIRole(message) {
    const type = message._getType();
    switch (type) {
      case "system":
        return "system";
      case "ai":
        return "assistant";
      case "human":
        return "user";
      case "function":
        return "function";
      case "tool":
        return "tool";
      case "generic": {
        if (!ChatMessage.isInstance(message))
          throw new Error("Invalid generic chat message");
        return extractGenericMessageCustomRole(message);
      }
      default:
        throw new Error(`Unknown message type: ${type}`);
    }
  }
  function _convertMessagesToOpenAIParams(messages, model) {
    return messages.flatMap((message) => {
      var _a3;
      let role = messageToOpenAIRole(message);
      if (role === "system" && isReasoningModel(model)) {
        role = "developer";
      }
      const completionParam = {
        role,
        content: message.content
      };
      if (message.name != null) {
        completionParam.name = message.name;
      }
      if (message.additional_kwargs.function_call != null) {
        completionParam.function_call = message.additional_kwargs.function_call;
        completionParam.content = null;
      }
      if (isAIMessage(message) && !!((_a3 = message.tool_calls) == null ? void 0 : _a3.length)) {
        completionParam.tool_calls = message.tool_calls.map(convertLangChainToolCallToOpenAI);
        completionParam.content = null;
      } else {
        if (message.additional_kwargs.tool_calls != null) {
          completionParam.tool_calls = message.additional_kwargs.tool_calls;
        }
        if (message.tool_call_id != null) {
          completionParam.tool_call_id = message.tool_call_id;
        }
      }
      if (message.additional_kwargs.audio && typeof message.additional_kwargs.audio === "object" && "id" in message.additional_kwargs.audio) {
        const audioMessage = {
          role: "assistant",
          audio: {
            id: message.additional_kwargs.audio.id
          }
        };
        return [completionParam, audioMessage];
      }
      return completionParam;
    });
  }
  function _convertChatOpenAIToolTypeToOpenAITool(tool, fields) {
    if (isOpenAITool(tool)) {
      if ((fields == null ? void 0 : fields.strict) !== void 0) {
        return {
          ...tool,
          function: {
            ...tool.function,
            strict: fields.strict
          }
        };
      }
      return tool;
    }
    return _convertToOpenAITool(tool, fields);
  }
  function isReasoningModel(model) {
    return (model == null ? void 0 : model.startsWith("o1")) || (model == null ? void 0 : model.startsWith("o3"));
  }
  class ChatOpenAI extends BaseChatModel {
    static lc_name() {
      return "ChatOpenAI";
    }
    get callKeys() {
      return [
        ...super.callKeys,
        "options",
        "function_call",
        "functions",
        "tools",
        "tool_choice",
        "promptIndex",
        "response_format",
        "seed",
        "reasoning_effort"
      ];
    }
    get lc_secrets() {
      return {
        openAIApiKey: "OPENAI_API_KEY",
        apiKey: "OPENAI_API_KEY",
        organization: "OPENAI_ORGANIZATION"
      };
    }
    get lc_aliases() {
      return {
        modelName: "model",
        openAIApiKey: "openai_api_key",
        apiKey: "openai_api_key"
      };
    }
    get lc_serializable_keys() {
      return [
        "configuration",
        "logprobs",
        "topLogprobs",
        "prefixMessages",
        "supportsStrictToolCalling",
        "modalities",
        "audio",
        "reasoningEffort",
        "temperature",
        "maxTokens",
        "topP",
        "frequencyPenalty",
        "presencePenalty",
        "n",
        "logitBias",
        "user",
        "streaming",
        "streamUsage",
        "modelName",
        "model",
        "modelKwargs",
        "stop",
        "stopSequences",
        "timeout",
        "openAIApiKey",
        "apiKey",
        "cache",
        "maxConcurrency",
        "maxRetries",
        "verbose",
        "callbacks",
        "tags",
        "metadata",
        "disableStreaming"
      ];
    }
    constructor(fields) {
      var _a3, _b2;
      super(fields ?? {});
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "temperature", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "topP", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "frequencyPenalty", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "presencePenalty", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "n", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 1
      });
      Object.defineProperty(this, "logitBias", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "modelName", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "model", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "gpt-3.5-turbo"
      });
      Object.defineProperty(this, "modelKwargs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "stop", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "stopSequences", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "user", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "timeout", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "streaming", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "streamUsage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "maxTokens", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "logprobs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "topLogprobs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "openAIApiKey", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "apiKey", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "organization", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "__includeRawResponse", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "client", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "clientConfig", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "supportsStrictToolCalling", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "audio", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "modalities", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "reasoningEffort", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.openAIApiKey = (fields == null ? void 0 : fields.apiKey) ?? (fields == null ? void 0 : fields.openAIApiKey) ?? ((_a3 = fields == null ? void 0 : fields.configuration) == null ? void 0 : _a3.apiKey) ?? getEnvironmentVariable("OPENAI_API_KEY");
      this.apiKey = this.openAIApiKey;
      this.organization = ((_b2 = fields == null ? void 0 : fields.configuration) == null ? void 0 : _b2.organization) ?? getEnvironmentVariable("OPENAI_ORGANIZATION");
      this.model = (fields == null ? void 0 : fields.model) ?? (fields == null ? void 0 : fields.modelName) ?? this.model;
      this.modelName = this.model;
      this.modelKwargs = (fields == null ? void 0 : fields.modelKwargs) ?? {};
      this.timeout = fields == null ? void 0 : fields.timeout;
      this.temperature = (fields == null ? void 0 : fields.temperature) ?? this.temperature;
      this.topP = (fields == null ? void 0 : fields.topP) ?? this.topP;
      this.frequencyPenalty = (fields == null ? void 0 : fields.frequencyPenalty) ?? this.frequencyPenalty;
      this.presencePenalty = (fields == null ? void 0 : fields.presencePenalty) ?? this.presencePenalty;
      this.logprobs = fields == null ? void 0 : fields.logprobs;
      this.topLogprobs = fields == null ? void 0 : fields.topLogprobs;
      this.n = (fields == null ? void 0 : fields.n) ?? this.n;
      this.logitBias = fields == null ? void 0 : fields.logitBias;
      this.stop = (fields == null ? void 0 : fields.stopSequences) ?? (fields == null ? void 0 : fields.stop);
      this.stopSequences = this == null ? void 0 : this.stop;
      this.user = fields == null ? void 0 : fields.user;
      this.__includeRawResponse = fields == null ? void 0 : fields.__includeRawResponse;
      this.audio = fields == null ? void 0 : fields.audio;
      this.modalities = fields == null ? void 0 : fields.modalities;
      this.reasoningEffort = fields == null ? void 0 : fields.reasoningEffort;
      this.maxTokens = (fields == null ? void 0 : fields.maxCompletionTokens) ?? (fields == null ? void 0 : fields.maxTokens);
      if (this.model === "o1") {
        this.disableStreaming = true;
      }
      this.streaming = (fields == null ? void 0 : fields.streaming) ?? false;
      this.streamUsage = (fields == null ? void 0 : fields.streamUsage) ?? this.streamUsage;
      this.clientConfig = {
        apiKey: this.apiKey,
        organization: this.organization,
        dangerouslyAllowBrowser: true,
        ...fields == null ? void 0 : fields.configuration
      };
      if ((fields == null ? void 0 : fields.supportsStrictToolCalling) !== void 0) {
        this.supportsStrictToolCalling = fields.supportsStrictToolCalling;
      }
    }
    getLsParams(options) {
      const params = this.invocationParams(options);
      return {
        ls_provider: "openai",
        ls_model_name: this.model,
        ls_model_type: "chat",
        ls_temperature: params.temperature ?? void 0,
        ls_max_tokens: params.max_tokens ?? void 0,
        ls_stop: options.stop
      };
    }
    bindTools(tools, kwargs) {
      let strict;
      if ((kwargs == null ? void 0 : kwargs.strict) !== void 0) {
        strict = kwargs.strict;
      } else if (this.supportsStrictToolCalling !== void 0) {
        strict = this.supportsStrictToolCalling;
      }
      return this.bind({
        tools: tools.map((tool) => _convertChatOpenAIToolTypeToOpenAITool(tool, { strict })),
        ...kwargs
      });
    }
    createResponseFormat(resFormat) {
      if (resFormat && resFormat.type === "json_schema" && resFormat.json_schema.schema && isZodSchema(resFormat.json_schema.schema)) {
        return zodResponseFormat(resFormat.json_schema.schema, resFormat.json_schema.name, {
          description: resFormat.json_schema.description
        });
      }
      return resFormat;
    }
    /**
     * Get the parameters used to invoke the model
     */
    invocationParams(options, extra) {
      var _a3;
      let strict;
      if ((options == null ? void 0 : options.strict) !== void 0) {
        strict = options.strict;
      } else if (this.supportsStrictToolCalling !== void 0) {
        strict = this.supportsStrictToolCalling;
      }
      let streamOptionsConfig = {};
      if ((options == null ? void 0 : options.stream_options) !== void 0) {
        streamOptionsConfig = { stream_options: options.stream_options };
      } else if (this.streamUsage && (this.streaming || (extra == null ? void 0 : extra.streaming))) {
        streamOptionsConfig = { stream_options: { include_usage: true } };
      }
      const params = {
        model: this.model,
        temperature: this.temperature,
        top_p: this.topP,
        frequency_penalty: this.frequencyPenalty,
        presence_penalty: this.presencePenalty,
        logprobs: this.logprobs,
        top_logprobs: this.topLogprobs,
        n: this.n,
        logit_bias: this.logitBias,
        stop: (options == null ? void 0 : options.stop) ?? this.stopSequences,
        user: this.user,
        // if include_usage is set or streamUsage then stream must be set to true.
        stream: this.streaming,
        functions: options == null ? void 0 : options.functions,
        function_call: options == null ? void 0 : options.function_call,
        tools: ((_a3 = options == null ? void 0 : options.tools) == null ? void 0 : _a3.length) ? options.tools.map((tool) => _convertChatOpenAIToolTypeToOpenAITool(tool, { strict })) : void 0,
        tool_choice: formatToOpenAIToolChoice(options == null ? void 0 : options.tool_choice),
        response_format: this.createResponseFormat(options == null ? void 0 : options.response_format),
        seed: options == null ? void 0 : options.seed,
        ...streamOptionsConfig,
        parallel_tool_calls: options == null ? void 0 : options.parallel_tool_calls,
        ...this.audio || (options == null ? void 0 : options.audio) ? { audio: this.audio || (options == null ? void 0 : options.audio) } : {},
        ...this.modalities || (options == null ? void 0 : options.modalities) ? { modalities: this.modalities || (options == null ? void 0 : options.modalities) } : {},
        ...this.modelKwargs
      };
      if ((options == null ? void 0 : options.prediction) !== void 0) {
        params.prediction = options.prediction;
      }
      const reasoningEffort = (options == null ? void 0 : options.reasoning_effort) ?? this.reasoningEffort;
      if (reasoningEffort !== void 0) {
        params.reasoning_effort = reasoningEffort;
      }
      if (isReasoningModel(params.model)) {
        params.max_completion_tokens = this.maxTokens === -1 ? void 0 : this.maxTokens;
      } else {
        params.max_tokens = this.maxTokens === -1 ? void 0 : this.maxTokens;
      }
      return params;
    }
    _convertOpenAIChatCompletionMessageToBaseMessage(message, rawResponse) {
      const rawToolCalls = message.tool_calls;
      switch (message.role) {
        case "assistant": {
          const toolCalls = [];
          const invalidToolCalls = [];
          for (const rawToolCall of rawToolCalls ?? []) {
            try {
              toolCalls.push(parseToolCall$1(rawToolCall, { returnId: true }));
            } catch (e) {
              invalidToolCalls.push(makeInvalidToolCall(rawToolCall, e.message));
            }
          }
          const additional_kwargs = {
            function_call: message.function_call,
            tool_calls: rawToolCalls
          };
          if (this.__includeRawResponse !== void 0) {
            additional_kwargs.__raw_response = rawResponse;
          }
          const response_metadata = {
            model_name: rawResponse.model,
            ...rawResponse.system_fingerprint ? {
              usage: { ...rawResponse.usage },
              system_fingerprint: rawResponse.system_fingerprint
            } : {}
          };
          if (message.audio) {
            additional_kwargs.audio = message.audio;
          }
          return new AIMessage({
            content: message.content || "",
            tool_calls: toolCalls,
            invalid_tool_calls: invalidToolCalls,
            additional_kwargs,
            response_metadata,
            id: rawResponse.id
          });
        }
        default:
          return new ChatMessage(message.content || "", message.role ?? "unknown");
      }
    }
    _convertOpenAIDeltaToBaseMessageChunk(delta, rawResponse, defaultRole) {
      var _a3, _b2;
      const role = delta.role ?? defaultRole;
      const content = delta.content ?? "";
      let additional_kwargs;
      if (delta.function_call) {
        additional_kwargs = {
          function_call: delta.function_call
        };
      } else if (delta.tool_calls) {
        additional_kwargs = {
          tool_calls: delta.tool_calls
        };
      } else {
        additional_kwargs = {};
      }
      if (this.__includeRawResponse) {
        additional_kwargs.__raw_response = rawResponse;
      }
      if (delta.audio) {
        additional_kwargs.audio = {
          ...delta.audio,
          index: rawResponse.choices[0].index
        };
      }
      const response_metadata = { usage: { ...rawResponse.usage } };
      if (role === "user") {
        return new HumanMessageChunk({ content, response_metadata });
      } else if (role === "assistant") {
        const toolCallChunks = [];
        if (Array.isArray(delta.tool_calls)) {
          for (const rawToolCall of delta.tool_calls) {
            toolCallChunks.push({
              name: (_a3 = rawToolCall.function) == null ? void 0 : _a3.name,
              args: (_b2 = rawToolCall.function) == null ? void 0 : _b2.arguments,
              id: rawToolCall.id,
              index: rawToolCall.index,
              type: "tool_call_chunk"
            });
          }
        }
        return new AIMessageChunk({
          content,
          tool_call_chunks: toolCallChunks,
          additional_kwargs,
          id: rawResponse.id,
          response_metadata
        });
      } else if (role === "system") {
        return new SystemMessageChunk({ content, response_metadata });
      } else if (role === "developer") {
        return new SystemMessageChunk({
          content,
          response_metadata,
          additional_kwargs: {
            __openai_role__: "developer"
          }
        });
      } else if (role === "function") {
        return new FunctionMessageChunk({
          content,
          additional_kwargs,
          name: delta.name,
          response_metadata
        });
      } else if (role === "tool") {
        return new ToolMessageChunk({
          content,
          additional_kwargs,
          tool_call_id: delta.tool_call_id,
          response_metadata
        });
      } else {
        return new ChatMessageChunk({ content, role, response_metadata });
      }
    }
    /** @ignore */
    _identifyingParams() {
      return {
        model_name: this.model,
        ...this.invocationParams(),
        ...this.clientConfig
      };
    }
    async *_streamResponseChunks(messages, options, runManager) {
      var _a3, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2;
      const messagesMapped = _convertMessagesToOpenAIParams(messages, this.model);
      const params = {
        ...this.invocationParams(options, {
          streaming: true
        }),
        messages: messagesMapped,
        stream: true
      };
      let defaultRole;
      const streamIterable = await this.completionWithRetry(params, options);
      let usage;
      for await (const data of streamIterable) {
        const choice = (_a3 = data == null ? void 0 : data.choices) == null ? void 0 : _a3[0];
        if (data.usage) {
          usage = data.usage;
        }
        if (!choice) {
          continue;
        }
        const { delta } = choice;
        if (!delta) {
          continue;
        }
        const chunk = this._convertOpenAIDeltaToBaseMessageChunk(delta, data, defaultRole);
        defaultRole = delta.role ?? defaultRole;
        const newTokenIndices = {
          prompt: options.promptIndex ?? 0,
          completion: choice.index ?? 0
        };
        if (typeof chunk.content !== "string") {
          console.log("[WARNING]: Received non-string content from OpenAI. This is currently not supported.");
          continue;
        }
        const generationInfo = { ...newTokenIndices };
        if (choice.finish_reason != null) {
          generationInfo.finish_reason = choice.finish_reason;
          generationInfo.system_fingerprint = data.system_fingerprint;
          generationInfo.model_name = data.model;
        }
        if (this.logprobs) {
          generationInfo.logprobs = choice.logprobs;
        }
        const generationChunk = new ChatGenerationChunk({
          message: chunk,
          text: chunk.content,
          generationInfo
        });
        yield generationChunk;
        await (runManager == null ? void 0 : runManager.handleLLMNewToken(generationChunk.text ?? "", newTokenIndices, void 0, void 0, void 0, { chunk: generationChunk }));
      }
      if (usage) {
        const inputTokenDetails = {
          ...((_b2 = usage.prompt_tokens_details) == null ? void 0 : _b2.audio_tokens) !== null && {
            audio: (_c2 = usage.prompt_tokens_details) == null ? void 0 : _c2.audio_tokens
          },
          ...((_d2 = usage.prompt_tokens_details) == null ? void 0 : _d2.cached_tokens) !== null && {
            cache_read: (_e2 = usage.prompt_tokens_details) == null ? void 0 : _e2.cached_tokens
          }
        };
        const outputTokenDetails = {
          ...((_f2 = usage.completion_tokens_details) == null ? void 0 : _f2.audio_tokens) !== null && {
            audio: (_g2 = usage.completion_tokens_details) == null ? void 0 : _g2.audio_tokens
          },
          ...((_h2 = usage.completion_tokens_details) == null ? void 0 : _h2.reasoning_tokens) !== null && {
            reasoning: (_i2 = usage.completion_tokens_details) == null ? void 0 : _i2.reasoning_tokens
          }
        };
        const generationChunk = new ChatGenerationChunk({
          message: new AIMessageChunk({
            content: "",
            response_metadata: {
              usage: { ...usage }
            },
            usage_metadata: {
              input_tokens: usage.prompt_tokens,
              output_tokens: usage.completion_tokens,
              total_tokens: usage.total_tokens,
              ...Object.keys(inputTokenDetails).length > 0 && {
                input_token_details: inputTokenDetails
              },
              ...Object.keys(outputTokenDetails).length > 0 && {
                output_token_details: outputTokenDetails
              }
            }
          }),
          text: ""
        });
        yield generationChunk;
      }
      if ((_j2 = options.signal) == null ? void 0 : _j2.aborted) {
        throw new Error("AbortError");
      }
    }
    /**
     * Get the identifying parameters for the model
     *
     */
    identifyingParams() {
      return this._identifyingParams();
    }
    /** @ignore */
    async _generate(messages, options, runManager) {
      var _a3, _b2;
      const usageMetadata = {};
      const params = this.invocationParams(options);
      const messagesMapped = _convertMessagesToOpenAIParams(messages, this.model);
      if (params.stream) {
        const stream = this._streamResponseChunks(messages, options, runManager);
        const finalChunks = {};
        for await (const chunk of stream) {
          chunk.message.response_metadata = {
            ...chunk.generationInfo,
            ...chunk.message.response_metadata
          };
          const index = ((_a3 = chunk.generationInfo) == null ? void 0 : _a3.completion) ?? 0;
          if (finalChunks[index] === void 0) {
            finalChunks[index] = chunk;
          } else {
            finalChunks[index] = finalChunks[index].concat(chunk);
          }
        }
        const generations = Object.entries(finalChunks).sort(([aKey], [bKey]) => parseInt(aKey, 10) - parseInt(bKey, 10)).map(([_, value]) => value);
        const { functions, function_call } = this.invocationParams(options);
        const promptTokenUsage = await this.getEstimatedTokenCountFromPrompt(messages, functions, function_call);
        const completionTokenUsage = await this.getNumTokensFromGenerations(generations);
        usageMetadata.input_tokens = promptTokenUsage;
        usageMetadata.output_tokens = completionTokenUsage;
        usageMetadata.total_tokens = promptTokenUsage + completionTokenUsage;
        return {
          generations,
          llmOutput: {
            estimatedTokenUsage: {
              promptTokens: usageMetadata.input_tokens,
              completionTokens: usageMetadata.output_tokens,
              totalTokens: usageMetadata.total_tokens
            }
          }
        };
      } else {
        let data;
        if (options.response_format && options.response_format.type === "json_schema") {
          data = await this.betaParsedCompletionWithRetry({
            ...params,
            stream: false,
            messages: messagesMapped
          }, {
            signal: options == null ? void 0 : options.signal,
            ...options == null ? void 0 : options.options
          });
        } else {
          data = await this.completionWithRetry({
            ...params,
            stream: false,
            messages: messagesMapped
          }, {
            signal: options == null ? void 0 : options.signal,
            ...options == null ? void 0 : options.options
          });
        }
        const { completion_tokens: completionTokens, prompt_tokens: promptTokens, total_tokens: totalTokens, prompt_tokens_details: promptTokensDetails, completion_tokens_details: completionTokensDetails } = (data == null ? void 0 : data.usage) ?? {};
        if (completionTokens) {
          usageMetadata.output_tokens = (usageMetadata.output_tokens ?? 0) + completionTokens;
        }
        if (promptTokens) {
          usageMetadata.input_tokens = (usageMetadata.input_tokens ?? 0) + promptTokens;
        }
        if (totalTokens) {
          usageMetadata.total_tokens = (usageMetadata.total_tokens ?? 0) + totalTokens;
        }
        if ((promptTokensDetails == null ? void 0 : promptTokensDetails.audio_tokens) !== null || (promptTokensDetails == null ? void 0 : promptTokensDetails.cached_tokens) !== null) {
          usageMetadata.input_token_details = {
            ...(promptTokensDetails == null ? void 0 : promptTokensDetails.audio_tokens) !== null && {
              audio: promptTokensDetails == null ? void 0 : promptTokensDetails.audio_tokens
            },
            ...(promptTokensDetails == null ? void 0 : promptTokensDetails.cached_tokens) !== null && {
              cache_read: promptTokensDetails == null ? void 0 : promptTokensDetails.cached_tokens
            }
          };
        }
        if ((completionTokensDetails == null ? void 0 : completionTokensDetails.audio_tokens) !== null || (completionTokensDetails == null ? void 0 : completionTokensDetails.reasoning_tokens) !== null) {
          usageMetadata.output_token_details = {
            ...(completionTokensDetails == null ? void 0 : completionTokensDetails.audio_tokens) !== null && {
              audio: completionTokensDetails == null ? void 0 : completionTokensDetails.audio_tokens
            },
            ...(completionTokensDetails == null ? void 0 : completionTokensDetails.reasoning_tokens) !== null && {
              reasoning: completionTokensDetails == null ? void 0 : completionTokensDetails.reasoning_tokens
            }
          };
        }
        const generations = [];
        for (const part of (data == null ? void 0 : data.choices) ?? []) {
          const text = ((_b2 = part.message) == null ? void 0 : _b2.content) ?? "";
          const generation = {
            text,
            message: this._convertOpenAIChatCompletionMessageToBaseMessage(part.message ?? { role: "assistant" }, data)
          };
          generation.generationInfo = {
            ...part.finish_reason ? { finish_reason: part.finish_reason } : {},
            ...part.logprobs ? { logprobs: part.logprobs } : {}
          };
          if (isAIMessage(generation.message)) {
            generation.message.usage_metadata = usageMetadata;
          }
          generation.message = new AIMessage(Object.fromEntries(Object.entries(generation.message).filter(([key]) => !key.startsWith("lc_"))));
          generations.push(generation);
        }
        return {
          generations,
          llmOutput: {
            tokenUsage: {
              promptTokens: usageMetadata.input_tokens,
              completionTokens: usageMetadata.output_tokens,
              totalTokens: usageMetadata.total_tokens
            }
          }
        };
      }
    }
    /**
     * Estimate the number of tokens a prompt will use.
     * Modified from: https://github.com/hmarr/openai-chat-tokens/blob/main/src/index.ts
     */
    async getEstimatedTokenCountFromPrompt(messages, functions, function_call) {
      let tokens = (await this.getNumTokensFromMessages(messages)).totalCount;
      if (functions && function_call !== "auto") {
        const promptDefinitions = formatFunctionDefinitions(functions);
        tokens += await this.getNumTokens(promptDefinitions);
        tokens += 9;
      }
      if (functions && messages.find((m) => m._getType() === "system")) {
        tokens -= 4;
      }
      if (function_call === "none") {
        tokens += 1;
      } else if (typeof function_call === "object") {
        tokens += await this.getNumTokens(function_call.name) + 4;
      }
      return tokens;
    }
    /**
     * Estimate the number of tokens an array of generations have used.
     */
    async getNumTokensFromGenerations(generations) {
      const generationUsages = await Promise.all(generations.map(async (generation) => {
        var _a3;
        if ((_a3 = generation.message.additional_kwargs) == null ? void 0 : _a3.function_call) {
          return (await this.getNumTokensFromMessages([generation.message])).countPerMessage[0];
        } else {
          return await this.getNumTokens(generation.message.content);
        }
      }));
      return generationUsages.reduce((a, b) => a + b, 0);
    }
    async getNumTokensFromMessages(messages) {
      let totalCount = 0;
      let tokensPerMessage = 0;
      let tokensPerName = 0;
      if (this.model === "gpt-3.5-turbo-0301") {
        tokensPerMessage = 4;
        tokensPerName = -1;
      } else {
        tokensPerMessage = 3;
        tokensPerName = 1;
      }
      const countPerMessage = await Promise.all(messages.map(async (message) => {
        var _a3, _b2, _c2, _d2, _e2, _f2;
        const textCount = await this.getNumTokens(message.content);
        const roleCount = await this.getNumTokens(messageToOpenAIRole(message));
        const nameCount = message.name !== void 0 ? tokensPerName + await this.getNumTokens(message.name) : 0;
        let count = textCount + tokensPerMessage + roleCount + nameCount;
        const openAIMessage = message;
        if (openAIMessage._getType() === "function") {
          count -= 2;
        }
        if ((_a3 = openAIMessage.additional_kwargs) == null ? void 0 : _a3.function_call) {
          count += 3;
        }
        if ((_b2 = openAIMessage == null ? void 0 : openAIMessage.additional_kwargs.function_call) == null ? void 0 : _b2.name) {
          count += await this.getNumTokens((_c2 = openAIMessage.additional_kwargs.function_call) == null ? void 0 : _c2.name);
        }
        if ((_d2 = openAIMessage.additional_kwargs.function_call) == null ? void 0 : _d2.arguments) {
          try {
            count += await this.getNumTokens(
              // Remove newlines and spaces
              JSON.stringify(JSON.parse((_e2 = openAIMessage.additional_kwargs.function_call) == null ? void 0 : _e2.arguments))
            );
          } catch (error) {
            console.error("Error parsing function arguments", error, JSON.stringify(openAIMessage.additional_kwargs.function_call));
            count += await this.getNumTokens((_f2 = openAIMessage.additional_kwargs.function_call) == null ? void 0 : _f2.arguments);
          }
        }
        totalCount += count;
        return count;
      }));
      totalCount += 3;
      return { totalCount, countPerMessage };
    }
    async completionWithRetry(request, options) {
      const requestOptions = this._getClientOptions(options);
      return this.caller.call(async () => {
        try {
          const res = await this.client.chat.completions.create(request, requestOptions);
          return res;
        } catch (e) {
          const error = wrapOpenAIClientError(e);
          throw error;
        }
      });
    }
    /**
     * Call the beta chat completions parse endpoint. This should only be called if
     * response_format is set to "json_object".
     * @param {OpenAIClient.Chat.ChatCompletionCreateParamsNonStreaming} request
     * @param {OpenAICoreRequestOptions | undefined} options
     */
    async betaParsedCompletionWithRetry(request, options) {
      const requestOptions = this._getClientOptions(options);
      return this.caller.call(async () => {
        try {
          const res = await this.client.beta.chat.completions.parse(request, requestOptions);
          return res;
        } catch (e) {
          const error = wrapOpenAIClientError(e);
          throw error;
        }
      });
    }
    _getClientOptions(options) {
      if (!this.client) {
        const openAIEndpointConfig = {
          baseURL: this.clientConfig.baseURL
        };
        const endpoint = getEndpoint(openAIEndpointConfig);
        const params = {
          ...this.clientConfig,
          baseURL: endpoint,
          timeout: this.timeout,
          maxRetries: 0
        };
        if (!params.baseURL) {
          delete params.baseURL;
        }
        this.client = new OpenAI$1(params);
      }
      const requestOptions = {
        ...this.clientConfig,
        ...options
      };
      return requestOptions;
    }
    _llmType() {
      return "openai";
    }
    /** @ignore */
    _combineLLMOutput(...llmOutputs) {
      return llmOutputs.reduce((acc, llmOutput) => {
        if (llmOutput && llmOutput.tokenUsage) {
          acc.tokenUsage.completionTokens += llmOutput.tokenUsage.completionTokens ?? 0;
          acc.tokenUsage.promptTokens += llmOutput.tokenUsage.promptTokens ?? 0;
          acc.tokenUsage.totalTokens += llmOutput.tokenUsage.totalTokens ?? 0;
        }
        return acc;
      }, {
        tokenUsage: {
          completionTokens: 0,
          promptTokens: 0,
          totalTokens: 0
        }
      });
    }
    withStructuredOutput(outputSchema, config2) {
      let schema;
      let name;
      let method;
      let includeRaw;
      if (isStructuredOutputMethodParams(outputSchema)) {
        schema = outputSchema.schema;
        name = outputSchema.name;
        method = outputSchema.method;
        includeRaw = outputSchema.includeRaw;
      } else {
        schema = outputSchema;
        name = config2 == null ? void 0 : config2.name;
        method = config2 == null ? void 0 : config2.method;
        includeRaw = config2 == null ? void 0 : config2.includeRaw;
      }
      let llm;
      let outputParser;
      if ((config2 == null ? void 0 : config2.strict) !== void 0 && method === "jsonMode") {
        throw new Error("Argument `strict` is only supported for `method` = 'function_calling'");
      }
      if (!this.model.startsWith("gpt-3") && !this.model.startsWith("gpt-4-") && this.model !== "gpt-4") {
        if (method === void 0) {
          method = "jsonSchema";
        }
      } else if (method === "jsonSchema") {
        console.warn(`[WARNING]: JSON Schema is not supported for model "${this.model}". Falling back to tool calling.`);
      }
      if (method === "jsonMode") {
        llm = this.bind({
          response_format: { type: "json_object" }
        });
        if (isZodSchema(schema)) {
          outputParser = StructuredOutputParser.fromZodSchema(schema);
        } else {
          outputParser = new JsonOutputParser();
        }
      } else if (method === "jsonSchema") {
        llm = this.bind({
          response_format: {
            type: "json_schema",
            json_schema: {
              name: name ?? "extract",
              description: schema.description,
              schema,
              strict: config2 == null ? void 0 : config2.strict
            }
          }
        });
        if (isZodSchema(schema)) {
          outputParser = StructuredOutputParser.fromZodSchema(schema);
        } else {
          outputParser = new JsonOutputParser();
        }
      } else {
        let functionName = name ?? "extract";
        if (isZodSchema(schema)) {
          const asJsonSchema = zodToJsonSchema$5(schema);
          llm = this.bind({
            tools: [
              {
                type: "function",
                function: {
                  name: functionName,
                  description: asJsonSchema.description,
                  parameters: asJsonSchema
                }
              }
            ],
            tool_choice: {
              type: "function",
              function: {
                name: functionName
              }
            },
            // Do not pass `strict` argument to OpenAI if `config.strict` is undefined
            ...(config2 == null ? void 0 : config2.strict) !== void 0 ? { strict: config2.strict } : {}
          });
          outputParser = new JsonOutputKeyToolsParser({
            returnSingle: true,
            keyName: functionName,
            zodSchema: schema
          });
        } else {
          let openAIFunctionDefinition;
          if (typeof schema.name === "string" && typeof schema.parameters === "object" && schema.parameters != null) {
            openAIFunctionDefinition = schema;
            functionName = schema.name;
          } else {
            functionName = schema.title ?? functionName;
            openAIFunctionDefinition = {
              name: functionName,
              description: schema.description ?? "",
              parameters: schema
            };
          }
          llm = this.bind({
            tools: [
              {
                type: "function",
                function: openAIFunctionDefinition
              }
            ],
            tool_choice: {
              type: "function",
              function: {
                name: functionName
              }
            },
            // Do not pass `strict` argument to OpenAI if `config.strict` is undefined
            ...(config2 == null ? void 0 : config2.strict) !== void 0 ? { strict: config2.strict } : {}
          });
          outputParser = new JsonOutputKeyToolsParser({
            returnSingle: true,
            keyName: functionName
          });
        }
      }
      if (!includeRaw) {
        return llm.pipe(outputParser);
      }
      const parserAssign = RunnablePassthrough.assign({
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        parsed: (input, config3) => outputParser.invoke(input.raw, config3)
      });
      const parserNone = RunnablePassthrough.assign({
        parsed: () => null
      });
      const parsedWithFallback = parserAssign.withFallbacks({
        fallbacks: [parserNone]
      });
      return RunnableSequence.from([
        {
          raw: llm
        },
        parsedWithFallback
      ]);
    }
  }
  function isZodSchema(input) {
    return typeof (input == null ? void 0 : input.parse) === "function";
  }
  function isStructuredOutputMethodParams(x) {
    return x !== void 0 && // eslint-disable-next-line @typescript-eslint/no-explicit-any
    typeof x.schema === "object";
  }
  class ChatXAI extends ChatOpenAI {
    static lc_name() {
      return "ChatXAI";
    }
    _llmType() {
      return "xai";
    }
    get lc_secrets() {
      return {
        apiKey: "XAI_API_KEY"
      };
    }
    constructor(fields) {
      const apiKey = (fields == null ? void 0 : fields.apiKey) || getEnvironmentVariable("XAI_API_KEY");
      if (!apiKey) {
        throw new Error(`xAI API key not found. Please set the XAI_API_KEY environment variable or provide the key into "apiKey" field.`);
      }
      super({
        ...fields,
        model: (fields == null ? void 0 : fields.model) || "grok-beta",
        apiKey,
        configuration: {
          baseURL: "https://api.x.ai/v1"
        }
      });
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ["langchain", "chat_models", "xai"]
      });
    }
    toJSON() {
      const result = super.toJSON();
      if ("kwargs" in result && typeof result.kwargs === "object" && result.kwargs != null) {
        delete result.kwargs.openai_api_key;
        delete result.kwargs.configuration;
      }
      return result;
    }
    getLsParams(options) {
      const params = super.getLsParams(options);
      params.ls_provider = "xai";
      return params;
    }
    /**
     * Calls the xAI API with retry logic in case of failures.
     * @param request The request to send to the xAI API.
     * @param options Optional configuration for the API call.
     * @returns The response from the xAI API.
     */
    async completionWithRetry(request, options) {
      delete request.frequency_penalty;
      delete request.presence_penalty;
      delete request.logit_bias;
      delete request.functions;
      const newRequestMessages = request.messages.map((msg) => {
        if (!msg.content) {
          return {
            ...msg,
            content: ""
          };
        }
        return msg;
      });
      const newRequest = {
        ...request,
        messages: newRequestMessages
      };
      if (newRequest.stream === true) {
        return super.completionWithRetry(newRequest, options);
      }
      return super.completionWithRetry(newRequest, options);
    }
    _convertOpenAIDeltaToBaseMessageChunk(delta, rawResponse, defaultRole) {
      var _a3;
      const messageChunk = super._convertOpenAIDeltaToBaseMessageChunk(delta, rawResponse, defaultRole);
      if (!((_a3 = rawResponse.choices[0]) == null ? void 0 : _a3.finish_reason)) {
        delete messageChunk.response_metadata.usage;
        delete messageChunk.usage_metadata;
      } else {
        messageChunk.usage_metadata = messageChunk.response_metadata.usage;
      }
      return messageChunk;
    }
    _convertOpenAIChatCompletionMessageToBaseMessage(message, rawResponse) {
      const langChainMessage = super._convertOpenAIChatCompletionMessageToBaseMessage(message, rawResponse);
      langChainMessage.additional_kwargs.reasoning_content = // eslint-disable-next-line @typescript-eslint/no-explicit-any
      message.reasoning_content;
      return langChainMessage;
    }
    withStructuredOutput(outputSchema, config2) {
      const ensuredConfig = { ...config2 };
      if ((ensuredConfig == null ? void 0 : ensuredConfig.method) === void 0) {
        ensuredConfig.method = "functionCalling";
      }
      return super.withStructuredOutput(outputSchema, ensuredConfig);
    }
  }
  var g = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
  typeof global !== "undefined" && global || {};
  var support = {
    searchParams: "URLSearchParams" in g,
    iterable: "Symbol" in g && "iterator" in Symbol,
    blob: "FileReader" in g && "Blob" in g && function() {
      try {
        new Blob();
        return true;
      } catch (e) {
        return false;
      }
    }(),
    formData: "FormData" in g,
    arrayBuffer: "ArrayBuffer" in g
  };
  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj);
  }
  if (support.arrayBuffer) {
    var viewClasses = [
      "[object Int8Array]",
      "[object Uint8Array]",
      "[object Uint8ClampedArray]",
      "[object Int16Array]",
      "[object Uint16Array]",
      "[object Int32Array]",
      "[object Uint32Array]",
      "[object Float32Array]",
      "[object Float64Array]"
    ];
    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
    };
  }
  function normalizeName(name) {
    if (typeof name !== "string") {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
      throw new TypeError('Invalid character in header field name: "' + name + '"');
    }
    return name.toLowerCase();
  }
  function normalizeValue(value) {
    if (typeof value !== "string") {
      value = String(value);
    }
    return value;
  }
  function iteratorFor(items) {
    var iterator2 = {
      next: function() {
        var value = items.shift();
        return { done: value === void 0, value };
      }
    };
    if (support.iterable) {
      iterator2[Symbol.iterator] = function() {
        return iterator2;
      };
    }
    return iterator2;
  }
  function Headers$1(headers) {
    this.map = {};
    if (headers instanceof Headers$1) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        if (header.length != 2) {
          throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
        }
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }
  Headers$1.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ", " + value : value;
  };
  Headers$1.prototype["delete"] = function(name) {
    delete this.map[normalizeName(name)];
  };
  Headers$1.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null;
  };
  Headers$1.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name));
  };
  Headers$1.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };
  Headers$1.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };
  Headers$1.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items);
  };
  Headers$1.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items);
  };
  Headers$1.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items);
  };
  if (support.iterable) {
    Headers$1.prototype[Symbol.iterator] = Headers$1.prototype.entries;
  }
  function consumed(body) {
    if (body._noBody) return;
    if (body.bodyUsed) {
      return Promise.reject(new TypeError("Already read"));
    }
    body.bodyUsed = true;
  }
  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    });
  }
  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise;
  }
  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
    var encoding = match ? match[1] : "utf-8";
    reader.readAsText(blob, encoding);
    return promise;
  }
  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);
    for (var i2 = 0; i2 < view.length; i2++) {
      chars[i2] = String.fromCharCode(view[i2]);
    }
    return chars.join("");
  }
  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0);
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer;
    }
  }
  function Body() {
    this.bodyUsed = false;
    this._initBody = function(body) {
      this.bodyUsed = this.bodyUsed;
      this._bodyInit = body;
      if (!body) {
        this._noBody = true;
        this._bodyText = "";
      } else if (typeof body === "string") {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }
      if (!this.headers.get("content-type")) {
        if (typeof body === "string") {
          this.headers.set("content-type", "text/plain;charset=UTF-8");
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set("content-type", this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
        }
      }
    };
    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected;
        }
        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob);
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]));
        } else if (this._bodyFormData) {
          throw new Error("could not read FormData body as blob");
        } else {
          return Promise.resolve(new Blob([this._bodyText]));
        }
      };
    }
    this.arrayBuffer = function() {
      if (this._bodyArrayBuffer) {
        var isConsumed = consumed(this);
        if (isConsumed) {
          return isConsumed;
        } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
          return Promise.resolve(
            this._bodyArrayBuffer.buffer.slice(
              this._bodyArrayBuffer.byteOffset,
              this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
            )
          );
        } else {
          return Promise.resolve(this._bodyArrayBuffer);
        }
      } else if (support.blob) {
        return this.blob().then(readBlobAsArrayBuffer);
      } else {
        throw new Error("could not read as ArrayBuffer");
      }
    };
    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected;
      }
      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
      } else if (this._bodyFormData) {
        throw new Error("could not read FormData body as text");
      } else {
        return Promise.resolve(this._bodyText);
      }
    };
    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode);
      };
    }
    this.json = function() {
      return this.text().then(JSON.parse);
    };
    return this;
  }
  var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method;
  }
  function Request$2(input, options) {
    if (!(this instanceof Request$2)) {
      throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
    }
    options = options || {};
    var body = options.body;
    if (input instanceof Request$2) {
      if (input.bodyUsed) {
        throw new TypeError("Already read");
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers$1(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }
    this.credentials = options.credentials || this.credentials || "same-origin";
    if (options.headers || !this.headers) {
      this.headers = new Headers$1(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || "GET");
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal || function() {
      if ("AbortController" in g) {
        var ctrl = new AbortController();
        return ctrl.signal;
      }
    }();
    this.referrer = null;
    if ((this.method === "GET" || this.method === "HEAD") && body) {
      throw new TypeError("Body not allowed for GET or HEAD requests");
    }
    this._initBody(body);
    if (this.method === "GET" || this.method === "HEAD") {
      if (options.cache === "no-store" || options.cache === "no-cache") {
        var reParamSearch = /([?&])_=[^&]*/;
        if (reParamSearch.test(this.url)) {
          this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
        } else {
          var reQueryString = /\?/;
          this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
        }
      }
    }
  }
  Request$2.prototype.clone = function() {
    return new Request$2(this, { body: this._bodyInit });
  };
  function decode(body) {
    var form = new FormData();
    body.trim().split("&").forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split("=");
        var name = split.shift().replace(/\+/g, " ");
        var value = split.join("=").replace(/\+/g, " ");
        form.append(decodeURIComponent(name), decodeURIComponent(value));
      }
    });
    return form;
  }
  function parseHeaders(rawHeaders) {
    var headers = new Headers$1();
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
    preProcessedHeaders.split("\r").map(function(header) {
      return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
    }).forEach(function(line) {
      var parts = line.split(":");
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(":").trim();
        try {
          headers.append(key, value);
        } catch (error) {
          console.warn("Response " + error.message);
        }
      }
    });
    return headers;
  }
  Body.call(Request$2.prototype);
  function Response$1(bodyInit, options) {
    if (!(this instanceof Response$1)) {
      throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
    }
    if (!options) {
      options = {};
    }
    this.type = "default";
    this.status = options.status === void 0 ? 200 : options.status;
    if (this.status < 200 || this.status > 599) {
      throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
    }
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
    this.headers = new Headers$1(options.headers);
    this.url = options.url || "";
    this._initBody(bodyInit);
  }
  Body.call(Response$1.prototype);
  Response$1.prototype.clone = function() {
    return new Response$1(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers$1(this.headers),
      url: this.url
    });
  };
  Response$1.error = function() {
    var response = new Response$1(null, { status: 200, statusText: "" });
    response.ok = false;
    response.status = 0;
    response.type = "error";
    return response;
  };
  var redirectStatuses = [301, 302, 303, 307, 308];
  Response$1.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError("Invalid status code");
    }
    return new Response$1(null, { status, headers: { location: url } });
  };
  var DOMException = g.DOMException;
  try {
    new DOMException();
  } catch (err) {
    DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    DOMException.prototype = Object.create(Error.prototype);
    DOMException.prototype.constructor = DOMException;
  }
  function fetch$1(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request$2(input, init);
      if (request.signal && request.signal.aborted) {
        return reject(new DOMException("Aborted", "AbortError"));
      }
      var xhr = new XMLHttpRequest();
      function abortXhr() {
        xhr.abort();
      }
      xhr.onload = function() {
        var options = {
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || "")
        };
        if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
          options.status = 200;
        } else {
          options.status = xhr.status;
        }
        options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
        var body = "response" in xhr ? xhr.response : xhr.responseText;
        setTimeout(function() {
          resolve(new Response$1(body, options));
        }, 0);
      };
      xhr.onerror = function() {
        setTimeout(function() {
          reject(new TypeError("Network request failed"));
        }, 0);
      };
      xhr.ontimeout = function() {
        setTimeout(function() {
          reject(new TypeError("Network request timed out"));
        }, 0);
      };
      xhr.onabort = function() {
        setTimeout(function() {
          reject(new DOMException("Aborted", "AbortError"));
        }, 0);
      };
      function fixUrl(url) {
        try {
          return url === "" && g.location.href ? g.location.href : url;
        } catch (e) {
          return url;
        }
      }
      xhr.open(request.method, fixUrl(request.url), true);
      if (request.credentials === "include") {
        xhr.withCredentials = true;
      } else if (request.credentials === "omit") {
        xhr.withCredentials = false;
      }
      if ("responseType" in xhr) {
        if (support.blob) {
          xhr.responseType = "blob";
        } else if (support.arrayBuffer) {
          xhr.responseType = "arraybuffer";
        }
      }
      if (init && typeof init.headers === "object" && !(init.headers instanceof Headers$1 || g.Headers && init.headers instanceof g.Headers)) {
        var names = [];
        Object.getOwnPropertyNames(init.headers).forEach(function(name) {
          names.push(normalizeName(name));
          xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
        });
        request.headers.forEach(function(value, name) {
          if (names.indexOf(name) === -1) {
            xhr.setRequestHeader(name, value);
          }
        });
      } else {
        request.headers.forEach(function(value, name) {
          xhr.setRequestHeader(name, value);
        });
      }
      if (request.signal) {
        request.signal.addEventListener("abort", abortXhr);
        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
            request.signal.removeEventListener("abort", abortXhr);
          }
        };
      }
      xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
    });
  }
  fetch$1.polyfill = true;
  if (!g.fetch) {
    g.fetch = fetch$1;
    g.Headers = Headers$1;
    g.Request = Request$2;
    g.Response = Response$1;
  }
  const version = "0.5.14";
  const defaultPort = "11434";
  const defaultHost = `http://127.0.0.1:${defaultPort}`;
  var __defProp$1 = Object.defineProperty;
  var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField$1 = (obj, key, value) => {
    __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  class ResponseError extends Error {
    constructor(error, status_code) {
      super(error);
      this.error = error;
      this.status_code = status_code;
      this.name = "ResponseError";
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, ResponseError);
      }
    }
  }
  class AbortableAsyncIterator {
    constructor(abortController, itr, doneCallback) {
      __publicField$1(this, "abortController");
      __publicField$1(this, "itr");
      __publicField$1(this, "doneCallback");
      this.abortController = abortController;
      this.itr = itr;
      this.doneCallback = doneCallback;
    }
    abort() {
      this.abortController.abort();
    }
    async *[Symbol.asyncIterator]() {
      for await (const message of this.itr) {
        if ("error" in message) {
          throw new Error(message.error);
        }
        yield message;
        if (message.done || message.status === "success") {
          this.doneCallback();
          return;
        }
      }
      throw new Error("Did not receive done or success response in stream.");
    }
  }
  const checkOk = async (response) => {
    var _a3;
    if (response.ok) {
      return;
    }
    let message = `Error ${response.status}: ${response.statusText}`;
    let errorData = null;
    if ((_a3 = response.headers.get("content-type")) == null ? void 0 : _a3.includes("application/json")) {
      try {
        errorData = await response.json();
        message = errorData.error || message;
      } catch (error) {
        console.log("Failed to parse error response as JSON");
      }
    } else {
      try {
        console.log("Getting text from response");
        const textResponse = await response.text();
        message = textResponse || message;
      } catch (error) {
        console.log("Failed to get text from error response");
      }
    }
    throw new ResponseError(message, response.status);
  };
  function getPlatform() {
    var _a3;
    if (typeof window !== "undefined" && window.navigator) {
      const nav = navigator;
      if ("userAgentData" in nav && ((_a3 = nav.userAgentData) == null ? void 0 : _a3.platform)) {
        return `${nav.userAgentData.platform.toLowerCase()} Browser/${navigator.userAgent};`;
      }
      if (navigator.platform) {
        return `${navigator.platform.toLowerCase()} Browser/${navigator.userAgent};`;
      }
      return `unknown Browser/${navigator.userAgent};`;
    } else if (typeof process !== "undefined") {
      return `${process.arch} ${process.platform} Node.js/${process.version}`;
    }
    return "";
  }
  function normalizeHeaders(headers) {
    if (headers instanceof Headers) {
      const obj = {};
      headers.forEach((value, key) => {
        obj[key] = value;
      });
      return obj;
    } else if (Array.isArray(headers)) {
      return Object.fromEntries(headers);
    } else {
      return headers || {};
    }
  }
  const fetchWithHeaders = async (fetch2, url, options = {}) => {
    const defaultHeaders = {
      "Content-Type": "application/json",
      Accept: "application/json",
      "User-Agent": `ollama-js/${version} (${getPlatform()})`
    };
    options.headers = normalizeHeaders(options.headers);
    const customHeaders = Object.fromEntries(
      Object.entries(options.headers).filter(([key]) => !Object.keys(defaultHeaders).some((defaultKey) => defaultKey.toLowerCase() === key.toLowerCase()))
    );
    options.headers = {
      ...defaultHeaders,
      ...customHeaders
    };
    return fetch2(url, options);
  };
  const get = async (fetch2, host, options) => {
    const response = await fetchWithHeaders(fetch2, host, {
      headers: options == null ? void 0 : options.headers
    });
    await checkOk(response);
    return response;
  };
  const post = async (fetch2, host, data, options) => {
    const isRecord = (input) => {
      return input !== null && typeof input === "object" && !Array.isArray(input);
    };
    const formattedData = isRecord(data) ? JSON.stringify(data) : data;
    const response = await fetchWithHeaders(fetch2, host, {
      method: "POST",
      body: formattedData,
      signal: options == null ? void 0 : options.signal,
      headers: options == null ? void 0 : options.headers
    });
    await checkOk(response);
    return response;
  };
  const del = async (fetch2, host, data, options) => {
    const response = await fetchWithHeaders(fetch2, host, {
      method: "DELETE",
      body: JSON.stringify(data),
      headers: options == null ? void 0 : options.headers
    });
    await checkOk(response);
    return response;
  };
  const parseJSON = async function* (itr) {
    const decoder = new TextDecoder("utf-8");
    let buffer = "";
    const reader = itr.getReader();
    while (true) {
      const { done, value: chunk } = await reader.read();
      if (done) {
        break;
      }
      buffer += decoder.decode(chunk);
      const parts = buffer.split("\n");
      buffer = parts.pop() ?? "";
      for (const part of parts) {
        try {
          yield JSON.parse(part);
        } catch (error) {
          console.warn("invalid json: ", part);
        }
      }
    }
    for (const part of buffer.split("\n").filter((p) => p !== "")) {
      try {
        yield JSON.parse(part);
      } catch (error) {
        console.warn("invalid json: ", part);
      }
    }
  };
  const formatHost = (host) => {
    if (!host) {
      return defaultHost;
    }
    let isExplicitProtocol = host.includes("://");
    if (host.startsWith(":")) {
      host = `http://127.0.0.1${host}`;
      isExplicitProtocol = true;
    }
    if (!isExplicitProtocol) {
      host = `http://${host}`;
    }
    const url = new URL(host);
    let port = url.port;
    if (!port) {
      if (!isExplicitProtocol) {
        port = defaultPort;
      } else {
        port = url.protocol === "https:" ? "443" : "80";
      }
    }
    let formattedHost = `${url.protocol}//${url.hostname}:${port}${url.pathname}`;
    if (formattedHost.endsWith("/")) {
      formattedHost = formattedHost.slice(0, -1);
    }
    return formattedHost;
  };
  var __defProp2 = Object.defineProperty;
  var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField2 = (obj, key, value) => {
    __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  let Ollama$1 = class Ollama {
    constructor(config2) {
      __publicField2(this, "config");
      __publicField2(this, "fetch");
      __publicField2(this, "ongoingStreamedRequests", []);
      this.config = {
        host: "",
        headers: config2 == null ? void 0 : config2.headers
      };
      if (!(config2 == null ? void 0 : config2.proxy)) {
        this.config.host = formatHost((config2 == null ? void 0 : config2.host) ?? defaultHost);
      }
      this.fetch = (config2 == null ? void 0 : config2.fetch) ?? fetch;
    }
    // Abort any ongoing streamed requests to Ollama
    abort() {
      for (const request of this.ongoingStreamedRequests) {
        request.abort();
      }
      this.ongoingStreamedRequests.length = 0;
    }
    /**
     * Processes a request to the Ollama server. If the request is streamable, it will return a
     * AbortableAsyncIterator that yields the response messages. Otherwise, it will return the response
     * object.
     * @param endpoint {string} - The endpoint to send the request to.
     * @param request {object} - The request object to send to the endpoint.
     * @protected {T | AbortableAsyncIterator<T>} - The response object or a AbortableAsyncIterator that yields
     * response messages.
     * @throws {Error} - If the response body is missing or if the response is an error.
     * @returns {Promise<T | AbortableAsyncIterator<T>>} - The response object or a AbortableAsyncIterator that yields the streamed response.
     */
    async processStreamableRequest(endpoint, request) {
      request.stream = request.stream ?? false;
      const host = `${this.config.host}/api/${endpoint}`;
      if (request.stream) {
        const abortController = new AbortController();
        const response2 = await post(this.fetch, host, request, {
          signal: abortController.signal,
          headers: this.config.headers
        });
        if (!response2.body) {
          throw new Error("Missing body");
        }
        const itr = parseJSON(response2.body);
        const abortableAsyncIterator = new AbortableAsyncIterator(
          abortController,
          itr,
          () => {
            const i2 = this.ongoingStreamedRequests.indexOf(abortableAsyncIterator);
            if (i2 > -1) {
              this.ongoingStreamedRequests.splice(i2, 1);
            }
          }
        );
        this.ongoingStreamedRequests.push(abortableAsyncIterator);
        return abortableAsyncIterator;
      }
      const response = await post(this.fetch, host, request, {
        headers: this.config.headers
      });
      return await response.json();
    }
    /**
     * Encodes an image to base64 if it is a Uint8Array.
     * @param image {Uint8Array | string} - The image to encode.
     * @returns {Promise<string>} - The base64 encoded image.
     */
    async encodeImage(image) {
      if (typeof image !== "string") {
        const uint8Array = new Uint8Array(image);
        let byteString = "";
        const len = uint8Array.byteLength;
        for (let i2 = 0; i2 < len; i2++) {
          byteString += String.fromCharCode(uint8Array[i2]);
        }
        return btoa(byteString);
      }
      return image;
    }
    /**
     * Generates a response from a text prompt.
     * @param request {GenerateRequest} - The request object.
     * @returns {Promise<GenerateResponse | AbortableAsyncIterator<GenerateResponse>>} - The response object or
     * an AbortableAsyncIterator that yields response messages.
     */
    async generate(request) {
      if (request.images) {
        request.images = await Promise.all(request.images.map(this.encodeImage.bind(this)));
      }
      return this.processStreamableRequest("generate", request);
    }
    /**
     * Chats with the model. The request object can contain messages with images that are either
     * Uint8Arrays or base64 encoded strings. The images will be base64 encoded before sending the
     * request.
     * @param request {ChatRequest} - The request object.
     * @returns {Promise<ChatResponse | AbortableAsyncIterator<ChatResponse>>} - The response object or an
     * AbortableAsyncIterator that yields response messages.
     */
    async chat(request) {
      if (request.messages) {
        for (const message of request.messages) {
          if (message.images) {
            message.images = await Promise.all(
              message.images.map(this.encodeImage.bind(this))
            );
          }
        }
      }
      return this.processStreamableRequest("chat", request);
    }
    /**
     * Creates a new model from a stream of data.
     * @param request {CreateRequest} - The request object.
     * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or a stream of progress responses.
     */
    async create(request) {
      return this.processStreamableRequest("create", {
        ...request
      });
    }
    /**
     * Pulls a model from the Ollama registry. The request object can contain a stream flag to indicate if the
     * response should be streamed.
     * @param request {PullRequest} - The request object.
     * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or
     * an AbortableAsyncIterator that yields response messages.
     */
    async pull(request) {
      return this.processStreamableRequest("pull", {
        name: request.model,
        stream: request.stream,
        insecure: request.insecure
      });
    }
    /**
     * Pushes a model to the Ollama registry. The request object can contain a stream flag to indicate if the
     * response should be streamed.
     * @param request {PushRequest} - The request object.
     * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or
     * an AbortableAsyncIterator that yields response messages.
     */
    async push(request) {
      return this.processStreamableRequest("push", {
        name: request.model,
        stream: request.stream,
        insecure: request.insecure
      });
    }
    /**
     * Deletes a model from the server. The request object should contain the name of the model to
     * delete.
     * @param request {DeleteRequest} - The request object.
     * @returns {Promise<StatusResponse>} - The response object.
     */
    async delete(request) {
      await del(
        this.fetch,
        `${this.config.host}/api/delete`,
        { name: request.model },
        { headers: this.config.headers }
      );
      return { status: "success" };
    }
    /**
     * Copies a model from one name to another. The request object should contain the name of the
     * model to copy and the new name.
     * @param request {CopyRequest} - The request object.
     * @returns {Promise<StatusResponse>} - The response object.
     */
    async copy(request) {
      await post(this.fetch, `${this.config.host}/api/copy`, { ...request }, {
        headers: this.config.headers
      });
      return { status: "success" };
    }
    /**
     * Lists the models on the server.
     * @returns {Promise<ListResponse>} - The response object.
     * @throws {Error} - If the response body is missing.
     */
    async list() {
      const response = await get(this.fetch, `${this.config.host}/api/tags`, {
        headers: this.config.headers
      });
      return await response.json();
    }
    /**
     * Shows the metadata of a model. The request object should contain the name of the model.
     * @param request {ShowRequest} - The request object.
     * @returns {Promise<ShowResponse>} - The response object.
     */
    async show(request) {
      const response = await post(this.fetch, `${this.config.host}/api/show`, {
        ...request
      }, {
        headers: this.config.headers
      });
      return await response.json();
    }
    /**
     * Embeds text input into vectors.
     * @param request {EmbedRequest} - The request object.
     * @returns {Promise<EmbedResponse>} - The response object.
     */
    async embed(request) {
      const response = await post(this.fetch, `${this.config.host}/api/embed`, {
        ...request
      }, {
        headers: this.config.headers
      });
      return await response.json();
    }
    /**
     * Embeds a text prompt into a vector.
     * @param request {EmbeddingsRequest} - The request object.
     * @returns {Promise<EmbeddingsResponse>} - The response object.
     */
    async embeddings(request) {
      const response = await post(this.fetch, `${this.config.host}/api/embeddings`, {
        ...request
      }, {
        headers: this.config.headers
      });
      return await response.json();
    }
    /**
     * Lists the running models on the server
     * @returns {Promise<ListResponse>} - The response object.
     * @throws {Error} - If the response body is missing.
     */
    async ps() {
      const response = await get(this.fetch, `${this.config.host}/api/ps`, {
        headers: this.config.headers
      });
      return await response.json();
    }
  };
  new Ollama$1();
  function convertOllamaMessagesToLangChain(messages, extra) {
    var _a3;
    return new AIMessageChunk({
      content: messages.content ?? "",
      tool_call_chunks: (_a3 = messages.tool_calls) == null ? void 0 : _a3.map((tc) => ({
        name: tc.function.name,
        args: JSON.stringify(tc.function.arguments),
        type: "tool_call_chunk",
        index: 0,
        id: v4()
      })),
      response_metadata: extra == null ? void 0 : extra.responseMetadata,
      usage_metadata: extra == null ? void 0 : extra.usageMetadata
    });
  }
  function extractBase64FromDataUrl(dataUrl) {
    const match = dataUrl.match(/^data:.*?;base64,(.*)$/);
    return match ? match[1] : "";
  }
  function convertAMessagesToOllama(messages) {
    var _a3, _b2, _c2;
    if (typeof messages.content === "string") {
      return [
        {
          role: "assistant",
          content: messages.content
        }
      ];
    }
    const textFields = messages.content.filter((c) => c.type === "text" && typeof c.text === "string");
    const textMessages = textFields.map((c) => ({
      role: "assistant",
      content: c.text
    }));
    let toolCallMsgs;
    if (messages.content.find((c) => c.type === "tool_use") && ((_a3 = messages.tool_calls) == null ? void 0 : _a3.length)) {
      const toolCalls = (_b2 = messages.tool_calls) == null ? void 0 : _b2.map((tc) => ({
        id: tc.id,
        type: "function",
        function: {
          name: tc.name,
          arguments: tc.args
        }
      }));
      if (toolCalls) {
        toolCallMsgs = {
          role: "assistant",
          tool_calls: toolCalls,
          content: ""
        };
      }
    } else if (messages.content.find((c) => c.type === "tool_use") && !((_c2 = messages.tool_calls) == null ? void 0 : _c2.length)) {
      throw new Error("'tool_use' content type is not supported without tool calls.");
    }
    return [...textMessages, ...toolCallMsgs ? [toolCallMsgs] : []];
  }
  function convertHumanGenericMessagesToOllama(message) {
    if (typeof message.content === "string") {
      return [
        {
          role: "user",
          content: message.content
        }
      ];
    }
    return message.content.map((c) => {
      if (c.type === "text") {
        return {
          role: "user",
          content: c.text
        };
      } else if (c.type === "image_url") {
        if (typeof c.image_url === "string") {
          return {
            role: "user",
            content: "",
            images: [extractBase64FromDataUrl(c.image_url)]
          };
        } else if (c.image_url.url && typeof c.image_url.url === "string") {
          return {
            role: "user",
            content: "",
            images: [extractBase64FromDataUrl(c.image_url.url)]
          };
        }
      }
      throw new Error(`Unsupported content type: ${c.type}`);
    });
  }
  function convertSystemMessageToOllama(message) {
    if (typeof message.content === "string") {
      return [
        {
          role: "system",
          content: message.content
        }
      ];
    } else if (message.content.every((c) => c.type === "text" && typeof c.text === "string")) {
      return message.content.map((c) => ({
        role: "system",
        content: c.text
      }));
    } else {
      throw new Error(`Unsupported content type(s): ${message.content.map((c) => c.type).join(", ")}`);
    }
  }
  function convertToolMessageToOllama(message) {
    if (typeof message.content !== "string") {
      throw new Error("Non string tool message content is not supported");
    }
    return [
      {
        role: "tool",
        content: message.content
      }
    ];
  }
  function convertToOllamaMessages(messages) {
    return messages.flatMap((msg) => {
      if (["human", "generic"].includes(msg._getType())) {
        return convertHumanGenericMessagesToOllama(msg);
      } else if (msg._getType() === "ai") {
        return convertAMessagesToOllama(msg);
      } else if (msg._getType() === "system") {
        return convertSystemMessageToOllama(msg);
      } else if (msg._getType() === "tool") {
        return convertToolMessageToOllama(msg);
      } else {
        throw new Error(`Unsupported message type: ${msg._getType()}`);
      }
    });
  }
  class ChatOllama extends BaseChatModel {
    // Used for tracing, replace with the same name as your class
    static lc_name() {
      return "ChatOllama";
    }
    constructor(fields) {
      super(fields ?? {});
      Object.defineProperty(this, "model", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "llama3"
      });
      Object.defineProperty(this, "numa", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "numCtx", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "numBatch", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "numGpu", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "mainGpu", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "lowVram", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "f16Kv", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "logitsAll", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "vocabOnly", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "useMmap", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "useMlock", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "embeddingOnly", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "numThread", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "numKeep", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "seed", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "numPredict", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "topK", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "topP", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "tfsZ", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "typicalP", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "repeatLastN", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "temperature", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "repeatPenalty", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "presencePenalty", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "frequencyPenalty", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "mirostat", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "mirostatTau", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "mirostatEta", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "penalizeNewline", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "streaming", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "format", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "keepAlive", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "client", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "checkOrPullModel", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "baseUrl", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "http://127.0.0.1:11434"
      });
      this.client = new Ollama$1({
        host: fields == null ? void 0 : fields.baseUrl,
        headers: fields == null ? void 0 : fields.headers
      });
      this.baseUrl = (fields == null ? void 0 : fields.baseUrl) ?? this.baseUrl;
      this.model = (fields == null ? void 0 : fields.model) ?? this.model;
      this.numa = fields == null ? void 0 : fields.numa;
      this.numCtx = fields == null ? void 0 : fields.numCtx;
      this.numBatch = fields == null ? void 0 : fields.numBatch;
      this.numGpu = fields == null ? void 0 : fields.numGpu;
      this.mainGpu = fields == null ? void 0 : fields.mainGpu;
      this.lowVram = fields == null ? void 0 : fields.lowVram;
      this.f16Kv = fields == null ? void 0 : fields.f16Kv;
      this.logitsAll = fields == null ? void 0 : fields.logitsAll;
      this.vocabOnly = fields == null ? void 0 : fields.vocabOnly;
      this.useMmap = fields == null ? void 0 : fields.useMmap;
      this.useMlock = fields == null ? void 0 : fields.useMlock;
      this.embeddingOnly = fields == null ? void 0 : fields.embeddingOnly;
      this.numThread = fields == null ? void 0 : fields.numThread;
      this.numKeep = fields == null ? void 0 : fields.numKeep;
      this.seed = fields == null ? void 0 : fields.seed;
      this.numPredict = fields == null ? void 0 : fields.numPredict;
      this.topK = fields == null ? void 0 : fields.topK;
      this.topP = fields == null ? void 0 : fields.topP;
      this.tfsZ = fields == null ? void 0 : fields.tfsZ;
      this.typicalP = fields == null ? void 0 : fields.typicalP;
      this.repeatLastN = fields == null ? void 0 : fields.repeatLastN;
      this.temperature = fields == null ? void 0 : fields.temperature;
      this.repeatPenalty = fields == null ? void 0 : fields.repeatPenalty;
      this.presencePenalty = fields == null ? void 0 : fields.presencePenalty;
      this.frequencyPenalty = fields == null ? void 0 : fields.frequencyPenalty;
      this.mirostat = fields == null ? void 0 : fields.mirostat;
      this.mirostatTau = fields == null ? void 0 : fields.mirostatTau;
      this.mirostatEta = fields == null ? void 0 : fields.mirostatEta;
      this.penalizeNewline = fields == null ? void 0 : fields.penalizeNewline;
      this.streaming = fields == null ? void 0 : fields.streaming;
      this.format = fields == null ? void 0 : fields.format;
      this.keepAlive = fields == null ? void 0 : fields.keepAlive;
      this.checkOrPullModel = (fields == null ? void 0 : fields.checkOrPullModel) ?? this.checkOrPullModel;
    }
    // Replace
    _llmType() {
      return "ollama";
    }
    /**
     * Download a model onto the local machine.
     *
     * @param {string} model The name of the model to download.
     * @param {PullModelOptions | undefined} options Options for pulling the model.
     * @returns {Promise<void>}
     */
    async pull(model, options) {
      const { stream, insecure, logProgress } = {
        stream: true,
        ...options
      };
      if (stream) {
        for await (const chunk of await this.client.pull({
          model,
          insecure,
          stream
        })) {
          if (logProgress) {
            console.log(chunk);
          }
        }
      } else {
        const response = await this.client.pull({ model, insecure });
        if (logProgress) {
          console.log(response);
        }
      }
    }
    bindTools(tools, kwargs) {
      return this.bind({
        tools: tools.map((tool) => convertToOpenAITool(tool)),
        ...kwargs
      });
    }
    getLsParams(options) {
      var _a3, _b2;
      const params = this.invocationParams(options);
      return {
        ls_provider: "ollama",
        ls_model_name: this.model,
        ls_model_type: "chat",
        ls_temperature: ((_a3 = params.options) == null ? void 0 : _a3.temperature) ?? void 0,
        ls_max_tokens: ((_b2 = params.options) == null ? void 0 : _b2.num_predict) ?? void 0,
        ls_stop: options.stop
      };
    }
    invocationParams(options) {
      var _a3;
      if (options == null ? void 0 : options.tool_choice) {
        throw new Error("Tool choice is not supported for ChatOllama.");
      }
      return {
        model: this.model,
        format: (options == null ? void 0 : options.format) ?? this.format,
        keep_alive: this.keepAlive,
        options: {
          numa: this.numa,
          num_ctx: this.numCtx,
          num_batch: this.numBatch,
          num_gpu: this.numGpu,
          main_gpu: this.mainGpu,
          low_vram: this.lowVram,
          f16_kv: this.f16Kv,
          logits_all: this.logitsAll,
          vocab_only: this.vocabOnly,
          use_mmap: this.useMmap,
          use_mlock: this.useMlock,
          embedding_only: this.embeddingOnly,
          num_thread: this.numThread,
          num_keep: this.numKeep,
          seed: this.seed,
          num_predict: this.numPredict,
          top_k: this.topK,
          top_p: this.topP,
          tfs_z: this.tfsZ,
          typical_p: this.typicalP,
          repeat_last_n: this.repeatLastN,
          temperature: this.temperature,
          repeat_penalty: this.repeatPenalty,
          presence_penalty: this.presencePenalty,
          frequency_penalty: this.frequencyPenalty,
          mirostat: this.mirostat,
          mirostat_tau: this.mirostatTau,
          mirostat_eta: this.mirostatEta,
          penalize_newline: this.penalizeNewline,
          stop: options == null ? void 0 : options.stop
        },
        tools: ((_a3 = options == null ? void 0 : options.tools) == null ? void 0 : _a3.length) ? options.tools.map((tool) => convertToOpenAITool(tool)) : void 0
      };
    }
    /**
     * Check if a model exists on the local machine.
     *
     * @param {string} model The name of the model to check.
     * @returns {Promise<boolean>} Whether or not the model exists.
     */
    async checkModelExistsOnMachine(model) {
      const { models } = await this.client.list();
      return !!models.find((m) => m.name === model || m.name === `${model}:latest`);
    }
    async _generate(messages, options, runManager) {
      if (this.checkOrPullModel) {
        if (!await this.checkModelExistsOnMachine(this.model)) {
          await this.pull(this.model, {
            logProgress: true
          });
        }
      }
      let finalChunk;
      for await (const chunk of this._streamResponseChunks(messages, options, runManager)) {
        if (!finalChunk) {
          finalChunk = chunk.message;
        } else {
          finalChunk = concat(finalChunk, chunk.message);
        }
      }
      const nonChunkMessage = new AIMessage({
        id: finalChunk == null ? void 0 : finalChunk.id,
        content: (finalChunk == null ? void 0 : finalChunk.content) ?? "",
        tool_calls: finalChunk == null ? void 0 : finalChunk.tool_calls,
        response_metadata: finalChunk == null ? void 0 : finalChunk.response_metadata,
        usage_metadata: finalChunk == null ? void 0 : finalChunk.usage_metadata
      });
      return {
        generations: [
          {
            text: typeof nonChunkMessage.content === "string" ? nonChunkMessage.content : "",
            message: nonChunkMessage
          }
        ]
      };
    }
    /**
     * Implement to support streaming.
     * Should yield chunks iteratively.
     */
    async *_streamResponseChunks(messages, options, runManager) {
      var _a3;
      if (this.checkOrPullModel) {
        if (!await this.checkModelExistsOnMachine(this.model)) {
          await this.pull(this.model, {
            logProgress: true
          });
        }
      }
      const params = this.invocationParams(options);
      const ollamaMessages = convertToOllamaMessages(messages);
      const usageMetadata = {
        input_tokens: 0,
        output_tokens: 0,
        total_tokens: 0
      };
      if (params.tools && params.tools.length > 0) {
        const toolResult = await this.client.chat({
          ...params,
          messages: ollamaMessages,
          stream: false
          // Ollama currently does not support streaming with tools
        });
        const { message: responseMessage, ...rest } = toolResult;
        usageMetadata.input_tokens += rest.prompt_eval_count ?? 0;
        usageMetadata.output_tokens += rest.eval_count ?? 0;
        usageMetadata.total_tokens = usageMetadata.input_tokens + usageMetadata.output_tokens;
        yield new ChatGenerationChunk({
          text: responseMessage.content,
          message: convertOllamaMessagesToLangChain(responseMessage, {
            responseMetadata: rest,
            usageMetadata
          })
        });
        return runManager == null ? void 0 : runManager.handleLLMNewToken(responseMessage.content);
      }
      const stream = await this.client.chat({
        ...params,
        messages: ollamaMessages,
        stream: true
      });
      let lastMetadata;
      for await (const chunk of stream) {
        if ((_a3 = options.signal) == null ? void 0 : _a3.aborted) {
          this.client.abort();
        }
        const { message: responseMessage, ...rest } = chunk;
        usageMetadata.input_tokens += rest.prompt_eval_count ?? 0;
        usageMetadata.output_tokens += rest.eval_count ?? 0;
        usageMetadata.total_tokens = usageMetadata.input_tokens + usageMetadata.output_tokens;
        lastMetadata = rest;
        yield new ChatGenerationChunk({
          text: responseMessage.content ?? "",
          message: convertOllamaMessagesToLangChain(responseMessage)
        });
        await (runManager == null ? void 0 : runManager.handleLLMNewToken(responseMessage.content ?? ""));
      }
      yield new ChatGenerationChunk({
        text: "",
        message: new AIMessageChunk({
          content: "",
          response_metadata: lastMetadata,
          usage_metadata: usageMetadata
        })
      });
    }
    withStructuredOutput(outputSchema, config2) {
      if ((config2 == null ? void 0 : config2.method) === void 0 || (config2 == null ? void 0 : config2.method) === "jsonSchema") {
        const outputSchemaIsZod = isZodSchema$2(outputSchema);
        const jsonSchema = outputSchemaIsZod ? zodToJsonSchema$4(outputSchema) : outputSchema;
        const llm = this.bind({
          format: jsonSchema
        });
        const outputParser = outputSchemaIsZod ? StructuredOutputParser.fromZodSchema(outputSchema) : new JsonOutputParser();
        if (!(config2 == null ? void 0 : config2.includeRaw)) {
          return llm.pipe(outputParser);
        }
        const parserAssign = RunnablePassthrough.assign({
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          parsed: (input, config3) => outputParser.invoke(input.raw, config3)
        });
        const parserNone = RunnablePassthrough.assign({
          parsed: () => null
        });
        const parsedWithFallback = parserAssign.withFallbacks({
          fallbacks: [parserNone]
        });
        return RunnableSequence.from([
          {
            raw: llm
          },
          parsedWithFallback
        ]);
      } else {
        return super.withStructuredOutput(outputSchema, config2);
      }
    }
  }
  class ChatDeepSeek extends ChatOpenAI {
    static lc_name() {
      return "ChatDeepSeek";
    }
    _llmType() {
      return "deepseek";
    }
    get lc_secrets() {
      return {
        apiKey: "DEEPSEEK_API_KEY"
      };
    }
    constructor(fields) {
      const apiKey = (fields == null ? void 0 : fields.apiKey) || getEnvironmentVariable("DEEPSEEK_API_KEY");
      if (!apiKey) {
        throw new Error(`Deepseek API key not found. Please set the DEEPSEEK_API_KEY environment variable or pass the key into "apiKey" field.`);
      }
      super({
        ...fields,
        apiKey,
        configuration: {
          baseURL: "https://api.deepseek.com",
          ...fields == null ? void 0 : fields.configuration
        }
      });
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ["langchain", "chat_models", "deepseek"]
      });
    }
    _convertOpenAIDeltaToBaseMessageChunk(delta, rawResponse, defaultRole) {
      const messageChunk = super._convertOpenAIDeltaToBaseMessageChunk(delta, rawResponse, defaultRole);
      messageChunk.additional_kwargs.reasoning_content = delta.reasoning_content;
      return messageChunk;
    }
    _convertOpenAIChatCompletionMessageToBaseMessage(message, rawResponse) {
      const langChainMessage = super._convertOpenAIChatCompletionMessageToBaseMessage(message, rawResponse);
      langChainMessage.additional_kwargs.reasoning_content = // eslint-disable-next-line @typescript-eslint/no-explicit-any
      message.reasoning_content;
      return langChainMessage;
    }
    withStructuredOutput(outputSchema, config2) {
      const ensuredConfig = { ...config2 };
      if ((ensuredConfig == null ? void 0 : ensuredConfig.method) === void 0) {
        ensuredConfig.method = "functionCalling";
      }
      return super.withStructuredOutput(outputSchema, ensuredConfig);
    }
  }
  const maxTokens = 1024 * 4;
  function isOpenAIOModel(modelName) {
    if (modelName.startsWith("openai/")) {
      return modelName.startsWith("openai/o");
    }
    return modelName.startsWith("o");
  }
  function createOpenAIChatModel(providerConfig, modelConfig, extraFetchOptions) {
    var _a3, _b2;
    const args = {
      model: modelConfig.modelName,
      apiKey: providerConfig.apiKey
    };
    const configuration = {};
    if (providerConfig.baseUrl) {
      configuration.baseURL = providerConfig.baseUrl;
    }
    if (extraFetchOptions == null ? void 0 : extraFetchOptions.headers) {
      configuration.defaultHeaders = extraFetchOptions.headers;
    }
    args.configuration = configuration;
    if (providerConfig.apiKey) {
      args.apiKey = providerConfig.apiKey;
    }
    if (isOpenAIOModel(modelConfig.modelName)) {
      args.modelKwargs = {
        max_completion_tokens: maxTokens
      };
      if (modelConfig.reasoningEffort) {
        args.modelKwargs.reasoning_effort = modelConfig.reasoningEffort;
      }
    } else {
      args.topP = ((_a3 = modelConfig.parameters) == null ? void 0 : _a3.topP) ?? 0.1;
      args.temperature = ((_b2 = modelConfig.parameters) == null ? void 0 : _b2.temperature) ?? 0.1;
      args.maxTokens = maxTokens;
    }
    return new ChatOpenAI$1(args);
  }
  function extractInstanceNameFromUrl(url) {
    try {
      const parsedUrl = new URL(url);
      const hostnameParts = parsedUrl.hostname.split(".");
      if (hostnameParts.length >= 4 && hostnameParts[1] === "openai" && hostnameParts[2] === "azure") {
        return hostnameParts[0];
      }
    } catch (e) {
      console.error("Error parsing Azure endpoint URL:", e);
    }
    return null;
  }
  function isAzureProvider(providerId) {
    return providerId === ProviderTypeEnum.AzureOpenAI || providerId.startsWith(`${ProviderTypeEnum.AzureOpenAI}_`);
  }
  function createAzureChatModel(providerConfig, modelConfig) {
    var _a3, _b2;
    const temperature = ((_a3 = modelConfig.parameters) == null ? void 0 : _a3.temperature) ?? 0.1;
    const topP = ((_b2 = modelConfig.parameters) == null ? void 0 : _b2.topP) ?? 0.1;
    if (!providerConfig.baseUrl || !providerConfig.azureDeploymentNames || providerConfig.azureDeploymentNames.length === 0 || !providerConfig.azureApiVersion || !providerConfig.apiKey) {
      throw new Error(
        "Azure configuration is incomplete. Endpoint, Deployment Name, API Version, and API Key are required. Please check settings."
      );
    }
    const deploymentName = modelConfig.modelName;
    if (!providerConfig.azureDeploymentNames.includes(deploymentName)) {
      console.warn(
        `[createChatModel] Selected deployment "${deploymentName}" not found in available deployments. Available: ${JSON.stringify(providerConfig.azureDeploymentNames)}. Using the model anyway.`
      );
    }
    const instanceName = extractInstanceNameFromUrl(providerConfig.baseUrl);
    if (!instanceName) {
      throw new Error(
        `Could not extract Instance Name from Azure Endpoint URL: ${providerConfig.baseUrl}. Expected format like https://<your-instance-name>.openai.azure.com/`
      );
    }
    const isOSeriesModel = isOpenAIOModel(deploymentName);
    const args = {
      azureOpenAIApiInstanceName: instanceName,
      // Derived from endpoint
      azureOpenAIApiDeploymentName: deploymentName,
      azureOpenAIApiKey: providerConfig.apiKey,
      azureOpenAIApiVersion: providerConfig.azureApiVersion,
      // For Azure, the model name should be the deployment name itself
      model: deploymentName,
      // Set model = deployment name to fix Azure requests
      // For O series models, use modelKwargs instead of temperature/topP
      ...isOSeriesModel ? {
        modelKwargs: {
          max_completion_tokens: maxTokens,
          // Add reasoning_effort parameter for Azure o-series models if specified
          ...modelConfig.reasoningEffort ? { reasoning_effort: modelConfig.reasoningEffort } : {}
        }
      } : {
        temperature,
        topP,
        maxTokens
      }
      // DO NOT pass baseUrl or configuration here
    };
    return new AzureChatOpenAI(args);
  }
  function createChatModel(providerConfig, modelConfig) {
    var _a3, _b2;
    const temperature = ((_a3 = modelConfig.parameters) == null ? void 0 : _a3.temperature) ?? 0.1;
    const topP = ((_b2 = modelConfig.parameters) == null ? void 0 : _b2.topP) ?? 0.1;
    const isAzure = isAzureProvider(modelConfig.provider);
    if (isAzure) {
      return createAzureChatModel(providerConfig, modelConfig);
    }
    switch (modelConfig.provider) {
      case ProviderTypeEnum.OpenAI: {
        return createOpenAIChatModel(providerConfig, modelConfig, void 0);
      }
      case ProviderTypeEnum.Anthropic: {
        const args = {
          model: modelConfig.modelName,
          apiKey: providerConfig.apiKey,
          maxTokens,
          temperature,
          topP,
          clientOptions: {}
        };
        return new ChatAnthropic(args);
      }
      case ProviderTypeEnum.DeepSeek: {
        const args = {
          model: modelConfig.modelName,
          apiKey: providerConfig.apiKey,
          temperature,
          topP
        };
        return new ChatDeepSeek(args);
      }
      case ProviderTypeEnum.Gemini: {
        const args = {
          model: modelConfig.modelName,
          apiKey: providerConfig.apiKey,
          temperature,
          topP
        };
        return new ChatGoogleGenerativeAI(args);
      }
      case ProviderTypeEnum.Grok: {
        const args = {
          model: modelConfig.modelName,
          apiKey: providerConfig.apiKey,
          temperature,
          topP,
          maxTokens,
          configuration: {}
        };
        return new ChatXAI(args);
      }
      case ProviderTypeEnum.Ollama: {
        const args = {
          model: modelConfig.modelName,
          // required but ignored by ollama
          apiKey: providerConfig.apiKey === "" ? "ollama" : providerConfig.apiKey,
          baseUrl: providerConfig.baseUrl ?? "http://localhost:11434",
          topP,
          temperature,
          maxTokens,
          // ollama usually has a very small context window, so we need to set a large number for agent to work
          // It was set to 128000 in the original code, but it will cause ollama reload the models frequently if you have multiple models working together
          // not sure why, but setting it to 64000 seems to work fine
          // TODO: configure the context window size in model config
          numCtx: 64e3
        };
        return new ChatOllama(args);
      }
      case ProviderTypeEnum.OpenRouter: {
        console.log("[createChatModel] Calling createOpenAIChatModel for OpenRouter");
        return createOpenAIChatModel(providerConfig, modelConfig, {
          headers: {
            "HTTP-Referer": "https://nanobrowser.ai",
            "X-Title": "Nanobrowser"
          }
        });
      }
      default: {
        return createOpenAIChatModel(providerConfig, modelConfig, void 0);
      }
    }
  }
  const logger = createLogger("background");
  const browserContext = new BrowserContext({});
  let currentExecutor = null;
  let currentPort = null;
  chrome.sidePanel.setPanelBehavior({ openPanelOnActionClick: true }).catch((error) => console.error(error));
  async function isScriptInjected(tabId) {
    var _a3;
    try {
      const results = await chrome.scripting.executeScript({
        target: { tabId },
        func: () => Object.prototype.hasOwnProperty.call(window, "buildDomTree")
      });
      return ((_a3 = results[0]) == null ? void 0 : _a3.result) || false;
    } catch (err) {
      console.error("Failed to check script injection status:", err);
      return false;
    }
  }
  async function injectBuildDomTree(tabId) {
    try {
      const alreadyInjected = await isScriptInjected(tabId);
      if (alreadyInjected) {
        console.log("Scripts already injected, skipping...");
        return;
      }
      await chrome.scripting.executeScript({
        target: { tabId },
        files: ["buildDomTree.js"]
      });
      console.log("Scripts successfully injected");
    } catch (err) {
      console.error("Failed to inject scripts:", err);
    }
  }
  chrome.tabs.onUpdated.addListener(async (tabId, changeInfo, tab) => {
    var _a3;
    if (tabId && changeInfo.status === "complete" && ((_a3 = tab.url) == null ? void 0 : _a3.startsWith("http"))) {
      await injectBuildDomTree(tabId);
    }
  });
  chrome.debugger.onDetach.addListener(async (source2, reason) => {
    console.log("Debugger detached:", source2, reason);
    if (reason === "canceled_by_user") {
      if (source2.tabId) {
        await browserContext.cleanup();
      }
    }
  });
  chrome.tabs.onRemoved.addListener((tabId) => {
    browserContext.removeAttachedPage(tabId);
  });
  logger.info("background loaded");
  chrome.runtime.onMessage.addListener(() => {
  });
  chrome.runtime.onConnect.addListener((port) => {
    if (port.name === "side-panel-connection") {
      currentPort = port;
      port.onMessage.addListener(async (message) => {
        try {
          switch (message.type) {
            case "heartbeat":
              port.postMessage({ type: "heartbeat_ack" });
              break;
            case "new_task": {
              if (!message.task) return port.postMessage({ type: "error", error: "No task provided" });
              if (!message.tabId) return port.postMessage({ type: "error", error: "No tab ID provided" });
              logger.info("new_task", message.tabId, message.task);
              currentExecutor = await setupExecutor(message.taskId, message.task, browserContext);
              subscribeToExecutorEvents(currentExecutor);
              const result = await currentExecutor.execute();
              logger.info("new_task execution result", message.tabId, result);
              break;
            }
            case "follow_up_task": {
              if (!message.task) return port.postMessage({ type: "error", error: "No follow up task provided" });
              if (!message.tabId) return port.postMessage({ type: "error", error: "No tab ID provided" });
              logger.info("follow_up_task", message.tabId, message.task);
              if (currentExecutor) {
                currentExecutor.addFollowUpTask(message.task);
                subscribeToExecutorEvents(currentExecutor);
                const result = await currentExecutor.execute();
                logger.info("follow_up_task execution result", message.tabId, result);
              } else {
                logger.info("follow_up_task: executor was cleaned up, can not add follow-up task");
                return port.postMessage({ type: "error", error: "Executor was cleaned up, can not add follow-up task" });
              }
              break;
            }
            case "cancel_task": {
              if (!currentExecutor) return port.postMessage({ type: "error", error: "No task to cancel" });
              await currentExecutor.cancel();
              break;
            }
            case "resume_task": {
              if (!currentExecutor) return port.postMessage({ type: "error", error: "No task to resume" });
              await currentExecutor.resume();
              return port.postMessage({ type: "success" });
            }
            case "pause_task": {
              if (!currentExecutor) return port.postMessage({ type: "error", error: "No task to pause" });
              await currentExecutor.pause();
              return port.postMessage({ type: "success" });
            }
            case "screenshot": {
              if (!message.tabId) return port.postMessage({ type: "error", error: "No tab ID provided" });
              const page = await browserContext.switchTab(message.tabId);
              const screenshot = await page.takeScreenshot();
              logger.info("screenshot", message.tabId, screenshot);
              return port.postMessage({ type: "success", screenshot });
            }
            case "state": {
              try {
                const browserState = await browserContext.getState();
                const elementsText = browserState.elementTree.clickableElementsToString(
                  DEFAULT_AGENT_OPTIONS.includeAttributes
                );
                logger.info("state", browserState);
                logger.info("interactive elements", elementsText);
                return port.postMessage({ type: "success", msg: "State printed to console" });
              } catch (error) {
                logger.error("Failed to get state:", error);
                return port.postMessage({ type: "error", error: "Failed to get state" });
              }
            }
            case "nohighlight": {
              const page = await browserContext.getCurrentPage();
              await page.removeHighlight();
              return port.postMessage({ type: "success", msg: "highlight removed" });
            }
            default:
              return port.postMessage({ type: "error", error: "Unknown message type" });
          }
        } catch (error) {
          console.error("Error handling port message:", error);
          port.postMessage({
            type: "error",
            error: error instanceof Error ? error.message : "Unknown error"
          });
        }
      });
      port.onDisconnect.addListener(() => {
        console.log("Side panel disconnected");
        currentPort = null;
      });
    }
  });
  async function setupExecutor(taskId, task, browserContext2) {
    const providers = await llmProviderStore.getAllProviders();
    if (Object.keys(providers).length === 0) {
      throw new Error("Please configure API keys in the settings first");
    }
    const agentModels = await agentModelStore.getAllAgentModels();
    for (const agentModel of Object.values(agentModels)) {
      if (!providers[agentModel.provider]) {
        throw new Error(`Provider ${agentModel.provider} not found in the settings`);
      }
    }
    const navigatorModel = agentModels[AgentNameEnum.Navigator];
    if (!navigatorModel) {
      throw new Error("Please choose a model for the navigator in the settings first");
    }
    const navigatorProviderConfig = providers[navigatorModel.provider];
    const navigatorLLM = createChatModel(navigatorProviderConfig, navigatorModel);
    let plannerLLM = null;
    const plannerModel = agentModels[AgentNameEnum.Planner];
    if (plannerModel) {
      const plannerProviderConfig = providers[plannerModel.provider];
      plannerLLM = createChatModel(plannerProviderConfig, plannerModel);
    }
    let validatorLLM = null;
    const validatorModel = agentModels[AgentNameEnum.Validator];
    if (validatorModel) {
      const validatorProviderConfig = providers[validatorModel.provider];
      validatorLLM = createChatModel(validatorProviderConfig, validatorModel);
    }
    const generalSettings = await generalSettingsStore.getSettings();
    const executor = new Executor(task, taskId, browserContext2, navigatorLLM, {
      plannerLLM: plannerLLM ?? navigatorLLM,
      validatorLLM: validatorLLM ?? navigatorLLM,
      agentOptions: {
        maxSteps: generalSettings.maxSteps,
        maxFailures: generalSettings.maxFailures,
        maxActionsPerStep: generalSettings.maxActionsPerStep,
        useVision: generalSettings.useVision,
        useVisionForPlanner: generalSettings.useVisionForPlanner,
        planningInterval: generalSettings.planningInterval
      }
    });
    return executor;
  }
  async function subscribeToExecutorEvents(executor) {
    executor.clearExecutionEvents();
    executor.subscribeExecutionEvents(async (event) => {
      try {
        if (currentPort) {
          currentPort.postMessage(event);
        }
      } catch (error) {
        logger.error("Failed to send message to side panel:", error);
      }
      if (event.state === ExecutionState.TASK_OK || event.state === ExecutionState.TASK_FAIL || event.state === ExecutionState.TASK_CANCEL) {
        await (currentExecutor == null ? void 0 : currentExecutor.cleanup());
      }
    });
  }
  var browser$3 = { exports: {} };
  var ms;
  var hasRequiredMs;
  function requireMs() {
    if (hasRequiredMs) return ms;
    hasRequiredMs = 1;
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    ms = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str2) {
      str2 = String(str2);
      if (str2.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str2
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d) {
        return Math.round(ms2 / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms2 / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms2 / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms2 / s) + "s";
      }
      return ms2 + "ms";
    }
    function fmtLong(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d) {
        return plural(ms2, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms2, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms2, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms2, msAbs, s, "second");
      }
      return ms2 + " ms";
    }
    function plural(ms2, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
    }
    return ms;
  }
  var common;
  var hasRequiredCommon;
  function requireCommon() {
    if (hasRequiredCommon) return common;
    hasRequiredCommon = 1;
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce2;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = requireMs();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i2 = 0; i2 < namespace.length; i2++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i2);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms2 = curr - (prevTime || curr);
          self2.diff = ms2;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce2(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    common = setup;
    return common;
  }
  var hasRequiredBrowser$1;
  function requireBrowser$1() {
    if (hasRequiredBrowser$1) return browser$3.exports;
    hasRequiredBrowser$1 = 1;
    (function(module, exports) {
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage = localstorage();
      exports.destroy = /* @__PURE__ */ (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        let m;
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
        typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index++;
          if (match === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
      }
      exports.log = console.debug || console.log || (() => {
      });
      function save(namespaces) {
        try {
          if (namespaces) {
            exports.storage.setItem("debug", namespaces);
          } else {
            exports.storage.removeItem("debug");
          }
        } catch (error) {
        }
      }
      function load() {
        let r;
        try {
          r = exports.storage.getItem("debug");
        } catch (error) {
        }
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = process.env.DEBUG;
        }
        return r;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error) {
        }
      }
      module.exports = requireCommon()(exports);
      const { formatters: formatters2 } = module.exports;
      formatters2.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };
    })(browser$3, browser$3.exports);
    return browser$3.exports;
  }
  var browserExports$1 = requireBrowser$1();
  const browser$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports$1);
  const browser$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: browser$1
  }, Symbol.toStringTag, { value: "Module" }));
  var BidiMapper = {};
  var BidiServer = {};
  var EventEmitter = {};
  function mitt(n) {
    return { all: n = n || /* @__PURE__ */ new Map(), on: function(t, e) {
      var i2 = n.get(t);
      i2 ? i2.push(e) : n.set(t, [e]);
    }, off: function(t, e) {
      var i2 = n.get(t);
      i2 && (e ? i2.splice(i2.indexOf(e) >>> 0, 1) : n.set(t, []));
    }, emit: function(t, e) {
      var i2 = n.get(t);
      i2 && i2.slice().map(function(n2) {
        n2(e);
      }), (i2 = n.get("*")) && i2.slice().map(function(n2) {
        n2(t, e);
      });
    } };
  }
  const mitt$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: mitt
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(mitt$1);
  var hasRequiredEventEmitter;
  function requireEventEmitter() {
    var _emitter3, _a3;
    if (hasRequiredEventEmitter) return EventEmitter;
    hasRequiredEventEmitter = 1;
    var __importDefault = EventEmitter && EventEmitter.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(EventEmitter, "__esModule", { value: true });
    EventEmitter.EventEmitter = void 0;
    const mitt_1 = __importDefault(require$$0$1);
    let EventEmitter$12 = (_a3 = class {
      constructor() {
        __privateAdd(this, _emitter3, (0, mitt_1.default)());
      }
      on(type, handler) {
        __privateGet(this, _emitter3).on(type, handler);
        return this;
      }
      /**
       * Like `on` but the listener will only be fired once and then it will be removed.
       * @param event The event you'd like to listen to
       * @param handler The handler function to run when the event occurs
       * @return `this` to enable chaining method calls.
       */
      once(event, handler) {
        const onceHandler = (eventData) => {
          handler(eventData);
          this.off(event, onceHandler);
        };
        return this.on(event, onceHandler);
      }
      off(type, handler) {
        __privateGet(this, _emitter3).off(type, handler);
        return this;
      }
      /**
       * Emits an event and call any associated listeners.
       *
       * @param event The event to emit.
       * @param eventData Any data to emit with the event.
       * @return `true` if there are any listeners, `false` otherwise.
       */
      emit(event, eventData) {
        __privateGet(this, _emitter3).emit(event, eventData);
      }
      /**
       * Removes all listeners. If given an event argument, it will remove only
       * listeners for that event.
       * @param event - the event to remove listeners for.
       * @returns `this` to enable you to chain method calls.
       */
      removeAllListeners(event) {
        if (event) {
          __privateGet(this, _emitter3).all.delete(event);
        } else {
          __privateGet(this, _emitter3).all.clear();
        }
        return this;
      }
    }, _emitter3 = new WeakMap(), _a3);
    EventEmitter.EventEmitter = EventEmitter$12;
    return EventEmitter;
  }
  var log = {};
  var hasRequiredLog;
  function requireLog() {
    if (hasRequiredLog) return log;
    hasRequiredLog = 1;
    Object.defineProperty(log, "__esModule", { value: true });
    log.LogType = void 0;
    var LogType;
    (function(LogType2) {
      LogType2["bidi"] = "bidi";
      LogType2["cdp"] = "cdp";
      LogType2["debug"] = "debug";
      LogType2["debugError"] = "debug:error";
      LogType2["debugInfo"] = "debug:info";
    })(LogType || (log.LogType = LogType = {}));
    return log;
  }
  var ProcessingQueue = {};
  var hasRequiredProcessingQueue;
  function requireProcessingQueue() {
    var _a4, _logger, _processor, _queue, _isProcessing, _ProcessingQueue_instances, processIfNeeded_fn;
    if (hasRequiredProcessingQueue) return ProcessingQueue;
    hasRequiredProcessingQueue = 1;
    var _a3;
    Object.defineProperty(ProcessingQueue, "__esModule", { value: true });
    ProcessingQueue.ProcessingQueue = void 0;
    const log_js_1 = requireLog();
    let ProcessingQueue$1 = (_a4 = class {
      constructor(processor, logger2) {
        __privateAdd(this, _ProcessingQueue_instances);
        __privateAdd(this, _logger);
        __privateAdd(this, _processor);
        __privateAdd(this, _queue, []);
        // Flag to keep only 1 active processor.
        __privateAdd(this, _isProcessing, false);
        __privateSet(this, _processor, processor);
        __privateSet(this, _logger, logger2);
      }
      add(entry, name) {
        __privateGet(this, _queue).push([entry, name]);
        void __privateMethod(this, _ProcessingQueue_instances, processIfNeeded_fn).call(this);
      }
    }, _logger = new WeakMap(), _processor = new WeakMap(), _queue = new WeakMap(), _isProcessing = new WeakMap(), _ProcessingQueue_instances = new WeakSet(), processIfNeeded_fn = async function() {
      var _a5;
      if (__privateGet(this, _isProcessing)) {
        return;
      }
      __privateSet(this, _isProcessing, true);
      while (__privateGet(this, _queue).length > 0) {
        const arrayEntry = __privateGet(this, _queue).shift();
        if (!arrayEntry) {
          continue;
        }
        const [entryPromise, name] = arrayEntry;
        (_a5 = __privateGet(this, _logger)) == null ? void 0 : _a5.call(this, _a3.LOGGER_PREFIX, "Processing event:", name);
        await entryPromise.then((entry) => {
          var _a6;
          if (entry.kind === "error") {
            (_a6 = __privateGet(this, _logger)) == null ? void 0 : _a6.call(this, log_js_1.LogType.debugError, "Event threw before sending:", entry.error.message, entry.error.stack);
            return;
          }
          return __privateGet(this, _processor).call(this, entry.value);
        }).catch((error) => {
          var _a6;
          (_a6 = __privateGet(this, _logger)) == null ? void 0 : _a6.call(this, log_js_1.LogType.debugError, "Event was not processed:", error == null ? void 0 : error.message);
        });
      }
      __privateSet(this, _isProcessing, false);
    }, __publicField(_a4, "LOGGER_PREFIX", `${log_js_1.LogType.debug}:queue`), _a4);
    ProcessingQueue.ProcessingQueue = ProcessingQueue$1;
    _a3 = ProcessingQueue$1;
    return ProcessingQueue;
  }
  var CommandProcessor = {};
  var protocol = {};
  var cdp = {};
  var hasRequiredCdp;
  function requireCdp() {
    if (hasRequiredCdp) return cdp;
    hasRequiredCdp = 1;
    Object.defineProperty(cdp, "__esModule", { value: true });
    return cdp;
  }
  var chromiumBidi = {};
  var hasRequiredChromiumBidi;
  function requireChromiumBidi() {
    if (hasRequiredChromiumBidi) return chromiumBidi;
    hasRequiredChromiumBidi = 1;
    Object.defineProperty(chromiumBidi, "__esModule", { value: true });
    chromiumBidi.EVENT_NAMES = chromiumBidi.Bluetooth = chromiumBidi.Network = chromiumBidi.BrowsingContext = chromiumBidi.Log = chromiumBidi.Script = chromiumBidi.BiDiModule = void 0;
    var BiDiModule;
    (function(BiDiModule2) {
      BiDiModule2["Bluetooth"] = "bluetooth";
      BiDiModule2["Browser"] = "browser";
      BiDiModule2["BrowsingContext"] = "browsingContext";
      BiDiModule2["Cdp"] = "goog:cdp";
      BiDiModule2["DeprecatedCdp"] = "cdp";
      BiDiModule2["Input"] = "input";
      BiDiModule2["Log"] = "log";
      BiDiModule2["Network"] = "network";
      BiDiModule2["Script"] = "script";
      BiDiModule2["Session"] = "session";
    })(BiDiModule || (chromiumBidi.BiDiModule = BiDiModule = {}));
    var Script;
    (function(Script2) {
      (function(EventNames) {
        EventNames["Message"] = "script.message";
        EventNames["RealmCreated"] = "script.realmCreated";
        EventNames["RealmDestroyed"] = "script.realmDestroyed";
      })(Script2.EventNames || (Script2.EventNames = {}));
    })(Script || (chromiumBidi.Script = Script = {}));
    var Log;
    (function(Log2) {
      (function(EventNames) {
        EventNames["LogEntryAdded"] = "log.entryAdded";
      })(Log2.EventNames || (Log2.EventNames = {}));
    })(Log || (chromiumBidi.Log = Log = {}));
    var BrowsingContext2;
    (function(BrowsingContext3) {
      (function(EventNames) {
        EventNames["ContextCreated"] = "browsingContext.contextCreated";
        EventNames["ContextDestroyed"] = "browsingContext.contextDestroyed";
        EventNames["DomContentLoaded"] = "browsingContext.domContentLoaded";
        EventNames["DownloadWillBegin"] = "browsingContext.downloadWillBegin";
        EventNames["FragmentNavigated"] = "browsingContext.fragmentNavigated";
        EventNames["HistoryUpdated"] = "browsingContext.historyUpdated";
        EventNames["Load"] = "browsingContext.load";
        EventNames["NavigationAborted"] = "browsingContext.navigationAborted";
        EventNames["NavigationFailed"] = "browsingContext.navigationFailed";
        EventNames["NavigationStarted"] = "browsingContext.navigationStarted";
        EventNames["UserPromptClosed"] = "browsingContext.userPromptClosed";
        EventNames["UserPromptOpened"] = "browsingContext.userPromptOpened";
      })(BrowsingContext3.EventNames || (BrowsingContext3.EventNames = {}));
    })(BrowsingContext2 || (chromiumBidi.BrowsingContext = BrowsingContext2 = {}));
    var Network;
    (function(Network2) {
      (function(EventNames) {
        EventNames["AuthRequired"] = "network.authRequired";
        EventNames["BeforeRequestSent"] = "network.beforeRequestSent";
        EventNames["FetchError"] = "network.fetchError";
        EventNames["ResponseCompleted"] = "network.responseCompleted";
        EventNames["ResponseStarted"] = "network.responseStarted";
      })(Network2.EventNames || (Network2.EventNames = {}));
    })(Network || (chromiumBidi.Network = Network = {}));
    var Bluetooth;
    (function(Bluetooth2) {
      (function(EventNames) {
        EventNames["RequestDevicePromptUpdated"] = "bluetooth.requestDevicePromptUpdated";
      })(Bluetooth2.EventNames || (Bluetooth2.EventNames = {}));
    })(Bluetooth || (chromiumBidi.Bluetooth = Bluetooth = {}));
    chromiumBidi.EVENT_NAMES = /* @__PURE__ */ new Set([
      // keep-sorted start
      ...Object.values(BiDiModule),
      ...Object.values(BrowsingContext2.EventNames),
      ...Object.values(Log.EventNames),
      ...Object.values(Network.EventNames),
      ...Object.values(Script.EventNames)
      // keep-sorted end
    ]);
    return chromiumBidi;
  }
  var webdriverBidi = {};
  var hasRequiredWebdriverBidi;
  function requireWebdriverBidi() {
    if (hasRequiredWebdriverBidi) return webdriverBidi;
    hasRequiredWebdriverBidi = 1;
    Object.defineProperty(webdriverBidi, "__esModule", { value: true });
    return webdriverBidi;
  }
  var ErrorResponse = {};
  var hasRequiredErrorResponse;
  function requireErrorResponse() {
    if (hasRequiredErrorResponse) return ErrorResponse;
    hasRequiredErrorResponse = 1;
    Object.defineProperty(ErrorResponse, "__esModule", { value: true });
    ErrorResponse.NoSuchWebExtensionException = ErrorResponse.InvalidWebExtensionException = ErrorResponse.UnderspecifiedStoragePartitionException = ErrorResponse.UnableToSetFileInputException = ErrorResponse.UnableToSetCookieException = ErrorResponse.NoSuchStoragePartitionException = ErrorResponse.UnsupportedOperationException = ErrorResponse.UnableToCloseBrowserException = ErrorResponse.UnableToCaptureScreenException = ErrorResponse.UnknownErrorException = ErrorResponse.UnknownCommandException = ErrorResponse.SessionNotCreatedException = ErrorResponse.NoSuchUserContextException = ErrorResponse.NoSuchScriptException = ErrorResponse.NoSuchRequestException = ErrorResponse.NoSuchNodeException = ErrorResponse.NoSuchInterceptException = ErrorResponse.NoSuchHistoryEntryException = ErrorResponse.NoSuchHandleException = ErrorResponse.NoSuchFrameException = ErrorResponse.NoSuchElementException = ErrorResponse.NoSuchAlertException = ErrorResponse.MoveTargetOutOfBoundsException = ErrorResponse.InvalidSessionIdException = ErrorResponse.InvalidSelectorException = ErrorResponse.InvalidArgumentException = ErrorResponse.Exception = void 0;
    class Exception extends Error {
      constructor(error, message, stacktrace) {
        super();
        __publicField(this, "error");
        __publicField(this, "message");
        __publicField(this, "stacktrace");
        this.error = error;
        this.message = message;
        this.stacktrace = stacktrace;
      }
      toErrorResponse(commandId) {
        return {
          type: "error",
          id: commandId,
          error: this.error,
          message: this.message,
          stacktrace: this.stacktrace
        };
      }
    }
    ErrorResponse.Exception = Exception;
    class InvalidArgumentException extends Exception {
      constructor(message, stacktrace) {
        super("invalid argument", message, stacktrace);
      }
    }
    ErrorResponse.InvalidArgumentException = InvalidArgumentException;
    class InvalidSelectorException extends Exception {
      constructor(message, stacktrace) {
        super("invalid selector", message, stacktrace);
      }
    }
    ErrorResponse.InvalidSelectorException = InvalidSelectorException;
    class InvalidSessionIdException extends Exception {
      constructor(message, stacktrace) {
        super("invalid session id", message, stacktrace);
      }
    }
    ErrorResponse.InvalidSessionIdException = InvalidSessionIdException;
    class MoveTargetOutOfBoundsException extends Exception {
      constructor(message, stacktrace) {
        super("move target out of bounds", message, stacktrace);
      }
    }
    ErrorResponse.MoveTargetOutOfBoundsException = MoveTargetOutOfBoundsException;
    class NoSuchAlertException extends Exception {
      constructor(message, stacktrace) {
        super("no such alert", message, stacktrace);
      }
    }
    ErrorResponse.NoSuchAlertException = NoSuchAlertException;
    class NoSuchElementException extends Exception {
      constructor(message, stacktrace) {
        super("no such element", message, stacktrace);
      }
    }
    ErrorResponse.NoSuchElementException = NoSuchElementException;
    class NoSuchFrameException extends Exception {
      constructor(message, stacktrace) {
        super("no such frame", message, stacktrace);
      }
    }
    ErrorResponse.NoSuchFrameException = NoSuchFrameException;
    class NoSuchHandleException extends Exception {
      constructor(message, stacktrace) {
        super("no such handle", message, stacktrace);
      }
    }
    ErrorResponse.NoSuchHandleException = NoSuchHandleException;
    class NoSuchHistoryEntryException extends Exception {
      constructor(message, stacktrace) {
        super("no such history entry", message, stacktrace);
      }
    }
    ErrorResponse.NoSuchHistoryEntryException = NoSuchHistoryEntryException;
    class NoSuchInterceptException extends Exception {
      constructor(message, stacktrace) {
        super("no such intercept", message, stacktrace);
      }
    }
    ErrorResponse.NoSuchInterceptException = NoSuchInterceptException;
    class NoSuchNodeException extends Exception {
      constructor(message, stacktrace) {
        super("no such node", message, stacktrace);
      }
    }
    ErrorResponse.NoSuchNodeException = NoSuchNodeException;
    class NoSuchRequestException extends Exception {
      constructor(message, stacktrace) {
        super("no such request", message, stacktrace);
      }
    }
    ErrorResponse.NoSuchRequestException = NoSuchRequestException;
    class NoSuchScriptException extends Exception {
      constructor(message, stacktrace) {
        super("no such script", message, stacktrace);
      }
    }
    ErrorResponse.NoSuchScriptException = NoSuchScriptException;
    class NoSuchUserContextException extends Exception {
      constructor(message, stacktrace) {
        super("no such user context", message, stacktrace);
      }
    }
    ErrorResponse.NoSuchUserContextException = NoSuchUserContextException;
    class SessionNotCreatedException extends Exception {
      constructor(message, stacktrace) {
        super("session not created", message, stacktrace);
      }
    }
    ErrorResponse.SessionNotCreatedException = SessionNotCreatedException;
    class UnknownCommandException extends Exception {
      constructor(message, stacktrace) {
        super("unknown command", message, stacktrace);
      }
    }
    ErrorResponse.UnknownCommandException = UnknownCommandException;
    class UnknownErrorException extends Exception {
      constructor(message, stacktrace = new Error().stack) {
        super("unknown error", message, stacktrace);
      }
    }
    ErrorResponse.UnknownErrorException = UnknownErrorException;
    class UnableToCaptureScreenException extends Exception {
      constructor(message, stacktrace) {
        super("unable to capture screen", message, stacktrace);
      }
    }
    ErrorResponse.UnableToCaptureScreenException = UnableToCaptureScreenException;
    class UnableToCloseBrowserException extends Exception {
      constructor(message, stacktrace) {
        super("unable to close browser", message, stacktrace);
      }
    }
    ErrorResponse.UnableToCloseBrowserException = UnableToCloseBrowserException;
    class UnsupportedOperationException extends Exception {
      constructor(message, stacktrace) {
        super("unsupported operation", message, stacktrace);
      }
    }
    ErrorResponse.UnsupportedOperationException = UnsupportedOperationException;
    class NoSuchStoragePartitionException extends Exception {
      constructor(message, stacktrace) {
        super("no such storage partition", message, stacktrace);
      }
    }
    ErrorResponse.NoSuchStoragePartitionException = NoSuchStoragePartitionException;
    class UnableToSetCookieException extends Exception {
      constructor(message, stacktrace) {
        super("unable to set cookie", message, stacktrace);
      }
    }
    ErrorResponse.UnableToSetCookieException = UnableToSetCookieException;
    class UnableToSetFileInputException extends Exception {
      constructor(message, stacktrace) {
        super("unable to set file input", message, stacktrace);
      }
    }
    ErrorResponse.UnableToSetFileInputException = UnableToSetFileInputException;
    class UnderspecifiedStoragePartitionException extends Exception {
      constructor(message, stacktrace) {
        super("underspecified storage partition", message, stacktrace);
      }
    }
    ErrorResponse.UnderspecifiedStoragePartitionException = UnderspecifiedStoragePartitionException;
    class InvalidWebExtensionException extends Exception {
      constructor(message, stacktrace) {
        super("invalid web extension", message, stacktrace);
      }
    }
    ErrorResponse.InvalidWebExtensionException = InvalidWebExtensionException;
    class NoSuchWebExtensionException extends Exception {
      constructor(message, stacktrace) {
        super("no such web extension", message, stacktrace);
      }
    }
    ErrorResponse.NoSuchWebExtensionException = NoSuchWebExtensionException;
    return ErrorResponse;
  }
  var webdriverBidiPermissions = {};
  var hasRequiredWebdriverBidiPermissions;
  function requireWebdriverBidiPermissions() {
    if (hasRequiredWebdriverBidiPermissions) return webdriverBidiPermissions;
    hasRequiredWebdriverBidiPermissions = 1;
    Object.defineProperty(webdriverBidiPermissions, "__esModule", { value: true });
    return webdriverBidiPermissions;
  }
  var webdriverBidiBluetooth = {};
  var hasRequiredWebdriverBidiBluetooth;
  function requireWebdriverBidiBluetooth() {
    if (hasRequiredWebdriverBidiBluetooth) return webdriverBidiBluetooth;
    hasRequiredWebdriverBidiBluetooth = 1;
    Object.defineProperty(webdriverBidiBluetooth, "__esModule", { value: true });
    return webdriverBidiBluetooth;
  }
  var hasRequiredProtocol;
  function requireProtocol() {
    if (hasRequiredProtocol) return protocol;
    hasRequiredProtocol = 1;
    (function(exports) {
      var __createBinding = protocol && protocol.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = protocol && protocol.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = protocol && protocol.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o) {
          ownKeys = Object.getOwnPropertyNames || function(o2) {
            var ar = [];
            for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
            return ar;
          };
          return ownKeys(o);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k = ownKeys(mod), i2 = 0; i2 < k.length; i2++) if (k[i2] !== "default") __createBinding(result, mod, k[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      var __exportStar = protocol && protocol.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ChromiumBidi = exports.Cdp = void 0;
      exports.Cdp = __importStar(requireCdp());
      exports.ChromiumBidi = __importStar(requireChromiumBidi());
      __exportStar(requireWebdriverBidi(), exports);
      __exportStar(requireErrorResponse(), exports);
      __exportStar(requireWebdriverBidiPermissions(), exports);
      __exportStar(requireWebdriverBidiBluetooth(), exports);
    })(protocol);
    return protocol;
  }
  var BidiNoOpParser = {};
  var hasRequiredBidiNoOpParser;
  function requireBidiNoOpParser() {
    if (hasRequiredBidiNoOpParser) return BidiNoOpParser;
    hasRequiredBidiNoOpParser = 1;
    Object.defineProperty(BidiNoOpParser, "__esModule", { value: true });
    BidiNoOpParser.BidiNoOpParser = void 0;
    let BidiNoOpParser$1 = class BidiNoOpParser {
      // Bluetooth module
      // keep-sorted start block=yes
      parseHandleRequestDevicePromptParams(params) {
        return params;
      }
      parseSimulateAdapterParameters(params) {
        return params;
      }
      parseSimulateAdvertisementParameters(params) {
        return params;
      }
      parseSimulatePreconnectedPeripheralParameters(params) {
        return params;
      }
      // keep-sorted end
      // Browser module
      // keep-sorted start block=yes
      parseRemoveUserContextParams(params) {
        return params;
      }
      // keep-sorted end
      // Browsing Context module
      // keep-sorted start block=yes
      parseActivateParams(params) {
        return params;
      }
      parseCaptureScreenshotParams(params) {
        return params;
      }
      parseCloseParams(params) {
        return params;
      }
      parseCreateParams(params) {
        return params;
      }
      parseGetTreeParams(params) {
        return params;
      }
      parseHandleUserPromptParams(params) {
        return params;
      }
      parseLocateNodesParams(params) {
        return params;
      }
      parseNavigateParams(params) {
        return params;
      }
      parsePrintParams(params) {
        return params;
      }
      parseReloadParams(params) {
        return params;
      }
      parseSetViewportParams(params) {
        return params;
      }
      parseTraverseHistoryParams(params) {
        return params;
      }
      // keep-sorted end
      // CDP module
      // keep-sorted start block=yes
      parseGetSessionParams(params) {
        return params;
      }
      parseResolveRealmParams(params) {
        return params;
      }
      parseSendCommandParams(params) {
        return params;
      }
      // keep-sorted end
      // Script module
      // keep-sorted start block=yes
      parseAddPreloadScriptParams(params) {
        return params;
      }
      parseCallFunctionParams(params) {
        return params;
      }
      parseDisownParams(params) {
        return params;
      }
      parseEvaluateParams(params) {
        return params;
      }
      parseGetRealmsParams(params) {
        return params;
      }
      parseRemovePreloadScriptParams(params) {
        return params;
      }
      // keep-sorted end
      // Input module
      // keep-sorted start block=yes
      parsePerformActionsParams(params) {
        return params;
      }
      parseReleaseActionsParams(params) {
        return params;
      }
      parseSetFilesParams(params) {
        return params;
      }
      // keep-sorted end
      // Network module
      // keep-sorted start block=yes
      parseAddInterceptParams(params) {
        return params;
      }
      parseContinueRequestParams(params) {
        return params;
      }
      parseContinueResponseParams(params) {
        return params;
      }
      parseContinueWithAuthParams(params) {
        return params;
      }
      parseFailRequestParams(params) {
        return params;
      }
      parseProvideResponseParams(params) {
        return params;
      }
      parseRemoveInterceptParams(params) {
        return params;
      }
      parseSetCacheBehavior(params) {
        return params;
      }
      // keep-sorted end
      // Permissions module
      // keep-sorted start block=yes
      parseSetPermissionsParams(params) {
        return params;
      }
      // keep-sorted end
      // Session module
      // keep-sorted start block=yes
      parseSubscribeParams(params) {
        return params;
      }
      // keep-sorted end
      // Storage module
      // keep-sorted start block=yes
      parseDeleteCookiesParams(params) {
        return params;
      }
      parseGetCookiesParams(params) {
        return params;
      }
      parseSetCookieParams(params) {
        return params;
      }
    };
    BidiNoOpParser.BidiNoOpParser = BidiNoOpParser$1;
    return BidiNoOpParser;
  }
  var BrowserProcessor = {};
  var hasRequiredBrowserProcessor;
  function requireBrowserProcessor() {
    var _browserCdpClient, _browsingContextStorage, _BrowserProcessor_instances, getWindowInfo_fn, _a3;
    if (hasRequiredBrowserProcessor) return BrowserProcessor;
    hasRequiredBrowserProcessor = 1;
    Object.defineProperty(BrowserProcessor, "__esModule", { value: true });
    BrowserProcessor.BrowserProcessor = void 0;
    const protocol_js_1 = requireProtocol();
    let BrowserProcessor$1 = (_a3 = class {
      constructor(browserCdpClient, browsingContextStorage) {
        __privateAdd(this, _BrowserProcessor_instances);
        __privateAdd(this, _browserCdpClient);
        __privateAdd(this, _browsingContextStorage);
        __privateSet(this, _browserCdpClient, browserCdpClient);
        __privateSet(this, _browsingContextStorage, browsingContextStorage);
      }
      close() {
        setTimeout(() => __privateGet(this, _browserCdpClient).sendCommand("Browser.close"), 0);
        return {};
      }
      async createUserContext(params) {
        const request = {
          proxyServer: params["goog:proxyServer"] ?? void 0
        };
        const proxyBypassList = params["goog:proxyBypassList"] ?? void 0;
        if (proxyBypassList) {
          request.proxyBypassList = proxyBypassList.join(",");
        }
        const context = await __privateGet(this, _browserCdpClient).sendCommand("Target.createBrowserContext", request);
        return {
          userContext: context.browserContextId
        };
      }
      async removeUserContext(params) {
        const userContext = params.userContext;
        if (userContext === "default") {
          throw new protocol_js_1.InvalidArgumentException("`default` user context cannot be removed");
        }
        try {
          await __privateGet(this, _browserCdpClient).sendCommand("Target.disposeBrowserContext", {
            browserContextId: userContext
          });
        } catch (err) {
          if (err.message.startsWith("Failed to find context with id")) {
            throw new protocol_js_1.NoSuchUserContextException(err.message);
          }
          throw err;
        }
        return {};
      }
      async getUserContexts() {
        const result = await __privateGet(this, _browserCdpClient).sendCommand("Target.getBrowserContexts");
        return {
          userContexts: [
            {
              userContext: "default"
            },
            ...result.browserContextIds.map((id) => {
              return {
                userContext: id
              };
            })
          ]
        };
      }
      async getClientWindows() {
        const topLevelTargetIds = __privateGet(this, _browsingContextStorage).getTopLevelContexts().map((b) => b.cdpTarget.id);
        const clientWindows = await Promise.all(topLevelTargetIds.map(async (targetId) => await __privateMethod(this, _BrowserProcessor_instances, getWindowInfo_fn).call(this, targetId)));
        const uniqueClientWindowIds = /* @__PURE__ */ new Set();
        const uniqueClientWindows = new Array();
        for (const window2 of clientWindows) {
          if (!uniqueClientWindowIds.has(window2.clientWindow)) {
            uniqueClientWindowIds.add(window2.clientWindow);
            uniqueClientWindows.push(window2);
          }
        }
        return { clientWindows: uniqueClientWindows };
      }
    }, _browserCdpClient = new WeakMap(), _browsingContextStorage = new WeakMap(), _BrowserProcessor_instances = new WeakSet(), getWindowInfo_fn = async function(targetId) {
      const windowInfo = await __privateGet(this, _browserCdpClient).sendCommand("Browser.getWindowForTarget", { targetId });
      return {
        // `active` is not supported in CDP yet.
        active: false,
        clientWindow: `${windowInfo.windowId}`,
        state: windowInfo.bounds.windowState ?? "normal",
        height: windowInfo.bounds.height ?? 0,
        width: windowInfo.bounds.width ?? 0,
        x: windowInfo.bounds.left ?? 0,
        y: windowInfo.bounds.top ?? 0
      };
    }, _a3);
    BrowserProcessor.BrowserProcessor = BrowserProcessor$1;
    return BrowserProcessor;
  }
  var CdpProcessor = {};
  var hasRequiredCdpProcessor;
  function requireCdpProcessor() {
    var _browsingContextStorage, _realmStorage, _cdpConnection, _browserCdpClient, _a3;
    if (hasRequiredCdpProcessor) return CdpProcessor;
    hasRequiredCdpProcessor = 1;
    Object.defineProperty(CdpProcessor, "__esModule", { value: true });
    CdpProcessor.CdpProcessor = void 0;
    const protocol_js_1 = requireProtocol();
    let CdpProcessor$1 = (_a3 = class {
      constructor(browsingContextStorage, realmStorage, cdpConnection, browserCdpClient) {
        __privateAdd(this, _browsingContextStorage);
        __privateAdd(this, _realmStorage);
        __privateAdd(this, _cdpConnection);
        __privateAdd(this, _browserCdpClient);
        __privateSet(this, _browsingContextStorage, browsingContextStorage);
        __privateSet(this, _realmStorage, realmStorage);
        __privateSet(this, _cdpConnection, cdpConnection);
        __privateSet(this, _browserCdpClient, browserCdpClient);
      }
      getSession(params) {
        const context = params.context;
        const sessionId = __privateGet(this, _browsingContextStorage).getContext(context).cdpTarget.cdpSessionId;
        if (sessionId === void 0) {
          return {};
        }
        return { session: sessionId };
      }
      resolveRealm(params) {
        const context = params.realm;
        const realm = __privateGet(this, _realmStorage).getRealm({ realmId: context });
        if (realm === void 0) {
          throw new protocol_js_1.UnknownErrorException(`Could not find realm ${params.realm}`);
        }
        return { executionContextId: realm.executionContextId };
      }
      async sendCommand(params) {
        const client2 = params.session ? __privateGet(this, _cdpConnection).getCdpClient(params.session) : __privateGet(this, _browserCdpClient);
        const result = await client2.sendCommand(params.method, params.params);
        return {
          result,
          session: params.session
        };
      }
    }, _browsingContextStorage = new WeakMap(), _realmStorage = new WeakMap(), _cdpConnection = new WeakMap(), _browserCdpClient = new WeakMap(), _a3);
    CdpProcessor.CdpProcessor = CdpProcessor$1;
    return CdpProcessor;
  }
  var BrowsingContextProcessor = {};
  var hasRequiredBrowsingContextProcessor;
  function requireBrowsingContextProcessor() {
    var _browserCdpClient, _browsingContextStorage, _eventManager, _BrowsingContextProcessor_instances, onContextCreatedSubscribeHook_fn, _a3;
    if (hasRequiredBrowsingContextProcessor) return BrowsingContextProcessor;
    hasRequiredBrowsingContextProcessor = 1;
    Object.defineProperty(BrowsingContextProcessor, "__esModule", { value: true });
    BrowsingContextProcessor.BrowsingContextProcessor = void 0;
    const protocol_js_1 = requireProtocol();
    let BrowsingContextProcessor$1 = (_a3 = class {
      constructor(browserCdpClient, browsingContextStorage, eventManager) {
        __privateAdd(this, _BrowsingContextProcessor_instances);
        __privateAdd(this, _browserCdpClient);
        __privateAdd(this, _browsingContextStorage);
        __privateAdd(this, _eventManager);
        __privateSet(this, _browserCdpClient, browserCdpClient);
        __privateSet(this, _browsingContextStorage, browsingContextStorage);
        __privateSet(this, _eventManager, eventManager);
        __privateGet(this, _eventManager).addSubscribeHook(protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.ContextCreated, __privateMethod(this, _BrowsingContextProcessor_instances, onContextCreatedSubscribeHook_fn).bind(this));
      }
      getTree(params) {
        const resultContexts = params.root === void 0 ? __privateGet(this, _browsingContextStorage).getTopLevelContexts() : [__privateGet(this, _browsingContextStorage).getContext(params.root)];
        return {
          contexts: resultContexts.map((c) => c.serializeToBidiValue(params.maxDepth ?? Number.MAX_VALUE))
        };
      }
      async create(params) {
        let referenceContext;
        let userContext = "default";
        if (params.referenceContext !== void 0) {
          referenceContext = __privateGet(this, _browsingContextStorage).getContext(params.referenceContext);
          if (!referenceContext.isTopLevelContext()) {
            throw new protocol_js_1.InvalidArgumentException(`referenceContext should be a top-level context`);
          }
          userContext = referenceContext.userContext;
        }
        if (params.userContext !== void 0) {
          userContext = params.userContext;
        }
        const existingContexts = __privateGet(this, _browsingContextStorage).getAllContexts().filter((context2) => context2.userContext === userContext);
        let newWindow = false;
        switch (params.type) {
          case "tab":
            newWindow = false;
            break;
          case "window":
            newWindow = true;
            break;
        }
        if (!existingContexts.length) {
          newWindow = true;
        }
        let result;
        try {
          result = await __privateGet(this, _browserCdpClient).sendCommand("Target.createTarget", {
            url: "about:blank",
            newWindow,
            browserContextId: userContext === "default" ? void 0 : userContext,
            background: params.background === true
          });
        } catch (err) {
          if (
            // See https://source.chromium.org/chromium/chromium/src/+/main:chrome/browser/devtools/protocol/target_handler.cc;l=90;drc=e80392ac11e48a691f4309964cab83a3a59e01c8
            err.message.startsWith("Failed to find browser context with id") || // See https://source.chromium.org/chromium/chromium/src/+/main:headless/lib/browser/protocol/target_handler.cc;l=49;drc=e80392ac11e48a691f4309964cab83a3a59e01c8
            err.message === "browserContextId"
          ) {
            throw new protocol_js_1.NoSuchUserContextException(`The context ${userContext} was not found`);
          }
          throw err;
        }
        const context = await __privateGet(this, _browsingContextStorage).waitForContext(result.targetId);
        await context.lifecycleLoaded();
        return { context: context.id };
      }
      navigate(params) {
        const context = __privateGet(this, _browsingContextStorage).getContext(params.context);
        return context.navigate(
          params.url,
          params.wait ?? "none"
          /* BrowsingContext.ReadinessState.None */
        );
      }
      reload(params) {
        const context = __privateGet(this, _browsingContextStorage).getContext(params.context);
        return context.reload(
          params.ignoreCache ?? false,
          params.wait ?? "none"
          /* BrowsingContext.ReadinessState.None */
        );
      }
      async activate(params) {
        const context = __privateGet(this, _browsingContextStorage).getContext(params.context);
        if (!context.isTopLevelContext()) {
          throw new protocol_js_1.InvalidArgumentException("Activation is only supported on the top-level context");
        }
        await context.activate();
        return {};
      }
      async captureScreenshot(params) {
        const context = __privateGet(this, _browsingContextStorage).getContext(params.context);
        return await context.captureScreenshot(params);
      }
      async print(params) {
        const context = __privateGet(this, _browsingContextStorage).getContext(params.context);
        return await context.print(params);
      }
      async setViewport(params) {
        const context = __privateGet(this, _browsingContextStorage).getContext(params.context);
        if (!context.isTopLevelContext()) {
          throw new protocol_js_1.InvalidArgumentException("Emulating viewport is only supported on the top-level context");
        }
        await context.setViewport(params.viewport, params.devicePixelRatio);
        return {};
      }
      async traverseHistory(params) {
        const context = __privateGet(this, _browsingContextStorage).getContext(params.context);
        if (!context) {
          throw new protocol_js_1.InvalidArgumentException(`No browsing context with id ${params.context}`);
        }
        if (!context.isTopLevelContext()) {
          throw new protocol_js_1.InvalidArgumentException("Traversing history is only supported on the top-level context");
        }
        await context.traverseHistory(params.delta);
        return {};
      }
      async handleUserPrompt(params) {
        var _a4;
        const context = __privateGet(this, _browsingContextStorage).getContext(params.context);
        try {
          await context.handleUserPrompt(params.accept, params.userText);
        } catch (error) {
          if ((_a4 = error.message) == null ? void 0 : _a4.includes("No dialog is showing")) {
            throw new protocol_js_1.NoSuchAlertException("No dialog is showing");
          }
          throw error;
        }
        return {};
      }
      async close(params) {
        const context = __privateGet(this, _browsingContextStorage).getContext(params.context);
        if (!context.isTopLevelContext()) {
          throw new protocol_js_1.InvalidArgumentException(`Non top-level browsing context ${context.id} cannot be closed.`);
        }
        const parentCdpClient = context.cdpTarget.parentCdpClient;
        try {
          const detachedFromTargetPromise = new Promise((resolve) => {
            const onContextDestroyed = (event) => {
              if (event.targetId === params.context) {
                parentCdpClient.off("Target.detachedFromTarget", onContextDestroyed);
                resolve();
              }
            };
            parentCdpClient.on("Target.detachedFromTarget", onContextDestroyed);
          });
          try {
            if (params.promptUnload) {
              await context.close();
            } else {
              await parentCdpClient.sendCommand("Target.closeTarget", {
                targetId: params.context
              });
            }
          } catch (error) {
            if (!parentCdpClient.isCloseError(error)) {
              throw error;
            }
          }
          await detachedFromTargetPromise;
        } catch (error) {
          if (!(error.code === -32e3 && error.message === "Not attached to an active page")) {
            throw error;
          }
        }
        return {};
      }
      async locateNodes(params) {
        const context = __privateGet(this, _browsingContextStorage).getContext(params.context);
        return await context.locateNodes(params);
      }
    }, _browserCdpClient = new WeakMap(), _browsingContextStorage = new WeakMap(), _eventManager = new WeakMap(), _BrowsingContextProcessor_instances = new WeakSet(), onContextCreatedSubscribeHook_fn = function(contextId) {
      const context = __privateGet(this, _browsingContextStorage).getContext(contextId);
      const contextsToReport = [
        context,
        ...__privateGet(this, _browsingContextStorage).getContext(contextId).allChildren
      ];
      contextsToReport.forEach((context2) => {
        __privateGet(this, _eventManager).registerEvent({
          type: "event",
          method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.ContextCreated,
          params: context2.serializeToBidiValue()
        }, context2.id);
      });
      return Promise.resolve();
    }, _a3);
    BrowsingContextProcessor.BrowsingContextProcessor = BrowsingContextProcessor$1;
    return BrowsingContextProcessor;
  }
  var InputProcessor = {};
  var assert = {};
  var hasRequiredAssert;
  function requireAssert() {
    if (hasRequiredAssert) return assert;
    hasRequiredAssert = 1;
    Object.defineProperty(assert, "__esModule", { value: true });
    assert.assert = assert$12;
    function assert$12(predicate, message) {
      if (!predicate) {
        throw new Error(message ?? "Internal assertion failed.");
      }
    }
    return assert;
  }
  var ActionDispatcher = {};
  var GraphemeTools = {};
  var hasRequiredGraphemeTools;
  function requireGraphemeTools() {
    if (hasRequiredGraphemeTools) return GraphemeTools;
    hasRequiredGraphemeTools = 1;
    Object.defineProperty(GraphemeTools, "__esModule", { value: true });
    GraphemeTools.isSingleComplexGrapheme = isSingleComplexGrapheme;
    GraphemeTools.isSingleGrapheme = isSingleGrapheme;
    function isSingleComplexGrapheme(value) {
      return isSingleGrapheme(value) && value.length > 1;
    }
    function isSingleGrapheme(value) {
      const segmenter = new Intl.Segmenter("en", { granularity: "grapheme" });
      return [...segmenter.segment(value)].length === 1;
    }
    return GraphemeTools;
  }
  var InputSource = {};
  var hasRequiredInputSource;
  function requireInputSource() {
    var _modifiers, _KeySource_instances, setModifier_fn, _a3, _DOUBLE_CLICK_TIME_MS, _MAX_DOUBLE_CLICK_RADIUS, _x2, _y2, _time, _clickContexts;
    if (hasRequiredInputSource) return InputSource;
    hasRequiredInputSource = 1;
    Object.defineProperty(InputSource, "__esModule", { value: true });
    InputSource.WheelSource = InputSource.PointerSource = InputSource.KeySource = InputSource.NoneSource = void 0;
    class NoneSource {
      constructor() {
        __publicField(this, "type", "none");
      }
    }
    InputSource.NoneSource = NoneSource;
    class KeySource {
      constructor() {
        __privateAdd(this, _KeySource_instances);
        __publicField(this, "type", "key");
        __publicField(this, "pressed", /* @__PURE__ */ new Set());
        // This is a bitfield that matches the modifiers parameter of
        // https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-dispatchKeyEvent
        __privateAdd(this, _modifiers, 0);
      }
      get modifiers() {
        return __privateGet(this, _modifiers);
      }
      get alt() {
        return (__privateGet(this, _modifiers) & 1) === 1;
      }
      set alt(value) {
        __privateMethod(this, _KeySource_instances, setModifier_fn).call(this, value, 1);
      }
      get ctrl() {
        return (__privateGet(this, _modifiers) & 2) === 2;
      }
      set ctrl(value) {
        __privateMethod(this, _KeySource_instances, setModifier_fn).call(this, value, 2);
      }
      get meta() {
        return (__privateGet(this, _modifiers) & 4) === 4;
      }
      set meta(value) {
        __privateMethod(this, _KeySource_instances, setModifier_fn).call(this, value, 4);
      }
      get shift() {
        return (__privateGet(this, _modifiers) & 8) === 8;
      }
      set shift(value) {
        __privateMethod(this, _KeySource_instances, setModifier_fn).call(this, value, 8);
      }
    }
    _modifiers = new WeakMap();
    _KeySource_instances = new WeakSet();
    setModifier_fn = function(value, bit) {
      if (value) {
        __privateSet(this, _modifiers, __privateGet(this, _modifiers) | bit);
      } else {
        __privateSet(this, _modifiers, __privateGet(this, _modifiers) & ~bit);
      }
    };
    InputSource.KeySource = KeySource;
    class PointerSource {
      constructor(id, subtype) {
        __publicField(this, "type", "pointer");
        __publicField(this, "subtype");
        __publicField(this, "pointerId");
        __publicField(this, "pressed", /* @__PURE__ */ new Set());
        __publicField(this, "x", 0);
        __publicField(this, "y", 0);
        __publicField(this, "radiusX");
        __publicField(this, "radiusY");
        __publicField(this, "force");
        __privateAdd(this, _clickContexts, /* @__PURE__ */ new Map());
        this.pointerId = id;
        this.subtype = subtype;
      }
      // This is a bitfield that matches the buttons parameter of
      // https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-dispatchMouseEvent
      get buttons() {
        let buttons = 0;
        for (const button of this.pressed) {
          switch (button) {
            case 0:
              buttons |= 1;
              break;
            case 1:
              buttons |= 4;
              break;
            case 2:
              buttons |= 2;
              break;
            case 3:
              buttons |= 8;
              break;
            case 4:
              buttons |= 16;
              break;
          }
        }
        return buttons;
      }
      setClickCount(button, context) {
        let storedContext = __privateGet(this, _clickContexts).get(button);
        if (!storedContext || storedContext.compare(context)) {
          storedContext = context;
        }
        ++storedContext.count;
        __privateGet(this, _clickContexts).set(button, storedContext);
        return storedContext.count;
      }
      getClickCount(button) {
        var _a4;
        return ((_a4 = __privateGet(this, _clickContexts).get(button)) == null ? void 0 : _a4.count) ?? 0;
      }
    }
    _clickContexts = new WeakMap();
    // --- Platform-specific code starts here ---
    // Input.dispatchMouseEvent doesn't know the concept of double click, so we
    // need to create the logic, similar to how it's done for OSes:
    // https://source.chromium.org/chromium/chromium/src/+/refs/heads/main:ui/events/event.cc;l=479
    __publicField(PointerSource, "ClickContext", (_a3 = class {
      constructor(x, y, time2) {
        __publicField(this, "count", 0);
        __privateAdd(this, _x2);
        __privateAdd(this, _y2);
        __privateAdd(this, _time);
        __privateSet(this, _x2, x);
        __privateSet(this, _y2, y);
        __privateSet(this, _time, time2);
      }
      compare(context) {
        return (
          // The click needs to be within a certain amount of ms.
          __privateGet(context, _time) - __privateGet(this, _time) > __privateGet(_a3, _DOUBLE_CLICK_TIME_MS) || // The click needs to be within a certain square radius.
          Math.abs(__privateGet(context, _x2) - __privateGet(this, _x2)) > __privateGet(_a3, _MAX_DOUBLE_CLICK_RADIUS) || Math.abs(__privateGet(context, _y2) - __privateGet(this, _y2)) > __privateGet(_a3, _MAX_DOUBLE_CLICK_RADIUS)
        );
      }
    }, _DOUBLE_CLICK_TIME_MS = new WeakMap(), _MAX_DOUBLE_CLICK_RADIUS = new WeakMap(), _x2 = new WeakMap(), _y2 = new WeakMap(), _time = new WeakMap(), __privateAdd(_a3, _DOUBLE_CLICK_TIME_MS, 500), __privateAdd(_a3, _MAX_DOUBLE_CLICK_RADIUS, 2), _a3));
    InputSource.PointerSource = PointerSource;
    class WheelSource {
      constructor() {
        __publicField(this, "type", "wheel");
      }
    }
    InputSource.WheelSource = WheelSource;
    return InputSource;
  }
  var keyUtils = {};
  var hasRequiredKeyUtils;
  function requireKeyUtils() {
    if (hasRequiredKeyUtils) return keyUtils;
    hasRequiredKeyUtils = 1;
    Object.defineProperty(keyUtils, "__esModule", { value: true });
    keyUtils.getNormalizedKey = getNormalizedKey;
    keyUtils.getKeyCode = getKeyCode;
    keyUtils.getKeyLocation = getKeyLocation;
    function getNormalizedKey(value) {
      switch (value) {
        case "":
          return "Unidentified";
        case "":
          return "Cancel";
        case "":
          return "Help";
        case "":
          return "Backspace";
        case "":
          return "Tab";
        case "":
          return "Clear";
        // Specification declares the '\uE006' to be `Return`, but it is not supported by
        // Chrome, so fall back to `Enter`, which aligns with WPT.
        case "":
        case "":
          return "Enter";
        case "":
          return "Shift";
        case "":
          return "Control";
        case "":
          return "Alt";
        case "":
          return "Pause";
        case "":
          return "Escape";
        case "":
          return " ";
        case "":
          return "PageUp";
        case "":
          return "PageDown";
        case "":
          return "End";
        case "":
          return "Home";
        case "":
          return "ArrowLeft";
        case "":
          return "ArrowUp";
        case "":
          return "ArrowRight";
        case "":
          return "ArrowDown";
        case "":
          return "Insert";
        case "":
          return "Delete";
        case "":
          return ";";
        case "":
          return "=";
        case "":
          return "0";
        case "":
          return "1";
        case "":
          return "2";
        case "":
          return "3";
        case "":
          return "4";
        case "":
          return "5";
        case "":
          return "6";
        case "":
          return "7";
        case "":
          return "8";
        case "":
          return "9";
        case "":
          return "*";
        case "":
          return "+";
        case "":
          return ",";
        case "":
          return "-";
        case "":
          return ".";
        case "":
          return "/";
        case "":
          return "F1";
        case "":
          return "F2";
        case "":
          return "F3";
        case "":
          return "F4";
        case "":
          return "F5";
        case "":
          return "F6";
        case "":
          return "F7";
        case "":
          return "F8";
        case "":
          return "F9";
        case "":
          return "F10";
        case "":
          return "F11";
        case "":
          return "F12";
        case "":
          return "Meta";
        case "":
          return "ZenkakuHankaku";
        case "":
          return "Shift";
        case "":
          return "Control";
        case "":
          return "Alt";
        case "":
          return "Meta";
        case "":
          return "PageUp";
        case "":
          return "PageDown";
        case "":
          return "End";
        case "":
          return "Home";
        case "":
          return "ArrowLeft";
        case "":
          return "ArrowUp";
        case "":
          return "ArrowRight";
        case "":
          return "ArrowDown";
        case "":
          return "Insert";
        case "":
          return "Delete";
        default:
          return value;
      }
    }
    function getKeyCode(key) {
      switch (key) {
        case "`":
        case "~":
          return "Backquote";
        case "\\":
        case "|":
          return "Backslash";
        case "":
          return "Backspace";
        case "[":
        case "{":
          return "BracketLeft";
        case "]":
        case "}":
          return "BracketRight";
        case ",":
        case "<":
          return "Comma";
        case "0":
        case ")":
          return "Digit0";
        case "1":
        case "!":
          return "Digit1";
        case "2":
        case "@":
          return "Digit2";
        case "3":
        case "#":
          return "Digit3";
        case "4":
        case "$":
          return "Digit4";
        case "5":
        case "%":
          return "Digit5";
        case "6":
        case "^":
          return "Digit6";
        case "7":
        case "&":
          return "Digit7";
        case "8":
        case "*":
          return "Digit8";
        case "9":
        case "(":
          return "Digit9";
        case "=":
        case "+":
          return "Equal";
        // The spec declares the '<' to be `IntlBackslash` as well, but it is already covered
        // in the `Comma` above.
        case ">":
          return "IntlBackslash";
        case "a":
        case "A":
          return "KeyA";
        case "b":
        case "B":
          return "KeyB";
        case "c":
        case "C":
          return "KeyC";
        case "d":
        case "D":
          return "KeyD";
        case "e":
        case "E":
          return "KeyE";
        case "f":
        case "F":
          return "KeyF";
        case "g":
        case "G":
          return "KeyG";
        case "h":
        case "H":
          return "KeyH";
        case "i":
        case "I":
          return "KeyI";
        case "j":
        case "J":
          return "KeyJ";
        case "k":
        case "K":
          return "KeyK";
        case "l":
        case "L":
          return "KeyL";
        case "m":
        case "M":
          return "KeyM";
        case "n":
        case "N":
          return "KeyN";
        case "o":
        case "O":
          return "KeyO";
        case "p":
        case "P":
          return "KeyP";
        case "q":
        case "Q":
          return "KeyQ";
        case "r":
        case "R":
          return "KeyR";
        case "s":
        case "S":
          return "KeyS";
        case "t":
        case "T":
          return "KeyT";
        case "u":
        case "U":
          return "KeyU";
        case "v":
        case "V":
          return "KeyV";
        case "w":
        case "W":
          return "KeyW";
        case "x":
        case "X":
          return "KeyX";
        case "y":
        case "Y":
          return "KeyY";
        case "z":
        case "Z":
          return "KeyZ";
        case "-":
        case "_":
          return "Minus";
        case ".":
          return "Period";
        case "'":
        case '"':
          return "Quote";
        case ";":
        case ":":
          return "Semicolon";
        case "/":
        case "?":
          return "Slash";
        case "":
          return "AltLeft";
        case "":
          return "AltRight";
        case "":
          return "ControlLeft";
        case "":
          return "ControlRight";
        case "":
          return "Enter";
        case "":
          return "Pause";
        case "":
          return "MetaLeft";
        case "":
          return "MetaRight";
        case "":
          return "ShiftLeft";
        case "":
          return "ShiftRight";
        case " ":
        case "":
          return "Space";
        case "":
          return "Tab";
        case "":
          return "Delete";
        case "":
          return "End";
        case "":
          return "Help";
        case "":
          return "Home";
        case "":
          return "Insert";
        case "":
          return "PageDown";
        case "":
          return "PageUp";
        case "":
          return "ArrowDown";
        case "":
          return "ArrowLeft";
        case "":
          return "ArrowRight";
        case "":
          return "ArrowUp";
        case "":
          return "Escape";
        case "":
          return "F1";
        case "":
          return "F2";
        case "":
          return "F3";
        case "":
          return "F4";
        case "":
          return "F5";
        case "":
          return "F6";
        case "":
          return "F7";
        case "":
          return "F8";
        case "":
          return "F9";
        case "":
          return "F10";
        case "":
          return "F11";
        case "":
          return "F12";
        case "":
          return "NumpadEqual";
        case "":
        case "":
          return "Numpad0";
        case "":
        case "":
          return "Numpad1";
        case "":
        case "":
          return "Numpad2";
        case "":
        case "":
          return "Numpad3";
        case "":
        case "":
          return "Numpad4";
        case "":
          return "Numpad5";
        case "":
        case "":
          return "Numpad6";
        case "":
        case "":
          return "Numpad7";
        case "":
        case "":
          return "Numpad8";
        case "":
        case "":
          return "Numpad9";
        case "":
          return "NumpadAdd";
        case "":
          return "NumpadComma";
        case "":
        case "":
          return "NumpadDecimal";
        case "":
          return "NumpadDivide";
        case "":
          return "NumpadEnter";
        case "":
          return "NumpadMultiply";
        case "":
          return "NumpadSubtract";
        default:
          return;
      }
    }
    function getKeyLocation(key) {
      switch (key) {
        case "":
        case "":
        case "":
        case "":
        case "":
          return 1;
        case "":
        case "":
        case "":
        case "":
        case "":
        case "":
        case "":
        case "":
        case "":
        case "":
        case "":
        case "":
        case "":
        case "":
        case "":
        case "":
        case "":
        case "":
        case "":
        case "":
        case "":
        case "":
        case "":
        case "":
        case "":
        case "":
        case "":
          return 3;
        case "":
        case "":
        case "":
        case "":
          return 2;
        default:
          return 0;
      }
    }
    return keyUtils;
  }
  var USKeyboardLayout = {};
  var hasRequiredUSKeyboardLayout;
  function requireUSKeyboardLayout() {
    if (hasRequiredUSKeyboardLayout) return USKeyboardLayout;
    hasRequiredUSKeyboardLayout = 1;
    Object.defineProperty(USKeyboardLayout, "__esModule", { value: true });
    USKeyboardLayout.KeyToKeyCode = void 0;
    USKeyboardLayout.KeyToKeyCode = {
      "0": 48,
      "1": 49,
      "2": 50,
      "3": 51,
      "4": 52,
      "5": 53,
      "6": 54,
      "7": 55,
      "8": 56,
      "9": 57,
      Abort: 3,
      Help: 6,
      Backspace: 8,
      Tab: 9,
      Numpad5: 12,
      NumpadEnter: 13,
      Enter: 13,
      "\\r": 13,
      "\\n": 13,
      ShiftLeft: 16,
      ShiftRight: 16,
      ControlLeft: 17,
      ControlRight: 17,
      AltLeft: 18,
      AltRight: 18,
      Pause: 19,
      CapsLock: 20,
      Escape: 27,
      Convert: 28,
      NonConvert: 29,
      Space: 32,
      Numpad9: 33,
      PageUp: 33,
      Numpad3: 34,
      PageDown: 34,
      End: 35,
      Numpad1: 35,
      Home: 36,
      Numpad7: 36,
      ArrowLeft: 37,
      Numpad4: 37,
      Numpad8: 38,
      ArrowUp: 38,
      ArrowRight: 39,
      Numpad6: 39,
      Numpad2: 40,
      ArrowDown: 40,
      Select: 41,
      Open: 43,
      PrintScreen: 44,
      Insert: 45,
      Numpad0: 45,
      Delete: 46,
      NumpadDecimal: 46,
      Digit0: 48,
      Digit1: 49,
      Digit2: 50,
      Digit3: 51,
      Digit4: 52,
      Digit5: 53,
      Digit6: 54,
      Digit7: 55,
      Digit8: 56,
      Digit9: 57,
      KeyA: 65,
      KeyB: 66,
      KeyC: 67,
      KeyD: 68,
      KeyE: 69,
      KeyF: 70,
      KeyG: 71,
      KeyH: 72,
      KeyI: 73,
      KeyJ: 74,
      KeyK: 75,
      KeyL: 76,
      KeyM: 77,
      KeyN: 78,
      KeyO: 79,
      KeyP: 80,
      KeyQ: 81,
      KeyR: 82,
      KeyS: 83,
      KeyT: 84,
      KeyU: 85,
      KeyV: 86,
      KeyW: 87,
      KeyX: 88,
      KeyY: 89,
      KeyZ: 90,
      MetaLeft: 91,
      MetaRight: 92,
      ContextMenu: 93,
      NumpadMultiply: 106,
      NumpadAdd: 107,
      NumpadSubtract: 109,
      NumpadDivide: 111,
      F1: 112,
      F2: 113,
      F3: 114,
      F4: 115,
      F5: 116,
      F6: 117,
      F7: 118,
      F8: 119,
      F9: 120,
      F10: 121,
      F11: 122,
      F12: 123,
      F13: 124,
      F14: 125,
      F15: 126,
      F16: 127,
      F17: 128,
      F18: 129,
      F19: 130,
      F20: 131,
      F21: 132,
      F22: 133,
      F23: 134,
      F24: 135,
      NumLock: 144,
      ScrollLock: 145,
      AudioVolumeMute: 173,
      AudioVolumeDown: 174,
      AudioVolumeUp: 175,
      MediaTrackNext: 176,
      MediaTrackPrevious: 177,
      MediaStop: 178,
      MediaPlayPause: 179,
      Semicolon: 186,
      Equal: 187,
      NumpadEqual: 187,
      Comma: 188,
      Minus: 189,
      Period: 190,
      Slash: 191,
      Backquote: 192,
      BracketLeft: 219,
      Backslash: 220,
      BracketRight: 221,
      Quote: 222,
      AltGraph: 225,
      Props: 247,
      Cancel: 3,
      Clear: 12,
      Shift: 16,
      Control: 17,
      Alt: 18,
      Accept: 30,
      ModeChange: 31,
      " ": 32,
      Print: 42,
      Execute: 43,
      "\\u0000": 46,
      a: 65,
      b: 66,
      c: 67,
      d: 68,
      e: 69,
      f: 70,
      g: 71,
      h: 72,
      i: 73,
      j: 74,
      k: 75,
      l: 76,
      m: 77,
      n: 78,
      o: 79,
      p: 80,
      q: 81,
      r: 82,
      s: 83,
      t: 84,
      u: 85,
      v: 86,
      w: 87,
      x: 88,
      y: 89,
      z: 90,
      Meta: 91,
      "*": 106,
      "+": 107,
      "-": 109,
      "/": 111,
      ";": 186,
      "=": 187,
      ",": 188,
      ".": 190,
      "`": 192,
      "[": 219,
      "\\\\": 220,
      "]": 221,
      "'": 222,
      Attn: 246,
      CrSel: 247,
      ExSel: 248,
      EraseEof: 249,
      Play: 250,
      ZoomOut: 251,
      ")": 48,
      "!": 49,
      "@": 50,
      "#": 51,
      $: 52,
      "%": 53,
      "^": 54,
      "&": 55,
      "(": 57,
      A: 65,
      B: 66,
      C: 67,
      D: 68,
      E: 69,
      F: 70,
      G: 71,
      H: 72,
      I: 73,
      J: 74,
      K: 75,
      L: 76,
      M: 77,
      N: 78,
      O: 79,
      P: 80,
      Q: 81,
      R: 82,
      S: 83,
      T: 84,
      U: 85,
      V: 86,
      W: 87,
      X: 88,
      Y: 89,
      Z: 90,
      ":": 186,
      "<": 188,
      _: 189,
      ">": 190,
      "?": 191,
      "~": 192,
      "{": 219,
      "|": 220,
      "}": 221,
      '"': 222,
      Camera: 44,
      EndCall: 95,
      VolumeDown: 182,
      VolumeUp: 183
    };
    return USKeyboardLayout;
  }
  var hasRequiredActionDispatcher;
  function requireActionDispatcher() {
    var _a3, _browsingContextStorage, _tickStart, _tickDuration, _inputState, _contextId, _isMacOS, _ActionDispatcher_instances, context_get, dispatchAction_fn, dispatchPointerDownAction_fn, dispatchPointerUpAction_fn, dispatchPointerMoveAction_fn, getFrameOffset_fn, getCoordinateFromOrigin_fn, dispatchScrollAction_fn, dispatchKeyDownAction_fn, dispatchKeyUpAction_fn;
    if (hasRequiredActionDispatcher) return ActionDispatcher;
    hasRequiredActionDispatcher = 1;
    Object.defineProperty(ActionDispatcher, "__esModule", { value: true });
    ActionDispatcher.ActionDispatcher = void 0;
    const protocol_js_1 = requireProtocol();
    const assert_js_1 = requireAssert();
    const GraphemeTools_js_1 = requireGraphemeTools();
    const InputSource_js_1 = requireInputSource();
    const keyUtils_js_1 = requireKeyUtils();
    const USKeyboardLayout_js_1 = requireUSKeyboardLayout();
    const CALCULATE_IN_VIEW_CENTER_PT_DECL = ((i2) => {
      const t = i2.getClientRects()[0], e = Math.max(0, Math.min(t.x, t.x + t.width)), n = Math.min(window.innerWidth, Math.max(t.x, t.x + t.width)), h = Math.max(0, Math.min(t.y, t.y + t.height)), m = Math.min(window.innerHeight, Math.max(t.y, t.y + t.height));
      return [e + (n - e >> 1), h + (m - h >> 1)];
    }).toString();
    const IS_MAC_DECL = (() => {
      return navigator.platform.toLowerCase().includes("mac");
    }).toString();
    async function getElementCenter(context, element) {
      var _a4, _b2, _c2, _d2;
      const sandbox = await context.getOrCreateSandbox(void 0);
      const result = await sandbox.callFunction(CALCULATE_IN_VIEW_CENTER_PT_DECL, false, { type: "undefined" }, [element]);
      if (result.type === "exception") {
        throw new protocol_js_1.NoSuchElementException(`Origin element ${element.sharedId} was not found`);
      }
      (0, assert_js_1.assert)(result.result.type === "array");
      (0, assert_js_1.assert)(((_b2 = (_a4 = result.result.value) == null ? void 0 : _a4[0]) == null ? void 0 : _b2.type) === "number");
      (0, assert_js_1.assert)(((_d2 = (_c2 = result.result.value) == null ? void 0 : _c2[1]) == null ? void 0 : _d2.type) === "number");
      const { result: { value: [{ value: x }, { value: y }] } } = result;
      return { x, y };
    }
    let ActionDispatcher$1 = (_a3 = class {
      constructor(inputState, browsingContextStorage, contextId, isMacOS) {
        __privateAdd(this, _ActionDispatcher_instances);
        __privateAdd(this, _browsingContextStorage);
        __privateAdd(this, _tickStart, 0);
        __privateAdd(this, _tickDuration, 0);
        __privateAdd(this, _inputState);
        __privateAdd(this, _contextId);
        __privateAdd(this, _isMacOS);
        __privateSet(this, _browsingContextStorage, browsingContextStorage);
        __privateSet(this, _inputState, inputState);
        __privateSet(this, _contextId, contextId);
        __privateSet(this, _isMacOS, isMacOS);
      }
      async dispatchActions(optionsByTick) {
        await __privateGet(this, _inputState).queue.run(async () => {
          for (const options of optionsByTick) {
            await this.dispatchTickActions(options);
          }
        });
      }
      async dispatchTickActions(options) {
        __privateSet(this, _tickStart, performance.now());
        __privateSet(this, _tickDuration, 0);
        for (const { action } of options) {
          if ("duration" in action && action.duration !== void 0) {
            __privateSet(this, _tickDuration, Math.max(__privateGet(this, _tickDuration), action.duration));
          }
        }
        const promises = [
          new Promise((resolve) => setTimeout(resolve, __privateGet(this, _tickDuration)))
        ];
        for (const option of options) {
          promises.push(__privateMethod(this, _ActionDispatcher_instances, dispatchAction_fn).call(this, option));
        }
        await Promise.all(promises);
      }
    }, _browsingContextStorage = new WeakMap(), _tickStart = new WeakMap(), _tickDuration = new WeakMap(), _inputState = new WeakMap(), _contextId = new WeakMap(), _isMacOS = new WeakMap(), _ActionDispatcher_instances = new WeakSet(), context_get = function() {
      return __privateGet(this, _browsingContextStorage).getContext(__privateGet(this, _contextId));
    }, dispatchAction_fn = async function({ id, action }) {
      const source2 = __privateGet(this, _inputState).get(id);
      const keyState = __privateGet(this, _inputState).getGlobalKeyState();
      switch (action.type) {
        case "keyDown": {
          await __privateMethod(this, _ActionDispatcher_instances, dispatchKeyDownAction_fn).call(this, source2, action);
          __privateGet(this, _inputState).cancelList.push({
            id,
            action: {
              ...action,
              type: "keyUp"
            }
          });
          break;
        }
        case "keyUp": {
          await __privateMethod(this, _ActionDispatcher_instances, dispatchKeyUpAction_fn).call(this, source2, action);
          break;
        }
        case "pause": {
          break;
        }
        case "pointerDown": {
          await __privateMethod(this, _ActionDispatcher_instances, dispatchPointerDownAction_fn).call(this, source2, keyState, action);
          __privateGet(this, _inputState).cancelList.push({
            id,
            action: {
              ...action,
              type: "pointerUp"
            }
          });
          break;
        }
        case "pointerMove": {
          await __privateMethod(this, _ActionDispatcher_instances, dispatchPointerMoveAction_fn).call(this, source2, keyState, action);
          break;
        }
        case "pointerUp": {
          await __privateMethod(this, _ActionDispatcher_instances, dispatchPointerUpAction_fn).call(this, source2, keyState, action);
          break;
        }
        case "scroll": {
          await __privateMethod(this, _ActionDispatcher_instances, dispatchScrollAction_fn).call(this, source2, keyState, action);
          break;
        }
      }
    }, dispatchPointerDownAction_fn = async function(source2, keyState, action) {
      const { button } = action;
      if (source2.pressed.has(button)) {
        return;
      }
      source2.pressed.add(button);
      const { x, y, subtype: pointerType } = source2;
      const { width, height, pressure, twist, tangentialPressure } = action;
      const { tiltX, tiltY } = getTilt(action);
      const { modifiers } = keyState;
      const { radiusX, radiusY } = getRadii(width ?? 1, height ?? 1);
      switch (pointerType) {
        case "mouse":
        case "pen":
          await __privateGet(this, _ActionDispatcher_instances, context_get).cdpTarget.cdpClient.sendCommand("Input.dispatchMouseEvent", {
            type: "mousePressed",
            x,
            y,
            modifiers,
            button: getCdpButton(button),
            buttons: source2.buttons,
            clickCount: source2.setClickCount(button, new InputSource_js_1.PointerSource.ClickContext(x, y, performance.now())),
            pointerType,
            tangentialPressure,
            tiltX,
            tiltY,
            twist,
            force: pressure
          });
          break;
        case "touch":
          await __privateGet(this, _ActionDispatcher_instances, context_get).cdpTarget.cdpClient.sendCommand("Input.dispatchTouchEvent", {
            type: "touchStart",
            touchPoints: [
              {
                x,
                y,
                radiusX,
                radiusY,
                tangentialPressure,
                tiltX,
                tiltY,
                twist,
                force: pressure,
                id: source2.pointerId
              }
            ],
            modifiers
          });
          break;
      }
      source2.radiusX = radiusX;
      source2.radiusY = radiusY;
      source2.force = pressure;
    }, dispatchPointerUpAction_fn = function(source2, keyState, action) {
      const { button } = action;
      if (!source2.pressed.has(button)) {
        return;
      }
      source2.pressed.delete(button);
      const { x, y, force, radiusX, radiusY, subtype: pointerType } = source2;
      const { modifiers } = keyState;
      switch (pointerType) {
        case "mouse":
        case "pen":
          return __privateGet(this, _ActionDispatcher_instances, context_get).cdpTarget.cdpClient.sendCommand("Input.dispatchMouseEvent", {
            type: "mouseReleased",
            x,
            y,
            modifiers,
            button: getCdpButton(button),
            buttons: source2.buttons,
            clickCount: source2.getClickCount(button),
            pointerType
          });
        case "touch":
          return __privateGet(this, _ActionDispatcher_instances, context_get).cdpTarget.cdpClient.sendCommand("Input.dispatchTouchEvent", {
            type: "touchEnd",
            touchPoints: [
              {
                x,
                y,
                id: source2.pointerId,
                force,
                radiusX,
                radiusY
              }
            ],
            modifiers
          });
      }
    }, dispatchPointerMoveAction_fn = async function(source2, keyState, action) {
      const { x: startX, y: startY, subtype: pointerType } = source2;
      const { width, height, pressure, twist, tangentialPressure, x: offsetX, y: offsetY, origin = "viewport", duration = __privateGet(this, _tickDuration) } = action;
      const { tiltX, tiltY } = getTilt(action);
      const { radiusX, radiusY } = getRadii(width ?? 1, height ?? 1);
      const { targetX, targetY } = await __privateMethod(this, _ActionDispatcher_instances, getCoordinateFromOrigin_fn).call(this, origin, offsetX, offsetY, startX, startY);
      if (targetX < 0 || targetY < 0) {
        throw new protocol_js_1.MoveTargetOutOfBoundsException(`Cannot move beyond viewport (x: ${targetX}, y: ${targetY})`);
      }
      let last2;
      do {
        const ratio = duration > 0 ? (performance.now() - __privateGet(this, _tickStart)) / duration : 1;
        last2 = ratio >= 1;
        let x;
        let y;
        if (last2) {
          x = targetX;
          y = targetY;
        } else {
          x = Math.round(ratio * (targetX - startX) + startX);
          y = Math.round(ratio * (targetY - startY) + startY);
        }
        if (source2.x !== x || source2.y !== y) {
          const { modifiers } = keyState;
          switch (pointerType) {
            case "mouse":
              await __privateGet(this, _ActionDispatcher_instances, context_get).cdpTarget.cdpClient.sendCommand("Input.dispatchMouseEvent", {
                type: "mouseMoved",
                x,
                y,
                modifiers,
                clickCount: 0,
                button: getCdpButton(source2.pressed.values().next().value ?? 5),
                buttons: source2.buttons,
                pointerType,
                tangentialPressure,
                tiltX,
                tiltY,
                twist,
                force: pressure
              });
              break;
            case "pen":
              if (source2.pressed.size !== 0) {
                await __privateGet(this, _ActionDispatcher_instances, context_get).cdpTarget.cdpClient.sendCommand("Input.dispatchMouseEvent", {
                  type: "mouseMoved",
                  x,
                  y,
                  modifiers,
                  clickCount: 0,
                  button: getCdpButton(source2.pressed.values().next().value ?? 5),
                  buttons: source2.buttons,
                  pointerType,
                  tangentialPressure,
                  tiltX,
                  tiltY,
                  twist,
                  force: pressure ?? 0.5
                });
              }
              break;
            case "touch":
              if (source2.pressed.size !== 0) {
                await __privateGet(this, _ActionDispatcher_instances, context_get).cdpTarget.cdpClient.sendCommand("Input.dispatchTouchEvent", {
                  type: "touchMove",
                  touchPoints: [
                    {
                      x,
                      y,
                      radiusX,
                      radiusY,
                      tangentialPressure,
                      tiltX,
                      tiltY,
                      twist,
                      force: pressure,
                      id: source2.pointerId
                    }
                  ],
                  modifiers
                });
              }
              break;
          }
          source2.x = x;
          source2.y = y;
          source2.radiusX = radiusX;
          source2.radiusY = radiusY;
          source2.force = pressure;
        }
      } while (!last2);
    }, getFrameOffset_fn = async function() {
      if (__privateGet(this, _ActionDispatcher_instances, context_get).id === __privateGet(this, _ActionDispatcher_instances, context_get).cdpTarget.id) {
        return { x: 0, y: 0 };
      }
      const { backendNodeId } = await __privateGet(this, _ActionDispatcher_instances, context_get).cdpTarget.cdpClient.sendCommand("DOM.getFrameOwner", { frameId: __privateGet(this, _ActionDispatcher_instances, context_get).id });
      const { model: frameBoxModel } = await __privateGet(this, _ActionDispatcher_instances, context_get).cdpTarget.cdpClient.sendCommand("DOM.getBoxModel", {
        backendNodeId
      });
      return { x: frameBoxModel.content[0], y: frameBoxModel.content[1] };
    }, getCoordinateFromOrigin_fn = async function(origin, offsetX, offsetY, startX, startY) {
      let targetX;
      let targetY;
      const frameOffset = await __privateMethod(this, _ActionDispatcher_instances, getFrameOffset_fn).call(this);
      switch (origin) {
        case "viewport":
          targetX = offsetX + frameOffset.x;
          targetY = offsetY + frameOffset.y;
          break;
        case "pointer":
          targetX = startX + offsetX + frameOffset.x;
          targetY = startY + offsetY + frameOffset.y;
          break;
        default: {
          const { x: posX, y: posY } = await getElementCenter(__privateGet(this, _ActionDispatcher_instances, context_get), origin.element);
          targetX = posX + offsetX + frameOffset.x;
          targetY = posY + offsetY + frameOffset.y;
          break;
        }
      }
      return { targetX, targetY };
    }, dispatchScrollAction_fn = async function(_source2, keyState, action) {
      const { deltaX: targetDeltaX, deltaY: targetDeltaY, x: offsetX, y: offsetY, origin = "viewport", duration = __privateGet(this, _tickDuration) } = action;
      if (origin === "pointer") {
        throw new protocol_js_1.InvalidArgumentException('"pointer" origin is invalid for scrolling.');
      }
      const { targetX, targetY } = await __privateMethod(this, _ActionDispatcher_instances, getCoordinateFromOrigin_fn).call(this, origin, offsetX, offsetY, 0, 0);
      if (targetX < 0 || targetY < 0) {
        throw new protocol_js_1.MoveTargetOutOfBoundsException(`Cannot move beyond viewport (x: ${targetX}, y: ${targetY})`);
      }
      let currentDeltaX = 0;
      let currentDeltaY = 0;
      let last2;
      do {
        const ratio = duration > 0 ? (performance.now() - __privateGet(this, _tickStart)) / duration : 1;
        last2 = ratio >= 1;
        let deltaX;
        let deltaY;
        if (last2) {
          deltaX = targetDeltaX - currentDeltaX;
          deltaY = targetDeltaY - currentDeltaY;
        } else {
          deltaX = Math.round(ratio * targetDeltaX - currentDeltaX);
          deltaY = Math.round(ratio * targetDeltaY - currentDeltaY);
        }
        if (deltaX !== 0 || deltaY !== 0) {
          const { modifiers } = keyState;
          await __privateGet(this, _ActionDispatcher_instances, context_get).cdpTarget.cdpClient.sendCommand("Input.dispatchMouseEvent", {
            type: "mouseWheel",
            deltaX,
            deltaY,
            x: targetX,
            y: targetY,
            modifiers
          });
          currentDeltaX += deltaX;
          currentDeltaY += deltaY;
        }
      } while (!last2);
    }, dispatchKeyDownAction_fn = async function(source2, action) {
      const rawKey = action.value;
      if (!(0, GraphemeTools_js_1.isSingleGrapheme)(rawKey)) {
        throw new protocol_js_1.InvalidArgumentException(`Invalid key value: ${rawKey}`);
      }
      const isGrapheme = (0, GraphemeTools_js_1.isSingleComplexGrapheme)(rawKey);
      const key = (0, keyUtils_js_1.getNormalizedKey)(rawKey);
      const repeat = source2.pressed.has(key);
      const code = (0, keyUtils_js_1.getKeyCode)(rawKey);
      const location = (0, keyUtils_js_1.getKeyLocation)(rawKey);
      switch (key) {
        case "Alt":
          source2.alt = true;
          break;
        case "Shift":
          source2.shift = true;
          break;
        case "Control":
          source2.ctrl = true;
          break;
        case "Meta":
          source2.meta = true;
          break;
      }
      source2.pressed.add(key);
      const { modifiers } = source2;
      const unmodifiedText = getKeyEventUnmodifiedText(key, source2, isGrapheme);
      const text = getKeyEventText(code ?? "", source2) ?? unmodifiedText;
      let command;
      if (__privateGet(this, _isMacOS) && source2.meta) {
        switch (code) {
          case "KeyA":
            command = "SelectAll";
            break;
          case "KeyC":
            command = "Copy";
            break;
          case "KeyV":
            command = source2.shift ? "PasteAndMatchStyle" : "Paste";
            break;
          case "KeyX":
            command = "Cut";
            break;
          case "KeyZ":
            command = source2.shift ? "Redo" : "Undo";
            break;
        }
      }
      const promises = [
        __privateGet(this, _ActionDispatcher_instances, context_get).cdpTarget.cdpClient.sendCommand("Input.dispatchKeyEvent", {
          type: text ? "keyDown" : "rawKeyDown",
          windowsVirtualKeyCode: USKeyboardLayout_js_1.KeyToKeyCode[key],
          key,
          code,
          text,
          unmodifiedText,
          autoRepeat: repeat,
          isSystemKey: source2.alt || void 0,
          location: location < 3 ? location : void 0,
          isKeypad: location === 3,
          modifiers,
          commands: command ? [command] : void 0
        })
      ];
      if (key === "Escape") {
        if (!source2.alt && (__privateGet(this, _isMacOS) && !source2.ctrl && !source2.meta || !__privateGet(this, _isMacOS))) {
          promises.push(__privateGet(this, _ActionDispatcher_instances, context_get).cdpTarget.cdpClient.sendCommand("Input.cancelDragging"));
        }
      }
      await Promise.all(promises);
    }, dispatchKeyUpAction_fn = function(source2, action) {
      const rawKey = action.value;
      if (!(0, GraphemeTools_js_1.isSingleGrapheme)(rawKey)) {
        throw new protocol_js_1.InvalidArgumentException(`Invalid key value: ${rawKey}`);
      }
      const isGrapheme = (0, GraphemeTools_js_1.isSingleComplexGrapheme)(rawKey);
      const key = (0, keyUtils_js_1.getNormalizedKey)(rawKey);
      if (!source2.pressed.has(key)) {
        return;
      }
      const code = (0, keyUtils_js_1.getKeyCode)(rawKey);
      const location = (0, keyUtils_js_1.getKeyLocation)(rawKey);
      switch (key) {
        case "Alt":
          source2.alt = false;
          break;
        case "Shift":
          source2.shift = false;
          break;
        case "Control":
          source2.ctrl = false;
          break;
        case "Meta":
          source2.meta = false;
          break;
      }
      source2.pressed.delete(key);
      const { modifiers } = source2;
      const unmodifiedText = getKeyEventUnmodifiedText(key, source2, isGrapheme);
      const text = getKeyEventText(code ?? "", source2) ?? unmodifiedText;
      return __privateGet(this, _ActionDispatcher_instances, context_get).cdpTarget.cdpClient.sendCommand("Input.dispatchKeyEvent", {
        type: "keyUp",
        windowsVirtualKeyCode: USKeyboardLayout_js_1.KeyToKeyCode[key],
        key,
        code,
        text,
        unmodifiedText,
        location: location < 3 ? location : void 0,
        isSystemKey: source2.alt || void 0,
        isKeypad: location === 3,
        modifiers
      });
    }, __publicField(_a3, "isMacOS", async (context) => {
      const result = await (await context.getOrCreateSandbox(void 0)).callFunction(IS_MAC_DECL, false);
      (0, assert_js_1.assert)(result.type !== "exception");
      (0, assert_js_1.assert)(result.result.type === "boolean");
      return result.result.value;
    }), _a3);
    ActionDispatcher.ActionDispatcher = ActionDispatcher$1;
    const getKeyEventUnmodifiedText = (key, source2, isGrapheme) => {
      if (isGrapheme) {
        return key;
      }
      if (key === "Enter") {
        return "\r";
      }
      return [...key].length === 1 ? source2.shift ? key.toLocaleUpperCase("en-US") : key : void 0;
    };
    const getKeyEventText = (code, source2) => {
      if (source2.ctrl) {
        switch (code) {
          case "Digit2":
            if (source2.shift) {
              return "\0";
            }
            break;
          case "KeyA":
            return "";
          case "KeyB":
            return "";
          case "KeyC":
            return "";
          case "KeyD":
            return "";
          case "KeyE":
            return "";
          case "KeyF":
            return "";
          case "KeyG":
            return "\x07";
          case "KeyH":
            return "\b";
          case "KeyI":
            return "	";
          case "KeyJ":
            return "\n";
          case "KeyK":
            return "\v";
          case "KeyL":
            return "\f";
          case "KeyM":
            return "\r";
          case "KeyN":
            return "";
          case "KeyO":
            return "";
          case "KeyP":
            return "";
          case "KeyQ":
            return "";
          case "KeyR":
            return "";
          case "KeyS":
            return "";
          case "KeyT":
            return "";
          case "KeyU":
            return "";
          case "KeyV":
            return "";
          case "KeyW":
            return "";
          case "KeyX":
            return "";
          case "KeyY":
            return "";
          case "KeyZ":
            return "";
          case "BracketLeft":
            return "\x1B";
          case "Backslash":
            return "";
          case "BracketRight":
            return "";
          case "Digit6":
            if (source2.shift) {
              return "";
            }
            break;
          case "Minus":
            return "";
        }
        return "";
      }
      if (source2.alt) {
        return "";
      }
      return;
    };
    function getCdpButton(button) {
      switch (button) {
        case 0:
          return "left";
        case 1:
          return "middle";
        case 2:
          return "right";
        case 3:
          return "back";
        case 4:
          return "forward";
        default:
          return "none";
      }
    }
    function getTilt(action) {
      const altitudeAngle = action.altitudeAngle ?? Math.PI / 2;
      const azimuthAngle = action.azimuthAngle ?? 0;
      let tiltXRadians = 0;
      let tiltYRadians = 0;
      if (altitudeAngle === 0) {
        if (azimuthAngle === 0 || azimuthAngle === 2 * Math.PI) {
          tiltXRadians = Math.PI / 2;
        }
        if (azimuthAngle === Math.PI / 2) {
          tiltYRadians = Math.PI / 2;
        }
        if (azimuthAngle === Math.PI) {
          tiltXRadians = -Math.PI / 2;
        }
        if (azimuthAngle === 3 * Math.PI / 2) {
          tiltYRadians = -Math.PI / 2;
        }
        if (azimuthAngle > 0 && azimuthAngle < Math.PI / 2) {
          tiltXRadians = Math.PI / 2;
          tiltYRadians = Math.PI / 2;
        }
        if (azimuthAngle > Math.PI / 2 && azimuthAngle < Math.PI) {
          tiltXRadians = -Math.PI / 2;
          tiltYRadians = Math.PI / 2;
        }
        if (azimuthAngle > Math.PI && azimuthAngle < 3 * Math.PI / 2) {
          tiltXRadians = -Math.PI / 2;
          tiltYRadians = -Math.PI / 2;
        }
        if (azimuthAngle > 3 * Math.PI / 2 && azimuthAngle < 2 * Math.PI) {
          tiltXRadians = Math.PI / 2;
          tiltYRadians = -Math.PI / 2;
        }
      }
      if (altitudeAngle !== 0) {
        const tanAlt = Math.tan(altitudeAngle);
        tiltXRadians = Math.atan(Math.cos(azimuthAngle) / tanAlt);
        tiltYRadians = Math.atan(Math.sin(azimuthAngle) / tanAlt);
      }
      const factor = 180 / Math.PI;
      return {
        tiltX: Math.round(tiltXRadians * factor),
        tiltY: Math.round(tiltYRadians * factor)
      };
    }
    function getRadii(width, height) {
      return {
        radiusX: width ? width / 2 : 0.5,
        radiusY: height ? height / 2 : 0.5
      };
    }
    return ActionDispatcher;
  }
  var InputStateManager = {};
  var InputState = {};
  var Mutex = {};
  var hasRequiredMutex;
  function requireMutex() {
    var _locked2, _acquirers2, _Mutex_instances, release_fn, _a3;
    if (hasRequiredMutex) return Mutex;
    hasRequiredMutex = 1;
    Object.defineProperty(Mutex, "__esModule", { value: true });
    Mutex.Mutex = void 0;
    let Mutex$12 = (_a3 = class {
      constructor() {
        __privateAdd(this, _Mutex_instances);
        __privateAdd(this, _locked2, false);
        __privateAdd(this, _acquirers2, []);
      }
      // This is FIFO.
      acquire() {
        const state = { resolved: false };
        if (__privateGet(this, _locked2)) {
          return new Promise((resolve) => {
            __privateGet(this, _acquirers2).push(() => resolve(__privateMethod(this, _Mutex_instances, release_fn).bind(this, state)));
          });
        }
        __privateSet(this, _locked2, true);
        return Promise.resolve(__privateMethod(this, _Mutex_instances, release_fn).bind(this, state));
      }
      async run(action) {
        const release = await this.acquire();
        try {
          const result = await action();
          return result;
        } finally {
          release();
        }
      }
    }, _locked2 = new WeakMap(), _acquirers2 = new WeakMap(), _Mutex_instances = new WeakSet(), release_fn = function(state) {
      if (state.resolved) {
        throw new Error("Cannot release more than once.");
      }
      state.resolved = true;
      const resolve = __privateGet(this, _acquirers2).shift();
      if (!resolve) {
        __privateSet(this, _locked2, false);
        return;
      }
      resolve();
    }, _a3);
    Mutex.Mutex = Mutex$12;
    return Mutex;
  }
  var hasRequiredInputState;
  function requireInputState() {
    var _sources, _mutex3, _a3;
    if (hasRequiredInputState) return InputState;
    hasRequiredInputState = 1;
    Object.defineProperty(InputState, "__esModule", { value: true });
    InputState.InputState = void 0;
    const protocol_js_1 = requireProtocol();
    const Mutex_js_1 = requireMutex();
    const InputSource_js_1 = requireInputSource();
    let InputState$1 = (_a3 = class {
      constructor() {
        __publicField(this, "cancelList", []);
        __privateAdd(this, _sources, /* @__PURE__ */ new Map());
        __privateAdd(this, _mutex3, new Mutex_js_1.Mutex());
      }
      getOrCreate(id, type, subtype) {
        let source2 = __privateGet(this, _sources).get(id);
        if (!source2) {
          switch (type) {
            case "none":
              source2 = new InputSource_js_1.NoneSource();
              break;
            case "key":
              source2 = new InputSource_js_1.KeySource();
              break;
            case "pointer": {
              let pointerId = subtype === "mouse" ? 0 : 2;
              const pointerIds = /* @__PURE__ */ new Set();
              for (const [, source3] of __privateGet(this, _sources)) {
                if (source3.type === "pointer") {
                  pointerIds.add(source3.pointerId);
                }
              }
              while (pointerIds.has(pointerId)) {
                ++pointerId;
              }
              source2 = new InputSource_js_1.PointerSource(pointerId, subtype);
              break;
            }
            case "wheel":
              source2 = new InputSource_js_1.WheelSource();
              break;
            default:
              throw new protocol_js_1.InvalidArgumentException(`Expected "${"none"}", "${"key"}", "${"pointer"}", or "${"wheel"}". Found unknown source type ${type}.`);
          }
          __privateGet(this, _sources).set(id, source2);
          return source2;
        }
        if (source2.type !== type) {
          throw new protocol_js_1.InvalidArgumentException(`Input source type of ${id} is ${source2.type}, but received ${type}.`);
        }
        return source2;
      }
      get(id) {
        const source2 = __privateGet(this, _sources).get(id);
        if (!source2) {
          throw new protocol_js_1.UnknownErrorException(`Internal error.`);
        }
        return source2;
      }
      getGlobalKeyState() {
        const state = new InputSource_js_1.KeySource();
        for (const [, source2] of __privateGet(this, _sources)) {
          if (source2.type !== "key") {
            continue;
          }
          for (const pressed of source2.pressed) {
            state.pressed.add(pressed);
          }
          state.alt || (state.alt = source2.alt);
          state.ctrl || (state.ctrl = source2.ctrl);
          state.meta || (state.meta = source2.meta);
          state.shift || (state.shift = source2.shift);
        }
        return state;
      }
      get queue() {
        return __privateGet(this, _mutex3);
      }
    }, _sources = new WeakMap(), _mutex3 = new WeakMap(), _a3);
    InputState.InputState = InputState$1;
    return InputState;
  }
  var hasRequiredInputStateManager;
  function requireInputStateManager() {
    if (hasRequiredInputStateManager) return InputStateManager;
    hasRequiredInputStateManager = 1;
    Object.defineProperty(InputStateManager, "__esModule", { value: true });
    InputStateManager.InputStateManager = void 0;
    const assert_js_1 = requireAssert();
    const InputState_js_1 = requireInputState();
    let InputStateManager$1 = class InputStateManager extends WeakMap {
      get(context) {
        (0, assert_js_1.assert)(context.isTopLevelContext());
        if (!this.has(context)) {
          this.set(context, new InputState_js_1.InputState());
        }
        return super.get(context);
      }
    };
    InputStateManager.InputStateManager = InputStateManager$1;
    return InputStateManager;
  }
  var hasRequiredInputProcessor;
  function requireInputProcessor() {
    var _browsingContextStorage, _inputStateManager, _InputProcessor_instances, getActionsByTick_fn, _a3;
    if (hasRequiredInputProcessor) return InputProcessor;
    hasRequiredInputProcessor = 1;
    Object.defineProperty(InputProcessor, "__esModule", { value: true });
    InputProcessor.InputProcessor = void 0;
    const protocol_js_1 = requireProtocol();
    const assert_js_1 = requireAssert();
    const ActionDispatcher_js_1 = requireActionDispatcher();
    const InputStateManager_js_1 = requireInputStateManager();
    let InputProcessor$1 = (_a3 = class {
      constructor(browsingContextStorage) {
        __privateAdd(this, _InputProcessor_instances);
        __privateAdd(this, _browsingContextStorage);
        __privateAdd(this, _inputStateManager, new InputStateManager_js_1.InputStateManager());
        __privateSet(this, _browsingContextStorage, browsingContextStorage);
      }
      async performActions(params) {
        const context = __privateGet(this, _browsingContextStorage).getContext(params.context);
        const inputState = __privateGet(this, _inputStateManager).get(context.top);
        const actionsByTick = __privateMethod(this, _InputProcessor_instances, getActionsByTick_fn).call(this, params, inputState);
        const dispatcher = new ActionDispatcher_js_1.ActionDispatcher(inputState, __privateGet(this, _browsingContextStorage), params.context, await ActionDispatcher_js_1.ActionDispatcher.isMacOS(context).catch(() => false));
        await dispatcher.dispatchActions(actionsByTick);
        return {};
      }
      async releaseActions(params) {
        const context = __privateGet(this, _browsingContextStorage).getContext(params.context);
        const topContext = context.top;
        const inputState = __privateGet(this, _inputStateManager).get(topContext);
        const dispatcher = new ActionDispatcher_js_1.ActionDispatcher(inputState, __privateGet(this, _browsingContextStorage), params.context, await ActionDispatcher_js_1.ActionDispatcher.isMacOS(context).catch(() => false));
        await dispatcher.dispatchTickActions(inputState.cancelList.reverse());
        __privateGet(this, _inputStateManager).delete(topContext);
        return {};
      }
      async setFiles(params) {
        const context = __privateGet(this, _browsingContextStorage).getContext(params.context);
        const realm = await context.getOrCreateSandbox(void 0);
        let result;
        try {
          result = await realm.callFunction(String(function getFiles(fileListLength) {
            if (!(this instanceof HTMLInputElement)) {
              if (this instanceof Element) {
                return 1;
              }
              return 0;
            }
            if (this.type !== "file") {
              return 2;
            }
            if (this.disabled) {
              return 3;
            }
            if (fileListLength > 1 && !this.multiple) {
              return 4;
            }
            return;
          }), false, params.element, [{ type: "number", value: params.files.length }]);
        } catch {
          throw new protocol_js_1.NoSuchNodeException(`Could not find element ${params.element.sharedId}`);
        }
        (0, assert_js_1.assert)(result.type === "success");
        if (result.result.type === "number") {
          switch (result.result.value) {
            case 0: {
              throw new protocol_js_1.NoSuchElementException(`Could not find element ${params.element.sharedId}`);
            }
            case 1: {
              throw new protocol_js_1.UnableToSetFileInputException(`Element ${params.element.sharedId} is not a input`);
            }
            case 2: {
              throw new protocol_js_1.UnableToSetFileInputException(`Input element ${params.element.sharedId} is not a file type`);
            }
            case 3: {
              throw new protocol_js_1.UnableToSetFileInputException(`Input element ${params.element.sharedId} is disabled`);
            }
            case 4: {
              throw new protocol_js_1.UnableToSetFileInputException(`Cannot set multiple files on a non-multiple input element`);
            }
          }
        }
        if (params.files.length === 0) {
          await realm.callFunction(String(function dispatchEvent() {
            var _a4;
            if (((_a4 = this.files) == null ? void 0 : _a4.length) === 0) {
              this.dispatchEvent(new Event("cancel", {
                bubbles: true
              }));
              return;
            }
            this.files = new DataTransfer().files;
            this.dispatchEvent(new Event("input", { bubbles: true, composed: true }));
            this.dispatchEvent(new Event("change", { bubbles: true }));
          }), false, params.element);
          return {};
        }
        const paths = [];
        for (let i2 = 0; i2 < params.files.length; ++i2) {
          const result2 = await realm.callFunction(
            String(function getFiles(index) {
              var _a4;
              return (_a4 = this.files) == null ? void 0 : _a4.item(index);
            }),
            false,
            params.element,
            [{ type: "number", value: 0 }],
            "root"
            /* Script.ResultOwnership.Root */
          );
          (0, assert_js_1.assert)(result2.type === "success");
          if (result2.result.type !== "object") {
            break;
          }
          const { handle } = result2.result;
          (0, assert_js_1.assert)(handle !== void 0);
          const { path } = await realm.cdpClient.sendCommand("DOM.getFileInfo", {
            objectId: handle
          });
          paths.push(path);
          void realm.disown(handle).catch(void 0);
        }
        paths.sort();
        const sortedFiles = [...params.files].sort();
        if (paths.length !== params.files.length || sortedFiles.some((path, index) => {
          return paths[index] !== path;
        })) {
          const { objectId } = await realm.deserializeForCdp(params.element);
          (0, assert_js_1.assert)(objectId !== void 0);
          await realm.cdpClient.sendCommand("DOM.setFileInputFiles", {
            files: params.files,
            objectId
          });
        } else {
          await realm.callFunction(String(function dispatchEvent() {
            this.dispatchEvent(new Event("cancel", {
              bubbles: true
            }));
          }), false, params.element);
        }
        return {};
      }
    }, _browsingContextStorage = new WeakMap(), _inputStateManager = new WeakMap(), _InputProcessor_instances = new WeakSet(), getActionsByTick_fn = function(params, inputState) {
      var _a4;
      const actionsByTick = [];
      for (const action of params.actions) {
        switch (action.type) {
          case "pointer": {
            action.parameters ?? (action.parameters = {
              pointerType: "mouse"
              /* Input.PointerType.Mouse */
            });
            (_a4 = action.parameters).pointerType ?? (_a4.pointerType = "mouse");
            const source2 = inputState.getOrCreate(action.id, "pointer", action.parameters.pointerType);
            if (source2.subtype !== action.parameters.pointerType) {
              throw new protocol_js_1.InvalidArgumentException(`Expected input source ${action.id} to be ${source2.subtype}; got ${action.parameters.pointerType}.`);
            }
            break;
          }
          default:
            inputState.getOrCreate(action.id, action.type);
        }
        const actions = action.actions.map((item) => ({
          id: action.id,
          action: item
        }));
        for (let i2 = 0; i2 < actions.length; i2++) {
          if (actionsByTick.length === i2) {
            actionsByTick.push([]);
          }
          actionsByTick[i2].push(actions[i2]);
        }
      }
      return actionsByTick;
    }, _a3);
    InputProcessor.InputProcessor = InputProcessor$1;
    return InputProcessor;
  }
  var NetworkProcessor = {};
  var NetworkUtils = {};
  var Base64 = {};
  var hasRequiredBase64;
  function requireBase64() {
    if (hasRequiredBase64) return Base64;
    hasRequiredBase64 = 1;
    Object.defineProperty(Base64, "__esModule", { value: true });
    Base64.base64ToString = base64ToString;
    function base64ToString(base64Str) {
      if ("atob" in globalThis) {
        return globalThis.atob(base64Str);
      }
      return Buffer.from(base64Str, "base64").toString("ascii");
    }
    return Base64;
  }
  var hasRequiredNetworkUtils;
  function requireNetworkUtils() {
    if (hasRequiredNetworkUtils) return NetworkUtils;
    hasRequiredNetworkUtils = 1;
    Object.defineProperty(NetworkUtils, "__esModule", { value: true });
    NetworkUtils.computeHeadersSize = computeHeadersSize;
    NetworkUtils.bidiNetworkHeadersFromCdpNetworkHeaders = bidiNetworkHeadersFromCdpNetworkHeaders;
    NetworkUtils.bidiNetworkHeadersFromCdpNetworkHeadersEntries = bidiNetworkHeadersFromCdpNetworkHeadersEntries;
    NetworkUtils.cdpNetworkHeadersFromBidiNetworkHeaders = cdpNetworkHeadersFromBidiNetworkHeaders;
    NetworkUtils.bidiNetworkHeadersFromCdpFetchHeaders = bidiNetworkHeadersFromCdpFetchHeaders;
    NetworkUtils.cdpFetchHeadersFromBidiNetworkHeaders = cdpFetchHeadersFromBidiNetworkHeaders;
    NetworkUtils.networkHeaderFromCookieHeaders = networkHeaderFromCookieHeaders;
    NetworkUtils.cdpAuthChallengeResponseFromBidiAuthContinueWithAuthAction = cdpAuthChallengeResponseFromBidiAuthContinueWithAuthAction;
    NetworkUtils.cdpToBiDiCookie = cdpToBiDiCookie;
    NetworkUtils.deserializeByteValue = deserializeByteValue;
    NetworkUtils.bidiToCdpCookie = bidiToCdpCookie;
    NetworkUtils.sameSiteBiDiToCdp = sameSiteBiDiToCdp;
    NetworkUtils.isSpecialScheme = isSpecialScheme;
    NetworkUtils.matchUrlPattern = matchUrlPattern;
    NetworkUtils.bidiBodySizeFromCdpPostDataEntries = bidiBodySizeFromCdpPostDataEntries;
    NetworkUtils.getTiming = getTiming;
    const ErrorResponse_js_1 = requireErrorResponse();
    const Base64_js_1 = requireBase64();
    function computeHeadersSize(headers) {
      const requestHeaders = headers.reduce((acc, header) => {
        return `${acc}${header.name}: ${header.value.value}\r
`;
      }, "");
      return new TextEncoder().encode(requestHeaders).length;
    }
    function bidiNetworkHeadersFromCdpNetworkHeaders(headers) {
      if (!headers) {
        return [];
      }
      return Object.entries(headers).map(([name, value]) => ({
        name,
        value: {
          type: "string",
          value
        }
      }));
    }
    function bidiNetworkHeadersFromCdpNetworkHeadersEntries(headers) {
      if (!headers) {
        return [];
      }
      return headers.map(({ name, value }) => ({
        name,
        value: {
          type: "string",
          value
        }
      }));
    }
    function cdpNetworkHeadersFromBidiNetworkHeaders(headers) {
      if (headers === void 0) {
        return void 0;
      }
      return headers.reduce((result, header) => {
        result[header.name] = header.value.value;
        return result;
      }, {});
    }
    function bidiNetworkHeadersFromCdpFetchHeaders(headers) {
      if (!headers) {
        return [];
      }
      return headers.map(({ name, value }) => ({
        name,
        value: {
          type: "string",
          value
        }
      }));
    }
    function cdpFetchHeadersFromBidiNetworkHeaders(headers) {
      if (headers === void 0) {
        return void 0;
      }
      return headers.map(({ name, value }) => ({
        name,
        value: value.value
      }));
    }
    function networkHeaderFromCookieHeaders(headers) {
      if (headers === void 0) {
        return void 0;
      }
      const value = headers.reduce((acc, value2, index) => {
        if (index > 0) {
          acc += ";";
        }
        const cookieValue = value2.value.type === "base64" ? btoa(value2.value.value) : value2.value.value;
        acc += `${value2.name}=${cookieValue}`;
        return acc;
      }, "");
      return {
        name: "Cookie",
        value: {
          type: "string",
          value
        }
      };
    }
    function cdpAuthChallengeResponseFromBidiAuthContinueWithAuthAction(action) {
      switch (action) {
        case "default":
          return "Default";
        case "cancel":
          return "CancelAuth";
        case "provideCredentials":
          return "ProvideCredentials";
      }
    }
    function cdpToBiDiCookie(cookie) {
      const result = {
        name: cookie.name,
        value: { type: "string", value: cookie.value },
        domain: cookie.domain,
        path: cookie.path,
        size: cookie.size,
        httpOnly: cookie.httpOnly,
        secure: cookie.secure,
        sameSite: cookie.sameSite === void 0 ? "none" : sameSiteCdpToBiDi(cookie.sameSite),
        ...cookie.expires >= 0 ? { expiry: cookie.expires } : void 0
      };
      result[`goog:session`] = cookie.session;
      result[`goog:priority`] = cookie.priority;
      result[`goog:sameParty`] = cookie.sameParty;
      result[`goog:sourceScheme`] = cookie.sourceScheme;
      result[`goog:sourcePort`] = cookie.sourcePort;
      if (cookie.partitionKey !== void 0) {
        result[`goog:partitionKey`] = cookie.partitionKey;
      }
      if (cookie.partitionKeyOpaque !== void 0) {
        result[`goog:partitionKeyOpaque`] = cookie.partitionKeyOpaque;
      }
      return result;
    }
    function deserializeByteValue(value) {
      if (value.type === "base64") {
        return (0, Base64_js_1.base64ToString)(value.value);
      }
      return value.value;
    }
    function bidiToCdpCookie(params, partitionKey) {
      const deserializedValue = deserializeByteValue(params.cookie.value);
      const result = {
        name: params.cookie.name,
        value: deserializedValue,
        domain: params.cookie.domain,
        path: params.cookie.path ?? "/",
        secure: params.cookie.secure ?? false,
        httpOnly: params.cookie.httpOnly ?? false,
        ...partitionKey.sourceOrigin !== void 0 && {
          partitionKey: {
            hasCrossSiteAncestor: false,
            // CDP's `partitionKey.topLevelSite` is the BiDi's `partition.sourceOrigin`.
            topLevelSite: partitionKey.sourceOrigin
          }
        },
        ...params.cookie.expiry !== void 0 && {
          expires: params.cookie.expiry
        },
        ...params.cookie.sameSite !== void 0 && {
          sameSite: sameSiteBiDiToCdp(params.cookie.sameSite)
        }
      };
      if (params.cookie[`goog:url`] !== void 0) {
        result.url = params.cookie[`goog:url`];
      }
      if (params.cookie[`goog:priority`] !== void 0) {
        result.priority = params.cookie[`goog:priority`];
      }
      if (params.cookie[`goog:sameParty`] !== void 0) {
        result.sameParty = params.cookie[`goog:sameParty`];
      }
      if (params.cookie[`goog:sourceScheme`] !== void 0) {
        result.sourceScheme = params.cookie[`goog:sourceScheme`];
      }
      if (params.cookie[`goog:sourcePort`] !== void 0) {
        result.sourcePort = params.cookie[`goog:sourcePort`];
      }
      return result;
    }
    function sameSiteCdpToBiDi(sameSite) {
      switch (sameSite) {
        case "Strict":
          return "strict";
        case "None":
          return "none";
        case "Lax":
          return "lax";
        default:
          return "lax";
      }
    }
    function sameSiteBiDiToCdp(sameSite) {
      switch (sameSite) {
        case "strict":
          return "Strict";
        case "lax":
          return "Lax";
        case "none":
          return "None";
      }
      throw new ErrorResponse_js_1.InvalidArgumentException(`Unknown 'sameSite' value ${sameSite}`);
    }
    function isSpecialScheme(protocol2) {
      return ["ftp", "file", "http", "https", "ws", "wss"].includes(protocol2.replace(/:$/, ""));
    }
    function getScheme(url) {
      return url.protocol.replace(/:$/, "");
    }
    function matchUrlPattern(pattern, url) {
      const parsedUrl = new URL(url);
      if (pattern.protocol !== void 0 && pattern.protocol !== getScheme(parsedUrl)) {
        return false;
      }
      if (pattern.hostname !== void 0 && pattern.hostname !== parsedUrl.hostname) {
        return false;
      }
      if (pattern.port !== void 0 && pattern.port !== parsedUrl.port) {
        return false;
      }
      if (pattern.pathname !== void 0 && pattern.pathname !== parsedUrl.pathname) {
        return false;
      }
      if (pattern.search !== void 0 && pattern.search !== parsedUrl.search) {
        return false;
      }
      return true;
    }
    function bidiBodySizeFromCdpPostDataEntries(entries) {
      let size = 0;
      for (const entry of entries) {
        size += atob(entry.bytes ?? "").length;
      }
      return size;
    }
    function getTiming(timing, offset = 0) {
      if (!timing) {
        return 0;
      }
      if (timing <= 0 || timing + offset <= 0) {
        return 0;
      }
      return timing + offset;
    }
    return NetworkUtils;
  }
  var hasRequiredNetworkProcessor;
  function requireNetworkProcessor() {
    var _browsingContextStorage, _networkStorage, _NetworkProcessor_instances, getRequestOrFail_fn, getBlockedRequestOrFail_fn, _a3;
    if (hasRequiredNetworkProcessor) return NetworkProcessor;
    hasRequiredNetworkProcessor = 1;
    Object.defineProperty(NetworkProcessor, "__esModule", { value: true });
    NetworkProcessor.NetworkProcessor = void 0;
    const protocol_js_1 = requireProtocol();
    const NetworkUtils_js_1 = requireNetworkUtils();
    let NetworkProcessor$1 = (_a3 = class {
      constructor(browsingContextStorage, networkStorage) {
        __privateAdd(this, _NetworkProcessor_instances);
        __privateAdd(this, _browsingContextStorage);
        __privateAdd(this, _networkStorage);
        __privateSet(this, _browsingContextStorage, browsingContextStorage);
        __privateSet(this, _networkStorage, networkStorage);
      }
      async addIntercept(params) {
        __privateGet(this, _browsingContextStorage).verifyTopLevelContextsList(params.contexts);
        const urlPatterns = params.urlPatterns ?? [];
        const parsedUrlPatterns = _a3.parseUrlPatterns(urlPatterns);
        const intercept = __privateGet(this, _networkStorage).addIntercept({
          urlPatterns: parsedUrlPatterns,
          phases: params.phases,
          contexts: params.contexts
        });
        await Promise.all(__privateGet(this, _browsingContextStorage).getAllContexts().map((context) => {
          return context.cdpTarget.toggleNetwork();
        }));
        return {
          intercept
        };
      }
      async continueRequest(params) {
        if (params.url !== void 0) {
          _a3.parseUrlString(params.url);
        }
        if (params.method !== void 0) {
          if (!_a3.isMethodValid(params.method)) {
            throw new protocol_js_1.InvalidArgumentException(`Method '${params.method}' is invalid.`);
          }
        }
        if (params.headers) {
          _a3.validateHeaders(params.headers);
        }
        const request = __privateMethod(this, _NetworkProcessor_instances, getBlockedRequestOrFail_fn).call(this, params.request, [
          "beforeRequestSent"
        ]);
        try {
          await request.continueRequest(params);
        } catch (error) {
          throw _a3.wrapInterceptionError(error);
        }
        return {};
      }
      async continueResponse(params) {
        if (params.headers) {
          _a3.validateHeaders(params.headers);
        }
        const request = __privateMethod(this, _NetworkProcessor_instances, getBlockedRequestOrFail_fn).call(this, params.request, [
          "authRequired",
          "responseStarted"
        ]);
        try {
          await request.continueResponse(params);
        } catch (error) {
          throw _a3.wrapInterceptionError(error);
        }
        return {};
      }
      async continueWithAuth(params) {
        const networkId = params.request;
        const request = __privateMethod(this, _NetworkProcessor_instances, getBlockedRequestOrFail_fn).call(this, networkId, [
          "authRequired"
        ]);
        await request.continueWithAuth(params);
        return {};
      }
      async failRequest({ request: networkId }) {
        const request = __privateMethod(this, _NetworkProcessor_instances, getRequestOrFail_fn).call(this, networkId);
        if (request.interceptPhase === "authRequired") {
          throw new protocol_js_1.InvalidArgumentException(`Request '${networkId}' in 'authRequired' phase cannot be failed`);
        }
        if (!request.interceptPhase) {
          throw new protocol_js_1.NoSuchRequestException(`No blocked request found for network id '${networkId}'`);
        }
        await request.failRequest("Failed");
        return {};
      }
      async provideResponse(params) {
        if (params.headers) {
          _a3.validateHeaders(params.headers);
        }
        const request = __privateMethod(this, _NetworkProcessor_instances, getBlockedRequestOrFail_fn).call(this, params.request, [
          "beforeRequestSent",
          "responseStarted",
          "authRequired"
        ]);
        try {
          await request.provideResponse(params);
        } catch (error) {
          throw _a3.wrapInterceptionError(error);
        }
        return {};
      }
      async removeIntercept(params) {
        __privateGet(this, _networkStorage).removeIntercept(params.intercept);
        await Promise.all(__privateGet(this, _browsingContextStorage).getAllContexts().map((context) => {
          return context.cdpTarget.toggleNetwork();
        }));
        return {};
      }
      async setCacheBehavior(params) {
        const contexts = __privateGet(this, _browsingContextStorage).verifyTopLevelContextsList(params.contexts);
        if (contexts.size === 0) {
          __privateGet(this, _networkStorage).defaultCacheBehavior = params.cacheBehavior;
          await Promise.all(__privateGet(this, _browsingContextStorage).getAllContexts().map((context) => {
            return context.cdpTarget.toggleSetCacheDisabled();
          }));
          return {};
        }
        const cacheDisabled = params.cacheBehavior === "bypass";
        await Promise.all([...contexts.values()].map((context) => {
          return context.cdpTarget.toggleSetCacheDisabled(cacheDisabled);
        }));
        return {};
      }
      /**
       * Validate https://fetch.spec.whatwg.org/#header-value
       */
      static validateHeaders(headers) {
        for (const header of headers) {
          let headerValue;
          if (header.value.type === "string") {
            headerValue = header.value.value;
          } else {
            headerValue = atob(header.value.value);
          }
          if (headerValue !== headerValue.trim() || headerValue.includes("\n") || headerValue.includes("\0")) {
            throw new protocol_js_1.InvalidArgumentException(`Header value '${headerValue}' is not acceptable value`);
          }
        }
      }
      static isMethodValid(method) {
        return /^[!#$%&'*+\-.^_`|~a-zA-Z\d]+$/.test(method);
      }
      /**
       * Attempts to parse the given url.
       * Throws an InvalidArgumentException if the url is invalid.
       */
      static parseUrlString(url) {
        try {
          return new URL(url);
        } catch (error) {
          throw new protocol_js_1.InvalidArgumentException(`Invalid URL '${url}': ${error}`);
        }
      }
      static parseUrlPatterns(urlPatterns) {
        return urlPatterns.map((urlPattern) => {
          let patternUrl = "";
          let hasProtocol = true;
          let hasHostname = true;
          let hasPort = true;
          let hasPathname = true;
          let hasSearch = true;
          switch (urlPattern.type) {
            case "string": {
              patternUrl = unescapeURLPattern(urlPattern.pattern);
              break;
            }
            case "pattern": {
              if (urlPattern.protocol === void 0) {
                hasProtocol = false;
                patternUrl += "http";
              } else {
                if (urlPattern.protocol === "") {
                  throw new protocol_js_1.InvalidArgumentException("URL pattern must specify a protocol");
                }
                urlPattern.protocol = unescapeURLPattern(urlPattern.protocol);
                if (!urlPattern.protocol.match(/^[a-zA-Z+-.]+$/)) {
                  throw new protocol_js_1.InvalidArgumentException("Forbidden characters");
                }
                patternUrl += urlPattern.protocol;
              }
              const scheme = patternUrl.toLocaleLowerCase();
              patternUrl += ":";
              if ((0, NetworkUtils_js_1.isSpecialScheme)(scheme)) {
                patternUrl += "//";
              }
              if (urlPattern.hostname === void 0) {
                if (scheme !== "file") {
                  patternUrl += "placeholder";
                }
                hasHostname = false;
              } else {
                if (urlPattern.hostname === "") {
                  throw new protocol_js_1.InvalidArgumentException("URL pattern must specify a hostname");
                }
                if (urlPattern.protocol === "file") {
                  throw new protocol_js_1.InvalidArgumentException(`URL pattern protocol cannot be 'file'`);
                }
                urlPattern.hostname = unescapeURLPattern(urlPattern.hostname);
                let insideBrackets = false;
                for (const c of urlPattern.hostname) {
                  if (c === "/" || c === "?" || c === "#") {
                    throw new protocol_js_1.InvalidArgumentException(`'/', '?', '#' are forbidden in hostname`);
                  }
                  if (!insideBrackets && c === ":") {
                    throw new protocol_js_1.InvalidArgumentException(`':' is only allowed inside brackets in hostname`);
                  }
                  if (c === "[") {
                    insideBrackets = true;
                  }
                  if (c === "]") {
                    insideBrackets = false;
                  }
                }
                patternUrl += urlPattern.hostname;
              }
              if (urlPattern.port === void 0) {
                hasPort = false;
              } else {
                if (urlPattern.port === "") {
                  throw new protocol_js_1.InvalidArgumentException(`URL pattern must specify a port`);
                }
                urlPattern.port = unescapeURLPattern(urlPattern.port);
                patternUrl += ":";
                if (!urlPattern.port.match(/^\d+$/)) {
                  throw new protocol_js_1.InvalidArgumentException("Forbidden characters");
                }
                patternUrl += urlPattern.port;
              }
              if (urlPattern.pathname === void 0) {
                hasPathname = false;
              } else {
                urlPattern.pathname = unescapeURLPattern(urlPattern.pathname);
                if (urlPattern.pathname[0] !== "/") {
                  patternUrl += "/";
                }
                if (urlPattern.pathname.includes("#") || urlPattern.pathname.includes("?")) {
                  throw new protocol_js_1.InvalidArgumentException("Forbidden characters");
                }
                patternUrl += urlPattern.pathname;
              }
              if (urlPattern.search === void 0) {
                hasSearch = false;
              } else {
                urlPattern.search = unescapeURLPattern(urlPattern.search);
                if (urlPattern.search[0] !== "?") {
                  patternUrl += "?";
                }
                if (urlPattern.search.includes("#")) {
                  throw new protocol_js_1.InvalidArgumentException("Forbidden characters");
                }
                patternUrl += urlPattern.search;
              }
              break;
            }
          }
          const serializePort = (url) => {
            const defaultPorts = {
              "ftp:": 21,
              "file:": null,
              "http:": 80,
              "https:": 443,
              "ws:": 80,
              "wss:": 443
            };
            if ((0, NetworkUtils_js_1.isSpecialScheme)(url.protocol) && defaultPorts[url.protocol] !== null && (!url.port || String(defaultPorts[url.protocol]) === url.port)) {
              return "";
            } else if (url.port) {
              return url.port;
            }
            return void 0;
          };
          try {
            const url = new URL(patternUrl);
            return {
              protocol: hasProtocol ? url.protocol.replace(/:$/, "") : void 0,
              hostname: hasHostname ? url.hostname : void 0,
              port: hasPort ? serializePort(url) : void 0,
              pathname: hasPathname && url.pathname ? url.pathname : void 0,
              search: hasSearch ? url.search : void 0
            };
          } catch (err) {
            throw new protocol_js_1.InvalidArgumentException(`${err.message} '${patternUrl}'`);
          }
        });
      }
      static wrapInterceptionError(error) {
        if (error == null ? void 0 : error.message.includes("Invalid header")) {
          return new protocol_js_1.InvalidArgumentException("Invalid header");
        }
        return error;
      }
    }, _browsingContextStorage = new WeakMap(), _networkStorage = new WeakMap(), _NetworkProcessor_instances = new WeakSet(), getRequestOrFail_fn = function(id) {
      const request = __privateGet(this, _networkStorage).getRequestById(id);
      if (!request) {
        throw new protocol_js_1.NoSuchRequestException(`Network request with ID '${id}' doesn't exist`);
      }
      return request;
    }, getBlockedRequestOrFail_fn = function(id, phases) {
      const request = __privateMethod(this, _NetworkProcessor_instances, getRequestOrFail_fn).call(this, id);
      if (!request.interceptPhase) {
        throw new protocol_js_1.NoSuchRequestException(`No blocked request found for network id '${id}'`);
      }
      if (request.interceptPhase && !phases.includes(request.interceptPhase)) {
        throw new protocol_js_1.InvalidArgumentException(`Blocked request for network id '${id}' is in '${request.interceptPhase}' phase`);
      }
      return request;
    }, _a3);
    NetworkProcessor.NetworkProcessor = NetworkProcessor$1;
    function unescapeURLPattern(pattern) {
      const forbidden = /* @__PURE__ */ new Set(["(", ")", "*", "{", "}"]);
      let result = "";
      let isEscaped = false;
      for (const c of pattern) {
        if (!isEscaped) {
          if (forbidden.has(c)) {
            throw new protocol_js_1.InvalidArgumentException("Forbidden characters");
          }
          if (c === "\\") {
            isEscaped = true;
            continue;
          }
        }
        result += c;
        isEscaped = false;
      }
      return result;
    }
    return NetworkProcessor;
  }
  var PermissionsProcessor = {};
  var hasRequiredPermissionsProcessor;
  function requirePermissionsProcessor() {
    var _browserCdpClient, _a3;
    if (hasRequiredPermissionsProcessor) return PermissionsProcessor;
    hasRequiredPermissionsProcessor = 1;
    Object.defineProperty(PermissionsProcessor, "__esModule", { value: true });
    PermissionsProcessor.PermissionsProcessor = void 0;
    const protocol_js_1 = requireProtocol();
    let PermissionsProcessor$1 = (_a3 = class {
      constructor(browserCdpClient) {
        __privateAdd(this, _browserCdpClient);
        __privateSet(this, _browserCdpClient, browserCdpClient);
      }
      async setPermissions(params) {
        try {
          const userContextId = params["goog:userContext"] || params.userContext;
          await __privateGet(this, _browserCdpClient).sendCommand("Browser.setPermission", {
            origin: params.origin,
            browserContextId: userContextId && userContextId !== "default" ? userContextId : void 0,
            permission: {
              name: params.descriptor.name
            },
            setting: params.state
          });
        } catch (err) {
          if (err.message === `Permission can't be granted to opaque origins.`) {
            return {};
          }
          throw new protocol_js_1.InvalidArgumentException(err.message);
        }
        return {};
      }
    }, _browserCdpClient = new WeakMap(), _a3);
    PermissionsProcessor.PermissionsProcessor = PermissionsProcessor$1;
    return PermissionsProcessor;
  }
  var ScriptProcessor = {};
  var PreloadScript = {};
  var uuid = {};
  const __viteBrowserExternal = {};
  const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: __viteBrowserExternal
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
  var hasRequiredUuid;
  function requireUuid() {
    if (hasRequiredUuid) return uuid;
    hasRequiredUuid = 1;
    Object.defineProperty(uuid, "__esModule", { value: true });
    uuid.uuidv4 = uuidv4;
    function bytesToHex(bytes) {
      return bytes.reduce((str2, byte) => str2 + byte.toString(16).padStart(2, "0"), "");
    }
    function uuidv4() {
      if ("crypto" in globalThis && "randomUUID" in globalThis.crypto) {
        return globalThis.crypto.randomUUID();
      }
      const randomValues = new Uint8Array(16);
      if ("crypto" in globalThis && "getRandomValues" in globalThis.crypto) {
        globalThis.crypto.getRandomValues(randomValues);
      } else {
        require$$0.webcrypto.getRandomValues(randomValues);
      }
      randomValues[6] = randomValues[6] & 15 | 64;
      randomValues[8] = randomValues[8] & 63 | 128;
      return [
        bytesToHex(randomValues.subarray(0, 4)),
        bytesToHex(randomValues.subarray(4, 6)),
        bytesToHex(randomValues.subarray(6, 8)),
        bytesToHex(randomValues.subarray(8, 10)),
        bytesToHex(randomValues.subarray(10, 16))
      ].join("-");
    }
    return uuid;
  }
  var ChannelProxy = {};
  var hasRequiredChannelProxy;
  function requireChannelProxy() {
    var _properties2, _id7, _logger, _ChannelProxy_static, _a3, createChannelProxyEvalStr_fn, createAndGetHandleInRealm_fn, createSendMessageHandle_fn, _ChannelProxy_instances, startListener_fn, getHandleFromWindow_fn;
    if (hasRequiredChannelProxy) return ChannelProxy;
    hasRequiredChannelProxy = 1;
    Object.defineProperty(ChannelProxy, "__esModule", { value: true });
    ChannelProxy.ChannelProxy = void 0;
    const protocol_js_1 = requireProtocol();
    const log_js_1 = requireLog();
    const uuid_js_1 = requireUuid();
    let ChannelProxy$1 = (_a3 = class {
      constructor(channel, logger2) {
        __privateAdd(this, _ChannelProxy_instances);
        __privateAdd(this, _properties2);
        __privateAdd(this, _id7, (0, uuid_js_1.uuidv4)());
        __privateAdd(this, _logger);
        __privateSet(this, _properties2, channel);
        __privateSet(this, _logger, logger2);
      }
      /**
       * Creates a channel proxy in the given realm, initialises listener and
       * returns a handle to `sendMessage` delegate.
       */
      async init(realm, eventManager) {
        var _a4, _b2;
        const channelHandle = await __privateMethod(_a4 = _a3, _ChannelProxy_static, createAndGetHandleInRealm_fn).call(_a4, realm);
        const sendMessageHandle = await __privateMethod(_b2 = _a3, _ChannelProxy_static, createSendMessageHandle_fn).call(_b2, realm, channelHandle);
        void __privateMethod(this, _ChannelProxy_instances, startListener_fn).call(this, realm, channelHandle, eventManager);
        return sendMessageHandle;
      }
      /** Gets a ChannelProxy from window and returns its handle. */
      async startListenerFromWindow(realm, eventManager) {
        var _a4;
        try {
          const channelHandle = await __privateMethod(this, _ChannelProxy_instances, getHandleFromWindow_fn).call(this, realm);
          void __privateMethod(this, _ChannelProxy_instances, startListener_fn).call(this, realm, channelHandle, eventManager);
        } catch (error) {
          (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, log_js_1.LogType.debugError, error);
        }
      }
      /**
       * String to be evaluated to create a ProxyChannel and put it to window.
       * Returns the delegate `sendMessage`. Used to provide an argument for preload
       * script. Does the following:
       * 1. Creates a ChannelProxy.
       * 2. Puts the ChannelProxy to window['${this.#id}'] or resolves the promise
       *    by calling delegate stored in window['${this.#id}'].
       *    This is needed because `#getHandleFromWindow` can be called before or
       *    after this method.
       * 3. Returns the delegate `sendMessage` of the created ChannelProxy.
       */
      getEvalInWindowStr() {
        var _a4;
        const delegate = String((id, channelProxy) => {
          const w = window;
          if (w[id] === void 0) {
            w[id] = channelProxy;
          } else {
            w[id](channelProxy);
            delete w[id];
          }
          return channelProxy.sendMessage;
        });
        const channelProxyEval = __privateMethod(_a4 = _a3, _ChannelProxy_static, createChannelProxyEvalStr_fn).call(_a4);
        return `(${delegate})('${__privateGet(this, _id7)}',${channelProxyEval})`;
      }
    }, _properties2 = new WeakMap(), _id7 = new WeakMap(), _logger = new WeakMap(), _ChannelProxy_static = new WeakSet(), createChannelProxyEvalStr_fn = function() {
      const functionStr = String(() => {
        const queue2 = [];
        let queueNonEmptyResolver = null;
        return {
          /**
           * Gets a promise, which is resolved as soon as a message occurs
           * in the queue.
           */
          async getMessage() {
            const onMessage = queue2.length > 0 ? Promise.resolve() : new Promise((resolve) => {
              queueNonEmptyResolver = resolve;
            });
            await onMessage;
            return queue2.shift();
          },
          /**
           * Adds a message to the queue.
           * Resolves the pending promise if needed.
           */
          sendMessage(message) {
            queue2.push(message);
            if (queueNonEmptyResolver !== null) {
              queueNonEmptyResolver();
              queueNonEmptyResolver = null;
            }
          }
        };
      });
      return `(${functionStr})()`;
    }, createAndGetHandleInRealm_fn = async function(realm) {
      const createChannelHandleResult = await realm.cdpClient.sendCommand("Runtime.evaluate", {
        expression: __privateMethod(this, _ChannelProxy_static, createChannelProxyEvalStr_fn).call(this),
        contextId: realm.executionContextId,
        serializationOptions: {
          serialization: "idOnly"
        }
      });
      if (createChannelHandleResult.exceptionDetails || createChannelHandleResult.result.objectId === void 0) {
        throw new Error(`Cannot create channel`);
      }
      return createChannelHandleResult.result.objectId;
    }, createSendMessageHandle_fn = async function(realm, channelHandle) {
      const sendMessageArgResult = await realm.cdpClient.sendCommand("Runtime.callFunctionOn", {
        functionDeclaration: String((channelHandle2) => {
          return channelHandle2.sendMessage;
        }),
        arguments: [{ objectId: channelHandle }],
        executionContextId: realm.executionContextId,
        serializationOptions: {
          serialization: "idOnly"
        }
      });
      return sendMessageArgResult.result.objectId;
    }, _ChannelProxy_instances = new WeakSet(), startListener_fn = async function(realm, channelHandle, eventManager) {
      var _a4, _b2;
      for (; ; ) {
        try {
          const message = await realm.cdpClient.sendCommand("Runtime.callFunctionOn", {
            functionDeclaration: String(async (channelHandle2) => await channelHandle2.getMessage()),
            arguments: [
              {
                objectId: channelHandle
              }
            ],
            awaitPromise: true,
            executionContextId: realm.executionContextId,
            serializationOptions: {
              serialization: "deep",
              maxDepth: ((_a4 = __privateGet(this, _properties2).serializationOptions) == null ? void 0 : _a4.maxObjectDepth) ?? void 0
            }
          });
          if (message.exceptionDetails) {
            throw new Error("Runtime.callFunctionOn in ChannelProxy", {
              cause: message.exceptionDetails
            });
          }
          for (const browsingContext of realm.associatedBrowsingContexts) {
            eventManager.registerEvent({
              type: "event",
              method: protocol_js_1.ChromiumBidi.Script.EventNames.Message,
              params: {
                channel: __privateGet(this, _properties2).channel,
                data: realm.cdpToBidiValue(
                  message,
                  __privateGet(this, _properties2).ownership ?? "none"
                  /* Script.ResultOwnership.None */
                ),
                source: realm.source
              }
            }, browsingContext.id);
          }
        } catch (error) {
          (_b2 = __privateGet(this, _logger)) == null ? void 0 : _b2.call(this, log_js_1.LogType.debugError, error);
          break;
        }
      }
    }, getHandleFromWindow_fn = async function(realm) {
      const channelHandleResult = await realm.cdpClient.sendCommand("Runtime.callFunctionOn", {
        functionDeclaration: String((id) => {
          const w = window;
          if (w[id] === void 0) {
            return new Promise((resolve) => w[id] = resolve);
          }
          const channelProxy = w[id];
          delete w[id];
          return channelProxy;
        }),
        arguments: [{ value: __privateGet(this, _id7) }],
        executionContextId: realm.executionContextId,
        awaitPromise: true,
        serializationOptions: {
          serialization: "idOnly"
        }
      });
      if (channelHandleResult.exceptionDetails !== void 0 || channelHandleResult.result.objectId === void 0) {
        throw new Error(`ChannelHandle not found in window["${__privateGet(this, _id7)}"]`);
      }
      return channelHandleResult.result.objectId;
    }, __privateAdd(_a3, _ChannelProxy_static), _a3);
    ChannelProxy.ChannelProxy = ChannelProxy$1;
    return ChannelProxy;
  }
  var hasRequiredPreloadScript;
  function requirePreloadScript() {
    var _id7, _cdpPreloadScripts, _functionDeclaration, _targetIds, _channels, _sandbox, _contexts2, _PreloadScript_instances, getEvaluateString_fn, _a3;
    if (hasRequiredPreloadScript) return PreloadScript;
    hasRequiredPreloadScript = 1;
    Object.defineProperty(PreloadScript, "__esModule", { value: true });
    PreloadScript.PreloadScript = void 0;
    const uuid_js_1 = requireUuid();
    const ChannelProxy_js_1 = requireChannelProxy();
    let PreloadScript$1 = (_a3 = class {
      constructor(params, logger2) {
        __privateAdd(this, _PreloadScript_instances);
        /** BiDi ID, an automatically generated UUID. */
        __privateAdd(this, _id7, (0, uuid_js_1.uuidv4)());
        /** CDP preload scripts. */
        __privateAdd(this, _cdpPreloadScripts, []);
        /** The script itself, in a format expected by the spec i.e. a function. */
        __privateAdd(this, _functionDeclaration);
        /** Targets, in which the preload script is initialized. */
        __privateAdd(this, _targetIds, /* @__PURE__ */ new Set());
        /** Channels to be added as arguments to functionDeclaration. */
        __privateAdd(this, _channels);
        /** The script sandbox / world name. */
        __privateAdd(this, _sandbox);
        /** The browsing contexts to execute the preload scripts in, if any. */
        __privateAdd(this, _contexts2);
        var _a4;
        __privateSet(this, _channels, ((_a4 = params.arguments) == null ? void 0 : _a4.map((a) => new ChannelProxy_js_1.ChannelProxy(a.value, logger2))) ?? []);
        __privateSet(this, _functionDeclaration, params.functionDeclaration);
        __privateSet(this, _sandbox, params.sandbox);
        __privateSet(this, _contexts2, params.contexts);
      }
      get id() {
        return __privateGet(this, _id7);
      }
      get targetIds() {
        return __privateGet(this, _targetIds);
      }
      /** Channels of the preload script. */
      get channels() {
        return __privateGet(this, _channels);
      }
      /** Contexts of the preload script, if any */
      get contexts() {
        return __privateGet(this, _contexts2);
      }
      /**
       * Adds the script to the given CDP targets by calling the
       * `Page.addScriptToEvaluateOnNewDocument` command.
       */
      async initInTargets(cdpTargets, runImmediately) {
        await Promise.all(Array.from(cdpTargets).map((cdpTarget) => this.initInTarget(cdpTarget, runImmediately)));
      }
      /**
       * Adds the script to the given CDP target by calling the
       * `Page.addScriptToEvaluateOnNewDocument` command.
       */
      async initInTarget(cdpTarget, runImmediately) {
        const addCdpPreloadScriptResult = await cdpTarget.cdpClient.sendCommand("Page.addScriptToEvaluateOnNewDocument", {
          source: __privateMethod(this, _PreloadScript_instances, getEvaluateString_fn).call(this),
          worldName: __privateGet(this, _sandbox),
          runImmediately
        });
        __privateGet(this, _cdpPreloadScripts).push({
          target: cdpTarget,
          preloadScriptId: addCdpPreloadScriptResult.identifier
        });
        __privateGet(this, _targetIds).add(cdpTarget.id);
      }
      /**
       * Removes this script from all CDP targets.
       */
      async remove() {
        await Promise.all([
          __privateGet(this, _cdpPreloadScripts).map(async (cdpPreloadScript) => {
            const cdpTarget = cdpPreloadScript.target;
            const cdpPreloadScriptId = cdpPreloadScript.preloadScriptId;
            return await cdpTarget.cdpClient.sendCommand("Page.removeScriptToEvaluateOnNewDocument", {
              identifier: cdpPreloadScriptId
            });
          })
        ]);
      }
      /** Removes the provided cdp target from the list of cdp preload scripts. */
      dispose(cdpTargetId) {
        __privateSet(this, _cdpPreloadScripts, __privateGet(this, _cdpPreloadScripts).filter((cdpPreloadScript) => {
          var _a4;
          return ((_a4 = cdpPreloadScript.target) == null ? void 0 : _a4.id) !== cdpTargetId;
        }));
        __privateGet(this, _targetIds).delete(cdpTargetId);
      }
    }, _id7 = new WeakMap(), _cdpPreloadScripts = new WeakMap(), _functionDeclaration = new WeakMap(), _targetIds = new WeakMap(), _channels = new WeakMap(), _sandbox = new WeakMap(), _contexts2 = new WeakMap(), _PreloadScript_instances = new WeakSet(), /**
     * String to be evaluated. Wraps user-provided function so that the following
     * steps are run:
     * 1. Create channels.
     * 2. Store the created channels in window.
     * 3. Call the user-provided function with channels as arguments.
     */
    getEvaluateString_fn = function() {
      const channelsArgStr = `[${this.channels.map((c) => c.getEvalInWindowStr()).join(", ")}]`;
      return `(()=>{(${__privateGet(this, _functionDeclaration)})(...${channelsArgStr})})()`;
    }, _a3);
    PreloadScript.PreloadScript = PreloadScript$1;
    return PreloadScript;
  }
  var hasRequiredScriptProcessor;
  function requireScriptProcessor() {
    var _eventManager, _browsingContextStorage, _realmStorage, _preloadScriptStorage, _logger, _ScriptProcessor_instances, onRealmCreatedSubscribeHook_fn, getRealm_fn2, _a3;
    if (hasRequiredScriptProcessor) return ScriptProcessor;
    hasRequiredScriptProcessor = 1;
    Object.defineProperty(ScriptProcessor, "__esModule", { value: true });
    ScriptProcessor.ScriptProcessor = void 0;
    const protocol_js_1 = requireProtocol();
    const PreloadScript_js_1 = requirePreloadScript();
    let ScriptProcessor$1 = (_a3 = class {
      constructor(eventManager, browsingContextStorage, realmStorage, preloadScriptStorage, logger2) {
        __privateAdd(this, _ScriptProcessor_instances);
        __privateAdd(this, _eventManager);
        __privateAdd(this, _browsingContextStorage);
        __privateAdd(this, _realmStorage);
        __privateAdd(this, _preloadScriptStorage);
        __privateAdd(this, _logger);
        __privateSet(this, _browsingContextStorage, browsingContextStorage);
        __privateSet(this, _realmStorage, realmStorage);
        __privateSet(this, _preloadScriptStorage, preloadScriptStorage);
        __privateSet(this, _logger, logger2);
        __privateSet(this, _eventManager, eventManager);
        __privateGet(this, _eventManager).addSubscribeHook(protocol_js_1.ChromiumBidi.Script.EventNames.RealmCreated, __privateMethod(this, _ScriptProcessor_instances, onRealmCreatedSubscribeHook_fn).bind(this));
      }
      async addPreloadScript(params) {
        const contexts = __privateGet(this, _browsingContextStorage).verifyTopLevelContextsList(params.contexts);
        const preloadScript = new PreloadScript_js_1.PreloadScript(params, __privateGet(this, _logger));
        __privateGet(this, _preloadScriptStorage).add(preloadScript);
        const cdpTargets = contexts.size === 0 ? new Set(__privateGet(this, _browsingContextStorage).getTopLevelContexts().map((context) => context.cdpTarget)) : new Set([...contexts.values()].map((context) => context.cdpTarget));
        await preloadScript.initInTargets(cdpTargets, false);
        return {
          script: preloadScript.id
        };
      }
      async removePreloadScript(params) {
        const { script: id } = params;
        const scripts = __privateGet(this, _preloadScriptStorage).find({ id });
        if (scripts.length === 0) {
          throw new protocol_js_1.NoSuchScriptException(`No preload script with id '${id}'`);
        }
        await Promise.all(scripts.map((script) => script.remove()));
        __privateGet(this, _preloadScriptStorage).remove({ id });
        return {};
      }
      async callFunction(params) {
        const realm = await __privateMethod(this, _ScriptProcessor_instances, getRealm_fn2).call(this, params.target);
        return await realm.callFunction(params.functionDeclaration, params.awaitPromise, params.this, params.arguments, params.resultOwnership, params.serializationOptions, params.userActivation);
      }
      async evaluate(params) {
        const realm = await __privateMethod(this, _ScriptProcessor_instances, getRealm_fn2).call(this, params.target);
        return await realm.evaluate(params.expression, params.awaitPromise, params.resultOwnership, params.serializationOptions, params.userActivation);
      }
      async disown(params) {
        const realm = await __privateMethod(this, _ScriptProcessor_instances, getRealm_fn2).call(this, params.target);
        await Promise.all(params.handles.map(async (handle) => await realm.disown(handle)));
        return {};
      }
      getRealms(params) {
        if (params.context !== void 0) {
          __privateGet(this, _browsingContextStorage).getContext(params.context);
        }
        const realms = __privateGet(this, _realmStorage).findRealms({
          browsingContextId: params.context,
          type: params.type
        }).map((realm) => realm.realmInfo);
        return { realms };
      }
    }, _eventManager = new WeakMap(), _browsingContextStorage = new WeakMap(), _realmStorage = new WeakMap(), _preloadScriptStorage = new WeakMap(), _logger = new WeakMap(), _ScriptProcessor_instances = new WeakSet(), onRealmCreatedSubscribeHook_fn = function(contextId) {
      const context = __privateGet(this, _browsingContextStorage).getContext(contextId);
      const contextsToReport = [
        context,
        ...__privateGet(this, _browsingContextStorage).getContext(contextId).allChildren
      ];
      const realms = /* @__PURE__ */ new Set();
      for (const reportContext of contextsToReport) {
        const realmsForContext = __privateGet(this, _realmStorage).findRealms({
          browsingContextId: reportContext.id
        });
        for (const realm of realmsForContext) {
          realms.add(realm);
        }
      }
      for (const realm of realms) {
        __privateGet(this, _eventManager).registerEvent({
          type: "event",
          method: protocol_js_1.ChromiumBidi.Script.EventNames.RealmCreated,
          params: realm.realmInfo
        }, context.id);
      }
      return Promise.resolve();
    }, getRealm_fn2 = async function(target) {
      if ("context" in target) {
        const context = __privateGet(this, _browsingContextStorage).getContext(target.context);
        return await context.getOrCreateSandbox(target.sandbox);
      }
      return __privateGet(this, _realmStorage).getRealm({
        realmId: target.realm
      });
    }, _a3);
    ScriptProcessor.ScriptProcessor = ScriptProcessor$1;
    return ScriptProcessor;
  }
  var SessionProcessor = {};
  var hasRequiredSessionProcessor;
  function requireSessionProcessor() {
    var _eventManager, _browserCdpClient, _initConnection, _created, _SessionProcessor_instances, mergeCapabilities_fn, getUnhandledPromptBehavior_fn, _a3;
    if (hasRequiredSessionProcessor) return SessionProcessor;
    hasRequiredSessionProcessor = 1;
    Object.defineProperty(SessionProcessor, "__esModule", { value: true });
    SessionProcessor.SessionProcessor = void 0;
    const protocol_js_1 = requireProtocol();
    let SessionProcessor$1 = (_a3 = class {
      constructor(eventManager, browserCdpClient, initConnection) {
        __privateAdd(this, _SessionProcessor_instances);
        __privateAdd(this, _eventManager);
        __privateAdd(this, _browserCdpClient);
        __privateAdd(this, _initConnection);
        __privateAdd(this, _created, false);
        __privateSet(this, _eventManager, eventManager);
        __privateSet(this, _browserCdpClient, browserCdpClient);
        __privateSet(this, _initConnection, initConnection);
      }
      status() {
        return { ready: false, message: "already connected" };
      }
      async new(params) {
        if (__privateGet(this, _created)) {
          throw new Error("Session has been already created.");
        }
        __privateSet(this, _created, true);
        const matchedCapabitlites = __privateMethod(this, _SessionProcessor_instances, mergeCapabilities_fn).call(this, params.capabilities);
        await __privateGet(this, _initConnection).call(this, matchedCapabitlites);
        const version2 = await __privateGet(this, _browserCdpClient).sendCommand("Browser.getVersion");
        return {
          sessionId: "unknown",
          capabilities: {
            ...matchedCapabitlites,
            acceptInsecureCerts: matchedCapabitlites.acceptInsecureCerts ?? false,
            browserName: version2.product,
            browserVersion: version2.revision,
            platformName: "",
            setWindowRect: false,
            webSocketUrl: "",
            userAgent: version2.userAgent
          }
        };
      }
      async subscribe(params, channel = {}) {
        const subscription = await __privateGet(this, _eventManager).subscribe(params.events, params.contexts ?? [], channel);
        return {
          subscription
        };
      }
      async unsubscribe(params, channel = {}) {
        await __privateGet(this, _eventManager).unsubscribe(params.events, params.contexts ?? [], channel);
        return {};
      }
    }, _eventManager = new WeakMap(), _browserCdpClient = new WeakMap(), _initConnection = new WeakMap(), _created = new WeakMap(), _SessionProcessor_instances = new WeakSet(), mergeCapabilities_fn = function(capabilitiesRequest) {
      const mergedCapabilities = [];
      for (const first2 of capabilitiesRequest.firstMatch ?? [{}]) {
        const result = {
          ...capabilitiesRequest.alwaysMatch
        };
        for (const key of Object.keys(first2)) {
          if (result[key] !== void 0) {
            throw new protocol_js_1.InvalidArgumentException(`Capability ${key} in firstMatch is already defined in alwaysMatch`);
          }
          result[key] = first2[key];
        }
        mergedCapabilities.push(result);
      }
      const match = mergedCapabilities.find((c) => c.browserName === "chrome") ?? mergedCapabilities[0] ?? {};
      match.unhandledPromptBehavior = __privateMethod(this, _SessionProcessor_instances, getUnhandledPromptBehavior_fn).call(this, match.unhandledPromptBehavior);
      return match;
    }, getUnhandledPromptBehavior_fn = function(capabilityValue) {
      if (capabilityValue === void 0) {
        return void 0;
      }
      if (typeof capabilityValue === "object") {
        return capabilityValue;
      }
      if (typeof capabilityValue !== "string") {
        throw new protocol_js_1.InvalidArgumentException(`Unexpected 'unhandledPromptBehavior' type: ${typeof capabilityValue}`);
      }
      switch (capabilityValue) {
        case "accept":
        case "accept and notify":
          return {
            default: "accept"
            /* Session.UserPromptHandlerType.Accept */
          };
        case "dismiss":
        case "dismiss and notify":
          return {
            default: "dismiss"
            /* Session.UserPromptHandlerType.Dismiss */
          };
        case "ignore":
          return {
            default: "ignore"
            /* Session.UserPromptHandlerType.Ignore */
          };
        default:
          throw new protocol_js_1.InvalidArgumentException(`Unexpected 'unhandledPromptBehavior' value: ${capabilityValue}`);
      }
    }, _a3);
    SessionProcessor.SessionProcessor = SessionProcessor$1;
    return SessionProcessor;
  }
  var StorageProcessor = {};
  var hasRequiredStorageProcessor;
  function requireStorageProcessor() {
    var _browserCdpClient, _browsingContextStorage, _logger, _StorageProcessor_instances, isNoSuchUserContextError_fn, getCdpBrowserContextId_fn, expandStoragePartitionSpecByBrowsingContext_fn, expandStoragePartitionSpecByStorageKey_fn, expandStoragePartitionSpec_fn, matchCookie_fn, _a3;
    if (hasRequiredStorageProcessor) return StorageProcessor;
    hasRequiredStorageProcessor = 1;
    Object.defineProperty(StorageProcessor, "__esModule", { value: true });
    StorageProcessor.StorageProcessor = void 0;
    const protocol_js_1 = requireProtocol();
    const assert_js_1 = requireAssert();
    const log_js_1 = requireLog();
    const NetworkProcessor_js_1 = requireNetworkProcessor();
    const NetworkUtils_js_1 = requireNetworkUtils();
    let StorageProcessor$1 = (_a3 = class {
      constructor(browserCdpClient, browsingContextStorage, logger2) {
        __privateAdd(this, _StorageProcessor_instances);
        __privateAdd(this, _browserCdpClient);
        __privateAdd(this, _browsingContextStorage);
        __privateAdd(this, _logger);
        __privateSet(this, _browsingContextStorage, browsingContextStorage);
        __privateSet(this, _browserCdpClient, browserCdpClient);
        __privateSet(this, _logger, logger2);
      }
      async deleteCookies(params) {
        const partitionKey = __privateMethod(this, _StorageProcessor_instances, expandStoragePartitionSpec_fn).call(this, params.partition);
        let cdpResponse;
        try {
          cdpResponse = await __privateGet(this, _browserCdpClient).sendCommand("Storage.getCookies", {
            browserContextId: __privateMethod(this, _StorageProcessor_instances, getCdpBrowserContextId_fn).call(this, partitionKey)
          });
        } catch (err) {
          if (__privateMethod(this, _StorageProcessor_instances, isNoSuchUserContextError_fn).call(this, err)) {
            throw new protocol_js_1.NoSuchUserContextException(err.message);
          }
          throw err;
        }
        const cdpCookiesToDelete = cdpResponse.cookies.filter(
          // CDP's partition key is the source origin. If the request specifies the
          // `sourceOrigin` partition key, only cookies with the requested source origin
          // are returned.
          (c) => {
            var _a4;
            return partitionKey.sourceOrigin === void 0 || ((_a4 = c.partitionKey) == null ? void 0 : _a4.topLevelSite) === partitionKey.sourceOrigin;
          }
        ).filter((cdpCookie) => {
          const bidiCookie = (0, NetworkUtils_js_1.cdpToBiDiCookie)(cdpCookie);
          return __privateMethod(this, _StorageProcessor_instances, matchCookie_fn).call(this, bidiCookie, params.filter);
        }).map((cookie) => ({
          ...cookie,
          // Set expiry to pass date to delete the cookie.
          expires: 1
        }));
        await __privateGet(this, _browserCdpClient).sendCommand("Storage.setCookies", {
          cookies: cdpCookiesToDelete,
          browserContextId: __privateMethod(this, _StorageProcessor_instances, getCdpBrowserContextId_fn).call(this, partitionKey)
        });
        return {
          partitionKey
        };
      }
      async getCookies(params) {
        const partitionKey = __privateMethod(this, _StorageProcessor_instances, expandStoragePartitionSpec_fn).call(this, params.partition);
        let cdpResponse;
        try {
          cdpResponse = await __privateGet(this, _browserCdpClient).sendCommand("Storage.getCookies", {
            browserContextId: __privateMethod(this, _StorageProcessor_instances, getCdpBrowserContextId_fn).call(this, partitionKey)
          });
        } catch (err) {
          if (__privateMethod(this, _StorageProcessor_instances, isNoSuchUserContextError_fn).call(this, err)) {
            throw new protocol_js_1.NoSuchUserContextException(err.message);
          }
          throw err;
        }
        const filteredBiDiCookies = cdpResponse.cookies.filter(
          // CDP's partition key is the source origin. If the request specifies the
          // `sourceOrigin` partition key, only cookies with the requested source origin
          // are returned.
          (c) => {
            var _a4;
            return partitionKey.sourceOrigin === void 0 || ((_a4 = c.partitionKey) == null ? void 0 : _a4.topLevelSite) === partitionKey.sourceOrigin;
          }
        ).map((c) => (0, NetworkUtils_js_1.cdpToBiDiCookie)(c)).filter((c) => __privateMethod(this, _StorageProcessor_instances, matchCookie_fn).call(this, c, params.filter));
        return {
          cookies: filteredBiDiCookies,
          partitionKey
        };
      }
      async setCookie(params) {
        var _a4;
        const partitionKey = __privateMethod(this, _StorageProcessor_instances, expandStoragePartitionSpec_fn).call(this, params.partition);
        const cdpCookie = (0, NetworkUtils_js_1.bidiToCdpCookie)(params, partitionKey);
        try {
          await __privateGet(this, _browserCdpClient).sendCommand("Storage.setCookies", {
            cookies: [cdpCookie],
            browserContextId: __privateMethod(this, _StorageProcessor_instances, getCdpBrowserContextId_fn).call(this, partitionKey)
          });
        } catch (err) {
          if (__privateMethod(this, _StorageProcessor_instances, isNoSuchUserContextError_fn).call(this, err)) {
            throw new protocol_js_1.NoSuchUserContextException(err.message);
          }
          (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, log_js_1.LogType.debugError, err);
          throw new protocol_js_1.UnableToSetCookieException(err.toString());
        }
        return {
          partitionKey
        };
      }
    }, _browserCdpClient = new WeakMap(), _browsingContextStorage = new WeakMap(), _logger = new WeakMap(), _StorageProcessor_instances = new WeakSet(), isNoSuchUserContextError_fn = function(err) {
      var _a4;
      return (_a4 = err.message) == null ? void 0 : _a4.startsWith("Failed to find browser context for id");
    }, getCdpBrowserContextId_fn = function(partitionKey) {
      return partitionKey.userContext === "default" ? void 0 : partitionKey.userContext;
    }, expandStoragePartitionSpecByBrowsingContext_fn = function(descriptor) {
      const browsingContextId = descriptor.context;
      const browsingContext = __privateGet(this, _browsingContextStorage).getContext(browsingContextId);
      return {
        userContext: browsingContext.userContext
      };
    }, expandStoragePartitionSpecByStorageKey_fn = function(descriptor) {
      var _a4;
      const unsupportedPartitionKeys = /* @__PURE__ */ new Map();
      let sourceOrigin = descriptor.sourceOrigin;
      if (sourceOrigin !== void 0) {
        const url = NetworkProcessor_js_1.NetworkProcessor.parseUrlString(sourceOrigin);
        if (url.origin === "null") {
          sourceOrigin = url.origin;
        } else {
          sourceOrigin = `${url.protocol}//${url.hostname}`;
        }
      }
      for (const [key, value] of Object.entries(descriptor)) {
        if (key !== void 0 && value !== void 0 && !["type", "sourceOrigin", "userContext"].includes(key)) {
          unsupportedPartitionKeys.set(key, value);
        }
      }
      if (unsupportedPartitionKeys.size > 0) {
        (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, log_js_1.LogType.debugInfo, `Unsupported partition keys: ${JSON.stringify(Object.fromEntries(unsupportedPartitionKeys))}`);
      }
      const userContext = descriptor.userContext ?? "default";
      return {
        userContext,
        ...sourceOrigin === void 0 ? {} : { sourceOrigin }
      };
    }, expandStoragePartitionSpec_fn = function(partitionSpec) {
      if (partitionSpec === void 0) {
        return { userContext: "default" };
      }
      if (partitionSpec.type === "context") {
        return __privateMethod(this, _StorageProcessor_instances, expandStoragePartitionSpecByBrowsingContext_fn).call(this, partitionSpec);
      }
      (0, assert_js_1.assert)(partitionSpec.type === "storageKey", "Unknown partition type");
      return __privateMethod(this, _StorageProcessor_instances, expandStoragePartitionSpecByStorageKey_fn).call(this, partitionSpec);
    }, matchCookie_fn = function(cookie, filter2) {
      if (filter2 === void 0) {
        return true;
      }
      return (filter2.domain === void 0 || filter2.domain === cookie.domain) && (filter2.name === void 0 || filter2.name === cookie.name) && // `value` contains fields `type` and `value`.
      (filter2.value === void 0 || (0, NetworkUtils_js_1.deserializeByteValue)(filter2.value) === (0, NetworkUtils_js_1.deserializeByteValue)(cookie.value)) && (filter2.path === void 0 || filter2.path === cookie.path) && (filter2.size === void 0 || filter2.size === cookie.size) && (filter2.httpOnly === void 0 || filter2.httpOnly === cookie.httpOnly) && (filter2.secure === void 0 || filter2.secure === cookie.secure) && (filter2.sameSite === void 0 || filter2.sameSite === cookie.sameSite) && (filter2.expiry === void 0 || filter2.expiry === cookie.expiry);
    }, _a3);
    StorageProcessor.StorageProcessor = StorageProcessor$1;
    return StorageProcessor;
  }
  var OutgoingMessage = {};
  var hasRequiredOutgoingMessage;
  function requireOutgoingMessage() {
    var _message2, _channel2, _a3;
    if (hasRequiredOutgoingMessage) return OutgoingMessage;
    hasRequiredOutgoingMessage = 1;
    Object.defineProperty(OutgoingMessage, "__esModule", { value: true });
    OutgoingMessage.OutgoingMessage = void 0;
    let OutgoingMessage$1 = (_a3 = class {
      constructor(message, channel) {
        __privateAdd(this, _message2);
        __privateAdd(this, _channel2);
        __privateSet(this, _message2, message);
        __privateSet(this, _channel2, channel);
      }
      static createFromPromise(messagePromise, channel) {
        return messagePromise.then((message) => {
          if (message.kind === "success") {
            return {
              kind: "success",
              value: new _a3(message.value, channel)
            };
          }
          return message;
        });
      }
      static createResolved(message, channel) {
        return Promise.resolve({
          kind: "success",
          value: new _a3(message, channel)
        });
      }
      get message() {
        return __privateGet(this, _message2);
      }
      get channel() {
        return __privateGet(this, _channel2);
      }
    }, _message2 = new WeakMap(), _channel2 = new WeakMap(), _a3);
    OutgoingMessage.OutgoingMessage = OutgoingMessage$1;
    return OutgoingMessage;
  }
  var hasRequiredCommandProcessor;
  function requireCommandProcessor() {
    var _bluetoothProcessor, _browserProcessor, _browsingContextProcessor, _cdpProcessor, _inputProcessor, _networkProcessor, _permissionsProcessor, _scriptProcessor, _sessionProcessor, _storageProcessor, _parser, _logger, _CommandProcessor_instances, processCommand_fn, processTargetParams_fn, _a3;
    if (hasRequiredCommandProcessor) return CommandProcessor;
    hasRequiredCommandProcessor = 1;
    Object.defineProperty(CommandProcessor, "__esModule", { value: true });
    CommandProcessor.CommandProcessor = void 0;
    const protocol_js_1 = requireProtocol();
    const EventEmitter_js_1 = requireEventEmitter();
    const log_js_1 = requireLog();
    const BidiNoOpParser_js_1 = requireBidiNoOpParser();
    const BrowserProcessor_js_1 = requireBrowserProcessor();
    const CdpProcessor_js_1 = requireCdpProcessor();
    const BrowsingContextProcessor_js_1 = requireBrowsingContextProcessor();
    const InputProcessor_js_1 = requireInputProcessor();
    const NetworkProcessor_js_1 = requireNetworkProcessor();
    const PermissionsProcessor_js_1 = requirePermissionsProcessor();
    const ScriptProcessor_js_1 = requireScriptProcessor();
    const SessionProcessor_js_1 = requireSessionProcessor();
    const StorageProcessor_js_1 = requireStorageProcessor();
    const OutgoingMessage_js_1 = requireOutgoingMessage();
    let CommandProcessor$1 = (_a3 = class extends EventEmitter_js_1.EventEmitter {
      constructor(cdpConnection, browserCdpClient, eventManager, browsingContextStorage, realmStorage, preloadScriptStorage, networkStorage, bluetoothProcessor, parser = new BidiNoOpParser_js_1.BidiNoOpParser(), initConnection, logger2) {
        super();
        __privateAdd(this, _CommandProcessor_instances);
        // keep-sorted start
        __privateAdd(this, _bluetoothProcessor);
        __privateAdd(this, _browserProcessor);
        __privateAdd(this, _browsingContextProcessor);
        __privateAdd(this, _cdpProcessor);
        __privateAdd(this, _inputProcessor);
        __privateAdd(this, _networkProcessor);
        __privateAdd(this, _permissionsProcessor);
        __privateAdd(this, _scriptProcessor);
        __privateAdd(this, _sessionProcessor);
        __privateAdd(this, _storageProcessor);
        // keep-sorted end
        __privateAdd(this, _parser);
        __privateAdd(this, _logger);
        __privateSet(this, _parser, parser);
        __privateSet(this, _logger, logger2);
        __privateSet(this, _bluetoothProcessor, bluetoothProcessor);
        __privateSet(this, _browserProcessor, new BrowserProcessor_js_1.BrowserProcessor(browserCdpClient, browsingContextStorage));
        __privateSet(this, _browsingContextProcessor, new BrowsingContextProcessor_js_1.BrowsingContextProcessor(browserCdpClient, browsingContextStorage, eventManager));
        __privateSet(this, _cdpProcessor, new CdpProcessor_js_1.CdpProcessor(browsingContextStorage, realmStorage, cdpConnection, browserCdpClient));
        __privateSet(this, _inputProcessor, new InputProcessor_js_1.InputProcessor(browsingContextStorage));
        __privateSet(this, _networkProcessor, new NetworkProcessor_js_1.NetworkProcessor(browsingContextStorage, networkStorage));
        __privateSet(this, _permissionsProcessor, new PermissionsProcessor_js_1.PermissionsProcessor(browserCdpClient));
        __privateSet(this, _scriptProcessor, new ScriptProcessor_js_1.ScriptProcessor(eventManager, browsingContextStorage, realmStorage, preloadScriptStorage, logger2));
        __privateSet(this, _sessionProcessor, new SessionProcessor_js_1.SessionProcessor(eventManager, browserCdpClient, initConnection));
        __privateSet(this, _storageProcessor, new StorageProcessor_js_1.StorageProcessor(browserCdpClient, browsingContextStorage, logger2));
      }
      async processCommand(command) {
        var _a4;
        try {
          const result = await __privateMethod(this, _CommandProcessor_instances, processCommand_fn).call(this, command);
          const response = {
            type: "success",
            id: command.id,
            result
          };
          this.emit("response", {
            message: OutgoingMessage_js_1.OutgoingMessage.createResolved(response, command.channel),
            event: command.method
          });
        } catch (e) {
          if (e instanceof protocol_js_1.Exception) {
            this.emit("response", {
              message: OutgoingMessage_js_1.OutgoingMessage.createResolved(e.toErrorResponse(command.id), command.channel),
              event: command.method
            });
          } else {
            const error = e;
            (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, log_js_1.LogType.bidi, error);
            this.emit("response", {
              message: OutgoingMessage_js_1.OutgoingMessage.createResolved(new protocol_js_1.UnknownErrorException(error.message, error.stack).toErrorResponse(command.id), command.channel),
              event: command.method
            });
          }
        }
      }
    }, _bluetoothProcessor = new WeakMap(), _browserProcessor = new WeakMap(), _browsingContextProcessor = new WeakMap(), _cdpProcessor = new WeakMap(), _inputProcessor = new WeakMap(), _networkProcessor = new WeakMap(), _permissionsProcessor = new WeakMap(), _scriptProcessor = new WeakMap(), _sessionProcessor = new WeakMap(), _storageProcessor = new WeakMap(), _parser = new WeakMap(), _logger = new WeakMap(), _CommandProcessor_instances = new WeakSet(), processCommand_fn = async function(command) {
      switch (command.method) {
        // Bluetooth module
        // keep-sorted start block=yes
        case "bluetooth.handleRequestDevicePrompt":
          return await __privateGet(this, _bluetoothProcessor).handleRequestDevicePrompt(__privateGet(this, _parser).parseHandleRequestDevicePromptParams(command.params));
        case "bluetooth.simulateAdapter":
          return await __privateGet(this, _bluetoothProcessor).simulateAdapter(__privateGet(this, _parser).parseSimulateAdapterParameters(command.params));
        case "bluetooth.simulateAdvertisement":
          return await __privateGet(this, _bluetoothProcessor).simulateAdvertisement(__privateGet(this, _parser).parseSimulateAdvertisementParameters(command.params));
        case "bluetooth.simulatePreconnectedPeripheral":
          return await __privateGet(this, _bluetoothProcessor).simulatePreconnectedPeripheral(__privateGet(this, _parser).parseSimulatePreconnectedPeripheralParameters(command.params));
        // keep-sorted end
        // Browser module
        // keep-sorted start block=yes
        case "browser.close":
          return __privateGet(this, _browserProcessor).close();
        case "browser.createUserContext":
          return await __privateGet(this, _browserProcessor).createUserContext(command.params);
        case "browser.getClientWindows":
          return await __privateGet(this, _browserProcessor).getClientWindows();
        case "browser.getUserContexts":
          return await __privateGet(this, _browserProcessor).getUserContexts();
        case "browser.removeUserContext":
          return await __privateGet(this, _browserProcessor).removeUserContext(__privateGet(this, _parser).parseRemoveUserContextParams(command.params));
        case "browser.setClientWindowState":
          throw new protocol_js_1.UnknownErrorException(`Method ${command.method} is not implemented.`);
        // keep-sorted end
        // Browsing Context module
        // keep-sorted start block=yes
        case "browsingContext.activate":
          return await __privateGet(this, _browsingContextProcessor).activate(__privateGet(this, _parser).parseActivateParams(command.params));
        case "browsingContext.captureScreenshot":
          return await __privateGet(this, _browsingContextProcessor).captureScreenshot(__privateGet(this, _parser).parseCaptureScreenshotParams(command.params));
        case "browsingContext.close":
          return await __privateGet(this, _browsingContextProcessor).close(__privateGet(this, _parser).parseCloseParams(command.params));
        case "browsingContext.create":
          return await __privateGet(this, _browsingContextProcessor).create(__privateGet(this, _parser).parseCreateParams(command.params));
        case "browsingContext.getTree":
          return __privateGet(this, _browsingContextProcessor).getTree(__privateGet(this, _parser).parseGetTreeParams(command.params));
        case "browsingContext.handleUserPrompt":
          return await __privateGet(this, _browsingContextProcessor).handleUserPrompt(__privateGet(this, _parser).parseHandleUserPromptParams(command.params));
        case "browsingContext.locateNodes":
          return await __privateGet(this, _browsingContextProcessor).locateNodes(__privateGet(this, _parser).parseLocateNodesParams(command.params));
        case "browsingContext.navigate":
          return await __privateGet(this, _browsingContextProcessor).navigate(__privateGet(this, _parser).parseNavigateParams(command.params));
        case "browsingContext.print":
          return await __privateGet(this, _browsingContextProcessor).print(__privateGet(this, _parser).parsePrintParams(command.params));
        case "browsingContext.reload":
          return await __privateGet(this, _browsingContextProcessor).reload(__privateGet(this, _parser).parseReloadParams(command.params));
        case "browsingContext.setViewport":
          return await __privateGet(this, _browsingContextProcessor).setViewport(__privateGet(this, _parser).parseSetViewportParams(command.params));
        case "browsingContext.traverseHistory":
          return await __privateGet(this, _browsingContextProcessor).traverseHistory(__privateGet(this, _parser).parseTraverseHistoryParams(command.params));
        // keep-sorted end
        // CDP module
        // keep-sorted start block=yes
        case "goog:cdp.getSession":
          return __privateGet(this, _cdpProcessor).getSession(__privateGet(this, _parser).parseGetSessionParams(command.params));
        case "goog:cdp.resolveRealm":
          return __privateGet(this, _cdpProcessor).resolveRealm(__privateGet(this, _parser).parseResolveRealmParams(command.params));
        case "goog:cdp.sendCommand":
          return await __privateGet(this, _cdpProcessor).sendCommand(__privateGet(this, _parser).parseSendCommandParams(command.params));
        // keep-sorted end
        // CDP deprecated domain.
        // https://github.com/GoogleChromeLabs/chromium-bidi/issues/2844
        // keep-sorted start block=yes
        case "cdp.getSession":
          return __privateGet(this, _cdpProcessor).getSession(__privateGet(this, _parser).parseGetSessionParams(command.params));
        case "cdp.resolveRealm":
          return __privateGet(this, _cdpProcessor).resolveRealm(__privateGet(this, _parser).parseResolveRealmParams(command.params));
        case "cdp.sendCommand":
          return await __privateGet(this, _cdpProcessor).sendCommand(__privateGet(this, _parser).parseSendCommandParams(command.params));
        // keep-sorted end
        // Input module
        // keep-sorted start block=yes
        case "input.performActions":
          return await __privateGet(this, _inputProcessor).performActions(__privateGet(this, _parser).parsePerformActionsParams(command.params));
        case "input.releaseActions":
          return await __privateGet(this, _inputProcessor).releaseActions(__privateGet(this, _parser).parseReleaseActionsParams(command.params));
        case "input.setFiles":
          return await __privateGet(this, _inputProcessor).setFiles(__privateGet(this, _parser).parseSetFilesParams(command.params));
        // keep-sorted end
        // Network module
        // keep-sorted start block=yes
        case "network.addIntercept":
          return await __privateGet(this, _networkProcessor).addIntercept(__privateGet(this, _parser).parseAddInterceptParams(command.params));
        case "network.continueRequest":
          return await __privateGet(this, _networkProcessor).continueRequest(__privateGet(this, _parser).parseContinueRequestParams(command.params));
        case "network.continueResponse":
          return await __privateGet(this, _networkProcessor).continueResponse(__privateGet(this, _parser).parseContinueResponseParams(command.params));
        case "network.continueWithAuth":
          return await __privateGet(this, _networkProcessor).continueWithAuth(__privateGet(this, _parser).parseContinueWithAuthParams(command.params));
        case "network.failRequest":
          return await __privateGet(this, _networkProcessor).failRequest(__privateGet(this, _parser).parseFailRequestParams(command.params));
        case "network.provideResponse":
          return await __privateGet(this, _networkProcessor).provideResponse(__privateGet(this, _parser).parseProvideResponseParams(command.params));
        case "network.removeIntercept":
          return await __privateGet(this, _networkProcessor).removeIntercept(__privateGet(this, _parser).parseRemoveInterceptParams(command.params));
        case "network.setCacheBehavior":
          return await __privateGet(this, _networkProcessor).setCacheBehavior(__privateGet(this, _parser).parseSetCacheBehavior(command.params));
        // keep-sorted end
        // Permissions module
        // keep-sorted start block=yes
        case "permissions.setPermission":
          return await __privateGet(this, _permissionsProcessor).setPermissions(__privateGet(this, _parser).parseSetPermissionsParams(command.params));
        // keep-sorted end
        // Script module
        // keep-sorted start block=yes
        case "script.addPreloadScript":
          return await __privateGet(this, _scriptProcessor).addPreloadScript(__privateGet(this, _parser).parseAddPreloadScriptParams(command.params));
        case "script.callFunction":
          return await __privateGet(this, _scriptProcessor).callFunction(__privateGet(this, _parser).parseCallFunctionParams(__privateMethod(this, _CommandProcessor_instances, processTargetParams_fn).call(this, command.params)));
        case "script.disown":
          return await __privateGet(this, _scriptProcessor).disown(__privateGet(this, _parser).parseDisownParams(__privateMethod(this, _CommandProcessor_instances, processTargetParams_fn).call(this, command.params)));
        case "script.evaluate":
          return await __privateGet(this, _scriptProcessor).evaluate(__privateGet(this, _parser).parseEvaluateParams(__privateMethod(this, _CommandProcessor_instances, processTargetParams_fn).call(this, command.params)));
        case "script.getRealms":
          return __privateGet(this, _scriptProcessor).getRealms(__privateGet(this, _parser).parseGetRealmsParams(command.params));
        case "script.removePreloadScript":
          return await __privateGet(this, _scriptProcessor).removePreloadScript(__privateGet(this, _parser).parseRemovePreloadScriptParams(command.params));
        // keep-sorted end
        // Session module
        // keep-sorted start block=yes
        case "session.end":
          throw new protocol_js_1.UnknownErrorException(`Method ${command.method} is not implemented.`);
        case "session.new":
          return await __privateGet(this, _sessionProcessor).new(command.params);
        case "session.status":
          return __privateGet(this, _sessionProcessor).status();
        case "session.subscribe":
          return await __privateGet(this, _sessionProcessor).subscribe(__privateGet(this, _parser).parseSubscribeParams(command.params), command.channel);
        case "session.unsubscribe":
          return await __privateGet(this, _sessionProcessor).unsubscribe(__privateGet(this, _parser).parseSubscribeParams(command.params), command.channel);
        // keep-sorted end
        // Storage module
        // keep-sorted start block=yes
        case "storage.deleteCookies":
          return await __privateGet(this, _storageProcessor).deleteCookies(__privateGet(this, _parser).parseDeleteCookiesParams(command.params));
        case "storage.getCookies":
          return await __privateGet(this, _storageProcessor).getCookies(__privateGet(this, _parser).parseGetCookiesParams(command.params));
        case "storage.setCookie":
          return await __privateGet(this, _storageProcessor).setCookie(__privateGet(this, _parser).parseSetCookieParams(command.params));
        // keep-sorted end
        // WebExtension module
        // keep-sorted start block=yes
        case "webExtension.install":
          throw new protocol_js_1.UnknownErrorException(`Method ${command.method} is not implemented.`);
        case "webExtension.uninstall":
          throw new protocol_js_1.UnknownErrorException(`Method ${command.method} is not implemented.`);
      }
      throw new protocol_js_1.UnknownCommandException(`Unknown command '${command == null ? void 0 : command.method}'.`);
    }, // Workaround for as zod.union always take the first schema
    // https://github.com/w3c/webdriver-bidi/issues/635
    processTargetParams_fn = function(params) {
      if (typeof params === "object" && params && "target" in params && typeof params.target === "object" && params.target && "context" in params.target) {
        delete params.target["realm"];
      }
      return params;
    }, _a3);
    CommandProcessor.CommandProcessor = CommandProcessor$1;
    return CommandProcessor;
  }
  var BluetoothProcessor = {};
  var hasRequiredBluetoothProcessor;
  function requireBluetoothProcessor() {
    var _eventManager, _browsingContextStorage, _a3;
    if (hasRequiredBluetoothProcessor) return BluetoothProcessor;
    hasRequiredBluetoothProcessor = 1;
    Object.defineProperty(BluetoothProcessor, "__esModule", { value: true });
    BluetoothProcessor.BluetoothProcessor = void 0;
    let BluetoothProcessor$1 = (_a3 = class {
      constructor(eventManager, browsingContextStorage) {
        __privateAdd(this, _eventManager);
        __privateAdd(this, _browsingContextStorage);
        __privateSet(this, _eventManager, eventManager);
        __privateSet(this, _browsingContextStorage, browsingContextStorage);
      }
      async simulateAdapter(params) {
        const context = __privateGet(this, _browsingContextStorage).getContext(params.context);
        await context.cdpTarget.browserCdpClient.sendCommand("BluetoothEmulation.disable");
        await context.cdpTarget.browserCdpClient.sendCommand("BluetoothEmulation.enable", {
          state: params.state
        });
        return {};
      }
      async simulatePreconnectedPeripheral(params) {
        const context = __privateGet(this, _browsingContextStorage).getContext(params.context);
        await context.cdpTarget.browserCdpClient.sendCommand("BluetoothEmulation.simulatePreconnectedPeripheral", {
          address: params.address,
          name: params.name,
          knownServiceUuids: params.knownServiceUuids,
          manufacturerData: params.manufacturerData
        });
        return {};
      }
      async simulateAdvertisement(params) {
        const context = __privateGet(this, _browsingContextStorage).getContext(params.context);
        await context.cdpTarget.browserCdpClient.sendCommand("BluetoothEmulation.simulateAdvertisement", {
          entry: params.scanEntry
        });
        return {};
      }
      onCdpTargetCreated(cdpTarget) {
        cdpTarget.cdpClient.on("DeviceAccess.deviceRequestPrompted", (event) => {
          __privateGet(this, _eventManager).registerEvent({
            type: "event",
            method: "bluetooth.requestDevicePromptUpdated",
            params: {
              context: cdpTarget.id,
              prompt: event.id,
              devices: event.devices
            }
          }, cdpTarget.id);
        });
      }
      async handleRequestDevicePrompt(params) {
        const context = __privateGet(this, _browsingContextStorage).getContext(params.context);
        if (params.accept) {
          await context.cdpTarget.cdpClient.sendCommand("DeviceAccess.selectPrompt", {
            id: params.prompt,
            deviceId: params.device
          });
        } else {
          await context.cdpTarget.cdpClient.sendCommand("DeviceAccess.cancelPrompt", {
            id: params.prompt
          });
        }
        return {};
      }
    }, _eventManager = new WeakMap(), _browsingContextStorage = new WeakMap(), _a3);
    BluetoothProcessor.BluetoothProcessor = BluetoothProcessor$1;
    return BluetoothProcessor;
  }
  var CdpTargetManager = {};
  var BrowsingContextImpl = {};
  var Deferred = {};
  var hasRequiredDeferred;
  function requireDeferred() {
    var _a3, _isFinished, _promise2, _result2, _resolve2, _reject, _b2;
    if (hasRequiredDeferred) return Deferred;
    hasRequiredDeferred = 1;
    Object.defineProperty(Deferred, "__esModule", { value: true });
    Deferred.Deferred = void 0;
    let Deferred$12 = (_a3 = Symbol.toStringTag, _b2 = class {
      constructor() {
        __privateAdd(this, _isFinished, false);
        __privateAdd(this, _promise2);
        __privateAdd(this, _result2);
        __privateAdd(this, _resolve2);
        __privateAdd(this, _reject);
        __publicField(this, _a3, "Promise");
        __privateSet(this, _promise2, new Promise((resolve, reject) => {
          __privateSet(this, _resolve2, resolve);
          __privateSet(this, _reject, reject);
        }));
        __privateGet(this, _promise2).catch((_error2) => {
        });
      }
      get isFinished() {
        return __privateGet(this, _isFinished);
      }
      get result() {
        if (!__privateGet(this, _isFinished)) {
          throw new Error("Deferred is not finished yet");
        }
        return __privateGet(this, _result2);
      }
      then(onFulfilled, onRejected) {
        return __privateGet(this, _promise2).then(onFulfilled, onRejected);
      }
      catch(onRejected) {
        return __privateGet(this, _promise2).catch(onRejected);
      }
      resolve(value) {
        __privateSet(this, _result2, value);
        if (!__privateGet(this, _isFinished)) {
          __privateSet(this, _isFinished, true);
          __privateGet(this, _resolve2).call(this, value);
        }
      }
      reject(reason) {
        if (!__privateGet(this, _isFinished)) {
          __privateSet(this, _isFinished, true);
          __privateGet(this, _reject).call(this, reason);
        }
      }
      finally(onFinally) {
        return __privateGet(this, _promise2).finally(onFinally);
      }
    }, _isFinished = new WeakMap(), _promise2 = new WeakMap(), _result2 = new WeakMap(), _resolve2 = new WeakMap(), _reject = new WeakMap(), _b2);
    Deferred.Deferred = Deferred$12;
    return Deferred;
  }
  var time = {};
  var hasRequiredTime;
  function requireTime() {
    if (hasRequiredTime) return time;
    hasRequiredTime = 1;
    Object.defineProperty(time, "__esModule", { value: true });
    time.getTimestamp = getTimestamp;
    function getTimestamp() {
      return (/* @__PURE__ */ new Date()).getTime();
    }
    return time;
  }
  var unitConversions = {};
  var hasRequiredUnitConversions;
  function requireUnitConversions() {
    if (hasRequiredUnitConversions) return unitConversions;
    hasRequiredUnitConversions = 1;
    Object.defineProperty(unitConversions, "__esModule", { value: true });
    unitConversions.inchesFromCm = inchesFromCm;
    function inchesFromCm(cm) {
      return cm / 2.54;
    }
    return unitConversions;
  }
  var WindowRealm$1 = {};
  var Realm$1 = {};
  var hasRequiredRealm;
  function requireRealm() {
    var _cdpClient, _eventManager, _executionContextId, _logger, _origin, _realmId, _realmStorage, _Realm_instances, registerEvent_fn, _Realm_static, cdpRemoteObjectToCallArgument_fn, flattenKeyValuePairs_fn, flattenValueList_fn, serializeCdpExceptionDetails_fn, getExceptionResult_fn, getSerializationOptions_fn, getAdditionalSerializationParameters_fn, getMaxObjectDepth_fn, releaseObject_fn;
    if (hasRequiredRealm) return Realm$1;
    hasRequiredRealm = 1;
    Object.defineProperty(Realm$1, "__esModule", { value: true });
    Realm$1.Realm = void 0;
    const protocol_js_1 = requireProtocol();
    const log_js_1 = requireLog();
    const uuid_js_1 = requireUuid();
    const ChannelProxy_js_1 = requireChannelProxy();
    const _Realm = class _Realm {
      constructor(cdpClient, eventManager, executionContextId, logger2, origin, realmId, realmStorage) {
        __privateAdd(this, _Realm_instances);
        __privateAdd(this, _cdpClient);
        __privateAdd(this, _eventManager);
        __privateAdd(this, _executionContextId);
        __privateAdd(this, _logger);
        __privateAdd(this, _origin);
        __privateAdd(this, _realmId);
        __privateAdd(this, _realmStorage);
        __privateSet(this, _cdpClient, cdpClient);
        __privateSet(this, _eventManager, eventManager);
        __privateSet(this, _executionContextId, executionContextId);
        __privateSet(this, _logger, logger2);
        __privateSet(this, _origin, origin);
        __privateSet(this, _realmId, realmId);
        __privateSet(this, _realmStorage, realmStorage);
        __privateGet(this, _realmStorage).addRealm(this);
      }
      cdpToBidiValue(cdpValue, resultOwnership) {
        const bidiValue = this.serializeForBiDi(cdpValue.result.deepSerializedValue, /* @__PURE__ */ new Map());
        if (cdpValue.result.objectId) {
          const objectId = cdpValue.result.objectId;
          if (resultOwnership === "root") {
            bidiValue.handle = objectId;
            __privateGet(this, _realmStorage).knownHandlesToRealmMap.set(objectId, this.realmId);
          } else {
            void __privateMethod(this, _Realm_instances, releaseObject_fn).call(this, objectId).catch((error) => {
              var _a3;
              return (_a3 = __privateGet(this, _logger)) == null ? void 0 : _a3.call(this, log_js_1.LogType.debugError, error);
            });
          }
        }
        return bidiValue;
      }
      /**
       * Relies on the CDP to implement proper BiDi serialization, except:
       * * CDP integer property `backendNodeId` is replaced with `sharedId` of
       * `{documentId}_element_{backendNodeId}`;
       * * CDP integer property `weakLocalObjectReference` is replaced with UUID `internalId`
       * using unique-per serialization `internalIdMap`.
       * * CDP type `platformobject` is replaced with `object`.
       * @param deepSerializedValue - CDP value to be converted to BiDi.
       * @param internalIdMap - Map from CDP integer `weakLocalObjectReference` to BiDi UUID
       * `internalId`.
       */
      serializeForBiDi(deepSerializedValue, internalIdMap) {
        if (Object.hasOwn(deepSerializedValue, "weakLocalObjectReference")) {
          const weakLocalObjectReference = deepSerializedValue.weakLocalObjectReference;
          if (!internalIdMap.has(weakLocalObjectReference)) {
            internalIdMap.set(weakLocalObjectReference, (0, uuid_js_1.uuidv4)());
          }
          deepSerializedValue.internalId = internalIdMap.get(weakLocalObjectReference);
          delete deepSerializedValue["weakLocalObjectReference"];
        }
        if (deepSerializedValue.type === "node" && deepSerializedValue.value && Object.hasOwn(deepSerializedValue.value, "frameId")) {
          delete deepSerializedValue.value["frameId"];
        }
        if (deepSerializedValue.type === "platformobject") {
          return { type: "object" };
        }
        const bidiValue = deepSerializedValue.value;
        if (bidiValue === void 0) {
          return deepSerializedValue;
        }
        if (["array", "set", "htmlcollection", "nodelist"].includes(deepSerializedValue.type)) {
          for (const i2 in bidiValue) {
            bidiValue[i2] = this.serializeForBiDi(bidiValue[i2], internalIdMap);
          }
        }
        if (["object", "map"].includes(deepSerializedValue.type)) {
          for (const i2 in bidiValue) {
            bidiValue[i2] = [
              this.serializeForBiDi(bidiValue[i2][0], internalIdMap),
              this.serializeForBiDi(bidiValue[i2][1], internalIdMap)
            ];
          }
        }
        return deepSerializedValue;
      }
      get realmId() {
        return __privateGet(this, _realmId);
      }
      get executionContextId() {
        return __privateGet(this, _executionContextId);
      }
      get origin() {
        return __privateGet(this, _origin);
      }
      get source() {
        return {
          realm: this.realmId
        };
      }
      get cdpClient() {
        return __privateGet(this, _cdpClient);
      }
      get baseInfo() {
        return {
          realm: this.realmId,
          origin: this.origin
        };
      }
      async evaluate(expression, awaitPromise, resultOwnership = "none", serializationOptions = {}, userActivation = false, includeCommandLineApi = false) {
        var _a3;
        const cdpEvaluateResult = await this.cdpClient.sendCommand("Runtime.evaluate", {
          contextId: this.executionContextId,
          expression,
          awaitPromise,
          serializationOptions: __privateMethod(_a3 = _Realm, _Realm_static, getSerializationOptions_fn).call(_a3, "deep", serializationOptions),
          userGesture: userActivation,
          includeCommandLineAPI: includeCommandLineApi
        });
        if (cdpEvaluateResult.exceptionDetails) {
          return await __privateMethod(this, _Realm_instances, getExceptionResult_fn).call(this, cdpEvaluateResult.exceptionDetails, 0, resultOwnership);
        }
        return {
          realm: this.realmId,
          result: this.cdpToBidiValue(cdpEvaluateResult, resultOwnership),
          type: "success"
        };
      }
      initialize() {
        __privateMethod(this, _Realm_instances, registerEvent_fn).call(this, {
          type: "event",
          method: protocol_js_1.ChromiumBidi.Script.EventNames.RealmCreated,
          params: this.realmInfo
        });
      }
      /**
       * Serializes a given CDP object into BiDi, keeping references in the
       * target's `globalThis`.
       */
      async serializeCdpObject(cdpRemoteObject, resultOwnership) {
        var _a3;
        const argument = __privateMethod(_a3 = _Realm, _Realm_static, cdpRemoteObjectToCallArgument_fn).call(_a3, cdpRemoteObject);
        const cdpValue = await this.cdpClient.sendCommand("Runtime.callFunctionOn", {
          functionDeclaration: String((remoteObject) => remoteObject),
          awaitPromise: false,
          arguments: [argument],
          serializationOptions: {
            serialization: "deep"
          },
          executionContextId: this.executionContextId
        });
        return this.cdpToBidiValue(cdpValue, resultOwnership);
      }
      /**
       * Gets the string representation of an object. This is equivalent to
       * calling `toString()` on the object value.
       */
      async stringifyObject(cdpRemoteObject) {
        const { result } = await this.cdpClient.sendCommand("Runtime.callFunctionOn", {
          functionDeclaration: String(
            // eslint-disable-next-line @typescript-eslint/no-base-to-string
            (remoteObject) => String(remoteObject)
          ),
          awaitPromise: false,
          arguments: [cdpRemoteObject],
          returnByValue: true,
          executionContextId: this.executionContextId
        });
        return result.value;
      }
      async callFunction(functionDeclaration, awaitPromise, thisLocalValue = {
        type: "undefined"
      }, argumentsLocalValues = [], resultOwnership = "none", serializationOptions = {}, userActivation = false) {
        var _a3;
        const callFunctionAndSerializeScript = `(...args) => {
      function callFunction(f, args) {
        const deserializedThis = args.shift();
        const deserializedArgs = args;
        return f.apply(deserializedThis, deserializedArgs);
      }
      return callFunction((
        ${functionDeclaration}
      ), args);
    }`;
        const thisAndArgumentsList = [
          await this.deserializeForCdp(thisLocalValue),
          ...await Promise.all(argumentsLocalValues.map(async (argumentLocalValue) => await this.deserializeForCdp(argumentLocalValue)))
        ];
        let cdpCallFunctionResult;
        try {
          cdpCallFunctionResult = await this.cdpClient.sendCommand("Runtime.callFunctionOn", {
            functionDeclaration: callFunctionAndSerializeScript,
            awaitPromise,
            arguments: thisAndArgumentsList,
            serializationOptions: __privateMethod(_a3 = _Realm, _Realm_static, getSerializationOptions_fn).call(_a3, "deep", serializationOptions),
            executionContextId: this.executionContextId,
            userGesture: userActivation
          });
        } catch (error) {
          if (error.code === -32e3 && [
            "Could not find object with given id",
            "Argument should belong to the same JavaScript world as target object",
            "Invalid remote object id"
          ].includes(error.message)) {
            throw new protocol_js_1.NoSuchHandleException("Handle was not found.");
          }
          throw error;
        }
        if (cdpCallFunctionResult.exceptionDetails) {
          return await __privateMethod(this, _Realm_instances, getExceptionResult_fn).call(this, cdpCallFunctionResult.exceptionDetails, 1, resultOwnership);
        }
        return {
          type: "success",
          result: this.cdpToBidiValue(cdpCallFunctionResult, resultOwnership),
          realm: this.realmId
        };
      }
      async deserializeForCdp(localValue) {
        if ("handle" in localValue && localValue.handle) {
          return { objectId: localValue.handle };
        } else if ("handle" in localValue || "sharedId" in localValue) {
          throw new protocol_js_1.NoSuchHandleException("Handle was not found.");
        }
        switch (localValue.type) {
          case "undefined":
            return { unserializableValue: "undefined" };
          case "null":
            return { unserializableValue: "null" };
          case "string":
            return { value: localValue.value };
          case "number":
            if (localValue.value === "NaN") {
              return { unserializableValue: "NaN" };
            } else if (localValue.value === "-0") {
              return { unserializableValue: "-0" };
            } else if (localValue.value === "Infinity") {
              return { unserializableValue: "Infinity" };
            } else if (localValue.value === "-Infinity") {
              return { unserializableValue: "-Infinity" };
            }
            return {
              value: localValue.value
            };
          case "boolean":
            return { value: Boolean(localValue.value) };
          case "bigint":
            return {
              unserializableValue: `BigInt(${JSON.stringify(localValue.value)})`
            };
          case "date":
            return {
              unserializableValue: `new Date(Date.parse(${JSON.stringify(localValue.value)}))`
            };
          case "regexp":
            return {
              unserializableValue: `new RegExp(${JSON.stringify(localValue.value.pattern)}, ${JSON.stringify(localValue.value.flags)})`
            };
          case "map": {
            const keyValueArray = await __privateMethod(this, _Realm_instances, flattenKeyValuePairs_fn).call(this, localValue.value);
            const { result } = await this.cdpClient.sendCommand("Runtime.callFunctionOn", {
              functionDeclaration: String((...args) => {
                const result2 = /* @__PURE__ */ new Map();
                for (let i2 = 0; i2 < args.length; i2 += 2) {
                  result2.set(args[i2], args[i2 + 1]);
                }
                return result2;
              }),
              awaitPromise: false,
              arguments: keyValueArray,
              returnByValue: false,
              executionContextId: this.executionContextId
            });
            return { objectId: result.objectId };
          }
          case "object": {
            const keyValueArray = await __privateMethod(this, _Realm_instances, flattenKeyValuePairs_fn).call(this, localValue.value);
            const { result } = await this.cdpClient.sendCommand("Runtime.callFunctionOn", {
              functionDeclaration: String((...args) => {
                const result2 = {};
                for (let i2 = 0; i2 < args.length; i2 += 2) {
                  const key = args[i2];
                  result2[key] = args[i2 + 1];
                }
                return result2;
              }),
              awaitPromise: false,
              arguments: keyValueArray,
              returnByValue: false,
              executionContextId: this.executionContextId
            });
            return { objectId: result.objectId };
          }
          case "array": {
            const args = await __privateMethod(this, _Realm_instances, flattenValueList_fn).call(this, localValue.value);
            const { result } = await this.cdpClient.sendCommand("Runtime.callFunctionOn", {
              functionDeclaration: String((...args2) => args2),
              awaitPromise: false,
              arguments: args,
              returnByValue: false,
              executionContextId: this.executionContextId
            });
            return { objectId: result.objectId };
          }
          case "set": {
            const args = await __privateMethod(this, _Realm_instances, flattenValueList_fn).call(this, localValue.value);
            const { result } = await this.cdpClient.sendCommand("Runtime.callFunctionOn", {
              functionDeclaration: String((...args2) => new Set(args2)),
              awaitPromise: false,
              arguments: args,
              returnByValue: false,
              executionContextId: this.executionContextId
            });
            return { objectId: result.objectId };
          }
          case "channel": {
            const channelProxy = new ChannelProxy_js_1.ChannelProxy(localValue.value, __privateGet(this, _logger));
            const channelProxySendMessageHandle = await channelProxy.init(this, __privateGet(this, _eventManager));
            return { objectId: channelProxySendMessageHandle };
          }
        }
        throw new Error(`Value ${JSON.stringify(localValue)} is not deserializable.`);
      }
      async disown(handle) {
        if (__privateGet(this, _realmStorage).knownHandlesToRealmMap.get(handle) !== this.realmId) {
          return;
        }
        await __privateMethod(this, _Realm_instances, releaseObject_fn).call(this, handle);
        __privateGet(this, _realmStorage).knownHandlesToRealmMap.delete(handle);
      }
      dispose() {
        __privateMethod(this, _Realm_instances, registerEvent_fn).call(this, {
          type: "event",
          method: protocol_js_1.ChromiumBidi.Script.EventNames.RealmDestroyed,
          params: {
            realm: this.realmId
          }
        });
      }
    };
    _cdpClient = new WeakMap();
    _eventManager = new WeakMap();
    _executionContextId = new WeakMap();
    _logger = new WeakMap();
    _origin = new WeakMap();
    _realmId = new WeakMap();
    _realmStorage = new WeakMap();
    _Realm_instances = new WeakSet();
    registerEvent_fn = function(event) {
      if (this.associatedBrowsingContexts.length === 0) {
        __privateGet(this, _eventManager).registerGlobalEvent(event);
      } else {
        for (const browsingContext of this.associatedBrowsingContexts) {
          __privateGet(this, _eventManager).registerEvent(event, browsingContext.id);
        }
      }
    };
    _Realm_static = new WeakSet();
    cdpRemoteObjectToCallArgument_fn = function(cdpRemoteObject) {
      if (cdpRemoteObject.objectId !== void 0) {
        return { objectId: cdpRemoteObject.objectId };
      }
      if (cdpRemoteObject.unserializableValue !== void 0) {
        return { unserializableValue: cdpRemoteObject.unserializableValue };
      }
      return { value: cdpRemoteObject.value };
    };
    flattenKeyValuePairs_fn = async function(mappingLocalValue) {
      const keyValueArray = await Promise.all(mappingLocalValue.map(async ([key, value]) => {
        let keyArg;
        if (typeof key === "string") {
          keyArg = { value: key };
        } else {
          keyArg = await this.deserializeForCdp(key);
        }
        const valueArg = await this.deserializeForCdp(value);
        return [keyArg, valueArg];
      }));
      return keyValueArray.flat();
    };
    flattenValueList_fn = async function(listLocalValue) {
      return await Promise.all(listLocalValue.map((localValue) => this.deserializeForCdp(localValue)));
    };
    serializeCdpExceptionDetails_fn = async function(cdpExceptionDetails, lineOffset, resultOwnership) {
      var _a3;
      const callFrames = ((_a3 = cdpExceptionDetails.stackTrace) == null ? void 0 : _a3.callFrames.map((frame) => ({
        url: frame.url,
        functionName: frame.functionName,
        lineNumber: frame.lineNumber - lineOffset,
        columnNumber: frame.columnNumber
      }))) ?? [];
      const exception = cdpExceptionDetails.exception;
      return {
        exception: await this.serializeCdpObject(exception, resultOwnership),
        columnNumber: cdpExceptionDetails.columnNumber,
        lineNumber: cdpExceptionDetails.lineNumber - lineOffset,
        stackTrace: {
          callFrames
        },
        text: await this.stringifyObject(exception) || cdpExceptionDetails.text
      };
    };
    getExceptionResult_fn = async function(exceptionDetails, lineOffset, resultOwnership) {
      return {
        exceptionDetails: await __privateMethod(this, _Realm_instances, serializeCdpExceptionDetails_fn).call(this, exceptionDetails, lineOffset, resultOwnership),
        realm: this.realmId,
        type: "exception"
      };
    };
    getSerializationOptions_fn = function(serialization, serializationOptions) {
      var _a3, _b2;
      return {
        serialization,
        additionalParameters: __privateMethod(_a3 = _Realm, _Realm_static, getAdditionalSerializationParameters_fn).call(_a3, serializationOptions),
        ...__privateMethod(_b2 = _Realm, _Realm_static, getMaxObjectDepth_fn).call(_b2, serializationOptions)
      };
    };
    getAdditionalSerializationParameters_fn = function(serializationOptions) {
      const additionalParameters = {};
      if (serializationOptions.maxDomDepth !== void 0) {
        additionalParameters["maxNodeDepth"] = serializationOptions.maxDomDepth === null ? 1e3 : serializationOptions.maxDomDepth;
      }
      if (serializationOptions.includeShadowTree !== void 0) {
        additionalParameters["includeShadowTree"] = serializationOptions.includeShadowTree;
      }
      return additionalParameters;
    };
    getMaxObjectDepth_fn = function(serializationOptions) {
      return serializationOptions.maxObjectDepth === void 0 || serializationOptions.maxObjectDepth === null ? {} : { maxDepth: serializationOptions.maxObjectDepth };
    };
    releaseObject_fn = async function(handle) {
      try {
        await this.cdpClient.sendCommand("Runtime.releaseObject", {
          objectId: handle
        });
      } catch (error) {
        if (!(error.code === -32e3 && error.message === "Invalid remote object id")) {
          throw error;
        }
      }
    };
    __privateAdd(_Realm, _Realm_static);
    let Realm2 = _Realm;
    Realm$1.Realm = Realm2;
    return Realm$1;
  }
  var SharedId = {};
  var hasRequiredSharedId;
  function requireSharedId() {
    if (hasRequiredSharedId) return SharedId;
    hasRequiredSharedId = 1;
    Object.defineProperty(SharedId, "__esModule", { value: true });
    SharedId.getSharedId = getSharedId;
    SharedId.parseSharedId = parseSharedId;
    const SHARED_ID_DIVIDER = "_element_";
    function getSharedId(frameId, documentId, backendNodeId) {
      return `f.${frameId}.d.${documentId}.e.${backendNodeId}`;
    }
    function parseLegacySharedId(sharedId) {
      const match = sharedId.match(new RegExp(`(.*)${SHARED_ID_DIVIDER}(.*)`));
      if (!match) {
        return null;
      }
      const documentId = match[1];
      const elementId = match[2];
      if (documentId === void 0 || elementId === void 0) {
        return null;
      }
      const backendNodeId = parseInt(elementId ?? "");
      if (isNaN(backendNodeId)) {
        return null;
      }
      return {
        documentId,
        backendNodeId
      };
    }
    function parseSharedId(sharedId) {
      const legacyFormattedSharedId = parseLegacySharedId(sharedId);
      if (legacyFormattedSharedId !== null) {
        return { ...legacyFormattedSharedId, frameId: void 0 };
      }
      const match = sharedId.match(/f\.(.*)\.d\.(.*)\.e\.([0-9]*)/);
      if (!match) {
        return null;
      }
      const frameId = match[1];
      const documentId = match[2];
      const elementId = match[3];
      if (frameId === void 0 || documentId === void 0 || elementId === void 0) {
        return null;
      }
      const backendNodeId = parseInt(elementId ?? "");
      if (isNaN(backendNodeId)) {
        return null;
      }
      return {
        frameId,
        documentId,
        backendNodeId
      };
    }
    return SharedId;
  }
  var hasRequiredWindowRealm;
  function requireWindowRealm() {
    var _browsingContextId, _browsingContextStorage, _WindowRealm_instances2, getBrowsingContextId_fn;
    if (hasRequiredWindowRealm) return WindowRealm$1;
    hasRequiredWindowRealm = 1;
    Object.defineProperty(WindowRealm$1, "__esModule", { value: true });
    WindowRealm$1.WindowRealm = void 0;
    const protocol_js_1 = requireProtocol();
    const Realm_js_1 = requireRealm();
    const SharedId_js_1 = requireSharedId();
    class WindowRealm2 extends Realm_js_1.Realm {
      constructor(browsingContextId, browsingContextStorage, cdpClient, eventManager, executionContextId, logger2, origin, realmId, realmStorage, sandbox) {
        super(cdpClient, eventManager, executionContextId, logger2, origin, realmId, realmStorage);
        __privateAdd(this, _WindowRealm_instances2);
        __privateAdd(this, _browsingContextId);
        __privateAdd(this, _browsingContextStorage);
        __publicField(this, "sandbox");
        __privateSet(this, _browsingContextId, browsingContextId);
        __privateSet(this, _browsingContextStorage, browsingContextStorage);
        this.sandbox = sandbox;
        this.initialize();
      }
      get browsingContext() {
        return __privateGet(this, _browsingContextStorage).getContext(__privateGet(this, _browsingContextId));
      }
      get associatedBrowsingContexts() {
        return [this.browsingContext];
      }
      get realmType() {
        return "window";
      }
      get realmInfo() {
        return {
          ...this.baseInfo,
          type: this.realmType,
          context: __privateGet(this, _browsingContextId),
          sandbox: this.sandbox
        };
      }
      get source() {
        return {
          realm: this.realmId,
          context: this.browsingContext.id
        };
      }
      serializeForBiDi(deepSerializedValue, internalIdMap) {
        const bidiValue = deepSerializedValue.value;
        if (deepSerializedValue.type === "node" && bidiValue !== void 0) {
          if (Object.hasOwn(bidiValue, "backendNodeId")) {
            let navigableId = this.browsingContext.navigableId ?? "UNKNOWN";
            if (Object.hasOwn(bidiValue, "loaderId")) {
              navigableId = bidiValue.loaderId;
              delete bidiValue["loaderId"];
            }
            deepSerializedValue.sharedId = (0, SharedId_js_1.getSharedId)(__privateMethod(this, _WindowRealm_instances2, getBrowsingContextId_fn).call(this, navigableId), navigableId, bidiValue.backendNodeId);
            delete bidiValue["backendNodeId"];
          }
          if (Object.hasOwn(bidiValue, "children")) {
            for (const i2 in bidiValue.children) {
              bidiValue.children[i2] = this.serializeForBiDi(bidiValue.children[i2], internalIdMap);
            }
          }
          if (Object.hasOwn(bidiValue, "shadowRoot") && bidiValue.shadowRoot !== null) {
            bidiValue.shadowRoot = this.serializeForBiDi(bidiValue.shadowRoot, internalIdMap);
          }
          if (bidiValue.namespaceURI === "") {
            bidiValue.namespaceURI = null;
          }
        }
        return super.serializeForBiDi(deepSerializedValue, internalIdMap);
      }
      async deserializeForCdp(localValue) {
        if ("sharedId" in localValue && localValue.sharedId) {
          const parsedSharedId = (0, SharedId_js_1.parseSharedId)(localValue.sharedId);
          if (parsedSharedId === null) {
            throw new protocol_js_1.NoSuchNodeException(`SharedId "${localValue.sharedId}" was not found.`);
          }
          const { documentId, backendNodeId } = parsedSharedId;
          if (this.browsingContext.navigableId !== documentId) {
            throw new protocol_js_1.NoSuchNodeException(`SharedId "${localValue.sharedId}" belongs to different document. Current document is ${this.browsingContext.navigableId}.`);
          }
          try {
            const { object } = await this.cdpClient.sendCommand("DOM.resolveNode", {
              backendNodeId,
              executionContextId: this.executionContextId
            });
            return { objectId: object.objectId };
          } catch (error) {
            if (error.code === -32e3 && error.message === "No node with given id found") {
              throw new protocol_js_1.NoSuchNodeException(`SharedId "${localValue.sharedId}" was not found.`);
            }
            throw new protocol_js_1.UnknownErrorException(error.message, error.stack);
          }
        }
        return await super.deserializeForCdp(localValue);
      }
      async evaluate(expression, awaitPromise, resultOwnership, serializationOptions, userActivation, includeCommandLineApi) {
        await __privateGet(this, _browsingContextStorage).getContext(__privateGet(this, _browsingContextId)).targetUnblockedOrThrow();
        return await super.evaluate(expression, awaitPromise, resultOwnership, serializationOptions, userActivation, includeCommandLineApi);
      }
      async callFunction(functionDeclaration, awaitPromise, thisLocalValue, argumentsLocalValues, resultOwnership, serializationOptions, userActivation) {
        await __privateGet(this, _browsingContextStorage).getContext(__privateGet(this, _browsingContextId)).targetUnblockedOrThrow();
        return await super.callFunction(functionDeclaration, awaitPromise, thisLocalValue, argumentsLocalValues, resultOwnership, serializationOptions, userActivation);
      }
    }
    _browsingContextId = new WeakMap();
    _browsingContextStorage = new WeakMap();
    _WindowRealm_instances2 = new WeakSet();
    getBrowsingContextId_fn = function(navigableId) {
      const maybeBrowsingContext = __privateGet(this, _browsingContextStorage).getAllContexts().find((context) => context.navigableId === navigableId);
      return (maybeBrowsingContext == null ? void 0 : maybeBrowsingContext.id) ?? "UNKNOWN";
    };
    WindowRealm$1.WindowRealm = WindowRealm2;
    return WindowRealm$1;
  }
  var NavigationTracker = {};
  var UrlHelpers = {};
  var hasRequiredUrlHelpers;
  function requireUrlHelpers() {
    if (hasRequiredUrlHelpers) return UrlHelpers;
    hasRequiredUrlHelpers = 1;
    Object.defineProperty(UrlHelpers, "__esModule", { value: true });
    UrlHelpers.urlMatchesAboutBlank = urlMatchesAboutBlank;
    function urlMatchesAboutBlank(url) {
      if (url === "") {
        return true;
      }
      try {
        const parsedUrl = new URL(url);
        const schema = parsedUrl.protocol.replace(/:$/, "");
        return schema.toLowerCase() === "about" && parsedUrl.pathname.toLowerCase() === "blank" && parsedUrl.username === "" && parsedUrl.password === "" && parsedUrl.host === "";
      } catch (err) {
        if (err instanceof TypeError) {
          return false;
        }
        throw err;
      }
    }
    return UrlHelpers;
  }
  var hasRequiredNavigationTracker;
  function requireNavigationTracker() {
    var _browsingContextId, _started3, _finished, _isInitial, _eventManager, _navigated, _NavigationState_instances, finish_fn2, _eventManager2, _logger, _loaderIdToNavigationsMap, _browsingContextId2, _currentNavigation, _pendingNavigation, _isInitialNavigation, _NavigationTracker_instances, getNavigationForFrameNavigated_fn, _a3;
    if (hasRequiredNavigationTracker) return NavigationTracker;
    hasRequiredNavigationTracker = 1;
    Object.defineProperty(NavigationTracker, "__esModule", { value: true });
    NavigationTracker.NavigationTracker = NavigationTracker.NavigationState = NavigationTracker.NavigationResult = void 0;
    const protocol_js_1 = requireProtocol();
    const Deferred_js_1 = requireDeferred();
    const log_js_1 = requireLog();
    const time_js_1 = requireTime();
    const UrlHelpers_js_1 = requireUrlHelpers();
    const uuid_js_1 = requireUuid();
    class NavigationResult {
      constructor(eventName, message) {
        __publicField(this, "eventName");
        __publicField(this, "message");
        this.eventName = eventName;
        this.message = message;
      }
    }
    NavigationTracker.NavigationResult = NavigationResult;
    class NavigationState {
      constructor(url, browsingContextId, isInitial, eventManager) {
        __privateAdd(this, _NavigationState_instances);
        __publicField(this, "navigationId", (0, uuid_js_1.uuidv4)());
        __privateAdd(this, _browsingContextId);
        __privateAdd(this, _started3, false);
        __privateAdd(this, _finished, new Deferred_js_1.Deferred());
        __publicField(this, "url");
        __publicField(this, "loaderId");
        __privateAdd(this, _isInitial);
        __privateAdd(this, _eventManager);
        __privateAdd(this, _navigated, false);
        __publicField(this, "isFragmentNavigation");
        __privateSet(this, _browsingContextId, browsingContextId);
        this.url = url;
        __privateSet(this, _isInitial, isInitial);
        __privateSet(this, _eventManager, eventManager);
      }
      get finished() {
        return __privateGet(this, _finished);
      }
      navigationInfo() {
        return {
          context: __privateGet(this, _browsingContextId),
          navigation: this.navigationId,
          timestamp: (0, time_js_1.getTimestamp)(),
          url: this.url
        };
      }
      start() {
        if (!__privateGet(this, _isInitial) && !__privateGet(this, _started3)) {
          __privateGet(this, _eventManager).registerEvent({
            type: "event",
            method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.NavigationStarted,
            params: this.navigationInfo()
          }, __privateGet(this, _browsingContextId));
        }
        __privateSet(this, _started3, true);
      }
      frameNavigated() {
        __privateSet(this, _navigated, true);
      }
      fragmentNavigated() {
        __privateSet(this, _navigated, true);
        __privateMethod(this, _NavigationState_instances, finish_fn2).call(this, new NavigationResult(
          "browsingContext.fragmentNavigated"
          /* NavigationEventName.FragmentNavigated */
        ));
      }
      load() {
        __privateMethod(this, _NavigationState_instances, finish_fn2).call(this, new NavigationResult(
          "browsingContext.load"
          /* NavigationEventName.Load */
        ));
      }
      fail(message) {
        __privateMethod(this, _NavigationState_instances, finish_fn2).call(this, new NavigationResult(__privateGet(this, _navigated) ? "browsingContext.navigationAborted" : "browsingContext.navigationFailed", message));
      }
    }
    _browsingContextId = new WeakMap();
    _started3 = new WeakMap();
    _finished = new WeakMap();
    _isInitial = new WeakMap();
    _eventManager = new WeakMap();
    _navigated = new WeakMap();
    _NavigationState_instances = new WeakSet();
    finish_fn2 = function(navigationResult) {
      __privateSet(this, _started3, true);
      if (!__privateGet(this, _isInitial) && !__privateGet(this, _finished).isFinished && navigationResult.eventName !== "browsingContext.load") {
        __privateGet(this, _eventManager).registerEvent({
          type: "event",
          method: navigationResult.eventName,
          params: this.navigationInfo()
        }, __privateGet(this, _browsingContextId));
      }
      __privateGet(this, _finished).resolve(navigationResult);
    };
    NavigationTracker.NavigationState = NavigationState;
    let NavigationTracker$1 = (_a3 = class {
      constructor(url, browsingContextId, eventManager, logger2) {
        __privateAdd(this, _NavigationTracker_instances);
        __privateAdd(this, _eventManager2);
        __privateAdd(this, _logger);
        __privateAdd(this, _loaderIdToNavigationsMap, /* @__PURE__ */ new Map());
        __privateAdd(this, _browsingContextId2);
        __privateAdd(this, _currentNavigation);
        // When a new navigation is started via `BrowsingContext.navigate` with `wait` set to
        // `None`, the command result should have `navigation` value, but mapper does not have
        // it yet. This value will be set to `navigationId` after next .
        __privateAdd(this, _pendingNavigation);
        // Flags if the initial navigation to `about:blank` is in progress.
        __privateAdd(this, _isInitialNavigation, true);
        __privateSet(this, _browsingContextId2, browsingContextId);
        __privateSet(this, _eventManager2, eventManager);
        __privateSet(this, _logger, logger2);
        __privateSet(this, _isInitialNavigation, true);
        __privateSet(this, _currentNavigation, new NavigationState(url, browsingContextId, (0, UrlHelpers_js_1.urlMatchesAboutBlank)(url), __privateGet(this, _eventManager2)));
      }
      /**
       * Returns current started ongoing navigation. It can be either a started pending
       * navigation, or one is already navigated.
       */
      get currentNavigationId() {
        var _a4;
        if (((_a4 = __privateGet(this, _pendingNavigation)) == null ? void 0 : _a4.loaderId) !== void 0) {
          return __privateGet(this, _pendingNavigation).navigationId;
        }
        return __privateGet(this, _currentNavigation).navigationId;
      }
      /**
       * Flags if the current navigation relates to the initial to `about:blank` navigation.
       */
      get isInitialNavigation() {
        return __privateGet(this, _isInitialNavigation);
      }
      /**
       * Url of the last navigated navigation.
       */
      get url() {
        return __privateGet(this, _currentNavigation).url;
      }
      /**
       * Creates a pending navigation e.g. when navigation command is called. Required to
       * provide navigation id before the actual navigation is started. It will be used when
       * navigation started. Can be aborted, failed, fragment navigated, or became a current
       * navigation.
       */
      createPendingNavigation(url, canBeInitialNavigation = false) {
        var _a4, _b2;
        (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, log_js_1.LogType.debug, "createCommandNavigation");
        __privateSet(this, _isInitialNavigation, canBeInitialNavigation && __privateGet(this, _isInitialNavigation) && (0, UrlHelpers_js_1.urlMatchesAboutBlank)(url));
        (_b2 = __privateGet(this, _pendingNavigation)) == null ? void 0 : _b2.fail("navigation canceled by concurrent navigation");
        const navigation = new NavigationState(url, __privateGet(this, _browsingContextId2), __privateGet(this, _isInitialNavigation), __privateGet(this, _eventManager2));
        __privateSet(this, _pendingNavigation, navigation);
        return navigation;
      }
      dispose() {
        var _a4;
        (_a4 = __privateGet(this, _pendingNavigation)) == null ? void 0 : _a4.fail("navigation canceled by context disposal");
        __privateGet(this, _currentNavigation).fail("navigation canceled by context disposal");
      }
      // Update the current url.
      onTargetInfoChanged(url) {
        var _a4;
        (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, log_js_1.LogType.debug, `onTargetInfoChanged ${url}`);
        __privateGet(this, _currentNavigation).url = url;
      }
      /**
       * @param {string} unreachableUrl indicated the navigation is actually failed.
       */
      frameNavigated(url, loaderId, unreachableUrl) {
        var _a4;
        (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, log_js_1.LogType.debug, `frameNavigated ${url}`);
        if (unreachableUrl !== void 0 && !__privateGet(this, _loaderIdToNavigationsMap).has(loaderId)) {
          const navigation2 = __privateGet(this, _pendingNavigation) ?? this.createPendingNavigation(unreachableUrl, true);
          navigation2.url = unreachableUrl;
          navigation2.start();
          navigation2.fail("the requested url is unreachable");
          return;
        }
        const navigation = __privateMethod(this, _NavigationTracker_instances, getNavigationForFrameNavigated_fn).call(this, url, loaderId);
        navigation.frameNavigated();
        if (navigation !== __privateGet(this, _currentNavigation)) {
          __privateGet(this, _currentNavigation).fail("navigation canceled by concurrent navigation");
        }
        navigation.url = url;
        navigation.loaderId = loaderId;
        __privateGet(this, _loaderIdToNavigationsMap).set(loaderId, navigation);
        navigation.start();
        __privateSet(this, _currentNavigation, navigation);
        if (__privateGet(this, _pendingNavigation) === navigation) {
          __privateSet(this, _pendingNavigation, void 0);
        }
      }
      navigatedWithinDocument(url, navigationType) {
        var _a4;
        (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, log_js_1.LogType.debug, `navigatedWithinDocument ${url}, ${navigationType}`);
        __privateGet(this, _currentNavigation).url = url;
        if (navigationType !== "fragment") {
          return;
        }
        const fragmentNavigation = __privateGet(this, _pendingNavigation) !== void 0 && __privateGet(this, _pendingNavigation).loaderId === void 0 ? __privateGet(this, _pendingNavigation) : new NavigationState(url, __privateGet(this, _browsingContextId2), false, __privateGet(this, _eventManager2));
        fragmentNavigation.fragmentNavigated();
        if (fragmentNavigation === __privateGet(this, _pendingNavigation)) {
          __privateSet(this, _pendingNavigation, void 0);
        }
      }
      frameRequestedNavigation(url) {
        var _a4;
        (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, log_js_1.LogType.debug, `Page.frameRequestedNavigation ${url}`);
        this.createPendingNavigation(url, true);
      }
      /**
       * Required to mark navigation as fully complete.
       * TODO: navigation should be complete when it became the current one on
       * `Page.frameNavigated` or on navigating command finished with a new loader Id.
       */
      loadPageEvent(loaderId) {
        var _a4, _b2;
        (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, log_js_1.LogType.debug, "loadPageEvent");
        __privateSet(this, _isInitialNavigation, false);
        (_b2 = __privateGet(this, _loaderIdToNavigationsMap).get(loaderId)) == null ? void 0 : _b2.load();
      }
      /**
       * Fail navigation due to navigation command failed.
       */
      failNavigation(navigation, errorText) {
        var _a4;
        (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, log_js_1.LogType.debug, "failCommandNavigation");
        navigation.fail(errorText);
      }
      /**
       * Updates the navigation's `loaderId` and sets it as current one, if it is a
       * cross-document navigation.
       */
      navigationCommandFinished(navigation, loaderId) {
        var _a4;
        (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, log_js_1.LogType.debug, `finishCommandNavigation ${navigation.navigationId}, ${loaderId}`);
        if (loaderId !== void 0) {
          navigation.loaderId = loaderId;
          __privateGet(this, _loaderIdToNavigationsMap).set(loaderId, navigation);
        }
        navigation.isFragmentNavigation = loaderId === void 0;
        if (loaderId === void 0 || __privateGet(this, _currentNavigation) === navigation) {
          return;
        }
        __privateGet(this, _currentNavigation).fail("navigation canceled by concurrent navigation");
        navigation.start();
        __privateSet(this, _currentNavigation, navigation);
        if (__privateGet(this, _pendingNavigation) === navigation) {
          __privateSet(this, _pendingNavigation, void 0);
        }
      }
      /**
       * Emulated event, tight to `Network.requestWillBeSent`.
       */
      frameStartedNavigating(url, loaderId) {
        var _a4;
        (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, log_js_1.LogType.debug, `frameStartedNavigating ${url}, ${loaderId}`);
        if (__privateGet(this, _loaderIdToNavigationsMap).has(loaderId)) {
          return;
        }
        const pendingNavigation = __privateGet(this, _pendingNavigation) ?? this.createPendingNavigation(url, true);
        pendingNavigation.url = url;
        pendingNavigation.start();
        pendingNavigation.loaderId = loaderId;
        __privateGet(this, _loaderIdToNavigationsMap).set(loaderId, pendingNavigation);
      }
      /**
       * In case of `beforeunload` handler, the pending navigation should be marked as started
       * for consistency, as the `browsingContext.navigationStarted` should be emitted before
       * user prompt.
       */
      beforeunload() {
        var _a4, _b2;
        (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, log_js_1.LogType.debug, `beforeunload`);
        if (__privateGet(this, _pendingNavigation) === void 0) {
          (_b2 = __privateGet(this, _logger)) == null ? void 0 : _b2.call(this, log_js_1.LogType.debugError, `Unexpectedly no pending navigation on beforeunload`);
          return;
        }
        __privateGet(this, _pendingNavigation).start();
      }
      /**
       * If there is a navigation with the loaderId equals to the network request id, it means
       * that the navigation failed.
       */
      networkLoadingFailed(loaderId, errorText) {
        var _a4;
        (_a4 = __privateGet(this, _loaderIdToNavigationsMap).get(loaderId)) == null ? void 0 : _a4.fail(errorText);
      }
    }, _eventManager2 = new WeakMap(), _logger = new WeakMap(), _loaderIdToNavigationsMap = new WeakMap(), _browsingContextId2 = new WeakMap(), _currentNavigation = new WeakMap(), _pendingNavigation = new WeakMap(), _isInitialNavigation = new WeakMap(), _NavigationTracker_instances = new WeakSet(), getNavigationForFrameNavigated_fn = function(url, loaderId) {
      var _a4;
      if (__privateGet(this, _loaderIdToNavigationsMap).has(loaderId)) {
        return __privateGet(this, _loaderIdToNavigationsMap).get(loaderId);
      }
      if (__privateGet(this, _pendingNavigation) !== void 0 && ((_a4 = __privateGet(this, _pendingNavigation)) == null ? void 0 : _a4.loaderId) === void 0) {
        return __privateGet(this, _pendingNavigation);
      }
      return this.createPendingNavigation(url, true);
    }, _a3);
    NavigationTracker.NavigationTracker = NavigationTracker$1;
    return NavigationTracker;
  }
  var hasRequiredBrowsingContextImpl;
  function requireBrowsingContextImpl() {
    var _a4, _children, _id7, _loaderId, _parentId, _previousViewport, _originalOpener, _lifecycle, _cdpTarget, _defaultRealmDeferred, _browsingContextStorage, _eventManager, _logger, _navigationTracker, _realmStorage, _unhandledPromptBehavior, _lastUserPromptType, _BrowsingContextImpl_instances, deleteAllChildren_fn, initListeners_fn, _BrowsingContextImpl_static, getPromptType_fn, getPromptHandler_fn, documentChanged_fn, resetLifecycleIfFinished_fn, failLifecycleIfNotFinished_fn, waitNavigation_fn, parseRect_fn, getLocatorDelegate_fn, locateNodesByLocator_fn;
    if (hasRequiredBrowsingContextImpl) return BrowsingContextImpl;
    hasRequiredBrowsingContextImpl = 1;
    var _a3;
    Object.defineProperty(BrowsingContextImpl, "__esModule", { value: true });
    BrowsingContextImpl.BrowsingContextImpl = void 0;
    BrowsingContextImpl.serializeOrigin = serializeOrigin;
    const protocol_js_1 = requireProtocol();
    const assert_js_1 = requireAssert();
    const Deferred_js_1 = requireDeferred();
    const log_js_1 = requireLog();
    const time_js_1 = requireTime();
    const unitConversions_js_1 = requireUnitConversions();
    const WindowRealm_js_1 = requireWindowRealm();
    const NavigationTracker_js_1 = requireNavigationTracker();
    let BrowsingContextImpl$1 = (_a4 = class {
      constructor(id, parentId, userContext, cdpTarget, eventManager, browsingContextStorage, realmStorage, url, originalOpener, unhandledPromptBehavior, logger2) {
        __privateAdd(this, _BrowsingContextImpl_instances);
        /** Direct children browsing contexts. */
        __privateAdd(this, _children, /* @__PURE__ */ new Set());
        /** The ID of this browsing context. */
        __privateAdd(this, _id7);
        __publicField(this, "userContext");
        /**
         * The ID of the parent browsing context.
         * If null, this is a top-level context.
         */
        __privateAdd(this, _loaderId);
        __privateAdd(this, _parentId, null);
        // Keeps track of the previously set viewport.
        __privateAdd(this, _previousViewport, { width: 0, height: 0 });
        __privateAdd(this, _originalOpener);
        __privateAdd(this, _lifecycle, {
          DOMContentLoaded: new Deferred_js_1.Deferred(),
          load: new Deferred_js_1.Deferred()
        });
        __privateAdd(this, _cdpTarget);
        __privateAdd(this, _defaultRealmDeferred, new Deferred_js_1.Deferred());
        __privateAdd(this, _browsingContextStorage);
        __privateAdd(this, _eventManager);
        __privateAdd(this, _logger);
        __privateAdd(this, _navigationTracker);
        __privateAdd(this, _realmStorage);
        // The deferred will be resolved when the default realm is created.
        __privateAdd(this, _unhandledPromptBehavior);
        // Set when the user prompt is opened. Required to provide the type in closing event.
        __privateAdd(this, _lastUserPromptType);
        __privateSet(this, _cdpTarget, cdpTarget);
        __privateSet(this, _id7, id);
        __privateSet(this, _parentId, parentId);
        this.userContext = userContext;
        __privateSet(this, _eventManager, eventManager);
        __privateSet(this, _browsingContextStorage, browsingContextStorage);
        __privateSet(this, _realmStorage, realmStorage);
        __privateSet(this, _unhandledPromptBehavior, unhandledPromptBehavior);
        __privateSet(this, _logger, logger2);
        __privateSet(this, _originalOpener, originalOpener);
        __privateSet(this, _navigationTracker, new NavigationTracker_js_1.NavigationTracker(url, id, eventManager, logger2));
      }
      static create(id, parentId, userContext, cdpTarget, eventManager, browsingContextStorage, realmStorage, url, originalOpener, unhandledPromptBehavior, logger2) {
        var _a5;
        const context = new _a3(id, parentId, userContext, cdpTarget, eventManager, browsingContextStorage, realmStorage, url, originalOpener, unhandledPromptBehavior, logger2);
        __privateMethod(_a5 = context, _BrowsingContextImpl_instances, initListeners_fn).call(_a5);
        browsingContextStorage.addContext(context);
        if (!context.isTopLevelContext()) {
          context.parent.addChild(context.id);
        }
        eventManager.registerPromiseEvent(context.targetUnblockedOrThrow().then(() => {
          return {
            kind: "success",
            value: {
              type: "event",
              method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.ContextCreated,
              params: {
                ...context.serializeToBidiValue(),
                // Hack to provide the initial URL of the context, as it can be changed
                // between the page target is attached and unblocked, as the page is not
                // fully paused in MPArch session (https://crbug.com/372842894).
                // TODO: remove once https://crbug.com/372842894 is addressed.
                url
              }
            }
          };
        }, (error) => {
          return {
            kind: "error",
            error
          };
        }), context.id, protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.ContextCreated);
        return context;
      }
      /**
       * @see https://html.spec.whatwg.org/multipage/document-sequences.html#navigable
       */
      get navigableId() {
        return __privateGet(this, _loaderId);
      }
      get navigationId() {
        return __privateGet(this, _navigationTracker).currentNavigationId;
      }
      dispose(emitContextDestroyed) {
        __privateGet(this, _navigationTracker).dispose();
        __privateMethod(this, _BrowsingContextImpl_instances, deleteAllChildren_fn).call(this);
        __privateGet(this, _realmStorage).deleteRealms({
          browsingContextId: this.id
        });
        if (!this.isTopLevelContext()) {
          __privateGet(this.parent, _children).delete(this.id);
        }
        __privateMethod(this, _BrowsingContextImpl_instances, failLifecycleIfNotFinished_fn).call(this);
        if (emitContextDestroyed) {
          __privateGet(this, _eventManager).registerEvent({
            type: "event",
            method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.ContextDestroyed,
            params: this.serializeToBidiValue()
          }, this.id);
        }
        __privateGet(this, _eventManager).clearBufferedEvents(this.id);
        __privateGet(this, _browsingContextStorage).deleteContextById(this.id);
      }
      /** Returns the ID of this context. */
      get id() {
        return __privateGet(this, _id7);
      }
      /** Returns the parent context ID. */
      get parentId() {
        return __privateGet(this, _parentId);
      }
      /** Sets the parent context ID and updates parent's children. */
      set parentId(parentId) {
        var _a5;
        if (__privateGet(this, _parentId) !== null) {
          (_a5 = __privateGet(this, _logger)) == null ? void 0 : _a5.call(this, log_js_1.LogType.debugError, "Parent context already set");
          return;
        }
        __privateSet(this, _parentId, parentId);
        if (!this.isTopLevelContext()) {
          this.parent.addChild(this.id);
        }
      }
      /** Returns the parent context. */
      get parent() {
        if (this.parentId === null) {
          return null;
        }
        return __privateGet(this, _browsingContextStorage).getContext(this.parentId);
      }
      /** Returns all direct children contexts. */
      get directChildren() {
        return [...__privateGet(this, _children)].map((id) => __privateGet(this, _browsingContextStorage).getContext(id));
      }
      /** Returns all children contexts, flattened. */
      get allChildren() {
        const children = this.directChildren;
        return children.concat(...children.map((child) => child.allChildren));
      }
      /**
       * Returns true if this is a top-level context.
       * This is the case whenever the parent context ID is null.
       */
      isTopLevelContext() {
        return __privateGet(this, _parentId) === null;
      }
      get top() {
        let topContext = this;
        let parent = topContext.parent;
        while (parent) {
          topContext = parent;
          parent = topContext.parent;
        }
        return topContext;
      }
      addChild(childId) {
        __privateGet(this, _children).add(childId);
      }
      get cdpTarget() {
        return __privateGet(this, _cdpTarget);
      }
      updateCdpTarget(cdpTarget) {
        __privateSet(this, _cdpTarget, cdpTarget);
        __privateMethod(this, _BrowsingContextImpl_instances, initListeners_fn).call(this);
      }
      get url() {
        return __privateGet(this, _navigationTracker).url;
      }
      async lifecycleLoaded() {
        await __privateGet(this, _lifecycle).load;
      }
      async targetUnblockedOrThrow() {
        const result = await __privateGet(this, _cdpTarget).unblocked;
        if (result.kind === "error") {
          throw result.error;
        }
      }
      async getOrCreateSandbox(sandbox) {
        if (sandbox === void 0 || sandbox === "") {
          return await __privateGet(this, _defaultRealmDeferred);
        }
        let maybeSandboxes = __privateGet(this, _realmStorage).findRealms({
          browsingContextId: this.id,
          sandbox
        });
        if (maybeSandboxes.length === 0) {
          await __privateGet(this, _cdpTarget).cdpClient.sendCommand("Page.createIsolatedWorld", {
            frameId: this.id,
            worldName: sandbox
          });
          maybeSandboxes = __privateGet(this, _realmStorage).findRealms({
            browsingContextId: this.id,
            sandbox
          });
          (0, assert_js_1.assert)(maybeSandboxes.length !== 0);
        }
        return maybeSandboxes[0];
      }
      serializeToBidiValue(maxDepth = 0, addParentField = true) {
        return {
          context: __privateGet(this, _id7),
          url: this.url,
          userContext: this.userContext,
          originalOpener: __privateGet(this, _originalOpener) ?? null,
          // TODO(#2646): Implement Client Window correctly
          clientWindow: "",
          children: maxDepth > 0 ? this.directChildren.map((c) => c.serializeToBidiValue(maxDepth - 1, false)) : null,
          ...addParentField ? { parent: __privateGet(this, _parentId) } : {}
        };
      }
      onTargetInfoChanged(params) {
        __privateGet(this, _navigationTracker).onTargetInfoChanged(params.targetInfo.url);
      }
      async navigate(url, wait) {
        try {
          new URL(url);
        } catch {
          throw new protocol_js_1.InvalidArgumentException(`Invalid URL: ${url}`);
        }
        const navigationState = __privateGet(this, _navigationTracker).createPendingNavigation(url);
        const cdpNavigatePromise = (async () => {
          const cdpNavigateResult = await __privateGet(this, _cdpTarget).cdpClient.sendCommand("Page.navigate", {
            url,
            frameId: this.id
          });
          if (cdpNavigateResult.errorText) {
            __privateGet(this, _navigationTracker).failNavigation(navigationState, cdpNavigateResult.errorText);
            throw new protocol_js_1.UnknownErrorException(cdpNavigateResult.errorText);
          }
          __privateGet(this, _navigationTracker).navigationCommandFinished(navigationState, cdpNavigateResult.loaderId);
          __privateMethod(this, _BrowsingContextImpl_instances, documentChanged_fn).call(this, cdpNavigateResult.loaderId);
        })();
        const result = await Promise.race([
          // No `loaderId` means same-document navigation.
          __privateMethod(this, _BrowsingContextImpl_instances, waitNavigation_fn).call(this, wait, cdpNavigatePromise, navigationState),
          // Throw an error if the navigation is canceled.
          navigationState.finished
        ]);
        if (result instanceof NavigationTracker_js_1.NavigationResult) {
          if (
            // TODO: check after decision on the spec is done:
            //  https://github.com/w3c/webdriver-bidi/issues/799.
            result.eventName === "browsingContext.navigationAborted" || result.eventName === "browsingContext.navigationFailed"
          ) {
            throw new protocol_js_1.UnknownErrorException(result.message ?? "unknown exception");
          }
        }
        return {
          navigation: navigationState.navigationId,
          // Url can change due to redirects. Get the one from commandNavigation.
          url: navigationState.url
        };
      }
      // TODO: support concurrent navigations analogous to `navigate`.
      async reload(ignoreCache, wait) {
        await this.targetUnblockedOrThrow();
        __privateMethod(this, _BrowsingContextImpl_instances, resetLifecycleIfFinished_fn).call(this);
        const navigationState = __privateGet(this, _navigationTracker).createPendingNavigation(__privateGet(this, _navigationTracker).url);
        const cdpReloadPromise = __privateGet(this, _cdpTarget).cdpClient.sendCommand("Page.reload", {
          ignoreCache
        });
        const result = await Promise.race([
          // No `loaderId` means same-document navigation.
          __privateMethod(this, _BrowsingContextImpl_instances, waitNavigation_fn).call(this, wait, cdpReloadPromise, navigationState),
          // Throw an error if the navigation is canceled.
          navigationState.finished
        ]);
        if (result instanceof NavigationTracker_js_1.NavigationResult) {
          if (result.eventName === "browsingContext.navigationAborted" || result.eventName === "browsingContext.navigationFailed") {
            throw new protocol_js_1.UnknownErrorException(result.message ?? "unknown exception");
          }
        }
        return {
          navigation: navigationState.navigationId,
          // Url can change due to redirects. Get the one from commandNavigation.
          url: navigationState.url
        };
      }
      async setViewport(viewport, devicePixelRatio) {
        if (viewport === null && devicePixelRatio === null) {
          await __privateGet(this, _cdpTarget).cdpClient.sendCommand("Emulation.clearDeviceMetricsOverride");
        } else {
          try {
            let appliedViewport;
            if (viewport === void 0) {
              appliedViewport = __privateGet(this, _previousViewport);
            } else if (viewport === null) {
              appliedViewport = {
                width: 0,
                height: 0
              };
            } else {
              appliedViewport = viewport;
            }
            __privateSet(this, _previousViewport, appliedViewport);
            await __privateGet(this, _cdpTarget).cdpClient.sendCommand("Emulation.setDeviceMetricsOverride", {
              width: __privateGet(this, _previousViewport).width,
              height: __privateGet(this, _previousViewport).height,
              deviceScaleFactor: devicePixelRatio ? devicePixelRatio : 0,
              mobile: false,
              dontSetVisibleSize: true
            });
          } catch (err) {
            if (err.message.startsWith(
              // https://crsrc.org/c/content/browser/devtools/protocol/emulation_handler.cc;l=257;drc=2f6eee84cf98d4227e7c41718dd71b82f26d90ff
              "Width and height values must be positive"
            )) {
              throw new protocol_js_1.UnsupportedOperationException("Provided viewport dimensions are not supported");
            }
            throw err;
          }
        }
      }
      async handleUserPrompt(accept, userText) {
        await __privateGet(this, _cdpTarget).cdpClient.sendCommand("Page.handleJavaScriptDialog", {
          accept: accept ?? true,
          promptText: userText
        });
      }
      async activate() {
        await __privateGet(this, _cdpTarget).cdpClient.sendCommand("Page.bringToFront");
      }
      async captureScreenshot(params) {
        if (!this.isTopLevelContext()) {
          throw new protocol_js_1.UnsupportedOperationException(`Non-top-level 'context' (${params.context}) is currently not supported`);
        }
        const formatParameters = getImageFormatParameters(params);
        let captureBeyondViewport = false;
        let script;
        params.origin ?? (params.origin = "viewport");
        switch (params.origin) {
          case "document": {
            script = String(() => {
              const element = document.documentElement;
              return {
                x: 0,
                y: 0,
                width: element.scrollWidth,
                height: element.scrollHeight
              };
            });
            captureBeyondViewport = true;
            break;
          }
          case "viewport": {
            script = String(() => {
              const viewport = window.visualViewport;
              return {
                x: viewport.pageLeft,
                y: viewport.pageTop,
                width: viewport.width,
                height: viewport.height
              };
            });
            break;
          }
        }
        const realm = await this.getOrCreateSandbox(void 0);
        const originResult = await realm.callFunction(script, false);
        (0, assert_js_1.assert)(originResult.type === "success");
        const origin = deserializeDOMRect(originResult.result);
        (0, assert_js_1.assert)(origin);
        let rect = origin;
        if (params.clip) {
          const clip = params.clip;
          if (params.origin === "viewport" && clip.type === "box") {
            clip.x += origin.x;
            clip.y += origin.y;
          }
          rect = getIntersectionRect2(await __privateMethod(this, _BrowsingContextImpl_instances, parseRect_fn).call(this, clip), origin);
        }
        if (rect.width === 0 || rect.height === 0) {
          throw new protocol_js_1.UnableToCaptureScreenException(`Unable to capture screenshot with zero dimensions: width=${rect.width}, height=${rect.height}`);
        }
        return await __privateGet(this, _cdpTarget).cdpClient.sendCommand("Page.captureScreenshot", {
          clip: { ...rect, scale: 1 },
          ...formatParameters,
          captureBeyondViewport
        });
      }
      async print(params) {
        var _a5, _b2, _c2, _d2, _e2, _f2;
        if (!this.isTopLevelContext()) {
          throw new protocol_js_1.UnsupportedOperationException("Printing of non-top level contexts is not supported");
        }
        const cdpParams = {};
        if (params.background !== void 0) {
          cdpParams.printBackground = params.background;
        }
        if (((_a5 = params.margin) == null ? void 0 : _a5.bottom) !== void 0) {
          cdpParams.marginBottom = (0, unitConversions_js_1.inchesFromCm)(params.margin.bottom);
        }
        if (((_b2 = params.margin) == null ? void 0 : _b2.left) !== void 0) {
          cdpParams.marginLeft = (0, unitConversions_js_1.inchesFromCm)(params.margin.left);
        }
        if (((_c2 = params.margin) == null ? void 0 : _c2.right) !== void 0) {
          cdpParams.marginRight = (0, unitConversions_js_1.inchesFromCm)(params.margin.right);
        }
        if (((_d2 = params.margin) == null ? void 0 : _d2.top) !== void 0) {
          cdpParams.marginTop = (0, unitConversions_js_1.inchesFromCm)(params.margin.top);
        }
        if (params.orientation !== void 0) {
          cdpParams.landscape = params.orientation === "landscape";
        }
        if (((_e2 = params.page) == null ? void 0 : _e2.height) !== void 0) {
          cdpParams.paperHeight = (0, unitConversions_js_1.inchesFromCm)(params.page.height);
        }
        if (((_f2 = params.page) == null ? void 0 : _f2.width) !== void 0) {
          cdpParams.paperWidth = (0, unitConversions_js_1.inchesFromCm)(params.page.width);
        }
        if (params.pageRanges !== void 0) {
          for (const range2 of params.pageRanges) {
            if (typeof range2 === "number") {
              continue;
            }
            const rangeParts = range2.split("-");
            if (rangeParts.length < 1 || rangeParts.length > 2) {
              throw new protocol_js_1.InvalidArgumentException(`Invalid page range: ${range2} is not a valid integer range.`);
            }
            if (rangeParts.length === 1) {
              void parseInteger(rangeParts[0] ?? "");
              continue;
            }
            let lowerBound2;
            let upperBound;
            const [rangeLowerPart = "", rangeUpperPart = ""] = rangeParts;
            if (rangeLowerPart === "") {
              lowerBound2 = 1;
            } else {
              lowerBound2 = parseInteger(rangeLowerPart);
            }
            if (rangeUpperPart === "") {
              upperBound = Number.MAX_SAFE_INTEGER;
            } else {
              upperBound = parseInteger(rangeUpperPart);
            }
            if (lowerBound2 > upperBound) {
              throw new protocol_js_1.InvalidArgumentException(`Invalid page range: ${rangeLowerPart} > ${rangeUpperPart}`);
            }
          }
          cdpParams.pageRanges = params.pageRanges.join(",");
        }
        if (params.scale !== void 0) {
          cdpParams.scale = params.scale;
        }
        if (params.shrinkToFit !== void 0) {
          cdpParams.preferCSSPageSize = !params.shrinkToFit;
        }
        try {
          const result = await __privateGet(this, _cdpTarget).cdpClient.sendCommand("Page.printToPDF", cdpParams);
          return {
            data: result.data
          };
        } catch (error) {
          if (error.message === "invalid print parameters: content area is empty") {
            throw new protocol_js_1.UnsupportedOperationException(error.message);
          }
          throw error;
        }
      }
      async close() {
        await __privateGet(this, _cdpTarget).cdpClient.sendCommand("Page.close");
      }
      async traverseHistory(delta) {
        if (delta === 0) {
          return;
        }
        const history = await __privateGet(this, _cdpTarget).cdpClient.sendCommand("Page.getNavigationHistory");
        const entry = history.entries[history.currentIndex + delta];
        if (!entry) {
          throw new protocol_js_1.NoSuchHistoryEntryException(`No history entry at delta ${delta}`);
        }
        await __privateGet(this, _cdpTarget).cdpClient.sendCommand("Page.navigateToHistoryEntry", {
          entryId: entry.id
        });
      }
      async toggleModulesIfNeeded() {
        await Promise.all([
          __privateGet(this, _cdpTarget).toggleNetworkIfNeeded(),
          __privateGet(this, _cdpTarget).toggleDeviceAccessIfNeeded()
        ]);
      }
      async locateNodes(params) {
        return await __privateMethod(this, _BrowsingContextImpl_instances, locateNodesByLocator_fn).call(this, await __privateGet(this, _defaultRealmDeferred), params.locator, params.startNodes ?? [], params.maxNodeCount, params.serializationOptions);
      }
    }, _children = new WeakMap(), _id7 = new WeakMap(), _loaderId = new WeakMap(), _parentId = new WeakMap(), _previousViewport = new WeakMap(), _originalOpener = new WeakMap(), _lifecycle = new WeakMap(), _cdpTarget = new WeakMap(), _defaultRealmDeferred = new WeakMap(), _browsingContextStorage = new WeakMap(), _eventManager = new WeakMap(), _logger = new WeakMap(), _navigationTracker = new WeakMap(), _realmStorage = new WeakMap(), _unhandledPromptBehavior = new WeakMap(), _lastUserPromptType = new WeakMap(), _BrowsingContextImpl_instances = new WeakSet(), deleteAllChildren_fn = function(emitContextDestroyed = false) {
      this.directChildren.map((child) => child.dispose(emitContextDestroyed));
    }, initListeners_fn = function() {
      __privateGet(this, _cdpTarget).cdpClient.on("Network.loadingFailed", (params) => {
        __privateGet(this, _navigationTracker).networkLoadingFailed(params.requestId, params.errorText);
      });
      __privateGet(this, _cdpTarget).cdpClient.on("Page.frameNavigated", (params) => {
        if (this.id !== params.frame.id) {
          return;
        }
        __privateGet(this, _navigationTracker).frameNavigated(
          params.frame.url + (params.frame.urlFragment ?? ""),
          params.frame.loaderId,
          // `unreachableUrl` indicates if the navigation failed.
          params.frame.unreachableUrl
        );
        __privateMethod(this, _BrowsingContextImpl_instances, deleteAllChildren_fn).call(this);
        __privateMethod(this, _BrowsingContextImpl_instances, documentChanged_fn).call(this, params.frame.loaderId);
      });
      __privateGet(this, _cdpTarget).on("frameStartedNavigating", (params) => {
        var _a5;
        (_a5 = __privateGet(this, _logger)) == null ? void 0 : _a5.call(this, log_js_1.LogType.debugInfo, `Received ${"frameStartedNavigating"} event`, params);
        const possibleFrameIds = [
          this.id,
          ...this.cdpTarget.id === this.id ? [void 0] : []
        ];
        if (!possibleFrameIds.includes(params.frameId)) {
          return;
        }
        __privateGet(this, _navigationTracker).frameStartedNavigating(params.url, params.loaderId);
      });
      __privateGet(this, _cdpTarget).cdpClient.on("Page.navigatedWithinDocument", (params) => {
        if (this.id !== params.frameId) {
          return;
        }
        __privateGet(this, _navigationTracker).navigatedWithinDocument(params.url, params.navigationType);
        if (params.navigationType === "historyApi") {
          __privateGet(this, _eventManager).registerEvent({
            type: "event",
            method: "browsingContext.historyUpdated",
            params: {
              context: this.id,
              url: __privateGet(this, _navigationTracker).url
            }
          }, this.id);
          return;
        }
      });
      __privateGet(this, _cdpTarget).cdpClient.on("Page.frameRequestedNavigation", (params) => {
        if (this.id !== params.frameId) {
          return;
        }
        __privateGet(this, _navigationTracker).frameRequestedNavigation(params.url);
      });
      __privateGet(this, _cdpTarget).cdpClient.on("Page.lifecycleEvent", (params) => {
        if (this.id !== params.frameId) {
          return;
        }
        if (params.name === "init") {
          __privateMethod(this, _BrowsingContextImpl_instances, documentChanged_fn).call(this, params.loaderId);
          return;
        }
        if (params.name === "commit") {
          __privateSet(this, _loaderId, params.loaderId);
          return;
        }
        if (!__privateGet(this, _loaderId)) {
          __privateSet(this, _loaderId, params.loaderId);
        }
        if (params.loaderId !== __privateGet(this, _loaderId)) {
          return;
        }
        switch (params.name) {
          case "DOMContentLoaded":
            if (!__privateGet(this, _navigationTracker).isInitialNavigation) {
              __privateGet(this, _eventManager).registerEvent({
                type: "event",
                method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.DomContentLoaded,
                params: {
                  context: this.id,
                  navigation: __privateGet(this, _navigationTracker).currentNavigationId,
                  timestamp: (0, time_js_1.getTimestamp)(),
                  url: __privateGet(this, _navigationTracker).url
                }
              }, this.id);
            }
            __privateGet(this, _lifecycle).DOMContentLoaded.resolve();
            break;
          case "load":
            if (!__privateGet(this, _navigationTracker).isInitialNavigation) {
              __privateGet(this, _eventManager).registerEvent({
                type: "event",
                method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.Load,
                params: {
                  context: this.id,
                  navigation: __privateGet(this, _navigationTracker).currentNavigationId,
                  timestamp: (0, time_js_1.getTimestamp)(),
                  url: __privateGet(this, _navigationTracker).url
                }
              }, this.id);
            }
            __privateGet(this, _navigationTracker).loadPageEvent(params.loaderId);
            __privateGet(this, _lifecycle).load.resolve();
            break;
        }
      });
      __privateGet(this, _cdpTarget).cdpClient.on("Runtime.executionContextCreated", (params) => {
        var _a5;
        const { auxData, name, uniqueId, id } = params.context;
        if (!auxData || auxData.frameId !== this.id) {
          return;
        }
        let origin;
        let sandbox;
        switch (auxData.type) {
          case "isolated":
            sandbox = name;
            if (!__privateGet(this, _defaultRealmDeferred).isFinished) {
              (_a5 = __privateGet(this, _logger)) == null ? void 0 : _a5.call(this, log_js_1.LogType.debugError, "Unexpectedly, isolated realm created before the default one");
            }
            origin = __privateGet(this, _defaultRealmDeferred).isFinished ? __privateGet(this, _defaultRealmDeferred).result.origin : (
              // This fallback is not expected to be ever reached.
              ""
            );
            break;
          case "default":
            origin = serializeOrigin(params.context.origin);
            break;
          default:
            return;
        }
        const realm = new WindowRealm_js_1.WindowRealm(this.id, __privateGet(this, _browsingContextStorage), __privateGet(this, _cdpTarget).cdpClient, __privateGet(this, _eventManager), id, __privateGet(this, _logger), origin, uniqueId, __privateGet(this, _realmStorage), sandbox);
        if (auxData.isDefault) {
          __privateGet(this, _defaultRealmDeferred).resolve(realm);
          void Promise.all(__privateGet(this, _cdpTarget).getChannels().map((channel) => channel.startListenerFromWindow(realm, __privateGet(this, _eventManager))));
        }
      });
      __privateGet(this, _cdpTarget).cdpClient.on("Runtime.executionContextDestroyed", (params) => {
        if (__privateGet(this, _defaultRealmDeferred).isFinished && __privateGet(this, _defaultRealmDeferred).result.executionContextId === params.executionContextId) {
          __privateSet(this, _defaultRealmDeferred, new Deferred_js_1.Deferred());
        }
        __privateGet(this, _realmStorage).deleteRealms({
          cdpSessionId: __privateGet(this, _cdpTarget).cdpSessionId,
          executionContextId: params.executionContextId
        });
      });
      __privateGet(this, _cdpTarget).cdpClient.on("Runtime.executionContextsCleared", () => {
        if (!__privateGet(this, _defaultRealmDeferred).isFinished) {
          __privateGet(this, _defaultRealmDeferred).reject(new protocol_js_1.UnknownErrorException("execution contexts cleared"));
        }
        __privateSet(this, _defaultRealmDeferred, new Deferred_js_1.Deferred());
        __privateGet(this, _realmStorage).deleteRealms({
          cdpSessionId: __privateGet(this, _cdpTarget).cdpSessionId
        });
      });
      __privateGet(this, _cdpTarget).cdpClient.on("Page.javascriptDialogClosed", (params) => {
        var _a5;
        const accepted = params.result;
        if (__privateGet(this, _lastUserPromptType) === void 0) {
          (_a5 = __privateGet(this, _logger)) == null ? void 0 : _a5.call(this, log_js_1.LogType.debugError, "Unexpectedly no opening prompt event before closing one");
        }
        __privateGet(this, _eventManager).registerEvent({
          type: "event",
          method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.UserPromptClosed,
          params: {
            context: this.id,
            accepted,
            // `lastUserPromptType` should never be undefined here, so fallback to
            // `UNKNOWN`. The fallback is required to prevent tests from hanging while
            // waiting for the closing event. The cast is required, as the `UNKNOWN` value
            // is not standard.
            type: __privateGet(this, _lastUserPromptType) ?? "UNKNOWN",
            userText: accepted && params.userInput ? params.userInput : void 0
          }
        }, this.id);
        __privateSet(this, _lastUserPromptType, void 0);
      });
      __privateGet(this, _cdpTarget).cdpClient.on("Page.javascriptDialogOpening", (params) => {
        var _a5;
        const promptType = __privateMethod(_a5 = _a3, _BrowsingContextImpl_static, getPromptType_fn).call(_a5, params.type);
        if (params.type === "beforeunload") {
          __privateGet(this, _navigationTracker).beforeunload();
        }
        __privateSet(this, _lastUserPromptType, promptType);
        const promptHandler = __privateMethod(this, _BrowsingContextImpl_instances, getPromptHandler_fn).call(this, promptType);
        __privateGet(this, _eventManager).registerEvent({
          type: "event",
          method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.UserPromptOpened,
          params: {
            context: this.id,
            handler: promptHandler,
            type: promptType,
            message: params.message,
            ...params.type === "prompt" ? { defaultValue: params.defaultPrompt } : {}
          }
        }, this.id);
        switch (promptHandler) {
          // Based on `unhandledPromptBehavior`, check if the prompt should be handled
          // automatically (`accept`, `dismiss`) or wait for the user to do it.
          case "accept":
            void this.handleUserPrompt(true);
            break;
          case "dismiss":
            void this.handleUserPrompt(false);
            break;
        }
      });
    }, _BrowsingContextImpl_static = new WeakSet(), getPromptType_fn = function(cdpType) {
      switch (cdpType) {
        case "alert":
          return "alert";
        case "beforeunload":
          return "beforeunload";
        case "confirm":
          return "confirm";
        case "prompt":
          return "prompt";
      }
    }, getPromptHandler_fn = function(promptType) {
      var _a5, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
      const defaultPromptHandler = "dismiss";
      switch (promptType) {
        case "alert":
          return ((_a5 = __privateGet(this, _unhandledPromptBehavior)) == null ? void 0 : _a5.alert) ?? ((_b2 = __privateGet(this, _unhandledPromptBehavior)) == null ? void 0 : _b2.default) ?? defaultPromptHandler;
        case "beforeunload":
          return ((_c2 = __privateGet(this, _unhandledPromptBehavior)) == null ? void 0 : _c2.beforeUnload) ?? ((_d2 = __privateGet(this, _unhandledPromptBehavior)) == null ? void 0 : _d2.default) ?? "accept";
        case "confirm":
          return ((_e2 = __privateGet(this, _unhandledPromptBehavior)) == null ? void 0 : _e2.confirm) ?? ((_f2 = __privateGet(this, _unhandledPromptBehavior)) == null ? void 0 : _f2.default) ?? defaultPromptHandler;
        case "prompt":
          return ((_g2 = __privateGet(this, _unhandledPromptBehavior)) == null ? void 0 : _g2.prompt) ?? ((_h2 = __privateGet(this, _unhandledPromptBehavior)) == null ? void 0 : _h2.default) ?? defaultPromptHandler;
      }
    }, documentChanged_fn = function(loaderId) {
      if (loaderId === void 0 || __privateGet(this, _loaderId) === loaderId) {
        return;
      }
      __privateMethod(this, _BrowsingContextImpl_instances, resetLifecycleIfFinished_fn).call(this);
      __privateSet(this, _loaderId, loaderId);
      __privateMethod(this, _BrowsingContextImpl_instances, deleteAllChildren_fn).call(this, true);
    }, resetLifecycleIfFinished_fn = function() {
      var _a5, _b2;
      if (__privateGet(this, _lifecycle).DOMContentLoaded.isFinished) {
        __privateGet(this, _lifecycle).DOMContentLoaded = new Deferred_js_1.Deferred();
      } else {
        (_a5 = __privateGet(this, _logger)) == null ? void 0 : _a5.call(this, _a3.LOGGER_PREFIX, "Document changed (DOMContentLoaded)");
      }
      if (__privateGet(this, _lifecycle).load.isFinished) {
        __privateGet(this, _lifecycle).load = new Deferred_js_1.Deferred();
      } else {
        (_b2 = __privateGet(this, _logger)) == null ? void 0 : _b2.call(this, _a3.LOGGER_PREFIX, "Document changed (load)");
      }
    }, failLifecycleIfNotFinished_fn = function() {
      if (!__privateGet(this, _lifecycle).DOMContentLoaded.isFinished) {
        __privateGet(this, _lifecycle).DOMContentLoaded.reject(new protocol_js_1.UnknownErrorException("navigation canceled"));
      }
      if (!__privateGet(this, _lifecycle).load.isFinished) {
        __privateGet(this, _lifecycle).load.reject(new protocol_js_1.UnknownErrorException("navigation canceled"));
      }
    }, waitNavigation_fn = async function(wait, cdpCommandPromise, navigationState) {
      if (wait === "none") {
        return;
      }
      await cdpCommandPromise;
      if (navigationState.isFragmentNavigation === true) {
        await navigationState.finished;
        return;
      }
      if (wait === "interactive") {
        await __privateGet(this, _lifecycle).DOMContentLoaded;
        return;
      }
      if (wait === "complete") {
        await __privateGet(this, _lifecycle).load;
        return;
      }
      throw new protocol_js_1.InvalidArgumentException(`Wait condition ${wait} is not supported`);
    }, parseRect_fn = async function(clip) {
      switch (clip.type) {
        case "box":
          return { x: clip.x, y: clip.y, width: clip.width, height: clip.height };
        case "element": {
          const sandbox = await this.getOrCreateSandbox(void 0);
          const result = await sandbox.callFunction(String((element) => {
            return element instanceof Element;
          }), false, { type: "undefined" }, [clip.element]);
          if (result.type === "exception") {
            throw new protocol_js_1.NoSuchElementException(`Element '${clip.element.sharedId}' was not found`);
          }
          (0, assert_js_1.assert)(result.result.type === "boolean");
          if (!result.result.value) {
            throw new protocol_js_1.NoSuchElementException(`Node '${clip.element.sharedId}' is not an Element`);
          }
          {
            const result2 = await sandbox.callFunction(String((element) => {
              const rect2 = element.getBoundingClientRect();
              return {
                x: rect2.x,
                y: rect2.y,
                height: rect2.height,
                width: rect2.width
              };
            }), false, { type: "undefined" }, [clip.element]);
            (0, assert_js_1.assert)(result2.type === "success");
            const rect = deserializeDOMRect(result2.result);
            if (!rect) {
              throw new protocol_js_1.UnableToCaptureScreenException(`Could not get bounding box for Element '${clip.element.sharedId}'`);
            }
            return rect;
          }
        }
      }
    }, getLocatorDelegate_fn = async function(realm, locator, maxNodeCount, startNodes) {
      switch (locator.type) {
        case "context":
          throw new Error("Unreachable");
        case "css":
          return {
            functionDeclaration: String((cssSelector, maxNodeCount2, ...startNodes2) => {
              const locateNodesUsingCss = (element) => {
                if (!(element instanceof HTMLElement || element instanceof Document || element instanceof DocumentFragment)) {
                  throw new Error("startNodes in css selector should be HTMLElement, Document or DocumentFragment");
                }
                return [...element.querySelectorAll(cssSelector)];
              };
              startNodes2 = startNodes2.length > 0 ? startNodes2 : [document];
              const returnedNodes = startNodes2.map((startNode) => (
                // TODO: stop search early if `maxNodeCount` is reached.
                locateNodesUsingCss(startNode)
              )).flat(1);
              return maxNodeCount2 === 0 ? returnedNodes : returnedNodes.slice(0, maxNodeCount2);
            }),
            argumentsLocalValues: [
              // `cssSelector`
              { type: "string", value: locator.value },
              // `maxNodeCount` with `0` means no limit.
              { type: "number", value: maxNodeCount ?? 0 },
              // `startNodes`
              ...startNodes
            ]
          };
        case "xpath":
          return {
            functionDeclaration: String((xPathSelector, maxNodeCount2, ...startNodes2) => {
              const evaluator = new XPathEvaluator();
              const expression = evaluator.createExpression(xPathSelector);
              const locateNodesUsingXpath = (element) => {
                const xPathResult = expression.evaluate(element, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE);
                const returnedNodes2 = [];
                for (let i2 = 0; i2 < xPathResult.snapshotLength; i2++) {
                  returnedNodes2.push(xPathResult.snapshotItem(i2));
                }
                return returnedNodes2;
              };
              startNodes2 = startNodes2.length > 0 ? startNodes2 : [document];
              const returnedNodes = startNodes2.map((startNode) => (
                // TODO: stop search early if `maxNodeCount` is reached.
                locateNodesUsingXpath(startNode)
              )).flat(1);
              return maxNodeCount2 === 0 ? returnedNodes : returnedNodes.slice(0, maxNodeCount2);
            }),
            argumentsLocalValues: [
              // `xPathSelector`
              { type: "string", value: locator.value },
              // `maxNodeCount` with `0` means no limit.
              { type: "number", value: maxNodeCount ?? 0 },
              // `startNodes`
              ...startNodes
            ]
          };
        case "innerText":
          if (locator.value === "") {
            throw new protocol_js_1.InvalidSelectorException("innerText locator cannot be empty");
          }
          return {
            functionDeclaration: String((innerTextSelector, fullMatch, ignoreCase, maxNodeCount2, maxDepth, ...startNodes2) => {
              const searchText = ignoreCase ? innerTextSelector.toUpperCase() : innerTextSelector;
              const locateNodesUsingInnerText = (node, currentMaxDepth) => {
                var _a5;
                const returnedNodes2 = [];
                if (node instanceof DocumentFragment || node instanceof Document) {
                  const children = [...node.children];
                  children.forEach((child) => (
                    // `currentMaxDepth` is not decremented intentionally according to
                    // https://github.com/w3c/webdriver-bidi/pull/713.
                    returnedNodes2.push(...locateNodesUsingInnerText(child, currentMaxDepth))
                  ));
                  return returnedNodes2;
                }
                if (!(node instanceof HTMLElement)) {
                  return [];
                }
                const element = node;
                const nodeInnerText = ignoreCase ? (_a5 = element.innerText) == null ? void 0 : _a5.toUpperCase() : element.innerText;
                if (!nodeInnerText.includes(searchText)) {
                  return [];
                }
                const childNodes = [];
                for (const child of element.children) {
                  if (child instanceof HTMLElement) {
                    childNodes.push(child);
                  }
                }
                if (childNodes.length === 0) {
                  if (fullMatch && nodeInnerText === searchText) {
                    returnedNodes2.push(element);
                  } else {
                    if (!fullMatch) {
                      returnedNodes2.push(element);
                    }
                  }
                } else {
                  const childNodeMatches = (
                    // Don't search deeper if `maxDepth` is reached.
                    currentMaxDepth <= 0 ? [] : childNodes.map((child) => locateNodesUsingInnerText(child, currentMaxDepth - 1)).flat(1)
                  );
                  if (childNodeMatches.length === 0) {
                    if (!fullMatch || nodeInnerText === searchText) {
                      returnedNodes2.push(element);
                    }
                  } else {
                    returnedNodes2.push(...childNodeMatches);
                  }
                }
                return returnedNodes2;
              };
              startNodes2 = startNodes2.length > 0 ? startNodes2 : [document];
              const returnedNodes = startNodes2.map((startNode) => (
                // TODO: stop search early if `maxNodeCount` is reached.
                locateNodesUsingInnerText(startNode, maxDepth)
              )).flat(1);
              return maxNodeCount2 === 0 ? returnedNodes : returnedNodes.slice(0, maxNodeCount2);
            }),
            argumentsLocalValues: [
              // `innerTextSelector`
              { type: "string", value: locator.value },
              // `fullMatch` with default `true`.
              { type: "boolean", value: locator.matchType !== "partial" },
              // `ignoreCase` with default `false`.
              { type: "boolean", value: locator.ignoreCase === true },
              // `maxNodeCount` with `0` means no limit.
              { type: "number", value: maxNodeCount ?? 0 },
              // `maxDepth` with default `1000` (same as default full serialization depth).
              { type: "number", value: locator.maxDepth ?? 1e3 },
              // `startNodes`
              ...startNodes
            ]
          };
        case "accessibility": {
          if (!locator.value.name && !locator.value.role) {
            throw new protocol_js_1.InvalidSelectorException("Either name or role has to be specified");
          }
          await Promise.all([
            __privateGet(this, _cdpTarget).cdpClient.sendCommand("Accessibility.enable"),
            __privateGet(this, _cdpTarget).cdpClient.sendCommand("Accessibility.getRootAXNode")
          ]);
          const bindings = await realm.evaluate(
            /* expression=*/
            "({getAccessibleName, getAccessibleRole})",
            /* awaitPromise=*/
            false,
            "root",
            /* serializationOptions= */
            void 0,
            /* userActivation=*/
            false,
            /* includeCommandLineApi=*/
            true
          );
          if (bindings.type !== "success") {
            throw new Error("Could not get bindings");
          }
          if (bindings.result.type !== "object") {
            throw new Error("Could not get bindings");
          }
          return {
            functionDeclaration: String((name, role, bindings2, maxNodeCount2, ...startNodes2) => {
              const returnedNodes = [];
              let aborted = false;
              function collect(contextNodes, selector) {
                if (aborted) {
                  return;
                }
                for (const contextNode of contextNodes) {
                  let match = true;
                  if (selector.role) {
                    const role2 = bindings2.getAccessibleRole(contextNode);
                    if (selector.role !== role2) {
                      match = false;
                    }
                  }
                  if (selector.name) {
                    const name2 = bindings2.getAccessibleName(contextNode);
                    if (selector.name !== name2) {
                      match = false;
                    }
                  }
                  if (match) {
                    if (maxNodeCount2 !== 0 && returnedNodes.length === maxNodeCount2) {
                      aborted = true;
                      break;
                    }
                    returnedNodes.push(contextNode);
                  }
                  const childNodes = [];
                  for (const child of contextNode.children) {
                    if (child instanceof HTMLElement) {
                      childNodes.push(child);
                    }
                  }
                  collect(childNodes, selector);
                }
              }
              startNodes2 = startNodes2.length > 0 ? startNodes2 : Array.from(document.documentElement.children).filter((c) => c instanceof HTMLElement);
              collect(startNodes2, {
                role,
                name
              });
              return returnedNodes;
            }),
            argumentsLocalValues: [
              // `name`
              { type: "string", value: locator.value.name || "" },
              // `role`
              { type: "string", value: locator.value.role || "" },
              // `bindings`.
              { handle: bindings.result.handle },
              // `maxNodeCount` with `0` means no limit.
              { type: "number", value: maxNodeCount ?? 0 },
              // `startNodes`
              ...startNodes
            ]
          };
        }
      }
    }, locateNodesByLocator_fn = async function(realm, locator, startNodes, maxNodeCount, serializationOptions) {
      var _a5, _b2, _c2;
      if (locator.type === "context") {
        if (startNodes.length !== 0) {
          throw new protocol_js_1.InvalidArgumentException("Start nodes are not supported");
        }
        const contextId = locator.value.context;
        if (!contextId) {
          throw new protocol_js_1.InvalidSelectorException("Invalid context");
        }
        const context = __privateGet(this, _browsingContextStorage).getContext(contextId);
        const parent = context.parent;
        if (!parent) {
          throw new protocol_js_1.InvalidArgumentException("This context has no container");
        }
        try {
          const { backendNodeId } = await __privateGet(parent, _cdpTarget).cdpClient.sendCommand("DOM.getFrameOwner", {
            frameId: contextId
          });
          const { object } = await __privateGet(parent, _cdpTarget).cdpClient.sendCommand("DOM.resolveNode", {
            backendNodeId
          });
          const locatorResult2 = await realm.callFunction(`function () { return this; }`, false, { handle: object.objectId }, [], "none", serializationOptions);
          if (locatorResult2.type === "exception") {
            throw new Error("Unknown exception");
          }
          return { nodes: [locatorResult2.result] };
        } catch {
          throw new protocol_js_1.InvalidArgumentException("Context does not exist");
        }
      }
      const locatorDelegate = await __privateMethod(this, _BrowsingContextImpl_instances, getLocatorDelegate_fn).call(this, realm, locator, maxNodeCount, startNodes);
      serializationOptions = {
        ...serializationOptions,
        // The returned object is an array of nodes, so no need in deeper JS serialization.
        maxObjectDepth: 1
      };
      const locatorResult = await realm.callFunction(locatorDelegate.functionDeclaration, false, { type: "undefined" }, locatorDelegate.argumentsLocalValues, "none", serializationOptions);
      if (locatorResult.type !== "success") {
        (_a5 = __privateGet(this, _logger)) == null ? void 0 : _a5.call(this, _a3.LOGGER_PREFIX, "Failed locateNodesByLocator", locatorResult);
        if (
          // CSS selector.
          ((_b2 = locatorResult.exceptionDetails.text) == null ? void 0 : _b2.endsWith("is not a valid selector.")) || // XPath selector.
          ((_c2 = locatorResult.exceptionDetails.text) == null ? void 0 : _c2.endsWith("is not a valid XPath expression."))
        ) {
          throw new protocol_js_1.InvalidSelectorException(`Not valid selector ${typeof locator.value === "string" ? locator.value : JSON.stringify(locator.value)}`);
        }
        if (locatorResult.exceptionDetails.text === "Error: startNodes in css selector should be HTMLElement, Document or DocumentFragment") {
          throw new protocol_js_1.InvalidArgumentException("startNodes in css selector should be HTMLElement, Document or DocumentFragment");
        }
        throw new protocol_js_1.UnknownErrorException(`Unexpected error in selector script: ${locatorResult.exceptionDetails.text}`);
      }
      if (locatorResult.result.type !== "array") {
        throw new protocol_js_1.UnknownErrorException(`Unexpected selector script result type: ${locatorResult.result.type}`);
      }
      const nodes = locatorResult.result.value.map((value) => {
        if (value.type !== "node") {
          throw new protocol_js_1.UnknownErrorException(`Unexpected selector script result element: ${value.type}`);
        }
        return value;
      });
      return { nodes };
    }, __privateAdd(_a4, _BrowsingContextImpl_static), __publicField(_a4, "LOGGER_PREFIX", `${log_js_1.LogType.debug}:browsingContext`), _a4);
    BrowsingContextImpl.BrowsingContextImpl = BrowsingContextImpl$1;
    _a3 = BrowsingContextImpl$1;
    function serializeOrigin(origin) {
      if (["://", ""].includes(origin)) {
        origin = "null";
      }
      return origin;
    }
    function getImageFormatParameters(params) {
      const { quality, type } = params.format ?? {
        type: "image/png"
      };
      switch (type) {
        case "image/png": {
          return { format: "png" };
        }
        case "image/jpeg": {
          return {
            format: "jpeg",
            ...quality === void 0 ? {} : { quality: Math.round(quality * 100) }
          };
        }
        case "image/webp": {
          return {
            format: "webp",
            ...quality === void 0 ? {} : { quality: Math.round(quality * 100) }
          };
        }
      }
      throw new protocol_js_1.InvalidArgumentException(`Image format '${type}' is not a supported format`);
    }
    function deserializeDOMRect(result) {
      var _a5, _b2, _c2, _d2;
      if (result.type !== "object" || result.value === void 0) {
        return;
      }
      const x = (_a5 = result.value.find(([key]) => {
        return key === "x";
      })) == null ? void 0 : _a5[1];
      const y = (_b2 = result.value.find(([key]) => {
        return key === "y";
      })) == null ? void 0 : _b2[1];
      const height = (_c2 = result.value.find(([key]) => {
        return key === "height";
      })) == null ? void 0 : _c2[1];
      const width = (_d2 = result.value.find(([key]) => {
        return key === "width";
      })) == null ? void 0 : _d2[1];
      if ((x == null ? void 0 : x.type) !== "number" || (y == null ? void 0 : y.type) !== "number" || (height == null ? void 0 : height.type) !== "number" || (width == null ? void 0 : width.type) !== "number") {
        return;
      }
      return {
        x: x.value,
        y: y.value,
        width: width.value,
        height: height.value
      };
    }
    function normalizeRect(box) {
      return {
        ...box.width < 0 ? {
          x: box.x + box.width,
          width: -box.width
        } : {
          x: box.x,
          width: box.width
        },
        ...box.height < 0 ? {
          y: box.y + box.height,
          height: -box.height
        } : {
          y: box.y,
          height: box.height
        }
      };
    }
    function getIntersectionRect2(first2, second) {
      first2 = normalizeRect(first2);
      second = normalizeRect(second);
      const x = Math.max(first2.x, second.x);
      const y = Math.max(first2.y, second.y);
      return {
        x,
        y,
        width: Math.max(Math.min(first2.x + first2.width, second.x + second.width) - x, 0),
        height: Math.max(Math.min(first2.y + first2.height, second.y + second.height) - y, 0)
      };
    }
    function parseInteger(value) {
      value = value.trim();
      if (!/^[0-9]+$/.test(value)) {
        throw new protocol_js_1.InvalidArgumentException(`Invalid integer: ${value}`);
      }
      return parseInt(value);
    }
    return BrowsingContextImpl;
  }
  var WorkerRealm = {};
  var hasRequiredWorkerRealm;
  function requireWorkerRealm() {
    var _realmType, _ownerRealms, _a3;
    if (hasRequiredWorkerRealm) return WorkerRealm;
    hasRequiredWorkerRealm = 1;
    Object.defineProperty(WorkerRealm, "__esModule", { value: true });
    WorkerRealm.WorkerRealm = void 0;
    const Realm_js_1 = requireRealm();
    let WorkerRealm$1 = (_a3 = class extends Realm_js_1.Realm {
      constructor(cdpClient, eventManager, executionContextId, logger2, origin, ownerRealms, realmId, realmStorage, realmType) {
        super(cdpClient, eventManager, executionContextId, logger2, origin, realmId, realmStorage);
        __privateAdd(this, _realmType);
        __privateAdd(this, _ownerRealms);
        __privateSet(this, _ownerRealms, ownerRealms);
        __privateSet(this, _realmType, realmType);
        this.initialize();
      }
      get associatedBrowsingContexts() {
        return __privateGet(this, _ownerRealms).flatMap((realm) => realm.associatedBrowsingContexts);
      }
      get realmType() {
        return __privateGet(this, _realmType);
      }
      get source() {
        var _a4;
        return {
          realm: this.realmId,
          // This is a hack to make Puppeteer able to track workers.
          // TODO: remove after Puppeteer tracks workers by owners and use the base version.
          context: (_a4 = this.associatedBrowsingContexts[0]) == null ? void 0 : _a4.id
        };
      }
      get realmInfo() {
        const owners = __privateGet(this, _ownerRealms).map((realm) => realm.realmId);
        const { realmType } = this;
        switch (realmType) {
          case "dedicated-worker": {
            const owner = owners[0];
            if (owner === void 0 || owners.length !== 1) {
              throw new Error("Dedicated worker must have exactly one owner");
            }
            return {
              ...this.baseInfo,
              type: realmType,
              owners: [owner]
            };
          }
          case "service-worker":
          case "shared-worker": {
            return {
              ...this.baseInfo,
              type: realmType
            };
          }
        }
      }
    }, _realmType = new WeakMap(), _ownerRealms = new WeakMap(), _a3);
    WorkerRealm.WorkerRealm = WorkerRealm$1;
    return WorkerRealm;
  }
  var CdpTarget = {};
  var LogManager = {};
  var logHelper = {};
  var hasRequiredLogHelper;
  function requireLogHelper() {
    if (hasRequiredLogHelper) return logHelper;
    hasRequiredLogHelper = 1;
    Object.defineProperty(logHelper, "__esModule", { value: true });
    logHelper.logMessageFormatter = logMessageFormatter;
    logHelper.getRemoteValuesText = getRemoteValuesText;
    const assert_js_1 = requireAssert();
    const specifiers = ["%s", "%d", "%i", "%f", "%o", "%O", "%c"];
    function isFormatSpecifier(str2) {
      return specifiers.some((spec) => str2.includes(spec));
    }
    function logMessageFormatter(args) {
      let output = "";
      const argFormat = args[0].value.toString();
      const argValues = args.slice(1, void 0);
      const tokens = argFormat.split(new RegExp(specifiers.map((spec) => `(${spec})`).join("|"), "g"));
      for (const token of tokens) {
        if (token === void 0 || token === "") {
          continue;
        }
        if (isFormatSpecifier(token)) {
          const arg = argValues.shift();
          (0, assert_js_1.assert)(arg, `Less value is provided: "${getRemoteValuesText(args, false)}"`);
          if (token === "%s") {
            output += stringFromArg(arg);
          } else if (token === "%d" || token === "%i") {
            if (arg.type === "bigint" || arg.type === "number" || arg.type === "string") {
              output += parseInt(arg.value.toString(), 10);
            } else {
              output += "NaN";
            }
          } else if (token === "%f") {
            if (arg.type === "bigint" || arg.type === "number" || arg.type === "string") {
              output += parseFloat(arg.value.toString());
            } else {
              output += "NaN";
            }
          } else {
            output += toJson(arg);
          }
        } else {
          output += token;
        }
      }
      if (argValues.length > 0) {
        throw new Error(`More value is provided: "${getRemoteValuesText(args, false)}"`);
      }
      return output;
    }
    function toJson(arg) {
      var _a3;
      if (arg.type !== "array" && arg.type !== "bigint" && arg.type !== "date" && arg.type !== "number" && arg.type !== "object" && arg.type !== "string") {
        return stringFromArg(arg);
      }
      if (arg.type === "bigint") {
        return `${arg.value.toString()}n`;
      }
      if (arg.type === "number") {
        return arg.value.toString();
      }
      if (["date", "string"].includes(arg.type)) {
        return JSON.stringify(arg.value);
      }
      if (arg.type === "object") {
        return `{${arg.value.map((pair) => {
          return `${JSON.stringify(pair[0])}:${toJson(pair[1])}`;
        }).join(",")}}`;
      }
      if (arg.type === "array") {
        return `[${((_a3 = arg.value) == null ? void 0 : _a3.map((val) => toJson(val)).join(",")) ?? ""}]`;
      }
      throw Error(`Invalid value type: ${arg}`);
    }
    function stringFromArg(arg) {
      var _a3, _b2, _c2, _d2;
      if (!Object.hasOwn(arg, "value")) {
        return arg.type;
      }
      switch (arg.type) {
        case "string":
        case "number":
        case "boolean":
        case "bigint":
          return String(arg.value);
        case "regexp":
          return `/${arg.value.pattern}/${arg.value.flags ?? ""}`;
        case "date":
          return new Date(arg.value).toString();
        case "object":
          return `Object(${((_a3 = arg.value) == null ? void 0 : _a3.length) ?? ""})`;
        case "array":
          return `Array(${((_b2 = arg.value) == null ? void 0 : _b2.length) ?? ""})`;
        case "map":
          return `Map(${(_c2 = arg.value) == null ? void 0 : _c2.length})`;
        case "set":
          return `Set(${(_d2 = arg.value) == null ? void 0 : _d2.length})`;
        default:
          return arg.type;
      }
    }
    function getRemoteValuesText(args, formatText) {
      const arg = args[0];
      if (!arg) {
        return "";
      }
      if (arg.type === "string" && isFormatSpecifier(arg.value.toString()) && formatText) {
        return logMessageFormatter(args);
      }
      return args.map((arg2) => {
        return stringFromArg(arg2);
      }).join(" ");
    }
    return logHelper;
  }
  var hasRequiredLogManager;
  function requireLogManager() {
    var _eventManager, _realmStorage, _cdpTarget, _logger, _LogManager_instances, heuristicSerializeArg_fn, initializeEntryAddedEventListener_fn, _LogManager_static, _a4, getExceptionText_fn;
    if (hasRequiredLogManager) return LogManager;
    hasRequiredLogManager = 1;
    var _a3;
    Object.defineProperty(LogManager, "__esModule", { value: true });
    LogManager.LogManager = void 0;
    const protocol_js_1 = requireProtocol();
    const log_js_1 = requireLog();
    const logHelper_js_1 = requireLogHelper();
    function getBidiStackTrace(cdpStackTrace) {
      const stackFrames = cdpStackTrace == null ? void 0 : cdpStackTrace.callFrames.map((callFrame) => {
        return {
          columnNumber: callFrame.columnNumber,
          functionName: callFrame.functionName,
          lineNumber: callFrame.lineNumber,
          url: callFrame.url
        };
      });
      return stackFrames ? { callFrames: stackFrames } : void 0;
    }
    function getLogLevel(consoleApiType) {
      if (["error", "assert"].includes(consoleApiType)) {
        return "error";
      }
      if (["debug", "trace"].includes(consoleApiType)) {
        return "debug";
      }
      if (["warn", "warning"].includes(consoleApiType)) {
        return "warn";
      }
      return "info";
    }
    function getLogMethod(consoleApiType) {
      switch (consoleApiType) {
        case "warning":
          return "warn";
        case "startGroup":
          return "group";
        case "startGroupCollapsed":
          return "groupCollapsed";
        case "endGroup":
          return "groupEnd";
      }
      return consoleApiType;
    }
    let LogManager$1 = (_a4 = class {
      constructor(cdpTarget, realmStorage, eventManager, logger2) {
        __privateAdd(this, _LogManager_instances);
        __privateAdd(this, _eventManager);
        __privateAdd(this, _realmStorage);
        __privateAdd(this, _cdpTarget);
        __privateAdd(this, _logger);
        __privateSet(this, _cdpTarget, cdpTarget);
        __privateSet(this, _realmStorage, realmStorage);
        __privateSet(this, _eventManager, eventManager);
        __privateSet(this, _logger, logger2);
      }
      static create(cdpTarget, realmStorage, eventManager, logger2) {
        var _a5;
        const logManager = new _a3(cdpTarget, realmStorage, eventManager, logger2);
        __privateMethod(_a5 = logManager, _LogManager_instances, initializeEntryAddedEventListener_fn).call(_a5);
        return logManager;
      }
    }, _eventManager = new WeakMap(), _realmStorage = new WeakMap(), _cdpTarget = new WeakMap(), _logger = new WeakMap(), _LogManager_instances = new WeakSet(), heuristicSerializeArg_fn = async function(arg, realm) {
      switch (arg.type) {
        // TODO: Implement regexp, array, object, map and set heuristics base on
        //  preview.
        case "undefined":
          return { type: "undefined" };
        case "boolean":
          return { type: "boolean", value: arg.value };
        case "string":
          return { type: "string", value: arg.value };
        case "number":
          return { type: "number", value: arg.unserializableValue ?? arg.value };
        case "bigint":
          if (arg.unserializableValue !== void 0 && arg.unserializableValue[arg.unserializableValue.length - 1] === "n") {
            return {
              type: arg.type,
              value: arg.unserializableValue.slice(0, -1)
            };
          }
          break;
        case "object":
          if (arg.subtype === "null") {
            return { type: "null" };
          }
          break;
      }
      return await realm.serializeCdpObject(
        arg,
        "none"
        /* Script.ResultOwnership.None */
      );
    }, initializeEntryAddedEventListener_fn = function() {
      __privateGet(this, _cdpTarget).cdpClient.on("Runtime.consoleAPICalled", (params) => {
        var _a5;
        const realm = __privateGet(this, _realmStorage).findRealm({
          cdpSessionId: __privateGet(this, _cdpTarget).cdpSessionId,
          executionContextId: params.executionContextId
        });
        if (realm === void 0) {
          (_a5 = __privateGet(this, _logger)) == null ? void 0 : _a5.call(this, log_js_1.LogType.cdp, params);
          return;
        }
        const argsPromise = Promise.all(params.args.map((arg) => __privateMethod(this, _LogManager_instances, heuristicSerializeArg_fn).call(this, arg, realm)));
        for (const browsingContext of realm.associatedBrowsingContexts) {
          __privateGet(this, _eventManager).registerPromiseEvent(argsPromise.then((args) => ({
            kind: "success",
            value: {
              type: "event",
              method: protocol_js_1.ChromiumBidi.Log.EventNames.LogEntryAdded,
              params: {
                level: getLogLevel(params.type),
                source: realm.source,
                text: (0, logHelper_js_1.getRemoteValuesText)(args, true),
                timestamp: Math.round(params.timestamp),
                stackTrace: getBidiStackTrace(params.stackTrace),
                type: "console",
                method: getLogMethod(params.type),
                args
              }
            }
          }), (error) => ({
            kind: "error",
            error
          })), browsingContext.id, protocol_js_1.ChromiumBidi.Log.EventNames.LogEntryAdded);
        }
      });
      __privateGet(this, _cdpTarget).cdpClient.on("Runtime.exceptionThrown", (params) => {
        var _a5, _b2;
        const realm = __privateGet(this, _realmStorage).findRealm({
          cdpSessionId: __privateGet(this, _cdpTarget).cdpSessionId,
          executionContextId: params.exceptionDetails.executionContextId
        });
        if (realm === void 0) {
          (_a5 = __privateGet(this, _logger)) == null ? void 0 : _a5.call(this, log_js_1.LogType.cdp, params);
          return;
        }
        for (const browsingContext of realm.associatedBrowsingContexts) {
          __privateGet(this, _eventManager).registerPromiseEvent(__privateMethod(_b2 = _a3, _LogManager_static, getExceptionText_fn).call(_b2, params, realm).then((text) => ({
            kind: "success",
            value: {
              type: "event",
              method: protocol_js_1.ChromiumBidi.Log.EventNames.LogEntryAdded,
              params: {
                level: "error",
                source: realm.source,
                text,
                timestamp: Math.round(params.timestamp),
                stackTrace: getBidiStackTrace(params.exceptionDetails.stackTrace),
                type: "javascript"
              }
            }
          }), (error) => ({
            kind: "error",
            error
          })), browsingContext.id, protocol_js_1.ChromiumBidi.Log.EventNames.LogEntryAdded);
        }
      });
    }, _LogManager_static = new WeakSet(), getExceptionText_fn = async function(params, realm) {
      if (!params.exceptionDetails.exception) {
        return params.exceptionDetails.text;
      }
      if (realm === void 0) {
        return JSON.stringify(params.exceptionDetails.exception);
      }
      return await realm.stringifyObject(params.exceptionDetails.exception);
    }, __privateAdd(_a4, _LogManager_static), _a4);
    LogManager.LogManager = LogManager$1;
    _a3 = LogManager$1;
    return LogManager;
  }
  var hasRequiredCdpTarget;
  function requireCdpTarget() {
    var _id7, _cdpClient, _browserCdpClient, _parentCdpClient, _realmStorage, _eventManager, _preloadScriptStorage, _browsingContextStorage, _prerenderingDisabled, _networkStorage, _unblocked, _unhandledPromptBehavior, _logger, _deviceAccessEnabled, _cacheDisableState, _fetchDomainStages, _CdpTarget_instances, unblock_fn, restoreFrameTreeState_fn, isExpectedError_fn, setEventListeners_fn, enableFetch_fn, disableFetch_fn, initAndEvaluatePreloadScripts_fn, _a3;
    if (hasRequiredCdpTarget) return CdpTarget;
    hasRequiredCdpTarget = 1;
    Object.defineProperty(CdpTarget, "__esModule", { value: true });
    CdpTarget.CdpTarget = void 0;
    const chromium_bidi_js_1 = requireChromiumBidi();
    const Deferred_js_1 = requireDeferred();
    const EventEmitter_js_1 = requireEventEmitter();
    const log_js_1 = requireLog();
    const BrowsingContextImpl_js_1 = requireBrowsingContextImpl();
    const LogManager_js_1 = requireLogManager();
    let CdpTarget$12 = (_a3 = class extends EventEmitter_js_1.EventEmitter {
      constructor(targetId, cdpClient, browserCdpClient, parentCdpClient, eventManager, realmStorage, preloadScriptStorage, browsingContextStorage, networkStorage, prerenderingDisabled, unhandledPromptBehavior, logger2) {
        super();
        __privateAdd(this, _CdpTarget_instances);
        __privateAdd(this, _id7);
        __privateAdd(this, _cdpClient);
        __privateAdd(this, _browserCdpClient);
        __privateAdd(this, _parentCdpClient);
        __privateAdd(this, _realmStorage);
        __privateAdd(this, _eventManager);
        __privateAdd(this, _preloadScriptStorage);
        __privateAdd(this, _browsingContextStorage);
        __privateAdd(this, _prerenderingDisabled);
        __privateAdd(this, _networkStorage);
        __privateAdd(this, _unblocked, new Deferred_js_1.Deferred());
        __privateAdd(this, _unhandledPromptBehavior);
        __privateAdd(this, _logger);
        __privateAdd(this, _deviceAccessEnabled, false);
        __privateAdd(this, _cacheDisableState, false);
        __privateAdd(this, _fetchDomainStages, {
          request: false,
          response: false,
          auth: false
        });
        __privateSet(this, _id7, targetId);
        __privateSet(this, _cdpClient, cdpClient);
        __privateSet(this, _browserCdpClient, browserCdpClient);
        __privateSet(this, _parentCdpClient, parentCdpClient);
        __privateSet(this, _eventManager, eventManager);
        __privateSet(this, _realmStorage, realmStorage);
        __privateSet(this, _preloadScriptStorage, preloadScriptStorage);
        __privateSet(this, _networkStorage, networkStorage);
        __privateSet(this, _browsingContextStorage, browsingContextStorage);
        __privateSet(this, _prerenderingDisabled, prerenderingDisabled);
        __privateSet(this, _unhandledPromptBehavior, unhandledPromptBehavior);
        __privateSet(this, _logger, logger2);
      }
      static create(targetId, cdpClient, browserCdpClient, parentCdpClient, realmStorage, eventManager, preloadScriptStorage, browsingContextStorage, networkStorage, prerenderingDisabled, unhandledPromptBehavior, logger2) {
        var _a4, _b2;
        const cdpTarget = new _a3(targetId, cdpClient, browserCdpClient, parentCdpClient, eventManager, realmStorage, preloadScriptStorage, browsingContextStorage, networkStorage, prerenderingDisabled, unhandledPromptBehavior, logger2);
        LogManager_js_1.LogManager.create(cdpTarget, realmStorage, eventManager, logger2);
        __privateMethod(_a4 = cdpTarget, _CdpTarget_instances, setEventListeners_fn).call(_a4);
        void __privateMethod(_b2 = cdpTarget, _CdpTarget_instances, unblock_fn).call(_b2);
        return cdpTarget;
      }
      /** Returns a deferred that resolves when the target is unblocked. */
      get unblocked() {
        return __privateGet(this, _unblocked);
      }
      get id() {
        return __privateGet(this, _id7);
      }
      get cdpClient() {
        return __privateGet(this, _cdpClient);
      }
      get parentCdpClient() {
        return __privateGet(this, _parentCdpClient);
      }
      get browserCdpClient() {
        return __privateGet(this, _browserCdpClient);
      }
      /** Needed for CDP escape path. */
      get cdpSessionId() {
        return __privateGet(this, _cdpClient).sessionId;
      }
      async toggleFetchIfNeeded() {
        const stages = __privateGet(this, _networkStorage).getInterceptionStages(this.topLevelId);
        if (__privateGet(this, _fetchDomainStages).request === stages.request && __privateGet(this, _fetchDomainStages).response === stages.response && __privateGet(this, _fetchDomainStages).auth === stages.auth) {
          return;
        }
        const patterns = [];
        __privateSet(this, _fetchDomainStages, stages);
        if (stages.request || stages.auth) {
          patterns.push({
            urlPattern: "*",
            requestStage: "Request"
          });
        }
        if (stages.response) {
          patterns.push({
            urlPattern: "*",
            requestStage: "Response"
          });
        }
        if (patterns.length) {
          await __privateGet(this, _cdpClient).sendCommand("Fetch.enable", {
            patterns,
            handleAuthRequests: stages.auth
          });
        } else {
          const blockedRequest = __privateGet(this, _networkStorage).getRequestsByTarget(this).filter((request) => request.interceptPhase);
          void Promise.allSettled(blockedRequest.map((request) => request.waitNextPhase)).then(async () => {
            const blockedRequest2 = __privateGet(this, _networkStorage).getRequestsByTarget(this).filter((request) => request.interceptPhase);
            if (blockedRequest2.length) {
              return await this.toggleFetchIfNeeded();
            }
            return await __privateGet(this, _cdpClient).sendCommand("Fetch.disable");
          }).catch((error) => {
            var _a4;
            (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, log_js_1.LogType.bidi, "Disable failed", error);
          });
        }
      }
      /**
       * Toggles CDP "Fetch" domain and enable/disable network cache.
       */
      async toggleNetworkIfNeeded() {
        var _a4;
        try {
          await Promise.all([
            this.toggleSetCacheDisabled(),
            this.toggleFetchIfNeeded()
          ]);
        } catch (err) {
          (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, log_js_1.LogType.debugError, err);
          if (!__privateMethod(this, _CdpTarget_instances, isExpectedError_fn).call(this, err)) {
            throw err;
          }
        }
      }
      async toggleSetCacheDisabled(disable) {
        var _a4;
        const defaultCacheDisabled = __privateGet(this, _networkStorage).defaultCacheBehavior === "bypass";
        const cacheDisabled = disable ?? defaultCacheDisabled;
        if (__privateGet(this, _cacheDisableState) === cacheDisabled) {
          return;
        }
        __privateSet(this, _cacheDisableState, cacheDisabled);
        try {
          await __privateGet(this, _cdpClient).sendCommand("Network.setCacheDisabled", {
            cacheDisabled
          });
        } catch (err) {
          (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, log_js_1.LogType.debugError, err);
          __privateSet(this, _cacheDisableState, !cacheDisabled);
          if (!__privateMethod(this, _CdpTarget_instances, isExpectedError_fn).call(this, err)) {
            throw err;
          }
        }
      }
      async toggleDeviceAccessIfNeeded() {
        var _a4;
        const enabled = this.isSubscribedTo(chromium_bidi_js_1.Bluetooth.EventNames.RequestDevicePromptUpdated);
        if (__privateGet(this, _deviceAccessEnabled) === enabled) {
          return;
        }
        __privateSet(this, _deviceAccessEnabled, enabled);
        try {
          await __privateGet(this, _cdpClient).sendCommand(enabled ? "DeviceAccess.enable" : "DeviceAccess.disable");
        } catch (err) {
          (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, log_js_1.LogType.debugError, err);
          __privateSet(this, _deviceAccessEnabled, !enabled);
          if (!__privateMethod(this, _CdpTarget_instances, isExpectedError_fn).call(this, err)) {
            throw err;
          }
        }
      }
      async toggleNetwork() {
        var _a4;
        const stages = __privateGet(this, _networkStorage).getInterceptionStages(this.topLevelId);
        const fetchEnable = Object.values(stages).some((value) => value);
        const fetchChanged = __privateGet(this, _fetchDomainStages).request !== stages.request || __privateGet(this, _fetchDomainStages).response !== stages.response || __privateGet(this, _fetchDomainStages).auth !== stages.auth;
        (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, log_js_1.LogType.debugInfo, "Toggle Network", `Fetch (${fetchEnable}) ${fetchChanged}`);
        if (fetchEnable && fetchChanged) {
          await __privateMethod(this, _CdpTarget_instances, enableFetch_fn).call(this, stages);
        }
        if (!fetchEnable && fetchChanged) {
          await __privateMethod(this, _CdpTarget_instances, disableFetch_fn).call(this);
        }
      }
      /**
       * All the ProxyChannels from all the preload scripts of the given
       * BrowsingContext.
       */
      getChannels() {
        return __privateGet(this, _preloadScriptStorage).find().flatMap((script) => script.channels);
      }
      get topLevelId() {
        return __privateGet(this, _browsingContextStorage).findTopLevelContextId(this.id) ?? this.id;
      }
      isSubscribedTo(moduleOrEvent) {
        return __privateGet(this, _eventManager).subscriptionManager.isSubscribedTo(moduleOrEvent, this.topLevelId);
      }
    }, _id7 = new WeakMap(), _cdpClient = new WeakMap(), _browserCdpClient = new WeakMap(), _parentCdpClient = new WeakMap(), _realmStorage = new WeakMap(), _eventManager = new WeakMap(), _preloadScriptStorage = new WeakMap(), _browsingContextStorage = new WeakMap(), _prerenderingDisabled = new WeakMap(), _networkStorage = new WeakMap(), _unblocked = new WeakMap(), _unhandledPromptBehavior = new WeakMap(), _logger = new WeakMap(), _deviceAccessEnabled = new WeakMap(), _cacheDisableState = new WeakMap(), _fetchDomainStages = new WeakMap(), _CdpTarget_instances = new WeakSet(), unblock_fn = async function() {
      var _a4;
      try {
        await Promise.all([
          __privateGet(this, _cdpClient).sendCommand("Page.enable"),
          // There can be some existing frames in the target, if reconnecting to an
          // existing browser instance, e.g. via Puppeteer. Need to restore the browsing
          // contexts for the frames to correctly handle further events, like
          // `Runtime.executionContextCreated`.
          // It's important to schedule this task together with enabling domains commands to
          // prepare the tree before the events (e.g. Runtime.executionContextCreated) start
          // coming.
          // https://github.com/GoogleChromeLabs/chromium-bidi/issues/2282
          __privateGet(this, _cdpClient).sendCommand("Page.getFrameTree").then((frameTree) => __privateMethod(this, _CdpTarget_instances, restoreFrameTreeState_fn).call(this, frameTree.frameTree)),
          __privateGet(this, _cdpClient).sendCommand("Runtime.enable"),
          __privateGet(this, _cdpClient).sendCommand("Page.setLifecycleEventsEnabled", {
            enabled: true
          }),
          __privateGet(this, _cdpClient).sendCommand("Page.setPrerenderingAllowed", {
            isAllowed: !__privateGet(this, _prerenderingDisabled)
          }).catch(() => {
          }),
          // Enabling CDP Network domain is required for navigation detection:
          // https://github.com/GoogleChromeLabs/chromium-bidi/issues/2856.
          __privateGet(this, _cdpClient).sendCommand("Network.enable").then(() => this.toggleNetworkIfNeeded()),
          __privateGet(this, _cdpClient).sendCommand("Target.setAutoAttach", {
            autoAttach: true,
            waitForDebuggerOnStart: true,
            flatten: true
          }),
          __privateMethod(this, _CdpTarget_instances, initAndEvaluatePreloadScripts_fn).call(this),
          __privateGet(this, _cdpClient).sendCommand("Runtime.runIfWaitingForDebugger"),
          // Resume tab execution as well if it was paused by the debugger.
          __privateGet(this, _parentCdpClient).sendCommand("Runtime.runIfWaitingForDebugger"),
          this.toggleDeviceAccessIfNeeded()
        ]);
      } catch (error) {
        (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, log_js_1.LogType.debugError, "Failed to unblock target", error);
        if (!__privateGet(this, _cdpClient).isCloseError(error)) {
          __privateGet(this, _unblocked).resolve({
            kind: "error",
            error
          });
          return;
        }
      }
      __privateGet(this, _unblocked).resolve({
        kind: "success",
        value: void 0
      });
    }, restoreFrameTreeState_fn = function(frameTree) {
      var _a4;
      const frame = frameTree.frame;
      const maybeContext = __privateGet(this, _browsingContextStorage).findContext(frame.id);
      if (maybeContext !== void 0) {
        if (maybeContext.parentId === null && frame.parentId !== null && frame.parentId !== void 0) {
          maybeContext.parentId = frame.parentId;
        }
      }
      if (maybeContext === void 0 && frame.parentId !== void 0) {
        const parentBrowsingContext = __privateGet(this, _browsingContextStorage).getContext(frame.parentId);
        BrowsingContextImpl_js_1.BrowsingContextImpl.create(frame.id, frame.parentId, parentBrowsingContext.userContext, parentBrowsingContext.cdpTarget, __privateGet(this, _eventManager), __privateGet(this, _browsingContextStorage), __privateGet(this, _realmStorage), frame.url, void 0, __privateGet(this, _unhandledPromptBehavior), __privateGet(this, _logger));
      }
      (_a4 = frameTree.childFrames) == null ? void 0 : _a4.map((frameTree2) => __privateMethod(this, _CdpTarget_instances, restoreFrameTreeState_fn).call(this, frameTree2));
    }, /**
     * Heuristic checking if the error is due to the session being closed. If so, ignore the
     * error.
     */
    isExpectedError_fn = function(err) {
      const error = err;
      return error.code === -32001 && error.message === "Session with given id not found." || __privateGet(this, _cdpClient).isCloseError(err);
    }, setEventListeners_fn = function() {
      __privateGet(this, _cdpClient).on("Network.requestWillBeSent", (eventParams) => {
        if (eventParams.loaderId === eventParams.requestId) {
          this.emit("frameStartedNavigating", {
            loaderId: eventParams.loaderId,
            url: eventParams.request.url,
            frameId: eventParams.frameId
          });
        }
      });
      __privateGet(this, _cdpClient).on("*", (event, params) => {
        if (typeof event !== "string") {
          return;
        }
        __privateGet(this, _eventManager).registerEvent({
          type: "event",
          method: `goog:cdp.${event}`,
          params: {
            event,
            params,
            session: this.cdpSessionId
          }
        }, this.id);
        __privateGet(this, _eventManager).registerEvent({
          type: "event",
          method: `cdp.${event}`,
          params: {
            event,
            params,
            session: this.cdpSessionId
          }
        }, this.id);
      });
    }, enableFetch_fn = async function(stages) {
      const patterns = [];
      if (stages.request || stages.auth) {
        patterns.push({
          urlPattern: "*",
          requestStage: "Request"
        });
      }
      if (stages.response) {
        patterns.push({
          urlPattern: "*",
          requestStage: "Response"
        });
      }
      if (patterns.length) {
        const oldStages = __privateGet(this, _fetchDomainStages);
        __privateSet(this, _fetchDomainStages, stages);
        try {
          await __privateGet(this, _cdpClient).sendCommand("Fetch.enable", {
            patterns,
            handleAuthRequests: stages.auth
          });
        } catch {
          __privateSet(this, _fetchDomainStages, oldStages);
        }
      }
    }, disableFetch_fn = async function() {
      const blockedRequest = __privateGet(this, _networkStorage).getRequestsByTarget(this).filter((request) => request.interceptPhase);
      if (blockedRequest.length === 0) {
        __privateSet(this, _fetchDomainStages, {
          request: false,
          response: false,
          auth: false
        });
        await __privateGet(this, _cdpClient).sendCommand("Fetch.disable");
      }
    }, initAndEvaluatePreloadScripts_fn = async function() {
      await Promise.all(__privateGet(this, _preloadScriptStorage).find({
        // Needed for OOPIF
        targetId: this.topLevelId,
        global: true
      }).map((script) => {
        return script.initInTarget(this, true);
      }));
    }, _a3);
    CdpTarget.CdpTarget = CdpTarget$12;
    return CdpTarget;
  }
  var hasRequiredCdpTargetManager;
  function requireCdpTargetManager() {
    var _browserCdpClient, _cdpConnection, _targetKeysToBeIgnoredByAutoAttach, _selfTargetId, _eventManager, _browsingContextStorage, _networkStorage, _bluetoothProcessor, _preloadScriptStorage, _realmStorage, _defaultUserContextId, _logger, _unhandledPromptBehavior, _prerenderingDisabled, _CdpTargetManager_instances, setEventListeners_fn, handleFrameAttachedEvent_fn, handleFrameDetachedEvent_fn, handleFrameSubtreeWillBeDetached_fn, handleAttachedToTargetEvent_fn, findFrameParentId_fn, createCdpTarget_fn, _workers5, handleWorkerTarget_fn, handleDetachedFromTargetEvent_fn, handleTargetInfoChangedEvent_fn, handleTargetCrashedEvent_fn, _a3;
    if (hasRequiredCdpTargetManager) return CdpTargetManager;
    hasRequiredCdpTargetManager = 1;
    Object.defineProperty(CdpTargetManager, "__esModule", { value: true });
    CdpTargetManager.CdpTargetManager = void 0;
    const log_js_1 = requireLog();
    const BrowsingContextImpl_js_1 = requireBrowsingContextImpl();
    const WorkerRealm_js_1 = requireWorkerRealm();
    const CdpTarget_js_1 = requireCdpTarget();
    const cdpToBidiTargetTypes = {
      service_worker: "service-worker",
      shared_worker: "shared-worker",
      worker: "dedicated-worker"
    };
    let CdpTargetManager$1 = (_a3 = class {
      constructor(cdpConnection, browserCdpClient, selfTargetId, eventManager, browsingContextStorage, realmStorage, networkStorage, bluetoothProcessor, preloadScriptStorage, defaultUserContextId, prerenderingDisabled, unhandledPromptBehavior, logger2) {
        __privateAdd(this, _CdpTargetManager_instances);
        __privateAdd(this, _browserCdpClient);
        __privateAdd(this, _cdpConnection);
        __privateAdd(this, _targetKeysToBeIgnoredByAutoAttach, /* @__PURE__ */ new Set());
        __privateAdd(this, _selfTargetId);
        __privateAdd(this, _eventManager);
        __privateAdd(this, _browsingContextStorage);
        __privateAdd(this, _networkStorage);
        __privateAdd(this, _bluetoothProcessor);
        __privateAdd(this, _preloadScriptStorage);
        __privateAdd(this, _realmStorage);
        __privateAdd(this, _defaultUserContextId);
        __privateAdd(this, _logger);
        __privateAdd(this, _unhandledPromptBehavior);
        __privateAdd(this, _prerenderingDisabled);
        __privateAdd(this, _workers5, /* @__PURE__ */ new Map());
        __privateSet(this, _cdpConnection, cdpConnection);
        __privateSet(this, _browserCdpClient, browserCdpClient);
        __privateGet(this, _targetKeysToBeIgnoredByAutoAttach).add(selfTargetId);
        __privateSet(this, _selfTargetId, selfTargetId);
        __privateSet(this, _eventManager, eventManager);
        __privateSet(this, _browsingContextStorage, browsingContextStorage);
        __privateSet(this, _preloadScriptStorage, preloadScriptStorage);
        __privateSet(this, _networkStorage, networkStorage);
        __privateSet(this, _bluetoothProcessor, bluetoothProcessor);
        __privateSet(this, _realmStorage, realmStorage);
        __privateSet(this, _defaultUserContextId, defaultUserContextId);
        __privateSet(this, _prerenderingDisabled, prerenderingDisabled);
        __privateSet(this, _unhandledPromptBehavior, unhandledPromptBehavior);
        __privateSet(this, _logger, logger2);
        __privateMethod(this, _CdpTargetManager_instances, setEventListeners_fn).call(this, browserCdpClient);
      }
    }, _browserCdpClient = new WeakMap(), _cdpConnection = new WeakMap(), _targetKeysToBeIgnoredByAutoAttach = new WeakMap(), _selfTargetId = new WeakMap(), _eventManager = new WeakMap(), _browsingContextStorage = new WeakMap(), _networkStorage = new WeakMap(), _bluetoothProcessor = new WeakMap(), _preloadScriptStorage = new WeakMap(), _realmStorage = new WeakMap(), _defaultUserContextId = new WeakMap(), _logger = new WeakMap(), _unhandledPromptBehavior = new WeakMap(), _prerenderingDisabled = new WeakMap(), _CdpTargetManager_instances = new WeakSet(), /**
     * This method is called for each CDP session, since this class is responsible
     * for creating and destroying all targets and browsing contexts.
     */
    setEventListeners_fn = function(cdpClient) {
      cdpClient.on("Target.attachedToTarget", (params) => {
        __privateMethod(this, _CdpTargetManager_instances, handleAttachedToTargetEvent_fn).call(this, params, cdpClient);
      });
      cdpClient.on("Target.detachedFromTarget", __privateMethod(this, _CdpTargetManager_instances, handleDetachedFromTargetEvent_fn).bind(this));
      cdpClient.on("Target.targetInfoChanged", __privateMethod(this, _CdpTargetManager_instances, handleTargetInfoChangedEvent_fn).bind(this));
      cdpClient.on("Inspector.targetCrashed", () => {
        __privateMethod(this, _CdpTargetManager_instances, handleTargetCrashedEvent_fn).call(this, cdpClient);
      });
      cdpClient.on("Page.frameAttached", __privateMethod(this, _CdpTargetManager_instances, handleFrameAttachedEvent_fn).bind(this));
      cdpClient.on("Page.frameDetached", __privateMethod(this, _CdpTargetManager_instances, handleFrameDetachedEvent_fn).bind(this));
      cdpClient.on("Page.frameSubtreeWillBeDetached", __privateMethod(this, _CdpTargetManager_instances, handleFrameSubtreeWillBeDetached_fn).bind(this));
    }, handleFrameAttachedEvent_fn = function(params) {
      const parentBrowsingContext = __privateGet(this, _browsingContextStorage).findContext(params.parentFrameId);
      if (parentBrowsingContext !== void 0) {
        BrowsingContextImpl_js_1.BrowsingContextImpl.create(
          params.frameId,
          params.parentFrameId,
          parentBrowsingContext.userContext,
          parentBrowsingContext.cdpTarget,
          __privateGet(this, _eventManager),
          __privateGet(this, _browsingContextStorage),
          __privateGet(this, _realmStorage),
          // At this point, we don't know the URL of the frame yet, so it will be updated
          // later.
          "about:blank",
          void 0,
          __privateGet(this, _unhandledPromptBehavior),
          __privateGet(this, _logger)
        );
      }
    }, handleFrameDetachedEvent_fn = function(params) {
      var _a4;
      if (params.reason === "swap") {
        return;
      }
      (_a4 = __privateGet(this, _browsingContextStorage).findContext(params.frameId)) == null ? void 0 : _a4.dispose(true);
    }, handleFrameSubtreeWillBeDetached_fn = function(params) {
      var _a4;
      (_a4 = __privateGet(this, _browsingContextStorage).findContext(params.frameId)) == null ? void 0 : _a4.dispose(true);
    }, handleAttachedToTargetEvent_fn = function(params, parentSessionCdpClient) {
      const { sessionId, targetInfo } = params;
      const targetCdpClient = __privateGet(this, _cdpConnection).getCdpClient(sessionId);
      const detach = async () => {
        await targetCdpClient.sendCommand("Runtime.runIfWaitingForDebugger").then(() => parentSessionCdpClient.sendCommand("Target.detachFromTarget", params)).catch((error) => {
          var _a4;
          return (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, log_js_1.LogType.debugError, error);
        });
      };
      if (__privateGet(this, _selfTargetId) === targetInfo.targetId) {
        void detach();
        return;
      }
      const targetKey = targetInfo.type === "service_worker" ? `${parentSessionCdpClient.sessionId}_${targetInfo.targetId}` : targetInfo.targetId;
      if (__privateGet(this, _targetKeysToBeIgnoredByAutoAttach).has(targetKey)) {
        return;
      }
      __privateGet(this, _targetKeysToBeIgnoredByAutoAttach).add(targetKey);
      switch (targetInfo.type) {
        case "tab":
          __privateMethod(this, _CdpTargetManager_instances, setEventListeners_fn).call(this, targetCdpClient);
          void (async () => {
            await targetCdpClient.sendCommand("Target.setAutoAttach", {
              autoAttach: true,
              waitForDebuggerOnStart: true,
              flatten: true
            });
          })();
          return;
        case "page":
        case "iframe": {
          const cdpTarget = __privateMethod(this, _CdpTargetManager_instances, createCdpTarget_fn).call(this, targetCdpClient, parentSessionCdpClient, targetInfo);
          const maybeContext = __privateGet(this, _browsingContextStorage).findContext(targetInfo.targetId);
          if (maybeContext && targetInfo.type === "iframe") {
            maybeContext.updateCdpTarget(cdpTarget);
          } else {
            const parentId = __privateMethod(this, _CdpTargetManager_instances, findFrameParentId_fn).call(this, targetInfo, parentSessionCdpClient.sessionId);
            const userContext = targetInfo.browserContextId && targetInfo.browserContextId !== __privateGet(this, _defaultUserContextId) ? targetInfo.browserContextId : "default";
            BrowsingContextImpl_js_1.BrowsingContextImpl.create(
              targetInfo.targetId,
              parentId,
              userContext,
              cdpTarget,
              __privateGet(this, _eventManager),
              __privateGet(this, _browsingContextStorage),
              __privateGet(this, _realmStorage),
              // Hack: when a new target created, CDP emits targetInfoChanged with an empty
              // url, and navigates it to about:blank later. When the event is emitted for
              // an existing target (reconnect), the url is already known, and navigation
              // events will not be emitted anymore. Replacing empty url with `about:blank`
              // allows to handle both cases in the same way.
              // "7.3.2.1 Creating browsing contexts".
              // https://html.spec.whatwg.org/multipage/document-sequences.html#creating-browsing-contexts
              // TODO: check who to deal with non-null creator and its `creatorOrigin`.
              targetInfo.url === "" ? "about:blank" : targetInfo.url,
              targetInfo.openerFrameId ?? targetInfo.openerId,
              __privateGet(this, _unhandledPromptBehavior),
              __privateGet(this, _logger)
            );
          }
          return;
        }
        case "service_worker":
        case "worker": {
          const realm = __privateGet(this, _realmStorage).findRealm({
            cdpSessionId: parentSessionCdpClient.sessionId
          });
          if (!realm) {
            void detach();
            return;
          }
          const cdpTarget = __privateMethod(this, _CdpTargetManager_instances, createCdpTarget_fn).call(this, targetCdpClient, parentSessionCdpClient, targetInfo);
          __privateMethod(this, _CdpTargetManager_instances, handleWorkerTarget_fn).call(this, cdpToBidiTargetTypes[targetInfo.type], cdpTarget, realm);
          return;
        }
        // In CDP, we only emit shared workers on the browser and not the set of
        // frames that use the shared worker. If we change this in the future to
        // behave like service workers (emits on both browser and frame targets),
        // we can remove this block and merge service workers with the above one.
        case "shared_worker": {
          const cdpTarget = __privateMethod(this, _CdpTargetManager_instances, createCdpTarget_fn).call(this, targetCdpClient, parentSessionCdpClient, targetInfo);
          __privateMethod(this, _CdpTargetManager_instances, handleWorkerTarget_fn).call(this, cdpToBidiTargetTypes[targetInfo.type], cdpTarget);
          return;
        }
      }
      void detach();
    }, /** Try to find the parent browsing context ID for the given attached target. */
    findFrameParentId_fn = function(targetInfo, parentSessionId) {
      var _a4;
      if (targetInfo.type !== "iframe") {
        return null;
      }
      const parentId = targetInfo.openerFrameId ?? targetInfo.openerId;
      if (parentId !== void 0) {
        return parentId;
      }
      if (parentSessionId !== void 0) {
        return ((_a4 = __privateGet(this, _browsingContextStorage).findContextBySession(parentSessionId)) == null ? void 0 : _a4.id) ?? null;
      }
      return null;
    }, createCdpTarget_fn = function(targetCdpClient, parentCdpClient, targetInfo) {
      __privateMethod(this, _CdpTargetManager_instances, setEventListeners_fn).call(this, targetCdpClient);
      const target = CdpTarget_js_1.CdpTarget.create(targetInfo.targetId, targetCdpClient, __privateGet(this, _browserCdpClient), parentCdpClient, __privateGet(this, _realmStorage), __privateGet(this, _eventManager), __privateGet(this, _preloadScriptStorage), __privateGet(this, _browsingContextStorage), __privateGet(this, _networkStorage), __privateGet(this, _prerenderingDisabled), __privateGet(this, _unhandledPromptBehavior), __privateGet(this, _logger));
      __privateGet(this, _networkStorage).onCdpTargetCreated(target);
      __privateGet(this, _bluetoothProcessor).onCdpTargetCreated(target);
      return target;
    }, _workers5 = new WeakMap(), handleWorkerTarget_fn = function(realmType, cdpTarget, ownerRealm) {
      cdpTarget.cdpClient.on("Runtime.executionContextCreated", (params) => {
        const { uniqueId, id, origin } = params.context;
        const workerRealm = new WorkerRealm_js_1.WorkerRealm(cdpTarget.cdpClient, __privateGet(this, _eventManager), id, __privateGet(this, _logger), (0, BrowsingContextImpl_js_1.serializeOrigin)(origin), ownerRealm ? [ownerRealm] : [], uniqueId, __privateGet(this, _realmStorage), realmType);
        __privateGet(this, _workers5).set(cdpTarget.cdpSessionId, workerRealm);
      });
    }, handleDetachedFromTargetEvent_fn = function({ sessionId, targetId }) {
      if (targetId) {
        __privateGet(this, _preloadScriptStorage).find({ targetId }).map((preloadScript) => {
          preloadScript.dispose(targetId);
        });
      }
      const context = __privateGet(this, _browsingContextStorage).findContextBySession(sessionId);
      if (context) {
        context.dispose(true);
        return;
      }
      const worker = __privateGet(this, _workers5).get(sessionId);
      if (worker) {
        __privateGet(this, _realmStorage).deleteRealms({
          cdpSessionId: worker.cdpClient.sessionId
        });
      }
    }, handleTargetInfoChangedEvent_fn = function(params) {
      const context = __privateGet(this, _browsingContextStorage).findContext(params.targetInfo.targetId);
      if (context) {
        context.onTargetInfoChanged(params);
      }
    }, handleTargetCrashedEvent_fn = function(cdpClient) {
      const realms = __privateGet(this, _realmStorage).findRealms({
        cdpSessionId: cdpClient.sessionId
      });
      for (const realm of realms) {
        realm.dispose();
      }
    }, _a3);
    CdpTargetManager.CdpTargetManager = CdpTargetManager$1;
    return CdpTargetManager;
  }
  var BrowsingContextStorage = {};
  var hasRequiredBrowsingContextStorage;
  function requireBrowsingContextStorage() {
    var _contexts2, _eventEmitter, _a3;
    if (hasRequiredBrowsingContextStorage) return BrowsingContextStorage;
    hasRequiredBrowsingContextStorage = 1;
    Object.defineProperty(BrowsingContextStorage, "__esModule", { value: true });
    BrowsingContextStorage.BrowsingContextStorage = void 0;
    const protocol_js_1 = requireProtocol();
    const EventEmitter_js_1 = requireEventEmitter();
    let BrowsingContextStorage$1 = (_a3 = class {
      constructor() {
        /** Map from context ID to context implementation. */
        __privateAdd(this, _contexts2, /* @__PURE__ */ new Map());
        /** Event emitter for browsing context storage eventsis not expected to be exposed to
         * the outside world. */
        __privateAdd(this, _eventEmitter, new EventEmitter_js_1.EventEmitter());
      }
      /** Gets all top-level contexts, i.e. those with no parent. */
      getTopLevelContexts() {
        return this.getAllContexts().filter((context) => context.isTopLevelContext());
      }
      /** Gets all contexts. */
      getAllContexts() {
        return Array.from(__privateGet(this, _contexts2).values());
      }
      /** Deletes the context with the given ID. */
      deleteContextById(id) {
        __privateGet(this, _contexts2).delete(id);
      }
      /** Deletes the given context. */
      deleteContext(context) {
        __privateGet(this, _contexts2).delete(context.id);
      }
      /** Tracks the given context. */
      addContext(context) {
        __privateGet(this, _contexts2).set(context.id, context);
        __privateGet(this, _eventEmitter).emit("added", {
          browsingContext: context
        });
      }
      /**
       * Waits for a context with the given ID to be added and returns it.
       */
      waitForContext(browsingContextId) {
        if (__privateGet(this, _contexts2).has(browsingContextId)) {
          return Promise.resolve(this.getContext(browsingContextId));
        }
        return new Promise((resolve) => {
          const listener = (event) => {
            if (event.browsingContext.id === browsingContextId) {
              __privateGet(this, _eventEmitter).off("added", listener);
              resolve(event.browsingContext);
            }
          };
          __privateGet(this, _eventEmitter).on("added", listener);
        });
      }
      /** Returns true whether there is an existing context with the given ID. */
      hasContext(id) {
        return __privateGet(this, _contexts2).has(id);
      }
      /** Gets the context with the given ID, if any. */
      findContext(id) {
        return __privateGet(this, _contexts2).get(id);
      }
      /** Returns the top-level context ID of the given context, if any. */
      findTopLevelContextId(id) {
        if (id === null) {
          return null;
        }
        const maybeContext = this.findContext(id);
        if (!maybeContext) {
          return null;
        }
        const parentId = maybeContext.parentId ?? null;
        if (parentId === null) {
          return id;
        }
        return this.findTopLevelContextId(parentId);
      }
      findContextBySession(sessionId) {
        for (const context of __privateGet(this, _contexts2).values()) {
          if (context.cdpTarget.cdpSessionId === sessionId) {
            return context;
          }
        }
        return;
      }
      /** Gets the context with the given ID, if any, otherwise throws. */
      getContext(id) {
        const result = this.findContext(id);
        if (result === void 0) {
          throw new protocol_js_1.NoSuchFrameException(`Context ${id} not found`);
        }
        return result;
      }
      verifyTopLevelContextsList(contexts) {
        const foundContexts = /* @__PURE__ */ new Set();
        if (!contexts) {
          return foundContexts;
        }
        for (const contextId of contexts) {
          const context = this.getContext(contextId);
          if (context.isTopLevelContext()) {
            foundContexts.add(context);
          } else {
            throw new protocol_js_1.InvalidArgumentException(`Non top-level context '${contextId}' given.`);
          }
        }
        return foundContexts;
      }
    }, _contexts2 = new WeakMap(), _eventEmitter = new WeakMap(), _a3);
    BrowsingContextStorage.BrowsingContextStorage = BrowsingContextStorage$1;
    return BrowsingContextStorage;
  }
  var NetworkStorage = {};
  var NetworkRequest = {};
  var DefaultMap = {};
  var hasRequiredDefaultMap;
  function requireDefaultMap() {
    var _getDefaultValue, _a3;
    if (hasRequiredDefaultMap) return DefaultMap;
    hasRequiredDefaultMap = 1;
    Object.defineProperty(DefaultMap, "__esModule", { value: true });
    DefaultMap.DefaultMap = void 0;
    let DefaultMap$1 = (_a3 = class extends Map {
      constructor(getDefaultValue, entries) {
        super(entries);
        /** The default value to return whenever a key is not present in the map. */
        __privateAdd(this, _getDefaultValue);
        __privateSet(this, _getDefaultValue, getDefaultValue);
      }
      get(key) {
        if (!this.has(key)) {
          this.set(key, __privateGet(this, _getDefaultValue).call(this, key));
        }
        return super.get(key);
      }
    }, _getDefaultValue = new WeakMap(), _a3);
    DefaultMap.DefaultMap = DefaultMap$1;
    return DefaultMap;
  }
  var hasRequiredNetworkRequest;
  function requireNetworkRequest() {
    var _a4, _id7, _fetchId, _interceptPhase, _servedFromCache, _redirectCount, _request3, _requestOverrides, _responseOverrides, _response2, _eventManager, _networkStorage, _cdpTarget, _logger, _emittedEvents, _NetworkRequest_instances, isDataUrl_fn, method_get, navigationId_get, cookies_get, bodySize_get, context_get, statusCode_get, requestHeaders_get, authChallenges_get, timings_get, phaseChanged_fn, interceptsInPhase_fn, isBlockedInPhase_fn, emitEventsIfReady_fn, continueRequest_fn, continueResponse_fn, continueWithAuth_fn, emitEvent_fn, getBaseEventParams_fn, getResponseEventParams_fn, getRequestData_fn, getDestination_fn, getInitiatorType_fn, getBeforeRequestEvent_fn, getResponseStartedEvent_fn, getResponseReceivedEvent_fn, isIgnoredEvent_fn, getOverrideHeader_fn, _NetworkRequest_static, getInitiator_fn;
    if (hasRequiredNetworkRequest) return NetworkRequest;
    hasRequiredNetworkRequest = 1;
    var _a3;
    Object.defineProperty(NetworkRequest, "__esModule", { value: true });
    NetworkRequest.NetworkRequest = void 0;
    const protocol_js_1 = requireProtocol();
    const assert_js_1 = requireAssert();
    const DefaultMap_js_1 = requireDefaultMap();
    const Deferred_js_1 = requireDeferred();
    const log_js_1 = requireLog();
    const NetworkUtils_js_1 = requireNetworkUtils();
    const REALM_REGEX = new RegExp('(?<=realm=").*(?=")');
    let NetworkRequest$1 = (_a4 = class {
      constructor(id, eventManager, networkStorage, cdpTarget, redirectCount = 0, logger2) {
        __privateAdd(this, _NetworkRequest_instances);
        /**
         * Each network request has an associated request id, which is a string
         * uniquely identifying that request.
         *
         * The identifier for a request resulting from a redirect matches that of the
         * request that initiated it.
         */
        __privateAdd(this, _id7);
        __privateAdd(this, _fetchId);
        /**
         * Indicates the network intercept phase, if the request is currently blocked.
         * Undefined necessarily implies that the request is not blocked.
         */
        __privateAdd(this, _interceptPhase);
        __privateAdd(this, _servedFromCache, false);
        __privateAdd(this, _redirectCount);
        __privateAdd(this, _request3, {});
        __privateAdd(this, _requestOverrides);
        __privateAdd(this, _responseOverrides);
        __privateAdd(this, _response2, {});
        __privateAdd(this, _eventManager);
        __privateAdd(this, _networkStorage);
        __privateAdd(this, _cdpTarget);
        __privateAdd(this, _logger);
        __privateAdd(this, _emittedEvents, {
          [protocol_js_1.ChromiumBidi.Network.EventNames.AuthRequired]: false,
          [protocol_js_1.ChromiumBidi.Network.EventNames.BeforeRequestSent]: false,
          [protocol_js_1.ChromiumBidi.Network.EventNames.FetchError]: false,
          [protocol_js_1.ChromiumBidi.Network.EventNames.ResponseCompleted]: false,
          [protocol_js_1.ChromiumBidi.Network.EventNames.ResponseStarted]: false
        });
        __publicField(this, "waitNextPhase", new Deferred_js_1.Deferred());
        __privateSet(this, _id7, id);
        __privateSet(this, _eventManager, eventManager);
        __privateSet(this, _networkStorage, networkStorage);
        __privateSet(this, _cdpTarget, cdpTarget);
        __privateSet(this, _redirectCount, redirectCount);
        __privateSet(this, _logger, logger2);
      }
      get id() {
        return __privateGet(this, _id7);
      }
      get fetchId() {
        return __privateGet(this, _fetchId);
      }
      /**
       * When blocked returns the phase for it
       */
      get interceptPhase() {
        return __privateGet(this, _interceptPhase);
      }
      get url() {
        var _a5, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
        const fragment = ((_a5 = __privateGet(this, _request3).info) == null ? void 0 : _a5.request.urlFragment) ?? ((_b2 = __privateGet(this, _request3).paused) == null ? void 0 : _b2.request.urlFragment) ?? "";
        const url = ((_c2 = __privateGet(this, _response2).paused) == null ? void 0 : _c2.request.url) ?? ((_d2 = __privateGet(this, _requestOverrides)) == null ? void 0 : _d2.url) ?? ((_e2 = __privateGet(this, _response2).info) == null ? void 0 : _e2.url) ?? ((_f2 = __privateGet(this, _request3).auth) == null ? void 0 : _f2.request.url) ?? ((_g2 = __privateGet(this, _request3).info) == null ? void 0 : _g2.request.url) ?? ((_h2 = __privateGet(this, _request3).paused) == null ? void 0 : _h2.request.url) ?? _a3.unknownParameter;
        return `${url}${fragment}`;
      }
      get redirectCount() {
        return __privateGet(this, _redirectCount);
      }
      get cdpTarget() {
        return __privateGet(this, _cdpTarget);
      }
      get cdpClient() {
        return __privateGet(this, _cdpTarget).cdpClient;
      }
      isRedirecting() {
        return Boolean(__privateGet(this, _request3).info);
      }
      handleRedirect(event) {
        __privateGet(this, _response2).hasExtraInfo = false;
        __privateGet(this, _response2).info = event.redirectResponse;
        __privateMethod(this, _NetworkRequest_instances, emitEventsIfReady_fn).call(this, {
          wasRedirected: true
        });
      }
      onRequestWillBeSentEvent(event) {
        __privateGet(this, _request3).info = event;
        __privateMethod(this, _NetworkRequest_instances, emitEventsIfReady_fn).call(this);
      }
      onRequestWillBeSentExtraInfoEvent(event) {
        __privateGet(this, _request3).extraInfo = event;
        __privateMethod(this, _NetworkRequest_instances, emitEventsIfReady_fn).call(this);
      }
      onResponseReceivedExtraInfoEvent(event) {
        if (event.statusCode >= 300 && event.statusCode <= 399 && __privateGet(this, _request3).info && event.headers["location"] === __privateGet(this, _request3).info.request.url) {
          return;
        }
        __privateGet(this, _response2).extraInfo = event;
        __privateMethod(this, _NetworkRequest_instances, emitEventsIfReady_fn).call(this);
      }
      onResponseReceivedEvent(event) {
        __privateGet(this, _response2).hasExtraInfo = event.hasExtraInfo;
        __privateGet(this, _response2).info = event.response;
        __privateMethod(this, _NetworkRequest_instances, emitEventsIfReady_fn).call(this);
      }
      onServedFromCache() {
        __privateSet(this, _servedFromCache, true);
        __privateMethod(this, _NetworkRequest_instances, emitEventsIfReady_fn).call(this);
      }
      onLoadingFailedEvent(event) {
        __privateMethod(this, _NetworkRequest_instances, emitEventsIfReady_fn).call(this, {
          hasFailed: true
        });
        __privateMethod(this, _NetworkRequest_instances, emitEvent_fn).call(this, () => {
          return {
            method: protocol_js_1.ChromiumBidi.Network.EventNames.FetchError,
            params: {
              ...__privateMethod(this, _NetworkRequest_instances, getBaseEventParams_fn).call(this),
              errorText: event.errorText
            }
          };
        });
      }
      /** @see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-failRequest */
      async failRequest(errorReason) {
        (0, assert_js_1.assert)(__privateGet(this, _fetchId), "Network Interception not set-up.");
        await this.cdpClient.sendCommand("Fetch.failRequest", {
          requestId: __privateGet(this, _fetchId),
          errorReason
        });
        __privateSet(this, _interceptPhase, void 0);
      }
      onRequestPaused(event) {
        __privateSet(this, _fetchId, event.requestId);
        if (event.responseStatusCode || event.responseErrorReason) {
          __privateGet(this, _response2).paused = event;
          if (__privateMethod(this, _NetworkRequest_instances, isBlockedInPhase_fn).call(this, "responseStarted") && // CDP may emit multiple events for a single request
          !__privateGet(this, _emittedEvents)[protocol_js_1.ChromiumBidi.Network.EventNames.ResponseStarted] && // Continue all response that have not enabled Network domain
          __privateGet(this, _fetchId) !== this.id) {
            __privateSet(this, _interceptPhase, "responseStarted");
          } else {
            void __privateMethod(this, _NetworkRequest_instances, continueResponse_fn).call(this);
          }
        } else {
          __privateGet(this, _request3).paused = event;
          if (__privateMethod(this, _NetworkRequest_instances, isBlockedInPhase_fn).call(this, "beforeRequestSent") && // CDP may emit multiple events for a single request
          !__privateGet(this, _emittedEvents)[protocol_js_1.ChromiumBidi.Network.EventNames.BeforeRequestSent] && // Continue all requests that have not enabled Network domain
          __privateGet(this, _fetchId) !== this.id) {
            __privateSet(this, _interceptPhase, "beforeRequestSent");
          } else {
            void __privateMethod(this, _NetworkRequest_instances, continueRequest_fn).call(this);
          }
        }
        __privateMethod(this, _NetworkRequest_instances, emitEventsIfReady_fn).call(this);
      }
      onAuthRequired(event) {
        __privateSet(this, _fetchId, event.requestId);
        __privateGet(this, _request3).auth = event;
        if (__privateMethod(this, _NetworkRequest_instances, isBlockedInPhase_fn).call(this, "authRequired") && // Continue all auth requests that have not enabled Network domain
        __privateGet(this, _fetchId) !== this.id) {
          __privateSet(this, _interceptPhase, "authRequired");
        } else {
          void __privateMethod(this, _NetworkRequest_instances, continueWithAuth_fn).call(this, {
            response: "Default"
          });
        }
        __privateMethod(this, _NetworkRequest_instances, emitEvent_fn).call(this, () => {
          return {
            method: protocol_js_1.ChromiumBidi.Network.EventNames.AuthRequired,
            params: {
              ...__privateMethod(this, _NetworkRequest_instances, getBaseEventParams_fn).call(this, "authRequired"),
              response: __privateMethod(this, _NetworkRequest_instances, getResponseEventParams_fn).call(this)
            }
          };
        });
      }
      /** @see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-continueRequest */
      async continueRequest(overrides = {}) {
        const overrideHeaders = __privateMethod(this, _NetworkRequest_instances, getOverrideHeader_fn).call(this, overrides.headers, overrides.cookies);
        const headers = (0, NetworkUtils_js_1.cdpFetchHeadersFromBidiNetworkHeaders)(overrideHeaders);
        const postData = getCdpBodyFromBiDiBytesValue(overrides.body);
        await __privateMethod(this, _NetworkRequest_instances, continueRequest_fn).call(this, {
          url: overrides.url,
          method: overrides.method,
          headers,
          postData
        });
        __privateSet(this, _requestOverrides, {
          url: overrides.url,
          method: overrides.method,
          headers: overrides.headers,
          cookies: overrides.cookies,
          bodySize: getSizeFromBiDiBytesValue(overrides.body)
        });
      }
      /** @see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-continueResponse */
      async continueResponse(overrides = {}) {
        var _a5, _b2, _c2;
        if (this.interceptPhase === "authRequired") {
          if (overrides.credentials) {
            await Promise.all([
              this.waitNextPhase,
              await __privateMethod(this, _NetworkRequest_instances, continueWithAuth_fn).call(this, {
                response: "ProvideCredentials",
                username: overrides.credentials.username,
                password: overrides.credentials.password
              })
            ]);
          } else {
            return await __privateMethod(this, _NetworkRequest_instances, continueWithAuth_fn).call(this, {
              response: "ProvideCredentials"
            });
          }
        }
        if (__privateGet(this, _interceptPhase) === "responseStarted") {
          const overrideHeaders = __privateMethod(this, _NetworkRequest_instances, getOverrideHeader_fn).call(this, overrides.headers, overrides.cookies);
          const responseHeaders = (0, NetworkUtils_js_1.cdpFetchHeadersFromBidiNetworkHeaders)(overrideHeaders);
          await __privateMethod(this, _NetworkRequest_instances, continueResponse_fn).call(this, {
            responseCode: overrides.statusCode ?? ((_a5 = __privateGet(this, _response2).paused) == null ? void 0 : _a5.responseStatusCode),
            responsePhrase: overrides.reasonPhrase ?? ((_b2 = __privateGet(this, _response2).paused) == null ? void 0 : _b2.responseStatusText),
            responseHeaders: responseHeaders ?? ((_c2 = __privateGet(this, _response2).paused) == null ? void 0 : _c2.responseHeaders)
          });
          __privateSet(this, _responseOverrides, {
            statusCode: overrides.statusCode,
            headers: overrideHeaders
          });
        }
      }
      /** @see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-continueWithAuth */
      async continueWithAuth(authChallenge) {
        let username;
        let password;
        if (authChallenge.action === "provideCredentials") {
          const { credentials } = authChallenge;
          username = credentials.username;
          password = credentials.password;
        }
        const response = (0, NetworkUtils_js_1.cdpAuthChallengeResponseFromBidiAuthContinueWithAuthAction)(authChallenge.action);
        await __privateMethod(this, _NetworkRequest_instances, continueWithAuth_fn).call(this, {
          response,
          username,
          password
        });
      }
      /** @see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-provideResponse */
      async provideResponse(overrides) {
        (0, assert_js_1.assert)(__privateGet(this, _fetchId), "Network Interception not set-up.");
        if (this.interceptPhase === "authRequired") {
          return await __privateMethod(this, _NetworkRequest_instances, continueWithAuth_fn).call(this, {
            response: "ProvideCredentials"
          });
        }
        if (!overrides.body && !overrides.headers) {
          return await __privateMethod(this, _NetworkRequest_instances, continueRequest_fn).call(this);
        }
        const overrideHeaders = __privateMethod(this, _NetworkRequest_instances, getOverrideHeader_fn).call(this, overrides.headers, overrides.cookies);
        const responseHeaders = (0, NetworkUtils_js_1.cdpFetchHeadersFromBidiNetworkHeaders)(overrideHeaders);
        const responseCode = overrides.statusCode ?? __privateGet(this, _NetworkRequest_instances, statusCode_get) ?? 200;
        await this.cdpClient.sendCommand("Fetch.fulfillRequest", {
          requestId: __privateGet(this, _fetchId),
          responseCode,
          responsePhrase: overrides.reasonPhrase,
          responseHeaders,
          body: getCdpBodyFromBiDiBytesValue(overrides.body)
        });
        __privateSet(this, _interceptPhase, void 0);
      }
      dispose() {
        this.waitNextPhase.reject(new Error("waitNextPhase disposed"));
      }
    }, _id7 = new WeakMap(), _fetchId = new WeakMap(), _interceptPhase = new WeakMap(), _servedFromCache = new WeakMap(), _redirectCount = new WeakMap(), _request3 = new WeakMap(), _requestOverrides = new WeakMap(), _responseOverrides = new WeakMap(), _response2 = new WeakMap(), _eventManager = new WeakMap(), _networkStorage = new WeakMap(), _cdpTarget = new WeakMap(), _logger = new WeakMap(), _emittedEvents = new WeakMap(), _NetworkRequest_instances = new WeakSet(), isDataUrl_fn = function() {
      return this.url.startsWith("data:");
    }, method_get = function() {
      var _a5, _b2, _c2, _d2, _e2;
      return ((_a5 = __privateGet(this, _requestOverrides)) == null ? void 0 : _a5.method) ?? ((_b2 = __privateGet(this, _request3).info) == null ? void 0 : _b2.request.method) ?? ((_c2 = __privateGet(this, _request3).paused) == null ? void 0 : _c2.request.method) ?? ((_d2 = __privateGet(this, _request3).auth) == null ? void 0 : _d2.request.method) ?? ((_e2 = __privateGet(this, _response2).paused) == null ? void 0 : _e2.request.method);
    }, navigationId_get = function() {
      if (!__privateGet(this, _request3).info || !__privateGet(this, _request3).info.loaderId || // When we navigate all CDP network events have `loaderId`
      // CDP's `loaderId` and `requestId` match when
      // that request triggered the loading
      __privateGet(this, _request3).info.loaderId !== __privateGet(this, _request3).info.requestId) {
        return null;
      }
      return __privateGet(this, _networkStorage).getNavigationId(__privateGet(this, _NetworkRequest_instances, context_get) ?? void 0);
    }, cookies_get = function() {
      let cookies = [];
      if (__privateGet(this, _request3).extraInfo) {
        cookies = __privateGet(this, _request3).extraInfo.associatedCookies.filter(({ blockedReasons }) => {
          return !Array.isArray(blockedReasons) || blockedReasons.length === 0;
        }).map(({ cookie }) => (0, NetworkUtils_js_1.cdpToBiDiCookie)(cookie));
      }
      return cookies;
    }, bodySize_get = function() {
      var _a5, _b2;
      let bodySize = 0;
      if (typeof ((_a5 = __privateGet(this, _requestOverrides)) == null ? void 0 : _a5.bodySize) === "number") {
        bodySize = __privateGet(this, _requestOverrides).bodySize;
      } else {
        bodySize = (0, NetworkUtils_js_1.bidiBodySizeFromCdpPostDataEntries)(((_b2 = __privateGet(this, _request3).info) == null ? void 0 : _b2.request.postDataEntries) ?? []);
      }
      return bodySize;
    }, context_get = function() {
      var _a5, _b2, _c2, _d2;
      return ((_a5 = __privateGet(this, _response2).paused) == null ? void 0 : _a5.frameId) ?? ((_b2 = __privateGet(this, _request3).info) == null ? void 0 : _b2.frameId) ?? ((_c2 = __privateGet(this, _request3).paused) == null ? void 0 : _c2.frameId) ?? ((_d2 = __privateGet(this, _request3).auth) == null ? void 0 : _d2.frameId) ?? null;
    }, statusCode_get = function() {
      var _a5, _b2, _c2, _d2;
      return ((_a5 = __privateGet(this, _responseOverrides)) == null ? void 0 : _a5.statusCode) ?? ((_b2 = __privateGet(this, _response2).paused) == null ? void 0 : _b2.responseStatusCode) ?? ((_c2 = __privateGet(this, _response2).extraInfo) == null ? void 0 : _c2.statusCode) ?? ((_d2 = __privateGet(this, _response2).info) == null ? void 0 : _d2.status);
    }, requestHeaders_get = function() {
      var _a5, _b2, _c2;
      let headers = [];
      if ((_a5 = __privateGet(this, _requestOverrides)) == null ? void 0 : _a5.headers) {
        const headerMap = new DefaultMap_js_1.DefaultMap(() => []);
        for (const header of __privateGet(this, _requestOverrides).headers) {
          headerMap.get(header.name).push(header.value.value);
        }
        for (const [name, value] of headerMap.entries()) {
          headers.push({
            name,
            value: {
              type: "string",
              value: value.join("\n").trimEnd()
            }
          });
        }
      } else {
        headers = [
          ...(0, NetworkUtils_js_1.bidiNetworkHeadersFromCdpNetworkHeaders)((_b2 = __privateGet(this, _request3).info) == null ? void 0 : _b2.request.headers),
          ...(0, NetworkUtils_js_1.bidiNetworkHeadersFromCdpNetworkHeaders)((_c2 = __privateGet(this, _request3).extraInfo) == null ? void 0 : _c2.headers)
        ];
      }
      return headers;
    }, authChallenges_get = function() {
      var _a5;
      if (!__privateGet(this, _response2).info) {
        return;
      }
      if (!(__privateGet(this, _NetworkRequest_instances, statusCode_get) === 401 || __privateGet(this, _NetworkRequest_instances, statusCode_get) === 407)) {
        return void 0;
      }
      const headerName = __privateGet(this, _NetworkRequest_instances, statusCode_get) === 401 ? "WWW-Authenticate" : "Proxy-Authenticate";
      const authChallenges = [];
      for (const [header, value] of Object.entries(__privateGet(this, _response2).info.headers)) {
        if (header.localeCompare(headerName, void 0, { sensitivity: "base" }) === 0) {
          authChallenges.push({
            scheme: value.split(" ").at(0) ?? "",
            realm: ((_a5 = value.match(REALM_REGEX)) == null ? void 0 : _a5.at(0)) ?? ""
          });
        }
      }
      return authChallenges;
    }, timings_get = function() {
      var _a5, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2, _k2, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v;
      const responseTimeOffset = (0, NetworkUtils_js_1.getTiming)((0, NetworkUtils_js_1.getTiming)((_b2 = (_a5 = __privateGet(this, _response2).info) == null ? void 0 : _a5.timing) == null ? void 0 : _b2.requestTime) - (0, NetworkUtils_js_1.getTiming)((_c2 = __privateGet(this, _request3).info) == null ? void 0 : _c2.timestamp));
      return {
        // TODO: Verify this is correct
        timeOrigin: Math.round((0, NetworkUtils_js_1.getTiming)((_d2 = __privateGet(this, _request3).info) == null ? void 0 : _d2.wallTime) * 1e3),
        // Timing baseline.
        // TODO: Verify this is correct.
        requestTime: 0,
        // TODO: set if redirect detected.
        redirectStart: 0,
        // TODO: set if redirect detected.
        redirectEnd: 0,
        // TODO: Verify this is correct
        // https://source.chromium.org/chromium/chromium/src/+/main:net/base/load_timing_info.h;l=145
        fetchStart: (0, NetworkUtils_js_1.getTiming)((_f2 = (_e2 = __privateGet(this, _response2).info) == null ? void 0 : _e2.timing) == null ? void 0 : _f2.workerFetchStart, responseTimeOffset),
        // fetchStart: 0,
        dnsStart: (0, NetworkUtils_js_1.getTiming)((_h2 = (_g2 = __privateGet(this, _response2).info) == null ? void 0 : _g2.timing) == null ? void 0 : _h2.dnsStart, responseTimeOffset),
        dnsEnd: (0, NetworkUtils_js_1.getTiming)((_j2 = (_i2 = __privateGet(this, _response2).info) == null ? void 0 : _i2.timing) == null ? void 0 : _j2.dnsEnd, responseTimeOffset),
        connectStart: (0, NetworkUtils_js_1.getTiming)((_l = (_k2 = __privateGet(this, _response2).info) == null ? void 0 : _k2.timing) == null ? void 0 : _l.connectStart, responseTimeOffset),
        connectEnd: (0, NetworkUtils_js_1.getTiming)((_n = (_m = __privateGet(this, _response2).info) == null ? void 0 : _m.timing) == null ? void 0 : _n.connectEnd, responseTimeOffset),
        tlsStart: (0, NetworkUtils_js_1.getTiming)((_p = (_o = __privateGet(this, _response2).info) == null ? void 0 : _o.timing) == null ? void 0 : _p.sslStart, responseTimeOffset),
        requestStart: (0, NetworkUtils_js_1.getTiming)((_r = (_q = __privateGet(this, _response2).info) == null ? void 0 : _q.timing) == null ? void 0 : _r.sendStart, responseTimeOffset),
        // https://source.chromium.org/chromium/chromium/src/+/main:net/base/load_timing_info.h;l=196
        responseStart: (0, NetworkUtils_js_1.getTiming)((_t = (_s = __privateGet(this, _response2).info) == null ? void 0 : _s.timing) == null ? void 0 : _t.receiveHeadersStart, responseTimeOffset),
        responseEnd: (0, NetworkUtils_js_1.getTiming)((_v = (_u = __privateGet(this, _response2).info) == null ? void 0 : _u.timing) == null ? void 0 : _v.receiveHeadersEnd, responseTimeOffset)
      };
    }, phaseChanged_fn = function() {
      this.waitNextPhase.resolve();
      this.waitNextPhase = new Deferred_js_1.Deferred();
    }, interceptsInPhase_fn = function(phase) {
      if (!__privateGet(this, _cdpTarget).isSubscribedTo(`network.${phase}`)) {
        return /* @__PURE__ */ new Set();
      }
      return __privateGet(this, _networkStorage).getInterceptsForPhase(this, phase);
    }, isBlockedInPhase_fn = function(phase) {
      return __privateMethod(this, _NetworkRequest_instances, interceptsInPhase_fn).call(this, phase).size > 0;
    }, emitEventsIfReady_fn = function(options = {}) {
      const requestExtraInfoCompleted = (
        // Flush redirects
        options.wasRedirected || options.hasFailed || __privateMethod(this, _NetworkRequest_instances, isDataUrl_fn).call(this) || Boolean(__privateGet(this, _request3).extraInfo) || // Requests from cache don't have extra info
        __privateGet(this, _servedFromCache) || // Sometimes there is no extra info and the response
        // is the only place we can find out
        Boolean(__privateGet(this, _response2).info && !__privateGet(this, _response2).hasExtraInfo)
      );
      const noInterceptionExpected = (
        // We can't intercept data urls from CDP
        __privateMethod(this, _NetworkRequest_instances, isDataUrl_fn).call(this) || // Cached requests never hit the network
        __privateGet(this, _servedFromCache)
      );
      const requestInterceptionExpected = !noInterceptionExpected && __privateMethod(this, _NetworkRequest_instances, isBlockedInPhase_fn).call(this, "beforeRequestSent");
      const requestInterceptionCompleted = !requestInterceptionExpected || requestInterceptionExpected && Boolean(__privateGet(this, _request3).paused);
      if (Boolean(__privateGet(this, _request3).info) && (requestInterceptionExpected ? requestInterceptionCompleted : requestExtraInfoCompleted)) {
        __privateMethod(this, _NetworkRequest_instances, emitEvent_fn).call(this, __privateMethod(this, _NetworkRequest_instances, getBeforeRequestEvent_fn).bind(this));
      }
      const responseExtraInfoCompleted = Boolean(__privateGet(this, _response2).extraInfo) || // Response from cache don't have extra info
      __privateGet(this, _servedFromCache) || // Don't expect extra info if the flag is false
      Boolean(__privateGet(this, _response2).info && !__privateGet(this, _response2).hasExtraInfo);
      const responseInterceptionExpected = !noInterceptionExpected && __privateMethod(this, _NetworkRequest_instances, isBlockedInPhase_fn).call(this, "responseStarted");
      if (__privateGet(this, _response2).info || responseInterceptionExpected && Boolean(__privateGet(this, _response2).paused)) {
        __privateMethod(this, _NetworkRequest_instances, emitEvent_fn).call(this, __privateMethod(this, _NetworkRequest_instances, getResponseStartedEvent_fn).bind(this));
      }
      const responseInterceptionCompleted = !responseInterceptionExpected || responseInterceptionExpected && Boolean(__privateGet(this, _response2).paused);
      if (Boolean(__privateGet(this, _response2).info) && responseExtraInfoCompleted && responseInterceptionCompleted) {
        __privateMethod(this, _NetworkRequest_instances, emitEvent_fn).call(this, __privateMethod(this, _NetworkRequest_instances, getResponseReceivedEvent_fn).bind(this));
        __privateGet(this, _networkStorage).deleteRequest(this.id);
      }
    }, continueRequest_fn = async function(overrides = {}) {
      (0, assert_js_1.assert)(__privateGet(this, _fetchId), "Network Interception not set-up.");
      await this.cdpClient.sendCommand("Fetch.continueRequest", {
        requestId: __privateGet(this, _fetchId),
        url: overrides.url,
        method: overrides.method,
        headers: overrides.headers,
        postData: overrides.postData
      });
      __privateSet(this, _interceptPhase, void 0);
    }, continueResponse_fn = async function({ responseCode, responsePhrase, responseHeaders } = {}) {
      (0, assert_js_1.assert)(__privateGet(this, _fetchId), "Network Interception not set-up.");
      await this.cdpClient.sendCommand("Fetch.continueResponse", {
        requestId: __privateGet(this, _fetchId),
        responseCode,
        responsePhrase,
        responseHeaders
      });
      __privateSet(this, _interceptPhase, void 0);
    }, continueWithAuth_fn = async function(authChallengeResponse) {
      (0, assert_js_1.assert)(__privateGet(this, _fetchId), "Network Interception not set-up.");
      await this.cdpClient.sendCommand("Fetch.continueWithAuth", {
        requestId: __privateGet(this, _fetchId),
        authChallengeResponse
      });
      __privateSet(this, _interceptPhase, void 0);
    }, emitEvent_fn = function(getEvent) {
      var _a5;
      let event;
      try {
        event = getEvent();
      } catch (error) {
        (_a5 = __privateGet(this, _logger)) == null ? void 0 : _a5.call(this, log_js_1.LogType.debugError, error);
        return;
      }
      if (__privateMethod(this, _NetworkRequest_instances, isIgnoredEvent_fn).call(this) || __privateGet(this, _emittedEvents)[event.method] && // Special case this event can be emitted multiple times
      event.method !== protocol_js_1.ChromiumBidi.Network.EventNames.AuthRequired) {
        return;
      }
      __privateMethod(this, _NetworkRequest_instances, phaseChanged_fn).call(this);
      __privateGet(this, _emittedEvents)[event.method] = true;
      if (__privateGet(this, _NetworkRequest_instances, context_get)) {
        __privateGet(this, _eventManager).registerEvent(Object.assign(event, {
          type: "event"
        }), __privateGet(this, _NetworkRequest_instances, context_get));
      } else {
        __privateGet(this, _eventManager).registerGlobalEvent(Object.assign(event, {
          type: "event"
        }));
      }
    }, getBaseEventParams_fn = function(phase) {
      var _a5;
      const interceptProps = {
        isBlocked: false
      };
      if (phase) {
        const blockedBy = __privateMethod(this, _NetworkRequest_instances, interceptsInPhase_fn).call(this, phase);
        interceptProps.isBlocked = blockedBy.size > 0;
        if (interceptProps.isBlocked) {
          interceptProps.intercepts = [...blockedBy];
        }
      }
      return {
        context: __privateGet(this, _NetworkRequest_instances, context_get),
        navigation: __privateGet(this, _NetworkRequest_instances, navigationId_get),
        redirectCount: __privateGet(this, _redirectCount),
        request: __privateMethod(this, _NetworkRequest_instances, getRequestData_fn).call(this),
        // Timestamp should be in milliseconds, while CDP provides it in seconds.
        timestamp: Math.round((0, NetworkUtils_js_1.getTiming)((_a5 = __privateGet(this, _request3).info) == null ? void 0 : _a5.wallTime) * 1e3),
        // Contains isBlocked and intercepts
        ...interceptProps
      };
    }, getResponseEventParams_fn = function() {
      var _a5, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2, _k2, _l;
      if ((_a5 = __privateGet(this, _response2).info) == null ? void 0 : _a5.fromDiskCache) {
        __privateGet(this, _response2).extraInfo = void 0;
      }
      const headers = [
        ...(0, NetworkUtils_js_1.bidiNetworkHeadersFromCdpNetworkHeaders)((_b2 = __privateGet(this, _response2).info) == null ? void 0 : _b2.headers),
        ...(0, NetworkUtils_js_1.bidiNetworkHeadersFromCdpNetworkHeaders)((_c2 = __privateGet(this, _response2).extraInfo) == null ? void 0 : _c2.headers)
        // TODO: Verify how to dedupe these
        // ...bidiNetworkHeadersFromCdpNetworkHeadersEntries(
        //   this.#response.paused?.responseHeaders
        // ),
      ];
      const authChallenges = __privateGet(this, _NetworkRequest_instances, authChallenges_get);
      const response = {
        url: this.url,
        protocol: ((_d2 = __privateGet(this, _response2).info) == null ? void 0 : _d2.protocol) ?? "",
        status: __privateGet(this, _NetworkRequest_instances, statusCode_get) ?? -1,
        // TODO: Throw an exception or use some other status code?
        statusText: ((_e2 = __privateGet(this, _response2).info) == null ? void 0 : _e2.statusText) || ((_f2 = __privateGet(this, _response2).paused) == null ? void 0 : _f2.responseStatusText) || "",
        fromCache: ((_g2 = __privateGet(this, _response2).info) == null ? void 0 : _g2.fromDiskCache) || ((_h2 = __privateGet(this, _response2).info) == null ? void 0 : _h2.fromPrefetchCache) || __privateGet(this, _servedFromCache),
        headers: ((_i2 = __privateGet(this, _responseOverrides)) == null ? void 0 : _i2.headers) ?? headers,
        mimeType: ((_j2 = __privateGet(this, _response2).info) == null ? void 0 : _j2.mimeType) || "",
        bytesReceived: ((_k2 = __privateGet(this, _response2).info) == null ? void 0 : _k2.encodedDataLength) || 0,
        headersSize: (0, NetworkUtils_js_1.computeHeadersSize)(headers),
        // TODO: consider removing from spec.
        bodySize: 0,
        content: {
          // TODO: consider removing from spec.
          size: 0
        },
        ...authChallenges ? { authChallenges } : {}
      };
      return {
        ...response,
        "goog:securityDetails": (_l = __privateGet(this, _response2).info) == null ? void 0 : _l.securityDetails
      };
    }, getRequestData_fn = function() {
      var _a5, _b2, _c2, _d2, _e2, _f2;
      const headers = __privateGet(this, _NetworkRequest_instances, requestHeaders_get);
      const request = {
        request: __privateGet(this, _id7),
        url: this.url,
        method: __privateGet(this, _NetworkRequest_instances, method_get) ?? _a3.unknownParameter,
        headers,
        cookies: __privateGet(this, _NetworkRequest_instances, cookies_get),
        headersSize: (0, NetworkUtils_js_1.computeHeadersSize)(headers),
        bodySize: __privateGet(this, _NetworkRequest_instances, bodySize_get),
        // TODO: populate
        destination: __privateMethod(this, _NetworkRequest_instances, getDestination_fn).call(this),
        // TODO: populate
        initiatorType: __privateMethod(this, _NetworkRequest_instances, getInitiatorType_fn).call(this),
        timings: __privateGet(this, _NetworkRequest_instances, timings_get)
      };
      return {
        ...request,
        "goog:postData": (_b2 = (_a5 = __privateGet(this, _request3).info) == null ? void 0 : _a5.request) == null ? void 0 : _b2.postData,
        "goog:hasPostData": (_d2 = (_c2 = __privateGet(this, _request3).info) == null ? void 0 : _c2.request) == null ? void 0 : _d2.hasPostData,
        "goog:resourceType": (_e2 = __privateGet(this, _request3).info) == null ? void 0 : _e2.type,
        "goog:resourceInitiator": (_f2 = __privateGet(this, _request3).info) == null ? void 0 : _f2.initiator
      };
    }, /**
     * Heuristic trying to guess the destination.
     * Specification: https://fetch.spec.whatwg.org/#concept-request-destination.
     * Specified values: "audio", "audioworklet", "document", "embed", "font", "frame",
     * "iframe", "image", "json", "manifest", "object", "paintworklet", "report", "script",
     * "serviceworker", "sharedworker", "style", "track", "video", "webidentity", "worker",
     * "xslt".
     */
    getDestination_fn = function() {
      var _a5, _b2;
      switch ((_a5 = __privateGet(this, _request3).info) == null ? void 0 : _a5.type) {
        case "Script":
          return "script";
        case "Stylesheet":
          return "style";
        case "Image":
          return "image";
        case "Document":
          return ((_b2 = __privateGet(this, _request3).info) == null ? void 0 : _b2.initiator.type) === "parser" ? "iframe" : "";
        default:
          return "";
      }
    }, /**
     * Heuristic trying to guess the initiator type.
     * Specification: https://fetch.spec.whatwg.org/#request-initiator-type.
     * Specified values: "audio", "beacon", "body", "css", "early-hints", "embed", "fetch",
     * "font", "frame", "iframe", "image", "img", "input", "link", "object", "ping",
     * "script", "track", "video", "xmlhttprequest", "other".
     */
    getInitiatorType_fn = function() {
      var _a5, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2;
      if (((_a5 = __privateGet(this, _request3).info) == null ? void 0 : _a5.initiator.type) === "parser") {
        switch ((_b2 = __privateGet(this, _request3).info) == null ? void 0 : _b2.type) {
          case "Document":
            return "iframe";
          case "Font":
            return ((_d2 = (_c2 = __privateGet(this, _request3).info) == null ? void 0 : _c2.initiator) == null ? void 0 : _d2.url) === ((_e2 = __privateGet(this, _request3).info) == null ? void 0 : _e2.documentURL) ? "font" : "css";
          case "Image":
            return ((_g2 = (_f2 = __privateGet(this, _request3).info) == null ? void 0 : _f2.initiator) == null ? void 0 : _g2.url) === ((_h2 = __privateGet(this, _request3).info) == null ? void 0 : _h2.documentURL) ? "img" : "css";
          case "Script":
            return "script";
          case "Stylesheet":
            return "link";
          default:
            return null;
        }
      }
      if (((_j2 = (_i2 = __privateGet(this, _request3)) == null ? void 0 : _i2.info) == null ? void 0 : _j2.type) === "Fetch") {
        return "fetch";
      }
      return null;
    }, getBeforeRequestEvent_fn = function() {
      var _a5;
      (0, assert_js_1.assert)(__privateGet(this, _request3).info, "RequestWillBeSentEvent is not set");
      return {
        method: protocol_js_1.ChromiumBidi.Network.EventNames.BeforeRequestSent,
        params: {
          ...__privateMethod(this, _NetworkRequest_instances, getBaseEventParams_fn).call(this, "beforeRequestSent"),
          initiator: {
            type: __privateMethod(_a5 = _a3, _NetworkRequest_static, getInitiator_fn).call(_a5, __privateGet(this, _request3).info.initiator.type),
            columnNumber: __privateGet(this, _request3).info.initiator.columnNumber,
            lineNumber: __privateGet(this, _request3).info.initiator.lineNumber,
            stackTrace: __privateGet(this, _request3).info.initiator.stack,
            request: __privateGet(this, _request3).info.initiator.requestId
          }
        }
      };
    }, getResponseStartedEvent_fn = function() {
      return {
        method: protocol_js_1.ChromiumBidi.Network.EventNames.ResponseStarted,
        params: {
          ...__privateMethod(this, _NetworkRequest_instances, getBaseEventParams_fn).call(this, "responseStarted"),
          response: __privateMethod(this, _NetworkRequest_instances, getResponseEventParams_fn).call(this)
        }
      };
    }, getResponseReceivedEvent_fn = function() {
      return {
        method: protocol_js_1.ChromiumBidi.Network.EventNames.ResponseCompleted,
        params: {
          ...__privateMethod(this, _NetworkRequest_instances, getBaseEventParams_fn).call(this),
          response: __privateMethod(this, _NetworkRequest_instances, getResponseEventParams_fn).call(this)
        }
      };
    }, isIgnoredEvent_fn = function() {
      var _a5, _b2;
      const faviconUrl = "/favicon.ico";
      return ((_a5 = __privateGet(this, _request3).paused) == null ? void 0 : _a5.request.url.endsWith(faviconUrl)) ?? ((_b2 = __privateGet(this, _request3).info) == null ? void 0 : _b2.request.url.endsWith(faviconUrl)) ?? false;
    }, getOverrideHeader_fn = function(headers, cookies) {
      if (!headers && !cookies) {
        return void 0;
      }
      let overrideHeaders = headers;
      const cookieHeader = (0, NetworkUtils_js_1.networkHeaderFromCookieHeaders)(cookies);
      if (cookieHeader && !overrideHeaders) {
        overrideHeaders = __privateGet(this, _NetworkRequest_instances, requestHeaders_get);
      }
      if (cookieHeader && overrideHeaders) {
        overrideHeaders.filter((header) => header.name.localeCompare("cookie", void 0, {
          sensitivity: "base"
        }) !== 0);
        overrideHeaders.push(cookieHeader);
      }
      return overrideHeaders;
    }, _NetworkRequest_static = new WeakSet(), getInitiator_fn = function(initiatorType) {
      switch (initiatorType) {
        case "parser":
        case "script":
        case "preflight":
          return initiatorType;
        default:
          return "other";
      }
    }, __privateAdd(_a4, _NetworkRequest_static), __publicField(_a4, "unknownParameter", "UNKNOWN"), _a4);
    NetworkRequest.NetworkRequest = NetworkRequest$1;
    _a3 = NetworkRequest$1;
    function getCdpBodyFromBiDiBytesValue(body) {
      let parsedBody;
      if ((body == null ? void 0 : body.type) === "string") {
        parsedBody = btoa(body.value);
      } else if ((body == null ? void 0 : body.type) === "base64") {
        parsedBody = body.value;
      }
      return parsedBody;
    }
    function getSizeFromBiDiBytesValue(body) {
      if ((body == null ? void 0 : body.type) === "string") {
        return body.value.length;
      } else if ((body == null ? void 0 : body.type) === "base64") {
        return atob(body.value).length;
      }
      return 0;
    }
    return NetworkRequest;
  }
  var hasRequiredNetworkStorage;
  function requireNetworkStorage() {
    var _browsingContextStorage, _eventManager, _logger, _requests, _intercepts, _defaultCacheBehavior, _NetworkStorage_instances, getOrCreateNetworkRequest_fn, _a3;
    if (hasRequiredNetworkStorage) return NetworkStorage;
    hasRequiredNetworkStorage = 1;
    Object.defineProperty(NetworkStorage, "__esModule", { value: true });
    NetworkStorage.NetworkStorage = void 0;
    const protocol_js_1 = requireProtocol();
    const uuid_js_1 = requireUuid();
    const NetworkRequest_js_1 = requireNetworkRequest();
    const NetworkUtils_js_1 = requireNetworkUtils();
    let NetworkStorage$1 = (_a3 = class {
      constructor(eventManager, browsingContextStorage, browserClient, logger2) {
        __privateAdd(this, _NetworkStorage_instances);
        __privateAdd(this, _browsingContextStorage);
        __privateAdd(this, _eventManager);
        __privateAdd(this, _logger);
        /**
         * A map from network request ID to Network Request objects.
         * Needed as long as information about requests comes from different events.
         */
        __privateAdd(this, _requests, /* @__PURE__ */ new Map());
        /** A map from intercept ID to track active network intercepts. */
        __privateAdd(this, _intercepts, /* @__PURE__ */ new Map());
        __privateAdd(this, _defaultCacheBehavior, "default");
        __privateSet(this, _browsingContextStorage, browsingContextStorage);
        __privateSet(this, _eventManager, eventManager);
        browserClient.on("Target.detachedFromTarget", ({ sessionId }) => {
          this.disposeRequestMap(sessionId);
        });
        __privateSet(this, _logger, logger2);
      }
      onCdpTargetCreated(cdpTarget) {
        const cdpClient = cdpTarget.cdpClient;
        const listeners = [
          [
            "Network.requestWillBeSent",
            (params) => {
              const request = this.getRequestById(params.requestId);
              if (request && request.isRedirecting()) {
                request.handleRedirect(params);
                this.deleteRequest(params.requestId);
                __privateMethod(this, _NetworkStorage_instances, getOrCreateNetworkRequest_fn).call(this, params.requestId, cdpTarget, request.redirectCount + 1).onRequestWillBeSentEvent(params);
              } else {
                __privateMethod(this, _NetworkStorage_instances, getOrCreateNetworkRequest_fn).call(this, params.requestId, cdpTarget).onRequestWillBeSentEvent(params);
              }
            }
          ],
          [
            "Network.requestWillBeSentExtraInfo",
            (params) => {
              __privateMethod(this, _NetworkStorage_instances, getOrCreateNetworkRequest_fn).call(this, params.requestId, cdpTarget).onRequestWillBeSentExtraInfoEvent(params);
            }
          ],
          [
            "Network.responseReceived",
            (params) => {
              __privateMethod(this, _NetworkStorage_instances, getOrCreateNetworkRequest_fn).call(this, params.requestId, cdpTarget).onResponseReceivedEvent(params);
            }
          ],
          [
            "Network.responseReceivedExtraInfo",
            (params) => {
              __privateMethod(this, _NetworkStorage_instances, getOrCreateNetworkRequest_fn).call(this, params.requestId, cdpTarget).onResponseReceivedExtraInfoEvent(params);
            }
          ],
          [
            "Network.requestServedFromCache",
            (params) => {
              __privateMethod(this, _NetworkStorage_instances, getOrCreateNetworkRequest_fn).call(this, params.requestId, cdpTarget).onServedFromCache();
            }
          ],
          [
            "Network.loadingFailed",
            (params) => {
              __privateMethod(this, _NetworkStorage_instances, getOrCreateNetworkRequest_fn).call(this, params.requestId, cdpTarget).onLoadingFailedEvent(params);
            }
          ],
          [
            "Fetch.requestPaused",
            (event) => {
              __privateMethod(this, _NetworkStorage_instances, getOrCreateNetworkRequest_fn).call(
                this,
                // CDP quirk if the Network domain is not present this is undefined
                event.networkId ?? event.requestId,
                cdpTarget
              ).onRequestPaused(event);
            }
          ],
          [
            "Fetch.authRequired",
            (event) => {
              let request = this.getRequestByFetchId(event.requestId);
              if (!request) {
                request = __privateMethod(this, _NetworkStorage_instances, getOrCreateNetworkRequest_fn).call(this, event.requestId, cdpTarget);
              }
              request.onAuthRequired(event);
            }
          ]
        ];
        for (const [event, listener] of listeners) {
          cdpClient.on(event, listener);
        }
      }
      getInterceptionStages(browsingContextId) {
        const stages = {
          request: false,
          response: false,
          auth: false
        };
        for (const intercept of __privateGet(this, _intercepts).values()) {
          if (intercept.contexts && !intercept.contexts.includes(browsingContextId)) {
            continue;
          }
          stages.request || (stages.request = intercept.phases.includes(
            "beforeRequestSent"
            /* Network.InterceptPhase.BeforeRequestSent */
          ));
          stages.response || (stages.response = intercept.phases.includes(
            "responseStarted"
            /* Network.InterceptPhase.ResponseStarted */
          ));
          stages.auth || (stages.auth = intercept.phases.includes(
            "authRequired"
            /* Network.InterceptPhase.AuthRequired */
          ));
        }
        return stages;
      }
      getInterceptsForPhase(request, phase) {
        if (request.url === NetworkRequest_js_1.NetworkRequest.unknownParameter) {
          return /* @__PURE__ */ new Set();
        }
        const intercepts = /* @__PURE__ */ new Set();
        for (const [interceptId, intercept] of __privateGet(this, _intercepts).entries()) {
          if (!intercept.phases.includes(phase) || intercept.contexts && !intercept.contexts.includes(request.cdpTarget.topLevelId)) {
            continue;
          }
          if (intercept.urlPatterns.length === 0) {
            intercepts.add(interceptId);
            continue;
          }
          for (const pattern of intercept.urlPatterns) {
            if ((0, NetworkUtils_js_1.matchUrlPattern)(pattern, request.url)) {
              intercepts.add(interceptId);
              break;
            }
          }
        }
        return intercepts;
      }
      disposeRequestMap(sessionId) {
        for (const request of __privateGet(this, _requests).values()) {
          if (request.cdpClient.sessionId === sessionId) {
            __privateGet(this, _requests).delete(request.id);
            request.dispose();
          }
        }
      }
      /**
       * Adds the given entry to the intercept map.
       * URL patterns are assumed to be parsed.
       *
       * @return The intercept ID.
       */
      addIntercept(value) {
        const interceptId = (0, uuid_js_1.uuidv4)();
        __privateGet(this, _intercepts).set(interceptId, value);
        return interceptId;
      }
      /**
       * Removes the given intercept from the intercept map.
       * Throws NoSuchInterceptException if the intercept does not exist.
       */
      removeIntercept(intercept) {
        if (!__privateGet(this, _intercepts).has(intercept)) {
          throw new protocol_js_1.NoSuchInterceptException(`Intercept '${intercept}' does not exist.`);
        }
        __privateGet(this, _intercepts).delete(intercept);
      }
      getRequestsByTarget(target) {
        const requests2 = [];
        for (const request of __privateGet(this, _requests).values()) {
          if (request.cdpTarget === target) {
            requests2.push(request);
          }
        }
        return requests2;
      }
      getRequestById(id) {
        return __privateGet(this, _requests).get(id);
      }
      getRequestByFetchId(fetchId) {
        for (const request of __privateGet(this, _requests).values()) {
          if (request.fetchId === fetchId) {
            return request;
          }
        }
        return;
      }
      addRequest(request) {
        __privateGet(this, _requests).set(request.id, request);
      }
      deleteRequest(id) {
        __privateGet(this, _requests).delete(id);
      }
      /**
       * Gets the virtual navigation ID for the given navigable ID.
       */
      getNavigationId(contextId) {
        var _a4;
        if (contextId === void 0) {
          return null;
        }
        return ((_a4 = __privateGet(this, _browsingContextStorage).findContext(contextId)) == null ? void 0 : _a4.navigationId) ?? null;
      }
      set defaultCacheBehavior(behavior) {
        __privateSet(this, _defaultCacheBehavior, behavior);
      }
      get defaultCacheBehavior() {
        return __privateGet(this, _defaultCacheBehavior);
      }
    }, _browsingContextStorage = new WeakMap(), _eventManager = new WeakMap(), _logger = new WeakMap(), _requests = new WeakMap(), _intercepts = new WeakMap(), _defaultCacheBehavior = new WeakMap(), _NetworkStorage_instances = new WeakSet(), /**
     * Gets the network request with the given ID, if any.
     * Otherwise, creates a new network request with the given ID and cdp target.
     */
    getOrCreateNetworkRequest_fn = function(id, cdpTarget, redirectCount) {
      let request = this.getRequestById(id);
      if (request) {
        return request;
      }
      request = new NetworkRequest_js_1.NetworkRequest(id, __privateGet(this, _eventManager), this, cdpTarget, redirectCount, __privateGet(this, _logger));
      this.addRequest(request);
      return request;
    }, _a3);
    NetworkStorage.NetworkStorage = NetworkStorage$1;
    return NetworkStorage;
  }
  var PreloadScriptStorage = {};
  var hasRequiredPreloadScriptStorage;
  function requirePreloadScriptStorage() {
    var _scripts2, _a3;
    if (hasRequiredPreloadScriptStorage) return PreloadScriptStorage;
    hasRequiredPreloadScriptStorage = 1;
    Object.defineProperty(PreloadScriptStorage, "__esModule", { value: true });
    PreloadScriptStorage.PreloadScriptStorage = void 0;
    let PreloadScriptStorage$1 = (_a3 = class {
      constructor() {
        /** Tracks all BiDi preload scripts.  */
        __privateAdd(this, _scripts2, /* @__PURE__ */ new Set());
      }
      /**
       * Finds all entries that match the given filter (OR logic).
       */
      find(filter2) {
        if (!filter2) {
          return [...__privateGet(this, _scripts2)];
        }
        return [...__privateGet(this, _scripts2)].filter((script) => {
          if (filter2.id !== void 0 && filter2.id === script.id) {
            return true;
          }
          if (filter2.targetId !== void 0 && script.targetIds.has(filter2.targetId)) {
            return true;
          }
          if (filter2.global !== void 0 && // Global scripts have no contexts
          (filter2.global && script.contexts === void 0 || // Non global scripts always have contexts
          !filter2.global && script.contexts !== void 0)) {
            return true;
          }
          return false;
        });
      }
      add(preloadScript) {
        __privateGet(this, _scripts2).add(preloadScript);
      }
      /** Deletes all BiDi preload script entries that match the given filter. */
      remove(filter2) {
        for (const preloadScript of this.find(filter2)) {
          __privateGet(this, _scripts2).delete(preloadScript);
        }
      }
    }, _scripts2 = new WeakMap(), _a3);
    PreloadScriptStorage.PreloadScriptStorage = PreloadScriptStorage$1;
    return PreloadScriptStorage;
  }
  var RealmStorage = {};
  var hasRequiredRealmStorage;
  function requireRealmStorage() {
    var _knownHandlesToRealmMap, _realmMap, _a3;
    if (hasRequiredRealmStorage) return RealmStorage;
    hasRequiredRealmStorage = 1;
    Object.defineProperty(RealmStorage, "__esModule", { value: true });
    RealmStorage.RealmStorage = void 0;
    const protocol_js_1 = requireProtocol();
    const WindowRealm_js_1 = requireWindowRealm();
    let RealmStorage$1 = (_a3 = class {
      constructor() {
        /** Tracks handles and their realms sent to the client. */
        __privateAdd(this, _knownHandlesToRealmMap, /* @__PURE__ */ new Map());
        /** Map from realm ID to Realm. */
        __privateAdd(this, _realmMap, /* @__PURE__ */ new Map());
      }
      get knownHandlesToRealmMap() {
        return __privateGet(this, _knownHandlesToRealmMap);
      }
      addRealm(realm) {
        __privateGet(this, _realmMap).set(realm.realmId, realm);
      }
      /** Finds all realms that match the given filter. */
      findRealms(filter2) {
        return Array.from(__privateGet(this, _realmMap).values()).filter((realm) => {
          if (filter2.realmId !== void 0 && filter2.realmId !== realm.realmId) {
            return false;
          }
          if (filter2.browsingContextId !== void 0 && !realm.associatedBrowsingContexts.map((browsingContext) => browsingContext.id).includes(filter2.browsingContextId)) {
            return false;
          }
          if (filter2.sandbox !== void 0 && (!(realm instanceof WindowRealm_js_1.WindowRealm) || filter2.sandbox !== realm.sandbox)) {
            return false;
          }
          if (filter2.executionContextId !== void 0 && filter2.executionContextId !== realm.executionContextId) {
            return false;
          }
          if (filter2.origin !== void 0 && filter2.origin !== realm.origin) {
            return false;
          }
          if (filter2.type !== void 0 && filter2.type !== realm.realmType) {
            return false;
          }
          if (filter2.cdpSessionId !== void 0 && filter2.cdpSessionId !== realm.cdpClient.sessionId) {
            return false;
          }
          return true;
        });
      }
      findRealm(filter2) {
        const maybeRealms = this.findRealms(filter2);
        if (maybeRealms.length !== 1) {
          return void 0;
        }
        return maybeRealms[0];
      }
      /** Gets the only realm that matches the given filter, if any, otherwise throws. */
      getRealm(filter2) {
        const maybeRealm = this.findRealm(filter2);
        if (maybeRealm === void 0) {
          throw new protocol_js_1.NoSuchFrameException(`Realm ${JSON.stringify(filter2)} not found`);
        }
        return maybeRealm;
      }
      /** Deletes all realms that match the given filter. */
      deleteRealms(filter2) {
        this.findRealms(filter2).map((realm) => {
          realm.dispose();
          __privateGet(this, _realmMap).delete(realm.realmId);
          Array.from(this.knownHandlesToRealmMap.entries()).filter(([, r]) => r === realm.realmId).map(([handle]) => this.knownHandlesToRealmMap.delete(handle));
        });
      }
    }, _knownHandlesToRealmMap = new WeakMap(), _realmMap = new WeakMap(), _a3);
    RealmStorage.RealmStorage = RealmStorage$1;
    return RealmStorage;
  }
  var EventManager = {};
  var Buffer$1 = {};
  var hasRequiredBuffer;
  function requireBuffer() {
    var _capacity, _entries, _onItemRemoved;
    if (hasRequiredBuffer) return Buffer$1;
    hasRequiredBuffer = 1;
    Object.defineProperty(Buffer$1, "__esModule", { value: true });
    Buffer$1.Buffer = void 0;
    class Buffer2 {
      /**
       * @param capacity The buffer capacity.
       * @param onItemRemoved Delegate called for each removed element.
       */
      constructor(capacity, onItemRemoved) {
        __privateAdd(this, _capacity);
        __privateAdd(this, _entries, []);
        __privateAdd(this, _onItemRemoved);
        __privateSet(this, _capacity, capacity);
        __privateSet(this, _onItemRemoved, onItemRemoved);
      }
      get() {
        return __privateGet(this, _entries);
      }
      add(value) {
        var _a3;
        __privateGet(this, _entries).push(value);
        while (__privateGet(this, _entries).length > __privateGet(this, _capacity)) {
          const item = __privateGet(this, _entries).shift();
          if (item !== void 0) {
            (_a3 = __privateGet(this, _onItemRemoved)) == null ? void 0 : _a3.call(this, item);
          }
        }
      }
    }
    _capacity = new WeakMap();
    _entries = new WeakMap();
    _onItemRemoved = new WeakMap();
    Buffer$1.Buffer = Buffer2;
    return Buffer$1;
  }
  var IdWrapper = {};
  var hasRequiredIdWrapper;
  function requireIdWrapper() {
    var _a3, _counter, _id7;
    if (hasRequiredIdWrapper) return IdWrapper;
    hasRequiredIdWrapper = 1;
    Object.defineProperty(IdWrapper, "__esModule", { value: true });
    IdWrapper.IdWrapper = void 0;
    let IdWrapper$1 = (_a3 = class {
      constructor() {
        __privateAdd(this, _id7);
        __privateSet(this, _id7, ++__privateWrapper(_a3, _counter)._);
      }
      get id() {
        return __privateGet(this, _id7);
      }
    }, _counter = new WeakMap(), _id7 = new WeakMap(), __privateAdd(_a3, _counter, 0), _a3);
    IdWrapper.IdWrapper = IdWrapper$1;
    return IdWrapper;
  }
  var events = {};
  var hasRequiredEvents;
  function requireEvents() {
    if (hasRequiredEvents) return events;
    hasRequiredEvents = 1;
    Object.defineProperty(events, "__esModule", { value: true });
    events.isCdpEvent = isCdpEvent2;
    events.isDeprecatedCdpEvent = isDeprecatedCdpEvent;
    events.assertSupportedEvent = assertSupportedEvent;
    const protocol_js_1 = requireProtocol();
    function isCdpEvent2(name) {
      var _a3;
      return ((_a3 = name.split(".").at(0)) == null ? void 0 : _a3.startsWith(protocol_js_1.ChromiumBidi.BiDiModule.Cdp)) ?? false;
    }
    function isDeprecatedCdpEvent(name) {
      var _a3;
      return ((_a3 = name.split(".").at(0)) == null ? void 0 : _a3.startsWith(protocol_js_1.ChromiumBidi.BiDiModule.DeprecatedCdp)) ?? false;
    }
    function assertSupportedEvent(name) {
      if (!protocol_js_1.ChromiumBidi.EVENT_NAMES.has(name) && !isCdpEvent2(name) && !isDeprecatedCdpEvent(name)) {
        throw new protocol_js_1.InvalidArgumentException(`Unknown event: ${name}`);
      }
    }
    return events;
  }
  var SubscriptionManager = {};
  var hasRequiredSubscriptionManager;
  function requireSubscriptionManager() {
    var _subscriptions3, _browsingContextStorage, _SubscriptionManager_instances, isSubscribedTo_fn, _a3;
    if (hasRequiredSubscriptionManager) return SubscriptionManager;
    hasRequiredSubscriptionManager = 1;
    Object.defineProperty(SubscriptionManager, "__esModule", { value: true });
    SubscriptionManager.SubscriptionManager = void 0;
    SubscriptionManager.cartesianProduct = cartesianProduct;
    SubscriptionManager.unrollEvents = unrollEvents;
    SubscriptionManager.difference = difference;
    const protocol_js_1 = requireProtocol();
    const uuid_js_1 = requireUuid();
    function cartesianProduct(...a) {
      return a.reduce((a2, b) => a2.flatMap((d) => b.map((e) => [d, e].flat())));
    }
    function unrollEvents(events2) {
      const allEvents = /* @__PURE__ */ new Set();
      function addEvents(events3) {
        for (const event of events3) {
          allEvents.add(event);
        }
      }
      for (const event of events2) {
        switch (event) {
          case protocol_js_1.ChromiumBidi.BiDiModule.Bluetooth:
            addEvents(Object.values(protocol_js_1.ChromiumBidi.Bluetooth.EventNames));
            break;
          case protocol_js_1.ChromiumBidi.BiDiModule.BrowsingContext:
            addEvents(Object.values(protocol_js_1.ChromiumBidi.BrowsingContext.EventNames));
            break;
          case protocol_js_1.ChromiumBidi.BiDiModule.Log:
            addEvents(Object.values(protocol_js_1.ChromiumBidi.Log.EventNames));
            break;
          case protocol_js_1.ChromiumBidi.BiDiModule.Network:
            addEvents(Object.values(protocol_js_1.ChromiumBidi.Network.EventNames));
            break;
          case protocol_js_1.ChromiumBidi.BiDiModule.Script:
            addEvents(Object.values(protocol_js_1.ChromiumBidi.Script.EventNames));
            break;
          default:
            allEvents.add(event);
        }
      }
      return [...allEvents.values()];
    }
    let SubscriptionManager$1 = (_a3 = class {
      constructor(browsingContextStorage) {
        __privateAdd(this, _SubscriptionManager_instances);
        __privateAdd(this, _subscriptions3, []);
        __privateAdd(this, _browsingContextStorage);
        __privateSet(this, _browsingContextStorage, browsingContextStorage);
      }
      getChannelsSubscribedToEvent(eventName, contextId) {
        const channels = /* @__PURE__ */ new Map();
        for (const subscription of __privateGet(this, _subscriptions3)) {
          if (__privateMethod(this, _SubscriptionManager_instances, isSubscribedTo_fn).call(this, subscription, eventName, contextId)) {
            channels.set(JSON.stringify(subscription.channel), subscription.channel);
          }
        }
        return Array.from(channels.values());
      }
      getChannelsSubscribedToEventGlobally(eventName) {
        const channels = /* @__PURE__ */ new Map();
        for (const subscription of __privateGet(this, _subscriptions3)) {
          if (__privateMethod(this, _SubscriptionManager_instances, isSubscribedTo_fn).call(this, subscription, eventName)) {
            channels.set(JSON.stringify(subscription.channel), subscription.channel);
          }
        }
        return Array.from(channels.values());
      }
      isSubscribedTo(moduleOrEvent, contextId) {
        for (const subscription of __privateGet(this, _subscriptions3)) {
          if (__privateMethod(this, _SubscriptionManager_instances, isSubscribedTo_fn).call(this, subscription, moduleOrEvent, contextId)) {
            return true;
          }
        }
        return false;
      }
      /**
       * Subscribes to event in the given context and channel.
       * @param {EventNames} event
       * @param {BrowsingContext.BrowsingContext | null} contextId
       * @param {BidiPlusChannel} channel
       * @return {SubscriptionItem[]} List of
       * subscriptions. If the event is a whole module, it will return all the specific
       * events. If the contextId is null, it will return all the top-level contexts which were
       * not subscribed before the command.
       */
      subscribe(eventNames, contextIds, channel) {
        const subscription = {
          id: (0, uuid_js_1.uuidv4)(),
          eventNames: new Set(unrollEvents(eventNames)),
          topLevelTraversableIds: new Set(contextIds.map((contextId) => {
            const topLevelContext = __privateGet(this, _browsingContextStorage).findTopLevelContextId(contextId);
            if (!topLevelContext) {
              throw new protocol_js_1.NoSuchFrameException(`Top-level navigable not found for context id ${contextId}`);
            }
            return topLevelContext;
          })),
          channel
        };
        __privateGet(this, _subscriptions3).push(subscription);
        return subscription;
      }
      /**
       * Unsubscribes atomically from all events in the given contexts and channel.
       *
       * This is a legacy spec branch to unsubscribe by attributes.
       */
      unsubscribe(inputEventNames, inputContextIds, channel) {
        const eventNames = new Set(unrollEvents(inputEventNames));
        for (const contextId of inputContextIds) {
          __privateGet(this, _browsingContextStorage).getContext(contextId);
        }
        const topLevelTraversables = new Set(inputContextIds.map((contextId) => {
          const topLevelContext = __privateGet(this, _browsingContextStorage).findTopLevelContextId(contextId);
          if (!topLevelContext) {
            throw new protocol_js_1.NoSuchFrameException(`Top-level navigable not found for context id ${contextId}`);
          }
          return topLevelContext;
        }));
        const isGlobalUnsubscribe = topLevelTraversables.size === 0;
        const newSubscriptions = [];
        const eventsMatched = /* @__PURE__ */ new Set();
        const contextsMatched = /* @__PURE__ */ new Set();
        for (const subscription of __privateGet(this, _subscriptions3)) {
          if (JSON.stringify(subscription.channel) !== JSON.stringify(channel)) {
            newSubscriptions.push(subscription);
            continue;
          }
          if (intersection(subscription.eventNames, eventNames).size === 0) {
            newSubscriptions.push(subscription);
            continue;
          }
          if (isGlobalUnsubscribe) {
            if (subscription.topLevelTraversableIds.size !== 0) {
              newSubscriptions.push(subscription);
              continue;
            }
            const subscriptionEventNames = new Set(subscription.eventNames);
            for (const eventName of eventNames) {
              if (subscriptionEventNames.has(eventName)) {
                eventsMatched.add(eventName);
                subscriptionEventNames.delete(eventName);
              }
            }
            if (subscriptionEventNames.size !== 0) {
              newSubscriptions.push({
                ...subscription,
                eventNames: subscriptionEventNames
              });
            }
          } else {
            if (subscription.topLevelTraversableIds.size === 0) {
              newSubscriptions.push(subscription);
              continue;
            }
            const eventMap = /* @__PURE__ */ new Map();
            for (const eventName of subscription.eventNames) {
              eventMap.set(eventName, new Set(subscription.topLevelTraversableIds));
            }
            for (const eventName of eventNames) {
              const eventContextSet = eventMap.get(eventName);
              if (!eventContextSet) {
                continue;
              }
              for (const toRemoveId of topLevelTraversables) {
                if (eventContextSet.has(toRemoveId)) {
                  contextsMatched.add(toRemoveId);
                  eventsMatched.add(eventName);
                  eventContextSet.delete(toRemoveId);
                }
              }
              if (eventContextSet.size === 0) {
                eventMap.delete(eventName);
              }
            }
            for (const [eventName, remainingContextIds] of eventMap) {
              const partialSubscription = {
                id: subscription.id,
                channel: subscription.channel,
                eventNames: /* @__PURE__ */ new Set([eventName]),
                topLevelTraversableIds: remainingContextIds
              };
              newSubscriptions.push(partialSubscription);
            }
          }
        }
        if (!equal(eventsMatched, eventNames)) {
          throw new protocol_js_1.InvalidArgumentException("No subscription found");
        }
        if (!isGlobalUnsubscribe && !equal(contextsMatched, topLevelTraversables)) {
          throw new protocol_js_1.InvalidArgumentException("No subscription found");
        }
        __privateSet(this, _subscriptions3, newSubscriptions);
      }
      /**
       * Unsubscribes by subscriptionId.
       */
      unsubscribeById(_subscription) {
      }
    }, _subscriptions3 = new WeakMap(), _browsingContextStorage = new WeakMap(), _SubscriptionManager_instances = new WeakSet(), isSubscribedTo_fn = function(subscription, moduleOrEvent, contextId) {
      let includesEvent = false;
      for (const eventName of subscription.eventNames) {
        if (
          // Event explicitly subscribed
          eventName === moduleOrEvent || // Event subscribed via module
          eventName === moduleOrEvent.split(".").at(0) || // Event explicitly subscribed compared to module
          eventName.split(".").at(0) === moduleOrEvent
        ) {
          includesEvent = true;
          break;
        }
      }
      if (!includesEvent) {
        return false;
      }
      if (subscription.topLevelTraversableIds.size === 0) {
        return true;
      }
      const topLevelContext = contextId ? __privateGet(this, _browsingContextStorage).findTopLevelContextId(contextId) : null;
      if (topLevelContext !== null && subscription.topLevelTraversableIds.has(topLevelContext)) {
        return true;
      }
      return false;
    }, _a3);
    SubscriptionManager.SubscriptionManager = SubscriptionManager$1;
    function intersection(setA, setB) {
      const result = /* @__PURE__ */ new Set();
      for (const a of setA) {
        if (setB.has(a)) {
          result.add(a);
        }
      }
      return result;
    }
    function difference(setA, setB) {
      const result = /* @__PURE__ */ new Set();
      for (const a of setA) {
        if (!setB.has(a)) {
          result.add(a);
        }
      }
      return result;
    }
    function equal(setA, setB) {
      if (setA.size !== setB.size) {
        return false;
      }
      for (const a of setA) {
        if (!setB.has(a)) {
          return false;
        }
      }
      return true;
    }
    return SubscriptionManager;
  }
  var hasRequiredEventManager;
  function requireEventManager() {
    var _idWrapper, _contextId, _event, _eventToContextsMap, _eventBuffers, _lastMessageSent, _subscriptionManager, _browsingContextStorage, _subscribeHooks, _EventManager_static, _a4, getMapKey_fn, _EventManager_instances, bufferEvent_fn, markEventSent_fn, getBufferedEvents_fn;
    if (hasRequiredEventManager) return EventManager;
    hasRequiredEventManager = 1;
    var _a3;
    Object.defineProperty(EventManager, "__esModule", { value: true });
    EventManager.EventManager = void 0;
    const protocol_js_1 = requireProtocol();
    const Buffer_js_1 = requireBuffer();
    const DefaultMap_js_1 = requireDefaultMap();
    const EventEmitter_js_1 = requireEventEmitter();
    const IdWrapper_js_1 = requireIdWrapper();
    const OutgoingMessage_js_1 = requireOutgoingMessage();
    const events_js_1 = requireEvents();
    const SubscriptionManager_js_1 = requireSubscriptionManager();
    class EventWrapper {
      constructor(event, contextId) {
        __privateAdd(this, _idWrapper, new IdWrapper_js_1.IdWrapper());
        __privateAdd(this, _contextId);
        __privateAdd(this, _event);
        __privateSet(this, _event, event);
        __privateSet(this, _contextId, contextId);
      }
      get id() {
        return __privateGet(this, _idWrapper).id;
      }
      get contextId() {
        return __privateGet(this, _contextId);
      }
      get event() {
        return __privateGet(this, _event);
      }
    }
    _idWrapper = new WeakMap();
    _contextId = new WeakMap();
    _event = new WeakMap();
    const eventBufferLength = /* @__PURE__ */ new Map([[protocol_js_1.ChromiumBidi.Log.EventNames.LogEntryAdded, 100]]);
    let EventManager$12 = (_a4 = class extends EventEmitter_js_1.EventEmitter {
      constructor(browsingContextStorage) {
        super();
        __privateAdd(this, _EventManager_instances);
        /**
         * Maps event name to a set of contexts where this event already happened.
         * Needed for getting buffered events from all the contexts in case of
         * subscripting to all contexts.
         */
        __privateAdd(this, _eventToContextsMap, new DefaultMap_js_1.DefaultMap(() => /* @__PURE__ */ new Set()));
        /**
         * Maps `eventName` + `browsingContext` to buffer. Used to get buffered events
         * during subscription. Channel-agnostic.
         */
        __privateAdd(this, _eventBuffers, /* @__PURE__ */ new Map());
        /**
         * Maps `eventName` + `browsingContext` to  Map of json stringified channel to last id.
         * Used to avoid sending duplicated events when user
         * subscribes -> unsubscribes -> subscribes.
         */
        __privateAdd(this, _lastMessageSent, /* @__PURE__ */ new Map());
        __privateAdd(this, _subscriptionManager);
        __privateAdd(this, _browsingContextStorage);
        /**
         * Map of event name to hooks to be called when client is subscribed to the event.
         */
        __privateAdd(this, _subscribeHooks);
        __privateSet(this, _browsingContextStorage, browsingContextStorage);
        __privateSet(this, _subscriptionManager, new SubscriptionManager_js_1.SubscriptionManager(browsingContextStorage));
        __privateSet(this, _subscribeHooks, new DefaultMap_js_1.DefaultMap(() => []));
      }
      get subscriptionManager() {
        return __privateGet(this, _subscriptionManager);
      }
      addSubscribeHook(event, hook) {
        __privateGet(this, _subscribeHooks).get(event).push(hook);
      }
      registerEvent(event, contextId) {
        this.registerPromiseEvent(Promise.resolve({
          kind: "success",
          value: event
        }), contextId, event.method);
      }
      registerGlobalEvent(event) {
        this.registerGlobalPromiseEvent(Promise.resolve({
          kind: "success",
          value: event
        }), event.method);
      }
      registerPromiseEvent(event, contextId, eventName) {
        const eventWrapper = new EventWrapper(event, contextId);
        const sortedChannels = __privateGet(this, _subscriptionManager).getChannelsSubscribedToEvent(eventName, contextId);
        __privateMethod(this, _EventManager_instances, bufferEvent_fn).call(this, eventWrapper, eventName);
        for (const channel of sortedChannels) {
          this.emit("event", {
            message: OutgoingMessage_js_1.OutgoingMessage.createFromPromise(event, channel),
            event: eventName
          });
          __privateMethod(this, _EventManager_instances, markEventSent_fn).call(this, eventWrapper, channel, eventName);
        }
      }
      registerGlobalPromiseEvent(event, eventName) {
        const eventWrapper = new EventWrapper(event, null);
        const sortedChannels = __privateGet(this, _subscriptionManager).getChannelsSubscribedToEventGlobally(eventName);
        __privateMethod(this, _EventManager_instances, bufferEvent_fn).call(this, eventWrapper, eventName);
        for (const channel of sortedChannels) {
          this.emit("event", {
            message: OutgoingMessage_js_1.OutgoingMessage.createFromPromise(event, channel),
            event: eventName
          });
          __privateMethod(this, _EventManager_instances, markEventSent_fn).call(this, eventWrapper, channel, eventName);
        }
      }
      async subscribe(eventNames, contextIds, channel) {
        for (const name of eventNames) {
          (0, events_js_1.assertSupportedEvent)(name);
        }
        for (const contextId of contextIds) {
          if (contextId !== null) {
            __privateGet(this, _browsingContextStorage).getContext(contextId);
          }
        }
        const unrolledEventNames = new Set((0, SubscriptionManager_js_1.unrollEvents)(eventNames));
        const subscribeStepEvents = /* @__PURE__ */ new Map();
        const subscriptionNavigableIds = new Set(contextIds.length ? contextIds.map((contextId) => {
          const id = __privateGet(this, _browsingContextStorage).findTopLevelContextId(contextId);
          if (!id) {
            throw new protocol_js_1.InvalidArgumentException("Invalid context id");
          }
          return id;
        }) : __privateGet(this, _browsingContextStorage).getTopLevelContexts().map((c) => c.id));
        for (const eventName of unrolledEventNames) {
          const subscribedNavigableIds = new Set(__privateGet(this, _browsingContextStorage).getTopLevelContexts().map((c) => c.id).filter((id) => {
            return __privateGet(this, _subscriptionManager).isSubscribedTo(eventName, id);
          }));
          subscribeStepEvents.set(eventName, (0, SubscriptionManager_js_1.difference)(subscriptionNavigableIds, subscribedNavigableIds));
        }
        const subscription = __privateGet(this, _subscriptionManager).subscribe(eventNames, contextIds, channel);
        for (const eventName of subscription.eventNames) {
          for (const contextId of subscriptionNavigableIds) {
            for (const eventWrapper of __privateMethod(this, _EventManager_instances, getBufferedEvents_fn).call(this, eventName, contextId, channel)) {
              this.emit("event", {
                message: OutgoingMessage_js_1.OutgoingMessage.createFromPromise(eventWrapper.event, channel),
                event: eventName
              });
              __privateMethod(this, _EventManager_instances, markEventSent_fn).call(this, eventWrapper, channel, eventName);
            }
          }
        }
        for (const [eventName, contextIds2] of subscribeStepEvents) {
          for (const contextId of contextIds2) {
            __privateGet(this, _subscribeHooks).get(eventName).forEach((hook) => hook(contextId));
          }
        }
        await this.toggleModulesIfNeeded();
        return subscription.id;
      }
      async unsubscribe(eventNames, contextIds, channel) {
        for (const name of eventNames) {
          (0, events_js_1.assertSupportedEvent)(name);
        }
        __privateGet(this, _subscriptionManager).unsubscribe(eventNames, contextIds, channel);
        await this.toggleModulesIfNeeded();
      }
      async toggleModulesIfNeeded() {
        await Promise.all(__privateGet(this, _browsingContextStorage).getAllContexts().map(async (context) => {
          return await context.toggleModulesIfNeeded();
        }));
      }
      clearBufferedEvents(contextId) {
        var _a5;
        for (const eventName of eventBufferLength.keys()) {
          const bufferMapKey = __privateMethod(_a5 = _a3, _EventManager_static, getMapKey_fn).call(_a5, eventName, contextId);
          __privateGet(this, _eventBuffers).delete(bufferMapKey);
        }
      }
    }, _eventToContextsMap = new WeakMap(), _eventBuffers = new WeakMap(), _lastMessageSent = new WeakMap(), _subscriptionManager = new WeakMap(), _browsingContextStorage = new WeakMap(), _subscribeHooks = new WeakMap(), _EventManager_static = new WeakSet(), getMapKey_fn = function(eventName, browsingContext) {
      return JSON.stringify({ eventName, browsingContext });
    }, _EventManager_instances = new WeakSet(), /**
     * If the event is buffer-able, put it in the buffer.
     */
    bufferEvent_fn = function(eventWrapper, eventName) {
      var _a5;
      if (!eventBufferLength.has(eventName)) {
        return;
      }
      const bufferMapKey = __privateMethod(_a5 = _a3, _EventManager_static, getMapKey_fn).call(_a5, eventName, eventWrapper.contextId);
      if (!__privateGet(this, _eventBuffers).has(bufferMapKey)) {
        __privateGet(this, _eventBuffers).set(bufferMapKey, new Buffer_js_1.Buffer(eventBufferLength.get(eventName)));
      }
      __privateGet(this, _eventBuffers).get(bufferMapKey).add(eventWrapper);
      __privateGet(this, _eventToContextsMap).get(eventName).add(eventWrapper.contextId);
    }, /**
     * If the event is buffer-able, mark it as sent to the given contextId and channel.
     */
    markEventSent_fn = function(eventWrapper, channel, eventName) {
      var _a5, _b2;
      if (!eventBufferLength.has(eventName)) {
        return;
      }
      const lastSentMapKey = __privateMethod(_a5 = _a3, _EventManager_static, getMapKey_fn).call(_a5, eventName, eventWrapper.contextId);
      const lastId = Math.max(((_b2 = __privateGet(this, _lastMessageSent).get(lastSentMapKey)) == null ? void 0 : _b2.get(JSON.stringify(channel))) ?? 0, eventWrapper.id);
      const channelMap = __privateGet(this, _lastMessageSent).get(lastSentMapKey);
      if (channelMap) {
        channelMap.set(JSON.stringify(channel), lastId);
      } else {
        __privateGet(this, _lastMessageSent).set(lastSentMapKey, /* @__PURE__ */ new Map([[JSON.stringify(channel), lastId]]));
      }
    }, /**
     * Returns events which are buffered and not yet sent to the given channel events.
     */
    getBufferedEvents_fn = function(eventName, contextId, channel) {
      var _a5, _b2, _c2;
      const bufferMapKey = __privateMethod(_a5 = _a3, _EventManager_static, getMapKey_fn).call(_a5, eventName, contextId);
      const lastSentMessageId = ((_b2 = __privateGet(this, _lastMessageSent).get(bufferMapKey)) == null ? void 0 : _b2.get(JSON.stringify(channel))) ?? -Infinity;
      const result = ((_c2 = __privateGet(this, _eventBuffers).get(bufferMapKey)) == null ? void 0 : _c2.get().filter((wrapper) => wrapper.id > lastSentMessageId)) ?? [];
      if (contextId === null) {
        Array.from(__privateGet(this, _eventToContextsMap).get(eventName).keys()).filter((_contextId2) => (
          // Events without context are already in the result.
          _contextId2 !== null && // Events from deleted contexts should not be sent.
          __privateGet(this, _browsingContextStorage).hasContext(_contextId2)
        )).map((_contextId2) => __privateMethod(this, _EventManager_instances, getBufferedEvents_fn).call(this, eventName, _contextId2, channel)).forEach((events2) => result.push(...events2));
      }
      return result.sort((e1, e2) => e1.id - e2.id);
    }, __privateAdd(_a4, _EventManager_static), _a4);
    EventManager.EventManager = EventManager$12;
    _a3 = EventManager$12;
    return EventManager;
  }
  var hasRequiredBidiServer;
  function requireBidiServer() {
    var _messageQueue, _transport3, _commandProcessor, _eventManager, _browsingContextStorage, _realmStorage, _preloadScriptStorage, _bluetoothProcessor, _logger, _handleIncomingMessage, _processOutgoingMessage, _BidiServer_instances, topLevelContextsLoaded_fn, _a3;
    if (hasRequiredBidiServer) return BidiServer;
    hasRequiredBidiServer = 1;
    Object.defineProperty(BidiServer, "__esModule", { value: true });
    BidiServer.BidiServer = void 0;
    const EventEmitter_js_1 = requireEventEmitter();
    const log_js_1 = requireLog();
    const ProcessingQueue_js_1 = requireProcessingQueue();
    const CommandProcessor_js_1 = requireCommandProcessor();
    const BluetoothProcessor_js_1 = requireBluetoothProcessor();
    const CdpTargetManager_js_1 = requireCdpTargetManager();
    const BrowsingContextStorage_js_1 = requireBrowsingContextStorage();
    const NetworkStorage_js_1 = requireNetworkStorage();
    const PreloadScriptStorage_js_1 = requirePreloadScriptStorage();
    const RealmStorage_js_1 = requireRealmStorage();
    const EventManager_js_1 = requireEventManager();
    let BidiServer$1 = (_a3 = class extends EventEmitter_js_1.EventEmitter {
      constructor(bidiTransport, cdpConnection, browserCdpClient, selfTargetId, defaultUserContextId, parser, logger2) {
        super();
        __privateAdd(this, _BidiServer_instances);
        __privateAdd(this, _messageQueue);
        __privateAdd(this, _transport3);
        __privateAdd(this, _commandProcessor);
        __privateAdd(this, _eventManager);
        __privateAdd(this, _browsingContextStorage, new BrowsingContextStorage_js_1.BrowsingContextStorage());
        __privateAdd(this, _realmStorage, new RealmStorage_js_1.RealmStorage());
        __privateAdd(this, _preloadScriptStorage, new PreloadScriptStorage_js_1.PreloadScriptStorage());
        __privateAdd(this, _bluetoothProcessor);
        __privateAdd(this, _logger);
        __privateAdd(this, _handleIncomingMessage, (message) => {
          void __privateGet(this, _commandProcessor).processCommand(message).catch((error) => {
            var _a4;
            (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, log_js_1.LogType.debugError, error);
          });
        });
        __privateAdd(this, _processOutgoingMessage, async (messageEntry) => {
          const message = { ...messageEntry.message, ...messageEntry.channel };
          await __privateGet(this, _transport3).sendMessage(message);
        });
        __privateSet(this, _logger, logger2);
        __privateSet(this, _messageQueue, new ProcessingQueue_js_1.ProcessingQueue(__privateGet(this, _processOutgoingMessage), __privateGet(this, _logger)));
        __privateSet(this, _transport3, bidiTransport);
        __privateGet(this, _transport3).setOnMessage(__privateGet(this, _handleIncomingMessage));
        __privateSet(this, _eventManager, new EventManager_js_1.EventManager(__privateGet(this, _browsingContextStorage)));
        const networkStorage = new NetworkStorage_js_1.NetworkStorage(__privateGet(this, _eventManager), __privateGet(this, _browsingContextStorage), browserCdpClient, logger2);
        __privateSet(this, _bluetoothProcessor, new BluetoothProcessor_js_1.BluetoothProcessor(__privateGet(this, _eventManager), __privateGet(this, _browsingContextStorage)));
        __privateSet(this, _commandProcessor, new CommandProcessor_js_1.CommandProcessor(cdpConnection, browserCdpClient, __privateGet(this, _eventManager), __privateGet(this, _browsingContextStorage), __privateGet(this, _realmStorage), __privateGet(this, _preloadScriptStorage), networkStorage, __privateGet(this, _bluetoothProcessor), parser, async (options) => {
          await browserCdpClient.sendCommand("Security.setIgnoreCertificateErrors", {
            ignore: options.acceptInsecureCerts ?? false
          });
          new CdpTargetManager_js_1.CdpTargetManager(cdpConnection, browserCdpClient, selfTargetId, __privateGet(this, _eventManager), __privateGet(this, _browsingContextStorage), __privateGet(this, _realmStorage), networkStorage, __privateGet(this, _bluetoothProcessor), __privateGet(this, _preloadScriptStorage), defaultUserContextId, (options == null ? void 0 : options["goog:prerenderingDisabled"]) ?? false, options == null ? void 0 : options.unhandledPromptBehavior, logger2);
          await browserCdpClient.sendCommand("Target.setDiscoverTargets", {
            discover: true
          });
          await browserCdpClient.sendCommand("Target.setAutoAttach", {
            autoAttach: true,
            waitForDebuggerOnStart: true,
            flatten: true,
            // Browser session should attach to tab instead of the page, so that
            // prerendering is not blocked.
            filter: [
              {
                type: "page",
                exclude: true
              },
              {}
            ]
          });
          await __privateMethod(this, _BidiServer_instances, topLevelContextsLoaded_fn).call(this);
        }, __privateGet(this, _logger)));
        __privateGet(this, _eventManager).on("event", ({ message, event }) => {
          this.emitOutgoingMessage(message, event);
        });
        __privateGet(this, _commandProcessor).on("response", ({ message, event }) => {
          this.emitOutgoingMessage(message, event);
        });
      }
      /**
       * Creates and starts BiDi Mapper instance.
       */
      static async createAndStart(bidiTransport, cdpConnection, browserCdpClient, selfTargetId, parser, logger2) {
        const [{ browserContextIds }, { targetInfos }] = await Promise.all([
          browserCdpClient.sendCommand("Target.getBrowserContexts"),
          browserCdpClient.sendCommand("Target.getTargets")
        ]);
        let defaultUserContextId = "default";
        for (const info of targetInfos) {
          if (info.browserContextId && !browserContextIds.includes(info.browserContextId)) {
            defaultUserContextId = info.browserContextId;
            break;
          }
        }
        const server = new _a3(bidiTransport, cdpConnection, browserCdpClient, selfTargetId, defaultUserContextId, parser, logger2);
        return server;
      }
      /**
       * Sends BiDi message.
       */
      emitOutgoingMessage(messageEntry, event) {
        __privateGet(this, _messageQueue).add(messageEntry, event);
      }
      close() {
        __privateGet(this, _transport3).close();
      }
    }, _messageQueue = new WeakMap(), _transport3 = new WeakMap(), _commandProcessor = new WeakMap(), _eventManager = new WeakMap(), _browsingContextStorage = new WeakMap(), _realmStorage = new WeakMap(), _preloadScriptStorage = new WeakMap(), _bluetoothProcessor = new WeakMap(), _logger = new WeakMap(), _handleIncomingMessage = new WeakMap(), _processOutgoingMessage = new WeakMap(), _BidiServer_instances = new WeakSet(), topLevelContextsLoaded_fn = async function() {
      await Promise.all(__privateGet(this, _browsingContextStorage).getTopLevelContexts().map((c) => c.lifecycleLoaded()));
    }, _a3);
    BidiServer.BidiServer = BidiServer$1;
    return BidiServer;
  }
  var hasRequiredBidiMapper;
  function requireBidiMapper() {
    if (hasRequiredBidiMapper) return BidiMapper;
    hasRequiredBidiMapper = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.OutgoingMessage = exports.EventEmitter = exports.BidiServer = void 0;
      var BidiServer_js_1 = requireBidiServer();
      Object.defineProperty(exports, "BidiServer", { enumerable: true, get: function() {
        return BidiServer_js_1.BidiServer;
      } });
      var EventEmitter_js_1 = requireEventEmitter();
      Object.defineProperty(exports, "EventEmitter", { enumerable: true, get: function() {
        return EventEmitter_js_1.EventEmitter;
      } });
      var OutgoingMessage_js_1 = requireOutgoingMessage();
      Object.defineProperty(exports, "OutgoingMessage", { enumerable: true, get: function() {
        return OutgoingMessage_js_1.OutgoingMessage;
      } });
    })(BidiMapper);
    return BidiMapper;
  }
  var BidiMapperExports = requireBidiMapper();
  const _BidiCdpSession = class _BidiCdpSession extends CDPSession {
    constructor(frame, sessionId) {
      super();
      __privateAdd(this, _detached, false);
      __privateAdd(this, _connection5);
      __privateAdd(this, _sessionId2, Deferred$1.create());
      __publicField(this, "frame");
      /**
       * @internal
       */
      __publicField(this, "onClose", () => {
        _BidiCdpSession.sessions.delete(this.id());
        __privateSet(this, _detached, true);
      });
      this.frame = frame;
      if (!this.frame.page().browser().cdpSupported) {
        return;
      }
      const connection = this.frame.page().browser().connection;
      __privateSet(this, _connection5, connection);
      if (sessionId) {
        __privateGet(this, _sessionId2).resolve(sessionId);
        _BidiCdpSession.sessions.set(sessionId, this);
      } else {
        (async () => {
          try {
            const { result } = await connection.send("goog:cdp.getSession", {
              context: frame._id
            });
            __privateGet(this, _sessionId2).resolve(result.session);
            _BidiCdpSession.sessions.set(result.session, this);
          } catch (error) {
            __privateGet(this, _sessionId2).reject(error);
          }
        })();
      }
      _BidiCdpSession.sessions.set(__privateGet(this, _sessionId2).value(), this);
    }
    connection() {
      return void 0;
    }
    async send(method, params, options) {
      if (__privateGet(this, _connection5) === void 0) {
        throw new UnsupportedOperation("CDP support is required for this feature. The current browser does not support CDP.");
      }
      if (__privateGet(this, _detached)) {
        throw new TargetCloseError(`Protocol error (${method}): Session closed. Most likely the page has been closed.`);
      }
      const session = await __privateGet(this, _sessionId2).valueOrThrow();
      const { result } = await __privateGet(this, _connection5).send("goog:cdp.sendCommand", {
        method,
        params,
        session
      }, options == null ? void 0 : options.timeout);
      return result.result;
    }
    async detach() {
      if (__privateGet(this, _connection5) === void 0 || __privateGet(this, _connection5).closed || __privateGet(this, _detached)) {
        return;
      }
      try {
        await this.frame.client.send("Target.detachFromTarget", {
          sessionId: this.id()
        });
      } finally {
        this.onClose();
      }
    }
    id() {
      const value = __privateGet(this, _sessionId2).value();
      return typeof value === "string" ? value : "";
    }
  };
  _detached = new WeakMap();
  _connection5 = new WeakMap();
  _sessionId2 = new WeakMap();
  __publicField(_BidiCdpSession, "sessions", /* @__PURE__ */ new Map());
  let BidiCdpSession = _BidiCdpSession;
  /**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  const debugProtocolSend = debug$3("puppeteer:webDriverBiDi:SEND ►");
  const debugProtocolReceive = debug$3("puppeteer:webDriverBiDi:RECV ◀");
  class BidiConnection extends EventEmitter$1 {
    constructor(url, transport, delay = 0, timeout2) {
      super();
      __privateAdd(this, _url4);
      __privateAdd(this, _transport2);
      __privateAdd(this, _delay2);
      __privateAdd(this, _timeout4, 0);
      __privateAdd(this, _closed3, false);
      __privateAdd(this, _callbacks4, new CallbackRegistry());
      __privateAdd(this, _emitters, []);
      __privateSet(this, _url4, url);
      __privateSet(this, _delay2, delay);
      __privateSet(this, _timeout4, timeout2 ?? 18e4);
      __privateSet(this, _transport2, transport);
      __privateGet(this, _transport2).onmessage = this.onMessage.bind(this);
      __privateGet(this, _transport2).onclose = this.unbind.bind(this);
    }
    get closed() {
      return __privateGet(this, _closed3);
    }
    get url() {
      return __privateGet(this, _url4);
    }
    pipeTo(emitter) {
      __privateGet(this, _emitters).push(emitter);
    }
    emit(type, event) {
      for (const emitter of __privateGet(this, _emitters)) {
        emitter.emit(type, event);
      }
      return super.emit(type, event);
    }
    send(method, params, timeout2) {
      assert$1(!__privateGet(this, _closed3), "Protocol error: Connection closed.");
      return __privateGet(this, _callbacks4).create(method, timeout2 ?? __privateGet(this, _timeout4), (id) => {
        const stringifiedMessage = JSON.stringify({
          id,
          method,
          params
        });
        debugProtocolSend(stringifiedMessage);
        __privateGet(this, _transport2).send(stringifiedMessage);
      });
    }
    /**
     * @internal
     */
    async onMessage(message) {
      var _a3;
      if (__privateGet(this, _delay2)) {
        await new Promise((f) => {
          return setTimeout(f, __privateGet(this, _delay2));
        });
      }
      debugProtocolReceive(message);
      const object = JSON.parse(message);
      if ("type" in object) {
        switch (object.type) {
          case "success":
            __privateGet(this, _callbacks4).resolve(object.id, object);
            return;
          case "error":
            if (object.id === null) {
              break;
            }
            __privateGet(this, _callbacks4).reject(object.id, createProtocolError(object), `${object.error}: ${object.message}`);
            return;
          case "event":
            if (isCdpEvent(object)) {
              (_a3 = BidiCdpSession.sessions.get(object.params.session)) == null ? void 0 : _a3.emit(object.params.event, object.params.params);
              return;
            }
            this.emit(object.method, object.params);
            return;
        }
      }
      if ("id" in object) {
        __privateGet(this, _callbacks4).reject(object.id, `Protocol Error. Message is not in BiDi protocol format: '${message}'`, object.message);
      }
      debugError(object);
    }
    /**
     * Unbinds the connection, but keeps the transport open. Useful when the transport will
     * be reused by other connection e.g. with different protocol.
     * @internal
     */
    unbind() {
      if (__privateGet(this, _closed3)) {
        return;
      }
      __privateSet(this, _closed3, true);
      __privateGet(this, _transport2).onmessage = () => {
      };
      __privateGet(this, _transport2).onclose = () => {
      };
      __privateGet(this, _callbacks4).clear();
    }
    /**
     * Unbinds the connection and closes the transport.
     */
    dispose() {
      this.unbind();
      __privateGet(this, _transport2).close();
    }
    getPendingProtocolErrors() {
      return __privateGet(this, _callbacks4).getPendingProtocolErrors();
    }
  }
  _url4 = new WeakMap();
  _transport2 = new WeakMap();
  _delay2 = new WeakMap();
  _timeout4 = new WeakMap();
  _closed3 = new WeakMap();
  _callbacks4 = new WeakMap();
  _emitters = new WeakMap();
  function createProtocolError(object) {
    let message = `${object.error} ${object.message}`;
    if (object.stacktrace) {
      message += ` ${object.stacktrace}`;
    }
    return message;
  }
  function isCdpEvent(event) {
    return event.method.startsWith("goog:cdp.");
  }
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  const bidiServerLogger = (prefix, ...args) => {
    debug$3(`bidi:${prefix}`)(args);
  };
  async function connectBidiOverCdp(cdp2) {
    const transportBiDi = new NoOpTransport();
    const cdpConnectionAdapter = new CdpConnectionAdapter(cdp2);
    const pptrTransport = {
      send(message) {
        transportBiDi.emitMessage(JSON.parse(message));
      },
      close() {
        bidiServer.close();
        cdpConnectionAdapter.close();
        cdp2.dispose();
      },
      onmessage(_message2) {
      }
    };
    transportBiDi.on("bidiResponse", (message) => {
      pptrTransport.onmessage(JSON.stringify(message));
    });
    const pptrBiDiConnection = new BidiConnection(cdp2.url(), pptrTransport, cdp2.delay, cdp2.timeout);
    const bidiServer = await BidiMapperExports.BidiServer.createAndStart(
      transportBiDi,
      cdpConnectionAdapter,
      cdpConnectionAdapter.browserClient(),
      /* selfTargetId= */
      "",
      void 0,
      bidiServerLogger
    );
    return pptrBiDiConnection;
  }
  class CdpConnectionAdapter {
    constructor(cdp2) {
      __privateAdd(this, _cdp);
      __privateAdd(this, _adapters, /* @__PURE__ */ new Map());
      __privateAdd(this, _browserCdpConnection);
      __privateSet(this, _cdp, cdp2);
      __privateSet(this, _browserCdpConnection, new CDPClientAdapter(cdp2));
    }
    browserClient() {
      return __privateGet(this, _browserCdpConnection);
    }
    getCdpClient(id) {
      const session = __privateGet(this, _cdp).session(id);
      if (!session) {
        throw new Error(`Unknown CDP session with id ${id}`);
      }
      if (!__privateGet(this, _adapters).has(session)) {
        const adapter = new CDPClientAdapter(session, id, __privateGet(this, _browserCdpConnection));
        __privateGet(this, _adapters).set(session, adapter);
        return adapter;
      }
      return __privateGet(this, _adapters).get(session);
    }
    close() {
      __privateGet(this, _browserCdpConnection).close();
      for (const adapter of __privateGet(this, _adapters).values()) {
        adapter.close();
      }
    }
  }
  _cdp = new WeakMap();
  _adapters = new WeakMap();
  _browserCdpConnection = new WeakMap();
  class CDPClientAdapter extends BidiMapperExports.EventEmitter {
    constructor(client2, sessionId, browserClient) {
      super();
      __privateAdd(this, _closed4, false);
      __privateAdd(this, _client15);
      __publicField(this, "sessionId");
      __privateAdd(this, _browserClient);
      __privateAdd(this, _forwardMessage, (method, event) => {
        this.emit(method, event);
      });
      __privateSet(this, _client15, client2);
      this.sessionId = sessionId;
      __privateSet(this, _browserClient, browserClient);
      __privateGet(this, _client15).on("*", __privateGet(this, _forwardMessage));
    }
    browserClient() {
      return __privateGet(this, _browserClient);
    }
    async sendCommand(method, ...params) {
      if (__privateGet(this, _closed4)) {
        return;
      }
      try {
        return await __privateGet(this, _client15).send(method, ...params);
      } catch (err) {
        if (__privateGet(this, _closed4)) {
          return;
        }
        throw err;
      }
    }
    close() {
      __privateGet(this, _client15).off("*", __privateGet(this, _forwardMessage));
      __privateSet(this, _closed4, true);
    }
    isCloseError(error) {
      return error instanceof TargetCloseError;
    }
  }
  _closed4 = new WeakMap();
  _client15 = new WeakMap();
  _browserClient = new WeakMap();
  _forwardMessage = new WeakMap();
  class NoOpTransport extends BidiMapperExports.EventEmitter {
    constructor() {
      super(...arguments);
      __privateAdd(this, _onMessage, async (_m) => {
        return;
      });
    }
    emitMessage(message) {
      void __privateGet(this, _onMessage).call(this, message);
    }
    setOnMessage(onMessage) {
      __privateSet(this, _onMessage, onMessage);
    }
    async sendMessage(message) {
      this.emit("bidiResponse", message);
    }
    close() {
      __privateSet(this, _onMessage, async (_m) => {
        return;
      });
    }
  }
  _onMessage = new WeakMap();
  /**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var __runInitializers$d = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i2 = 0; i2 < initializers.length; i2++) {
      value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate$d = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind2 = contextIn.kind, key = kind2 === "getter" ? "get" : kind2 === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function(f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i2])(kind2 === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind2 === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_ = accept(result.get)) descriptor.get = _;
        if (_ = accept(result.set)) descriptor.set = _;
        if (_ = accept(result.init)) initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind2 === "field") initializers.unshift(_);
        else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  let Navigation = (() => {
    var _request3, _navigation, _browsingContext, _disposables3, _id7, _Navigation_instances, initialize_fn8, matches_fn, session_get, _a3;
    let _classSuper = EventEmitter$1;
    let _instanceExtraInitializers = [];
    let _dispose_decorators;
    return _a3 = class extends _classSuper {
      constructor(context) {
        super();
        __privateAdd(this, _Navigation_instances);
        __privateAdd(this, _request3, __runInitializers$d(this, _instanceExtraInitializers));
        __privateAdd(this, _navigation);
        __privateAdd(this, _browsingContext);
        __privateAdd(this, _disposables3, new DisposableStack());
        __privateAdd(this, _id7);
        __privateSet(this, _browsingContext, context);
      }
      static from(context) {
        var _a4;
        const navigation = new _a3(context);
        __privateMethod(_a4 = navigation, _Navigation_instances, initialize_fn8).call(_a4);
        return navigation;
      }
      get disposed() {
        return __privateGet(this, _disposables3).disposed;
      }
      get request() {
        return __privateGet(this, _request3);
      }
      get navigation() {
        return __privateGet(this, _navigation);
      }
      dispose() {
        this[disposeSymbol]();
      }
      [(_dispose_decorators = [inertIfDisposed], disposeSymbol)]() {
        __privateGet(this, _disposables3).dispose();
        super[disposeSymbol]();
      }
    }, _request3 = new WeakMap(), _navigation = new WeakMap(), _browsingContext = new WeakMap(), _disposables3 = new WeakMap(), _id7 = new WeakMap(), _Navigation_instances = new WeakSet(), initialize_fn8 = function() {
      const browsingContextEmitter = __privateGet(this, _disposables3).use(new EventEmitter$1(__privateGet(this, _browsingContext)));
      browsingContextEmitter.once("closed", () => {
        this.emit("failed", {
          url: __privateGet(this, _browsingContext).url,
          timestamp: /* @__PURE__ */ new Date()
        });
        this.dispose();
      });
      browsingContextEmitter.on("request", ({ request }) => {
        if (request.navigation === void 0 || // If a request with a navigation ID comes in, then the navigation ID is
        // for this navigation.
        !__privateMethod(this, _Navigation_instances, matches_fn).call(this, request.navigation)) {
          return;
        }
        __privateSet(this, _request3, request);
        this.emit("request", request);
        const requestEmitter = __privateGet(this, _disposables3).use(new EventEmitter$1(__privateGet(this, _request3)));
        requestEmitter.on("redirect", (request2) => {
          __privateSet(this, _request3, request2);
        });
      });
      const sessionEmitter = __privateGet(this, _disposables3).use(new EventEmitter$1(__privateGet(this, _Navigation_instances, session_get)));
      sessionEmitter.on("browsingContext.navigationStarted", (info) => {
        if (info.context !== __privateGet(this, _browsingContext).id || __privateGet(this, _navigation) !== void 0) {
          return;
        }
        __privateSet(this, _navigation, _a3.from(__privateGet(this, _browsingContext)));
      });
      for (const eventName of [
        "browsingContext.domContentLoaded",
        "browsingContext.load"
      ]) {
        sessionEmitter.on(eventName, (info) => {
          if (info.context !== __privateGet(this, _browsingContext).id || info.navigation === null || !__privateMethod(this, _Navigation_instances, matches_fn).call(this, info.navigation)) {
            return;
          }
          this.dispose();
        });
      }
      for (const [eventName, event] of [
        ["browsingContext.fragmentNavigated", "fragment"],
        ["browsingContext.navigationFailed", "failed"],
        ["browsingContext.navigationAborted", "aborted"]
      ]) {
        sessionEmitter.on(eventName, (info) => {
          if (info.context !== __privateGet(this, _browsingContext).id || // Note we don't check if `navigation` is null since `null` means the
          // fragment navigated.
          !__privateMethod(this, _Navigation_instances, matches_fn).call(this, info.navigation)) {
            return;
          }
          this.emit(event, {
            url: info.url,
            timestamp: new Date(info.timestamp)
          });
          this.dispose();
        });
      }
    }, matches_fn = function(navigation) {
      if (__privateGet(this, _navigation) !== void 0 && !__privateGet(this, _navigation).disposed) {
        return false;
      }
      if (__privateGet(this, _id7) === void 0) {
        __privateSet(this, _id7, navigation);
        return true;
      }
      return __privateGet(this, _id7) === navigation;
    }, session_get = function() {
      return __privateGet(this, _browsingContext).userContext.browser.session;
    }, (() => {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      __esDecorate$d(_a3, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: (obj) => "dispose" in obj, get: (obj) => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
      if (_metadata) Object.defineProperty(_a3, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    })(), _a3;
  })();
  /**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var __runInitializers$c = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i2 = 0; i2 < initializers.length; i2++) {
      value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate$c = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind2 = contextIn.kind, key = kind2 === "getter" ? "get" : kind2 === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function(f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i2])(kind2 === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind2 === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_ = accept(result.get)) descriptor.get = _;
        if (_ = accept(result.set)) descriptor.set = _;
        if (_ = accept(result.init)) initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind2 === "field") initializers.unshift(_);
        else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  var _a$1;
  let Realm = (() => {
    var _reason, _a3;
    let _classSuper = EventEmitter$1;
    let _instanceExtraInitializers = [];
    let _dispose_decorators;
    let _disown_decorators;
    let _callFunction_decorators;
    let _evaluate_decorators;
    let _resolveExecutionContextId_decorators;
    return _a3 = class extends _classSuper {
      constructor(id, origin) {
        super();
        __privateAdd(this, _reason, __runInitializers$c(this, _instanceExtraInitializers));
        __publicField(this, "disposables", new DisposableStack());
        __publicField(this, "id");
        __publicField(this, "origin");
        __publicField(this, "executionContextId");
        this.id = id;
        this.origin = origin;
      }
      get disposed() {
        return __privateGet(this, _reason) !== void 0;
      }
      get target() {
        return { realm: this.id };
      }
      dispose(reason) {
        __privateSet(this, _reason, reason);
        this[disposeSymbol]();
      }
      async disown(handles) {
        await this.session.send("script.disown", {
          target: this.target,
          handles
        });
      }
      async callFunction(functionDeclaration, awaitPromise, options = {}) {
        const { result } = await this.session.send("script.callFunction", {
          functionDeclaration,
          awaitPromise,
          target: this.target,
          ...options
        });
        return result;
      }
      async evaluate(expression, awaitPromise, options = {}) {
        const { result } = await this.session.send("script.evaluate", {
          expression,
          awaitPromise,
          target: this.target,
          ...options
        });
        return result;
      }
      async resolveExecutionContextId() {
        if (!this.executionContextId) {
          const { result } = await this.session.connection.send("goog:cdp.resolveRealm", { realm: this.id });
          this.executionContextId = result.executionContextId;
        }
        return this.executionContextId;
      }
      [(_dispose_decorators = [inertIfDisposed], _disown_decorators = [throwIfDisposed((realm) => {
        return __privateGet(realm, _reason);
      })], _callFunction_decorators = [throwIfDisposed((realm) => {
        return __privateGet(realm, _reason);
      })], _evaluate_decorators = [throwIfDisposed((realm) => {
        return __privateGet(realm, _reason);
      })], _resolveExecutionContextId_decorators = [throwIfDisposed((realm) => {
        return __privateGet(realm, _reason);
      })], disposeSymbol)]() {
        __privateGet(this, _reason) ?? __privateSet(this, _reason, "Realm already destroyed, probably because all associated browsing contexts closed.");
        this.emit("destroyed", { reason: __privateGet(this, _reason) });
        this.disposables.dispose();
        super[disposeSymbol]();
      }
    }, _reason = new WeakMap(), (() => {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      __esDecorate$c(_a3, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: (obj) => "dispose" in obj, get: (obj) => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$c(_a3, null, _disown_decorators, { kind: "method", name: "disown", static: false, private: false, access: { has: (obj) => "disown" in obj, get: (obj) => obj.disown }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$c(_a3, null, _callFunction_decorators, { kind: "method", name: "callFunction", static: false, private: false, access: { has: (obj) => "callFunction" in obj, get: (obj) => obj.callFunction }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$c(_a3, null, _evaluate_decorators, { kind: "method", name: "evaluate", static: false, private: false, access: { has: (obj) => "evaluate" in obj, get: (obj) => obj.evaluate }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$c(_a3, null, _resolveExecutionContextId_decorators, { kind: "method", name: "resolveExecutionContextId", static: false, private: false, access: { has: (obj) => "resolveExecutionContextId" in obj, get: (obj) => obj.resolveExecutionContextId }, metadata: _metadata }, null, _instanceExtraInitializers);
      if (_metadata) Object.defineProperty(_a3, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    })(), _a3;
  })();
  const _WindowRealm = class _WindowRealm extends Realm {
    constructor(context, sandbox) {
      super("", "");
      __privateAdd(this, _WindowRealm_instances);
      __publicField(this, "browsingContext");
      __publicField(this, "sandbox");
      __privateAdd(this, _workers2, /* @__PURE__ */ new Map());
      this.browsingContext = context;
      this.sandbox = sandbox;
    }
    static from(context, sandbox) {
      var _a3;
      const realm = new _WindowRealm(context, sandbox);
      __privateMethod(_a3 = realm, _WindowRealm_instances, initialize_fn2).call(_a3);
      return realm;
    }
    get session() {
      return this.browsingContext.userContext.browser.session;
    }
    get target() {
      return { context: this.browsingContext.id, sandbox: this.sandbox };
    }
  };
  _workers2 = new WeakMap();
  _WindowRealm_instances = new WeakSet();
  initialize_fn2 = function() {
    const browsingContextEmitter = this.disposables.use(new EventEmitter$1(this.browsingContext));
    browsingContextEmitter.on("closed", ({ reason }) => {
      this.dispose(reason);
    });
    const sessionEmitter = this.disposables.use(new EventEmitter$1(this.session));
    sessionEmitter.on("script.realmCreated", (info) => {
      if (info.type !== "window" || info.context !== this.browsingContext.id || info.sandbox !== this.sandbox) {
        return;
      }
      this.id = info.realm;
      this.origin = info.origin;
      this.executionContextId = void 0;
      this.emit("updated", this);
    });
    sessionEmitter.on("script.realmCreated", (info) => {
      if (info.type !== "dedicated-worker") {
        return;
      }
      if (!info.owners.includes(this.id)) {
        return;
      }
      const realm = DedicatedWorkerRealm.from(this, info.realm, info.origin);
      __privateGet(this, _workers2).set(realm.id, realm);
      const realmEmitter = this.disposables.use(new EventEmitter$1(realm));
      realmEmitter.once("destroyed", () => {
        realmEmitter.removeAllListeners();
        __privateGet(this, _workers2).delete(realm.id);
      });
      this.emit("worker", realm);
    });
  };
  let WindowRealm = _WindowRealm;
  class DedicatedWorkerRealm extends Realm {
    constructor(owner, id, origin) {
      super(id, origin);
      __privateAdd(this, _DedicatedWorkerRealm_instances);
      __privateAdd(this, _workers3, /* @__PURE__ */ new Map());
      __publicField(this, "owners");
      this.owners = /* @__PURE__ */ new Set([owner]);
    }
    static from(owner, id, origin) {
      var _a3;
      const realm = new _a$1(owner, id, origin);
      __privateMethod(_a3 = realm, _DedicatedWorkerRealm_instances, initialize_fn3).call(_a3);
      return realm;
    }
    get session() {
      return this.owners.values().next().value.session;
    }
  }
  _workers3 = new WeakMap();
  _DedicatedWorkerRealm_instances = new WeakSet();
  initialize_fn3 = function() {
    const sessionEmitter = this.disposables.use(new EventEmitter$1(this.session));
    sessionEmitter.on("script.realmDestroyed", (info) => {
      if (info.realm !== this.id) {
        return;
      }
      this.dispose("Realm already destroyed.");
    });
    sessionEmitter.on("script.realmCreated", (info) => {
      if (info.type !== "dedicated-worker") {
        return;
      }
      if (!info.owners.includes(this.id)) {
        return;
      }
      const realm = _a$1.from(this, info.realm, info.origin);
      __privateGet(this, _workers3).set(realm.id, realm);
      const realmEmitter = this.disposables.use(new EventEmitter$1(realm));
      realmEmitter.once("destroyed", () => {
        __privateGet(this, _workers3).delete(realm.id);
      });
      this.emit("worker", realm);
    });
  };
  _a$1 = DedicatedWorkerRealm;
  const _SharedWorkerRealm = class _SharedWorkerRealm extends Realm {
    constructor(browser2, id, origin) {
      super(id, origin);
      __privateAdd(this, _SharedWorkerRealm_instances);
      __privateAdd(this, _workers4, /* @__PURE__ */ new Map());
      __publicField(this, "browser");
      this.browser = browser2;
    }
    static from(browser2, id, origin) {
      var _a3;
      const realm = new _SharedWorkerRealm(browser2, id, origin);
      __privateMethod(_a3 = realm, _SharedWorkerRealm_instances, initialize_fn4).call(_a3);
      return realm;
    }
    get session() {
      return this.browser.session;
    }
  };
  _workers4 = new WeakMap();
  _SharedWorkerRealm_instances = new WeakSet();
  initialize_fn4 = function() {
    const sessionEmitter = this.disposables.use(new EventEmitter$1(this.session));
    sessionEmitter.on("script.realmDestroyed", (info) => {
      if (info.realm !== this.id) {
        return;
      }
      this.dispose("Realm already destroyed.");
    });
    sessionEmitter.on("script.realmCreated", (info) => {
      if (info.type !== "dedicated-worker") {
        return;
      }
      if (!info.owners.includes(this.id)) {
        return;
      }
      const realm = DedicatedWorkerRealm.from(this, info.realm, info.origin);
      __privateGet(this, _workers4).set(realm.id, realm);
      const realmEmitter = this.disposables.use(new EventEmitter$1(realm));
      realmEmitter.once("destroyed", () => {
        __privateGet(this, _workers4).delete(realm.id);
      });
      this.emit("worker", realm);
    });
  };
  let SharedWorkerRealm = _SharedWorkerRealm;
  /**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var __runInitializers$b = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i2 = 0; i2 < initializers.length; i2++) {
      value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate$b = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind2 = contextIn.kind, key = kind2 === "getter" ? "get" : kind2 === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function(f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i2])(kind2 === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind2 === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_ = accept(result.get)) descriptor.get = _;
        if (_ = accept(result.set)) descriptor.set = _;
        if (_ = accept(result.init)) initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind2 === "field") initializers.unshift(_);
        else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  let Request$1 = (() => {
    var _error2, _redirect, _response2, _browsingContext, _disposables3, _event, _Request_instances, initialize_fn8, session_get, _a3;
    let _classSuper = EventEmitter$1;
    let _instanceExtraInitializers = [];
    let _dispose_decorators;
    return _a3 = class extends _classSuper {
      constructor(browsingContext, event) {
        super();
        __privateAdd(this, _Request_instances);
        __privateAdd(this, _error2, __runInitializers$b(this, _instanceExtraInitializers));
        __privateAdd(this, _redirect);
        __privateAdd(this, _response2);
        __privateAdd(this, _browsingContext);
        __privateAdd(this, _disposables3, new DisposableStack());
        __privateAdd(this, _event);
        __privateSet(this, _browsingContext, browsingContext);
        __privateSet(this, _event, event);
      }
      static from(browsingContext, event) {
        var _a4;
        const request = new _a3(browsingContext, event);
        __privateMethod(_a4 = request, _Request_instances, initialize_fn8).call(_a4);
        return request;
      }
      get disposed() {
        return __privateGet(this, _disposables3).disposed;
      }
      get error() {
        return __privateGet(this, _error2);
      }
      get headers() {
        return __privateGet(this, _event).request.headers;
      }
      get id() {
        return __privateGet(this, _event).request.request;
      }
      get initiator() {
        return __privateGet(this, _event).initiator;
      }
      get method() {
        return __privateGet(this, _event).request.method;
      }
      get navigation() {
        return __privateGet(this, _event).navigation ?? void 0;
      }
      get redirect() {
        return __privateGet(this, _redirect);
      }
      get lastRedirect() {
        let redirect = __privateGet(this, _redirect);
        while (redirect) {
          if (redirect && !__privateGet(redirect, _redirect)) {
            return redirect;
          }
          redirect = __privateGet(redirect, _redirect);
        }
        return redirect;
      }
      get response() {
        return __privateGet(this, _response2);
      }
      get url() {
        return __privateGet(this, _event).request.url;
      }
      get isBlocked() {
        return __privateGet(this, _event).isBlocked;
      }
      get resourceType() {
        return __privateGet(this, _event).request["goog:resourceType"] ?? void 0;
      }
      get postData() {
        return __privateGet(this, _event).request["goog:postData"] ?? void 0;
      }
      get hasPostData() {
        return __privateGet(this, _event).request["goog:hasPostData"] ?? false;
      }
      async continueRequest({ url, method, headers, cookies, body }) {
        await __privateGet(this, _Request_instances, session_get).send("network.continueRequest", {
          request: this.id,
          url,
          method,
          headers,
          body,
          cookies
        });
      }
      async failRequest() {
        await __privateGet(this, _Request_instances, session_get).send("network.failRequest", {
          request: this.id
        });
      }
      async provideResponse({ statusCode, reasonPhrase, headers, body }) {
        await __privateGet(this, _Request_instances, session_get).send("network.provideResponse", {
          request: this.id,
          statusCode,
          reasonPhrase,
          headers,
          body
        });
      }
      async continueWithAuth(parameters) {
        if (parameters.action === "provideCredentials") {
          await __privateGet(this, _Request_instances, session_get).send("network.continueWithAuth", {
            request: this.id,
            action: parameters.action,
            credentials: parameters.credentials
          });
        } else {
          await __privateGet(this, _Request_instances, session_get).send("network.continueWithAuth", {
            request: this.id,
            action: parameters.action
          });
        }
      }
      dispose() {
        this[disposeSymbol]();
      }
      [(_dispose_decorators = [inertIfDisposed], disposeSymbol)]() {
        __privateGet(this, _disposables3).dispose();
        super[disposeSymbol]();
      }
      timing() {
        return __privateGet(this, _event).request.timings;
      }
    }, _error2 = new WeakMap(), _redirect = new WeakMap(), _response2 = new WeakMap(), _browsingContext = new WeakMap(), _disposables3 = new WeakMap(), _event = new WeakMap(), _Request_instances = new WeakSet(), initialize_fn8 = function() {
      const browsingContextEmitter = __privateGet(this, _disposables3).use(new EventEmitter$1(__privateGet(this, _browsingContext)));
      browsingContextEmitter.once("closed", ({ reason }) => {
        __privateSet(this, _error2, reason);
        this.emit("error", __privateGet(this, _error2));
        this.dispose();
      });
      const sessionEmitter = __privateGet(this, _disposables3).use(new EventEmitter$1(__privateGet(this, _Request_instances, session_get)));
      sessionEmitter.on("network.beforeRequestSent", (event) => {
        if (event.context !== __privateGet(this, _browsingContext).id || event.request.request !== this.id || event.redirectCount !== __privateGet(this, _event).redirectCount + 1) {
          return;
        }
        __privateSet(this, _redirect, _a3.from(__privateGet(this, _browsingContext), event));
        this.emit("redirect", __privateGet(this, _redirect));
        this.dispose();
      });
      sessionEmitter.on("network.authRequired", (event) => {
        if (event.context !== __privateGet(this, _browsingContext).id || event.request.request !== this.id || // Don't try to authenticate for events that are not blocked
        !event.isBlocked) {
          return;
        }
        this.emit("authenticate", void 0);
      });
      sessionEmitter.on("network.fetchError", (event) => {
        if (event.context !== __privateGet(this, _browsingContext).id || event.request.request !== this.id || __privateGet(this, _event).redirectCount !== event.redirectCount) {
          return;
        }
        __privateSet(this, _error2, event.errorText);
        this.emit("error", __privateGet(this, _error2));
        this.dispose();
      });
      sessionEmitter.on("network.responseCompleted", (event) => {
        if (event.context !== __privateGet(this, _browsingContext).id || event.request.request !== this.id || __privateGet(this, _event).redirectCount !== event.redirectCount) {
          return;
        }
        __privateSet(this, _response2, event.response);
        __privateGet(this, _event).request.timings = event.request.timings;
        this.emit("success", __privateGet(this, _response2));
        if (__privateGet(this, _response2).status >= 300 && __privateGet(this, _response2).status < 400) {
          return;
        }
        this.dispose();
      });
    }, session_get = function() {
      return __privateGet(this, _browsingContext).userContext.browser.session;
    }, (() => {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      __esDecorate$b(_a3, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: (obj) => "dispose" in obj, get: (obj) => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
      if (_metadata) Object.defineProperty(_a3, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    })(), _a3;
  })();
  /**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var __runInitializers$a = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i2 = 0; i2 < initializers.length; i2++) {
      value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate$a = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind2 = contextIn.kind, key = kind2 === "getter" ? "get" : kind2 === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function(f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i2])(kind2 === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind2 === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_ = accept(result.get)) descriptor.get = _;
        if (_ = accept(result.set)) descriptor.set = _;
        if (_ = accept(result.init)) initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind2 === "field") initializers.unshift(_);
        else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  let UserPrompt = (() => {
    var _reason, _result2, _disposables3, _UserPrompt_instances, initialize_fn8, session_get, _a3;
    let _classSuper = EventEmitter$1;
    let _instanceExtraInitializers = [];
    let _dispose_decorators;
    let _handle_decorators;
    return _a3 = class extends _classSuper {
      constructor(context, info) {
        super();
        __privateAdd(this, _UserPrompt_instances);
        __privateAdd(this, _reason, __runInitializers$a(this, _instanceExtraInitializers));
        __privateAdd(this, _result2);
        __privateAdd(this, _disposables3, new DisposableStack());
        __publicField(this, "browsingContext");
        __publicField(this, "info");
        this.browsingContext = context;
        this.info = info;
      }
      static from(browsingContext, info) {
        var _a4;
        const userPrompt = new _a3(browsingContext, info);
        __privateMethod(_a4 = userPrompt, _UserPrompt_instances, initialize_fn8).call(_a4);
        return userPrompt;
      }
      get closed() {
        return __privateGet(this, _reason) !== void 0;
      }
      get disposed() {
        return this.closed;
      }
      get handled() {
        if (this.info.handler === "accept" || this.info.handler === "dismiss") {
          return true;
        }
        return __privateGet(this, _result2) !== void 0;
      }
      get result() {
        return __privateGet(this, _result2);
      }
      dispose(reason) {
        __privateSet(this, _reason, reason);
        this[disposeSymbol]();
      }
      async handle(options = {}) {
        await __privateGet(this, _UserPrompt_instances, session_get).send("browsingContext.handleUserPrompt", {
          ...options,
          context: this.info.context
        });
        return __privateGet(this, _result2);
      }
      [(_dispose_decorators = [inertIfDisposed], _handle_decorators = [throwIfDisposed((prompt) => {
        return __privateGet(prompt, _reason);
      })], disposeSymbol)]() {
        __privateGet(this, _reason) ?? __privateSet(this, _reason, "User prompt already closed, probably because the associated browsing context was destroyed.");
        this.emit("closed", { reason: __privateGet(this, _reason) });
        __privateGet(this, _disposables3).dispose();
        super[disposeSymbol]();
      }
    }, _reason = new WeakMap(), _result2 = new WeakMap(), _disposables3 = new WeakMap(), _UserPrompt_instances = new WeakSet(), initialize_fn8 = function() {
      const browserContextEmitter = __privateGet(this, _disposables3).use(new EventEmitter$1(this.browsingContext));
      browserContextEmitter.once("closed", ({ reason }) => {
        this.dispose(`User prompt already closed: ${reason}`);
      });
      const sessionEmitter = __privateGet(this, _disposables3).use(new EventEmitter$1(__privateGet(this, _UserPrompt_instances, session_get)));
      sessionEmitter.on("browsingContext.userPromptClosed", (parameters) => {
        if (parameters.context !== this.browsingContext.id) {
          return;
        }
        __privateSet(this, _result2, parameters);
        this.emit("handled", parameters);
        this.dispose("User prompt already handled.");
      });
    }, session_get = function() {
      return this.browsingContext.userContext.browser.session;
    }, (() => {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      __esDecorate$a(_a3, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: (obj) => "dispose" in obj, get: (obj) => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$a(_a3, null, _handle_decorators, { kind: "method", name: "handle", static: false, private: false, access: { has: (obj) => "handle" in obj, get: (obj) => obj.handle }, metadata: _metadata }, null, _instanceExtraInitializers);
      if (_metadata) Object.defineProperty(_a3, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    })(), _a3;
  })();
  /**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var __runInitializers$9 = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i2 = 0; i2 < initializers.length; i2++) {
      value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate$9 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind2 = contextIn.kind, key = kind2 === "getter" ? "get" : kind2 === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function(f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i2])(kind2 === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind2 === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_ = accept(result.get)) descriptor.get = _;
        if (_ = accept(result.set)) descriptor.set = _;
        if (_ = accept(result.init)) initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind2 === "field") initializers.unshift(_);
        else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  let BrowsingContext = (() => {
    var _navigation, _reason, _url5, _children, _disposables3, _realms, _requests, _BrowsingContext_instances, initialize_fn8, session_get, createWindowRealm_fn, _a3;
    let _classSuper = EventEmitter$1;
    let _instanceExtraInitializers = [];
    let _dispose_decorators;
    let _activate_decorators;
    let _captureScreenshot_decorators;
    let _close_decorators;
    let _traverseHistory_decorators;
    let _navigate_decorators;
    let _reload_decorators;
    let _setCacheBehavior_decorators;
    let _print_decorators;
    let _handleUserPrompt_decorators;
    let _setViewport_decorators;
    let _performActions_decorators;
    let _releaseActions_decorators;
    let _createWindowRealm_decorators;
    let _addPreloadScript_decorators;
    let _addIntercept_decorators;
    let _removePreloadScript_decorators;
    let _getCookies_decorators;
    let _setCookie_decorators;
    let _setFiles_decorators;
    let _subscribe_decorators;
    let _addInterception_decorators;
    let _deleteCookie_decorators;
    let _locateNodes_decorators;
    return _a3 = class extends _classSuper {
      constructor(context, parent, id, url, originalOpener) {
        super();
        __privateAdd(this, _BrowsingContext_instances);
        __privateAdd(this, _navigation, __runInitializers$9(this, _instanceExtraInitializers));
        __privateAdd(this, _reason);
        __privateAdd(this, _url5);
        __privateAdd(this, _children, /* @__PURE__ */ new Map());
        __privateAdd(this, _disposables3, new DisposableStack());
        __privateAdd(this, _realms, /* @__PURE__ */ new Map());
        __privateAdd(this, _requests, /* @__PURE__ */ new Map());
        __publicField(this, "defaultRealm");
        __publicField(this, "id");
        __publicField(this, "parent");
        __publicField(this, "userContext");
        __publicField(this, "originalOpener");
        __privateSet(this, _url5, url);
        this.id = id;
        this.parent = parent;
        this.userContext = context;
        this.originalOpener = originalOpener;
        this.defaultRealm = __privateMethod(this, _BrowsingContext_instances, createWindowRealm_fn).call(this);
      }
      static from(userContext, parent, id, url, originalOpener) {
        var _a4;
        const browsingContext = new _a3(userContext, parent, id, url, originalOpener);
        __privateMethod(_a4 = browsingContext, _BrowsingContext_instances, initialize_fn8).call(_a4);
        return browsingContext;
      }
      get children() {
        return __privateGet(this, _children).values();
      }
      get closed() {
        return __privateGet(this, _reason) !== void 0;
      }
      get disposed() {
        return this.closed;
      }
      get realms() {
        const self2 = this;
        return function* () {
          yield self2.defaultRealm;
          yield* __privateGet(self2, _realms).values();
        }();
      }
      get top() {
        let context = this;
        for (let { parent } = context; parent; { parent } = context) {
          context = parent;
        }
        return context;
      }
      get url() {
        return __privateGet(this, _url5);
      }
      dispose(reason) {
        __privateSet(this, _reason, reason);
        for (const context of __privateGet(this, _children).values()) {
          context.dispose("Parent browsing context was disposed");
        }
        this[disposeSymbol]();
      }
      async activate() {
        await __privateGet(this, _BrowsingContext_instances, session_get).send("browsingContext.activate", {
          context: this.id
        });
      }
      async captureScreenshot(options = {}) {
        const { result: { data } } = await __privateGet(this, _BrowsingContext_instances, session_get).send("browsingContext.captureScreenshot", {
          context: this.id,
          ...options
        });
        return data;
      }
      async close(promptUnload) {
        await Promise.all([...__privateGet(this, _children).values()].map(async (child) => {
          await child.close(promptUnload);
        }));
        await __privateGet(this, _BrowsingContext_instances, session_get).send("browsingContext.close", {
          context: this.id,
          promptUnload
        });
      }
      async traverseHistory(delta) {
        await __privateGet(this, _BrowsingContext_instances, session_get).send("browsingContext.traverseHistory", {
          context: this.id,
          delta
        });
      }
      async navigate(url, wait) {
        await __privateGet(this, _BrowsingContext_instances, session_get).send("browsingContext.navigate", {
          context: this.id,
          url,
          wait
        });
      }
      async reload(options = {}) {
        await __privateGet(this, _BrowsingContext_instances, session_get).send("browsingContext.reload", {
          context: this.id,
          ...options
        });
      }
      async setCacheBehavior(cacheBehavior) {
        await __privateGet(this, _BrowsingContext_instances, session_get).send("network.setCacheBehavior", {
          contexts: [this.id],
          cacheBehavior
        });
      }
      async print(options = {}) {
        const { result: { data } } = await __privateGet(this, _BrowsingContext_instances, session_get).send("browsingContext.print", {
          context: this.id,
          ...options
        });
        return data;
      }
      async handleUserPrompt(options = {}) {
        await __privateGet(this, _BrowsingContext_instances, session_get).send("browsingContext.handleUserPrompt", {
          context: this.id,
          ...options
        });
      }
      async setViewport(options = {}) {
        await __privateGet(this, _BrowsingContext_instances, session_get).send("browsingContext.setViewport", {
          context: this.id,
          ...options
        });
      }
      async performActions(actions) {
        await __privateGet(this, _BrowsingContext_instances, session_get).send("input.performActions", {
          context: this.id,
          actions
        });
      }
      async releaseActions() {
        await __privateGet(this, _BrowsingContext_instances, session_get).send("input.releaseActions", {
          context: this.id
        });
      }
      createWindowRealm(sandbox) {
        return __privateMethod(this, _BrowsingContext_instances, createWindowRealm_fn).call(this, sandbox);
      }
      async addPreloadScript(functionDeclaration, options = {}) {
        return await this.userContext.browser.addPreloadScript(functionDeclaration, {
          ...options,
          contexts: [this]
        });
      }
      async addIntercept(options) {
        const { result: { intercept } } = await this.userContext.browser.session.send("network.addIntercept", {
          ...options,
          contexts: [this.id]
        });
        return intercept;
      }
      async removePreloadScript(script) {
        await this.userContext.browser.removePreloadScript(script);
      }
      async getCookies(options = {}) {
        const { result: { cookies } } = await __privateGet(this, _BrowsingContext_instances, session_get).send("storage.getCookies", {
          ...options,
          partition: {
            type: "context",
            context: this.id
          }
        });
        return cookies;
      }
      async setCookie(cookie) {
        await __privateGet(this, _BrowsingContext_instances, session_get).send("storage.setCookie", {
          cookie,
          partition: {
            type: "context",
            context: this.id
          }
        });
      }
      async setFiles(element, files) {
        await __privateGet(this, _BrowsingContext_instances, session_get).send("input.setFiles", {
          context: this.id,
          element,
          files
        });
      }
      async subscribe(events2) {
        await __privateGet(this, _BrowsingContext_instances, session_get).subscribe(events2, [this.id]);
      }
      async addInterception(events2) {
        await __privateGet(this, _BrowsingContext_instances, session_get).subscribe(events2, [this.id]);
      }
      [(_dispose_decorators = [inertIfDisposed], _activate_decorators = [throwIfDisposed((context) => {
        return __privateGet(context, _reason);
      })], _captureScreenshot_decorators = [throwIfDisposed((context) => {
        return __privateGet(context, _reason);
      })], _close_decorators = [throwIfDisposed((context) => {
        return __privateGet(context, _reason);
      })], _traverseHistory_decorators = [throwIfDisposed((context) => {
        return __privateGet(context, _reason);
      })], _navigate_decorators = [throwIfDisposed((context) => {
        return __privateGet(context, _reason);
      })], _reload_decorators = [throwIfDisposed((context) => {
        return __privateGet(context, _reason);
      })], _setCacheBehavior_decorators = [throwIfDisposed((context) => {
        return __privateGet(context, _reason);
      })], _print_decorators = [throwIfDisposed((context) => {
        return __privateGet(context, _reason);
      })], _handleUserPrompt_decorators = [throwIfDisposed((context) => {
        return __privateGet(context, _reason);
      })], _setViewport_decorators = [throwIfDisposed((context) => {
        return __privateGet(context, _reason);
      })], _performActions_decorators = [throwIfDisposed((context) => {
        return __privateGet(context, _reason);
      })], _releaseActions_decorators = [throwIfDisposed((context) => {
        return __privateGet(context, _reason);
      })], _createWindowRealm_decorators = [throwIfDisposed((context) => {
        return __privateGet(context, _reason);
      })], _addPreloadScript_decorators = [throwIfDisposed((context) => {
        return __privateGet(context, _reason);
      })], _addIntercept_decorators = [throwIfDisposed((context) => {
        return __privateGet(context, _reason);
      })], _removePreloadScript_decorators = [throwIfDisposed((context) => {
        return __privateGet(context, _reason);
      })], _getCookies_decorators = [throwIfDisposed((context) => {
        return __privateGet(context, _reason);
      })], _setCookie_decorators = [throwIfDisposed((context) => {
        return __privateGet(context, _reason);
      })], _setFiles_decorators = [throwIfDisposed((context) => {
        return __privateGet(context, _reason);
      })], _subscribe_decorators = [throwIfDisposed((context) => {
        return __privateGet(context, _reason);
      })], _addInterception_decorators = [throwIfDisposed((context) => {
        return __privateGet(context, _reason);
      })], disposeSymbol)]() {
        __privateGet(this, _reason) ?? __privateSet(this, _reason, "Browsing context already closed, probably because the user context closed.");
        this.emit("closed", { reason: __privateGet(this, _reason) });
        __privateGet(this, _disposables3).dispose();
        super[disposeSymbol]();
      }
      async deleteCookie(...cookieFilters) {
        await Promise.all(cookieFilters.map(async (filter2) => {
          await __privateGet(this, _BrowsingContext_instances, session_get).send("storage.deleteCookies", {
            filter: filter2,
            partition: {
              type: "context",
              context: this.id
            }
          });
        }));
      }
      async locateNodes(locator, startNodes) {
        const result = await __privateGet(this, _BrowsingContext_instances, session_get).send("browsingContext.locateNodes", {
          context: this.id,
          locator,
          startNodes: startNodes.length ? startNodes : void 0
        });
        return result.result.nodes;
      }
    }, _navigation = new WeakMap(), _reason = new WeakMap(), _url5 = new WeakMap(), _children = new WeakMap(), _disposables3 = new WeakMap(), _realms = new WeakMap(), _requests = new WeakMap(), _BrowsingContext_instances = new WeakSet(), initialize_fn8 = function() {
      const userContextEmitter = __privateGet(this, _disposables3).use(new EventEmitter$1(this.userContext));
      userContextEmitter.once("closed", ({ reason }) => {
        this.dispose(`Browsing context already closed: ${reason}`);
      });
      const sessionEmitter = __privateGet(this, _disposables3).use(new EventEmitter$1(__privateGet(this, _BrowsingContext_instances, session_get)));
      sessionEmitter.on("browsingContext.contextCreated", (info) => {
        if (info.parent !== this.id) {
          return;
        }
        const browsingContext = _a3.from(this.userContext, this, info.context, info.url, info.originalOpener);
        __privateGet(this, _children).set(info.context, browsingContext);
        const browsingContextEmitter = __privateGet(this, _disposables3).use(new EventEmitter$1(browsingContext));
        browsingContextEmitter.once("closed", () => {
          browsingContextEmitter.removeAllListeners();
          __privateGet(this, _children).delete(browsingContext.id);
        });
        this.emit("browsingcontext", { browsingContext });
      });
      sessionEmitter.on("browsingContext.contextDestroyed", (info) => {
        if (info.context !== this.id) {
          return;
        }
        this.dispose("Browsing context already closed.");
      });
      sessionEmitter.on("browsingContext.historyUpdated", (info) => {
        if (info.context !== this.id) {
          return;
        }
        __privateSet(this, _url5, info.url);
        this.emit("historyUpdated", void 0);
      });
      sessionEmitter.on("browsingContext.domContentLoaded", (info) => {
        if (info.context !== this.id) {
          return;
        }
        __privateSet(this, _url5, info.url);
        this.emit("DOMContentLoaded", void 0);
      });
      sessionEmitter.on("browsingContext.load", (info) => {
        if (info.context !== this.id) {
          return;
        }
        __privateSet(this, _url5, info.url);
        this.emit("load", void 0);
      });
      sessionEmitter.on("browsingContext.navigationStarted", (info) => {
        if (info.context !== this.id) {
          return;
        }
        for (const [id, request] of __privateGet(this, _requests)) {
          if (request.disposed) {
            __privateGet(this, _requests).delete(id);
          }
        }
        if (__privateGet(this, _navigation) !== void 0 && !__privateGet(this, _navigation).disposed) {
          return;
        }
        __privateSet(this, _navigation, Navigation.from(this));
        const navigationEmitter = __privateGet(this, _disposables3).use(new EventEmitter$1(__privateGet(this, _navigation)));
        for (const eventName of ["fragment", "failed", "aborted"]) {
          navigationEmitter.once(eventName, ({ url }) => {
            navigationEmitter[disposeSymbol]();
            __privateSet(this, _url5, url);
          });
        }
        this.emit("navigation", { navigation: __privateGet(this, _navigation) });
      });
      sessionEmitter.on("network.beforeRequestSent", (event) => {
        if (event.context !== this.id) {
          return;
        }
        if (__privateGet(this, _requests).has(event.request.request)) {
          return;
        }
        const request = Request$1.from(this, event);
        __privateGet(this, _requests).set(request.id, request);
        this.emit("request", { request });
      });
      sessionEmitter.on("log.entryAdded", (entry) => {
        if (entry.source.context !== this.id) {
          return;
        }
        this.emit("log", { entry });
      });
      sessionEmitter.on("browsingContext.userPromptOpened", (info) => {
        if (info.context !== this.id) {
          return;
        }
        const userPrompt = UserPrompt.from(this, info);
        this.emit("userprompt", { userPrompt });
      });
    }, session_get = function() {
      return this.userContext.browser.session;
    }, createWindowRealm_fn = function(sandbox) {
      const realm = WindowRealm.from(this, sandbox);
      realm.on("worker", (realm2) => {
        this.emit("worker", { realm: realm2 });
      });
      return realm;
    }, (() => {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      _deleteCookie_decorators = [throwIfDisposed((context) => {
        return __privateGet(context, _reason);
      })];
      _locateNodes_decorators = [throwIfDisposed((context) => {
        return __privateGet(context, _reason);
      })];
      __esDecorate$9(_a3, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: (obj) => "dispose" in obj, get: (obj) => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$9(_a3, null, _activate_decorators, { kind: "method", name: "activate", static: false, private: false, access: { has: (obj) => "activate" in obj, get: (obj) => obj.activate }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$9(_a3, null, _captureScreenshot_decorators, { kind: "method", name: "captureScreenshot", static: false, private: false, access: { has: (obj) => "captureScreenshot" in obj, get: (obj) => obj.captureScreenshot }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$9(_a3, null, _close_decorators, { kind: "method", name: "close", static: false, private: false, access: { has: (obj) => "close" in obj, get: (obj) => obj.close }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$9(_a3, null, _traverseHistory_decorators, { kind: "method", name: "traverseHistory", static: false, private: false, access: { has: (obj) => "traverseHistory" in obj, get: (obj) => obj.traverseHistory }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$9(_a3, null, _navigate_decorators, { kind: "method", name: "navigate", static: false, private: false, access: { has: (obj) => "navigate" in obj, get: (obj) => obj.navigate }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$9(_a3, null, _reload_decorators, { kind: "method", name: "reload", static: false, private: false, access: { has: (obj) => "reload" in obj, get: (obj) => obj.reload }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$9(_a3, null, _setCacheBehavior_decorators, { kind: "method", name: "setCacheBehavior", static: false, private: false, access: { has: (obj) => "setCacheBehavior" in obj, get: (obj) => obj.setCacheBehavior }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$9(_a3, null, _print_decorators, { kind: "method", name: "print", static: false, private: false, access: { has: (obj) => "print" in obj, get: (obj) => obj.print }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$9(_a3, null, _handleUserPrompt_decorators, { kind: "method", name: "handleUserPrompt", static: false, private: false, access: { has: (obj) => "handleUserPrompt" in obj, get: (obj) => obj.handleUserPrompt }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$9(_a3, null, _setViewport_decorators, { kind: "method", name: "setViewport", static: false, private: false, access: { has: (obj) => "setViewport" in obj, get: (obj) => obj.setViewport }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$9(_a3, null, _performActions_decorators, { kind: "method", name: "performActions", static: false, private: false, access: { has: (obj) => "performActions" in obj, get: (obj) => obj.performActions }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$9(_a3, null, _releaseActions_decorators, { kind: "method", name: "releaseActions", static: false, private: false, access: { has: (obj) => "releaseActions" in obj, get: (obj) => obj.releaseActions }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$9(_a3, null, _createWindowRealm_decorators, { kind: "method", name: "createWindowRealm", static: false, private: false, access: { has: (obj) => "createWindowRealm" in obj, get: (obj) => obj.createWindowRealm }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$9(_a3, null, _addPreloadScript_decorators, { kind: "method", name: "addPreloadScript", static: false, private: false, access: { has: (obj) => "addPreloadScript" in obj, get: (obj) => obj.addPreloadScript }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$9(_a3, null, _addIntercept_decorators, { kind: "method", name: "addIntercept", static: false, private: false, access: { has: (obj) => "addIntercept" in obj, get: (obj) => obj.addIntercept }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$9(_a3, null, _removePreloadScript_decorators, { kind: "method", name: "removePreloadScript", static: false, private: false, access: { has: (obj) => "removePreloadScript" in obj, get: (obj) => obj.removePreloadScript }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$9(_a3, null, _getCookies_decorators, { kind: "method", name: "getCookies", static: false, private: false, access: { has: (obj) => "getCookies" in obj, get: (obj) => obj.getCookies }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$9(_a3, null, _setCookie_decorators, { kind: "method", name: "setCookie", static: false, private: false, access: { has: (obj) => "setCookie" in obj, get: (obj) => obj.setCookie }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$9(_a3, null, _setFiles_decorators, { kind: "method", name: "setFiles", static: false, private: false, access: { has: (obj) => "setFiles" in obj, get: (obj) => obj.setFiles }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$9(_a3, null, _subscribe_decorators, { kind: "method", name: "subscribe", static: false, private: false, access: { has: (obj) => "subscribe" in obj, get: (obj) => obj.subscribe }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$9(_a3, null, _addInterception_decorators, { kind: "method", name: "addInterception", static: false, private: false, access: { has: (obj) => "addInterception" in obj, get: (obj) => obj.addInterception }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$9(_a3, null, _deleteCookie_decorators, { kind: "method", name: "deleteCookie", static: false, private: false, access: { has: (obj) => "deleteCookie" in obj, get: (obj) => obj.deleteCookie }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$9(_a3, null, _locateNodes_decorators, { kind: "method", name: "locateNodes", static: false, private: false, access: { has: (obj) => "locateNodes" in obj, get: (obj) => obj.locateNodes }, metadata: _metadata }, null, _instanceExtraInitializers);
      if (_metadata) Object.defineProperty(_a3, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    })(), _a3;
  })();
  /**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var __runInitializers$8 = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i2 = 0; i2 < initializers.length; i2++) {
      value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate$8 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind2 = contextIn.kind, key = kind2 === "getter" ? "get" : kind2 === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function(f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i2])(kind2 === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind2 === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_ = accept(result.get)) descriptor.get = _;
        if (_ = accept(result.set)) descriptor.set = _;
        if (_ = accept(result.init)) initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind2 === "field") initializers.unshift(_);
        else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  let UserContext = (() => {
    var _a3, _reason, _browsingContexts, _disposables3, _id7, _UserContext_instances, initialize_fn8, session_get;
    let _classSuper = EventEmitter$1;
    let _instanceExtraInitializers = [];
    let _dispose_decorators;
    let _createBrowsingContext_decorators;
    let _remove_decorators;
    let _getCookies_decorators;
    let _setCookie_decorators;
    let _setPermissions_decorators;
    return _a3 = class extends _classSuper {
      constructor(browser2, id) {
        super();
        __privateAdd(this, _UserContext_instances);
        __privateAdd(this, _reason, __runInitializers$8(this, _instanceExtraInitializers));
        // Note these are only top-level contexts.
        __privateAdd(this, _browsingContexts, /* @__PURE__ */ new Map());
        __privateAdd(this, _disposables3, new DisposableStack());
        __privateAdd(this, _id7);
        __publicField(this, "browser");
        __privateSet(this, _id7, id);
        this.browser = browser2;
      }
      static create(browser2, id) {
        var _a4;
        const context = new _a3(browser2, id);
        __privateMethod(_a4 = context, _UserContext_instances, initialize_fn8).call(_a4);
        return context;
      }
      get browsingContexts() {
        return __privateGet(this, _browsingContexts).values();
      }
      get closed() {
        return __privateGet(this, _reason) !== void 0;
      }
      get disposed() {
        return this.closed;
      }
      get id() {
        return __privateGet(this, _id7);
      }
      dispose(reason) {
        __privateSet(this, _reason, reason);
        this[disposeSymbol]();
      }
      async createBrowsingContext(type, options = {}) {
        var _a4;
        const { result: { context: contextId } } = await __privateGet(this, _UserContext_instances, session_get).send("browsingContext.create", {
          type,
          ...options,
          referenceContext: (_a4 = options.referenceContext) == null ? void 0 : _a4.id,
          userContext: __privateGet(this, _id7)
        });
        const browsingContext = __privateGet(this, _browsingContexts).get(contextId);
        assert$1(browsingContext, "The WebDriver BiDi implementation is failing to create a browsing context correctly.");
        return browsingContext;
      }
      async remove() {
        try {
          await __privateGet(this, _UserContext_instances, session_get).send("browser.removeUserContext", {
            userContext: __privateGet(this, _id7)
          });
        } finally {
          this.dispose("User context already closed.");
        }
      }
      async getCookies(options = {}, sourceOrigin = void 0) {
        const { result: { cookies } } = await __privateGet(this, _UserContext_instances, session_get).send("storage.getCookies", {
          ...options,
          partition: {
            type: "storageKey",
            userContext: __privateGet(this, _id7),
            sourceOrigin
          }
        });
        return cookies;
      }
      async setCookie(cookie, sourceOrigin) {
        await __privateGet(this, _UserContext_instances, session_get).send("storage.setCookie", {
          cookie,
          partition: {
            type: "storageKey",
            sourceOrigin,
            userContext: this.id
          }
        });
      }
      async setPermissions(origin, descriptor, state) {
        await __privateGet(this, _UserContext_instances, session_get).send("permissions.setPermission", {
          origin,
          descriptor,
          state,
          userContext: __privateGet(this, _id7)
        });
      }
      [(_dispose_decorators = [inertIfDisposed], _createBrowsingContext_decorators = [throwIfDisposed((context) => {
        return __privateGet(context, _reason);
      })], _remove_decorators = [throwIfDisposed((context) => {
        return __privateGet(context, _reason);
      })], _getCookies_decorators = [throwIfDisposed((context) => {
        return __privateGet(context, _reason);
      })], _setCookie_decorators = [throwIfDisposed((context) => {
        return __privateGet(context, _reason);
      })], _setPermissions_decorators = [throwIfDisposed((context) => {
        return __privateGet(context, _reason);
      })], disposeSymbol)]() {
        __privateGet(this, _reason) ?? __privateSet(this, _reason, "User context already closed, probably because the browser disconnected/closed.");
        this.emit("closed", { reason: __privateGet(this, _reason) });
        __privateGet(this, _disposables3).dispose();
        super[disposeSymbol]();
      }
    }, _reason = new WeakMap(), _browsingContexts = new WeakMap(), _disposables3 = new WeakMap(), _id7 = new WeakMap(), _UserContext_instances = new WeakSet(), initialize_fn8 = function() {
      const browserEmitter = __privateGet(this, _disposables3).use(new EventEmitter$1(this.browser));
      browserEmitter.once("closed", ({ reason }) => {
        this.dispose(`User context was closed: ${reason}`);
      });
      browserEmitter.once("disconnected", ({ reason }) => {
        this.dispose(`User context was closed: ${reason}`);
      });
      const sessionEmitter = __privateGet(this, _disposables3).use(new EventEmitter$1(__privateGet(this, _UserContext_instances, session_get)));
      sessionEmitter.on("browsingContext.contextCreated", (info) => {
        if (info.parent) {
          return;
        }
        if (info.userContext !== __privateGet(this, _id7)) {
          return;
        }
        const browsingContext = BrowsingContext.from(this, void 0, info.context, info.url, info.originalOpener);
        __privateGet(this, _browsingContexts).set(browsingContext.id, browsingContext);
        const browsingContextEmitter = __privateGet(this, _disposables3).use(new EventEmitter$1(browsingContext));
        browsingContextEmitter.on("closed", () => {
          browsingContextEmitter.removeAllListeners();
          __privateGet(this, _browsingContexts).delete(browsingContext.id);
        });
        this.emit("browsingcontext", { browsingContext });
      });
    }, session_get = function() {
      return this.browser.session;
    }, (() => {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      __esDecorate$8(_a3, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: (obj) => "dispose" in obj, get: (obj) => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$8(_a3, null, _createBrowsingContext_decorators, { kind: "method", name: "createBrowsingContext", static: false, private: false, access: { has: (obj) => "createBrowsingContext" in obj, get: (obj) => obj.createBrowsingContext }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$8(_a3, null, _remove_decorators, { kind: "method", name: "remove", static: false, private: false, access: { has: (obj) => "remove" in obj, get: (obj) => obj.remove }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$8(_a3, null, _getCookies_decorators, { kind: "method", name: "getCookies", static: false, private: false, access: { has: (obj) => "getCookies" in obj, get: (obj) => obj.getCookies }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$8(_a3, null, _setCookie_decorators, { kind: "method", name: "setCookie", static: false, private: false, access: { has: (obj) => "setCookie" in obj, get: (obj) => obj.setCookie }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$8(_a3, null, _setPermissions_decorators, { kind: "method", name: "setPermissions", static: false, private: false, access: { has: (obj) => "setPermissions" in obj, get: (obj) => obj.setPermissions }, metadata: _metadata }, null, _instanceExtraInitializers);
      if (_metadata) Object.defineProperty(_a3, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    })(), __publicField(_a3, "DEFAULT", "default"), _a3;
  })();
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class BidiDeserializer {
    static deserialize(result) {
      var _a3, _b2, _c2, _d2;
      if (!result) {
        debugError("Service did not produce a result.");
        return void 0;
      }
      switch (result.type) {
        case "array":
          return (_a3 = result.value) == null ? void 0 : _a3.map((value) => {
            return this.deserialize(value);
          });
        case "set":
          return (_b2 = result.value) == null ? void 0 : _b2.reduce((acc, value) => {
            return acc.add(this.deserialize(value));
          }, /* @__PURE__ */ new Set());
        case "object":
          return (_c2 = result.value) == null ? void 0 : _c2.reduce((acc, tuple) => {
            const { key, value } = __privateMethod(this, _BidiDeserializer_static, deserializeTuple_fn).call(this, tuple);
            acc[key] = value;
            return acc;
          }, {});
        case "map":
          return (_d2 = result.value) == null ? void 0 : _d2.reduce((acc, tuple) => {
            const { key, value } = __privateMethod(this, _BidiDeserializer_static, deserializeTuple_fn).call(this, tuple);
            return acc.set(key, value);
          }, /* @__PURE__ */ new Map());
        case "promise":
          return {};
        case "regexp":
          return new RegExp(result.value.pattern, result.value.flags);
        case "date":
          return new Date(result.value);
        case "undefined":
          return void 0;
        case "null":
          return null;
        case "number":
          return __privateMethod(this, _BidiDeserializer_static, deserializeNumber_fn).call(this, result.value);
        case "bigint":
          return BigInt(result.value);
        case "boolean":
          return Boolean(result.value);
        case "string":
          return result.value;
      }
      debugError(`Deserialization of type ${result.type} not supported.`);
      return void 0;
    }
  }
  _BidiDeserializer_static = new WeakSet();
  deserializeNumber_fn = function(value) {
    switch (value) {
      case "-0":
        return -0;
      case "NaN":
        return NaN;
      case "Infinity":
        return Infinity;
      case "-Infinity":
        return -Infinity;
      default:
        return value;
    }
  };
  deserializeTuple_fn = function([serializedKey, serializedValue]) {
    const key = typeof serializedKey === "string" ? serializedKey : this.deserialize(serializedKey);
    const value = this.deserialize(serializedValue);
    return { key, value };
  };
  __privateAdd(BidiDeserializer, _BidiDeserializer_static);
  /**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  const _BidiDialog = class _BidiDialog extends Dialog {
    constructor(prompt) {
      super(prompt.info.type, prompt.info.message, prompt.info.defaultValue);
      __privateAdd(this, _prompt);
      __privateSet(this, _prompt, prompt);
      this.handled = prompt.handled;
    }
    static from(prompt) {
      return new _BidiDialog(prompt);
    }
    async handle(options) {
      await __privateGet(this, _prompt).handle({
        accept: options.accept,
        userText: options.text
      });
    }
  };
  _prompt = new WeakMap();
  let BidiDialog = _BidiDialog;
  var protocolExports = requireProtocol();
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  const _BidiJSHandle = class _BidiJSHandle extends JSHandle {
    constructor(value, realm) {
      super();
      __privateAdd(this, _remoteValue);
      __publicField(this, "realm");
      __privateAdd(this, _disposed5, false);
      __privateSet(this, _remoteValue, value);
      this.realm = realm;
    }
    static from(value, realm) {
      return new _BidiJSHandle(value, realm);
    }
    get disposed() {
      return __privateGet(this, _disposed5);
    }
    async jsonValue() {
      return await this.evaluate((value) => {
        return value;
      });
    }
    asElement() {
      return null;
    }
    async dispose() {
      if (__privateGet(this, _disposed5)) {
        return;
      }
      __privateSet(this, _disposed5, true);
      await this.realm.destroyHandles([this]);
    }
    get isPrimitiveValue() {
      switch (__privateGet(this, _remoteValue).type) {
        case "string":
        case "number":
        case "bigint":
        case "boolean":
        case "undefined":
        case "null":
          return true;
        default:
          return false;
      }
    }
    toString() {
      if (this.isPrimitiveValue) {
        return "JSHandle:" + BidiDeserializer.deserialize(__privateGet(this, _remoteValue));
      }
      return "JSHandle@" + __privateGet(this, _remoteValue).type;
    }
    get id() {
      return "handle" in __privateGet(this, _remoteValue) ? __privateGet(this, _remoteValue).handle : void 0;
    }
    remoteValue() {
      return __privateGet(this, _remoteValue);
    }
    remoteObject() {
      throw new UnsupportedOperation("Not available in WebDriver BiDi");
    }
  };
  _remoteValue = new WeakMap();
  _disposed5 = new WeakMap();
  let BidiJSHandle = _BidiJSHandle;
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var __runInitializers$7 = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i2 = 0; i2 < initializers.length; i2++) {
      value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate$7 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind2 = contextIn.kind, key = kind2 === "getter" ? "get" : kind2 === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function(f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i2])(kind2 === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind2 === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_ = accept(result.get)) descriptor.get = _;
        if (_ = accept(result.set)) descriptor.set = _;
        if (_ = accept(result.init)) initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind2 === "field") initializers.unshift(_);
        else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  var __addDisposableResource$5 = function(env, value, async2) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async2) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async2) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({ value, dispose, async: async2 });
    } else if (async2) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources$5 = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  let BidiElementHandle = (() => {
    var _backendNodeId, _a3;
    let _classSuper = ElementHandle;
    let _instanceExtraInitializers = [];
    let _autofill_decorators;
    let _contentFrame_decorators;
    return _a3 = class extends _classSuper {
      constructor(value, realm) {
        super(BidiJSHandle.from(value, realm));
        __privateAdd(this, _backendNodeId, __runInitializers$7(this, _instanceExtraInitializers));
      }
      static from(value, realm) {
        return new _a3(value, realm);
      }
      get realm() {
        return this.handle.realm;
      }
      get frame() {
        return this.realm.environment;
      }
      remoteValue() {
        return this.handle.remoteValue();
      }
      async autofill(data) {
        const client2 = this.frame.client;
        const nodeInfo = await client2.send("DOM.describeNode", {
          objectId: this.handle.id
        });
        const fieldId = nodeInfo.node.backendNodeId;
        const frameId = this.frame._id;
        await client2.send("Autofill.trigger", {
          fieldId,
          frameId,
          card: data.creditCard
        });
      }
      async contentFrame() {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
          const handle = __addDisposableResource$5(env_1, await this.evaluateHandle((element) => {
            if (element instanceof HTMLIFrameElement || element instanceof HTMLFrameElement) {
              return element.contentWindow;
            }
            return;
          }), false);
          const value = handle.remoteValue();
          if (value.type === "window") {
            return this.frame.page().frames().find((frame) => {
              return frame._id === value.value.context;
            }) ?? null;
          }
          return null;
        } catch (e_1) {
          env_1.error = e_1;
          env_1.hasError = true;
        } finally {
          __disposeResources$5(env_1);
        }
      }
      async uploadFile(...files) {
        const path = environment.value.path;
        if (path) {
          files = files.map((file) => {
            if (path.win32.isAbsolute(file) || path.posix.isAbsolute(file)) {
              return file;
            } else {
              return path.resolve(file);
            }
          });
        }
        await this.frame.setFiles(this, files);
      }
      async *queryAXTree(name, role) {
        const results = await this.frame.locateNodes(this, {
          type: "accessibility",
          value: {
            role,
            name
          }
        });
        return yield* AsyncIterableUtil.map(results, (node) => {
          return Promise.resolve(_a3.from(node, this.realm));
        });
      }
      async backendNodeId() {
        if (!this.frame.page().browser().cdpSupported) {
          throw new UnsupportedOperation();
        }
        if (__privateGet(this, _backendNodeId)) {
          return __privateGet(this, _backendNodeId);
        }
        const { node } = await this.frame.client.send("DOM.describeNode", {
          objectId: this.handle.id
        });
        __privateSet(this, _backendNodeId, node.backendNodeId);
        return __privateGet(this, _backendNodeId);
      }
    }, _backendNodeId = new WeakMap(), (() => {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      _autofill_decorators = [throwIfDisposed()];
      _contentFrame_decorators = [throwIfDisposed(), bindIsolatedHandle];
      __esDecorate$7(_a3, null, _autofill_decorators, { kind: "method", name: "autofill", static: false, private: false, access: { has: (obj) => "autofill" in obj, get: (obj) => obj.autofill }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$7(_a3, null, _contentFrame_decorators, { kind: "method", name: "contentFrame", static: false, private: false, access: { has: (obj) => "contentFrame" in obj, get: (obj) => obj.contentFrame }, metadata: _metadata }, null, _instanceExtraInitializers);
      if (_metadata) Object.defineProperty(_a3, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    })(), _a3;
  })();
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var __addDisposableResource$4 = function(env, value, async2) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async2) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async2) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({ value, dispose, async: async2 });
    } else if (async2) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources$4 = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  const _ExposeableFunction = class _ExposeableFunction {
    constructor(frame, name, apply, isolate = false) {
      __privateAdd(this, _ExposeableFunction_instances);
      __privateAdd(this, _frame4);
      __publicField(this, "name");
      __privateAdd(this, _apply);
      __privateAdd(this, _isolate);
      __privateAdd(this, _channel);
      __privateAdd(this, _scripts, []);
      __privateAdd(this, _disposables2, new DisposableStack());
      __privateAdd(this, _handleMessage, async (params) => {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
          if (params.channel !== __privateGet(this, _channel)) {
            return;
          }
          const realm = __privateMethod(this, _ExposeableFunction_instances, getRealm_fn).call(this, params.source);
          if (!realm) {
            return;
          }
          const dataHandle = __addDisposableResource$4(env_1, BidiJSHandle.from(params.data, realm), false);
          const argsHandle = __addDisposableResource$4(env_1, await dataHandle.evaluateHandle(([, , args2]) => {
            return args2;
          }), false);
          const stack = __addDisposableResource$4(env_1, new DisposableStack(), false);
          const args = [];
          for (const [index, handle] of await argsHandle.getProperties()) {
            stack.use(handle);
            if (handle instanceof BidiElementHandle) {
              args[+index] = handle;
              stack.use(handle);
              continue;
            }
            args[+index] = handle.jsonValue();
          }
          let result;
          try {
            result = await __privateGet(this, _apply).call(this, ...await Promise.all(args));
          } catch (error) {
            try {
              if (error instanceof Error) {
                await dataHandle.evaluate(([, reject], name, message, stack2) => {
                  const error2 = new Error(message);
                  error2.name = name;
                  if (stack2) {
                    error2.stack = stack2;
                  }
                  reject(error2);
                }, error.name, error.message, error.stack);
              } else {
                await dataHandle.evaluate(([, reject], error2) => {
                  reject(error2);
                }, error);
              }
            } catch (error2) {
              debugError(error2);
            }
            return;
          }
          try {
            await dataHandle.evaluate(([resolve], result2) => {
              resolve(result2);
            }, result);
          } catch (error) {
            debugError(error);
          }
        } catch (e_1) {
          env_1.error = e_1;
          env_1.hasError = true;
        } finally {
          __disposeResources$4(env_1);
        }
      });
      __privateSet(this, _frame4, frame);
      this.name = name;
      __privateSet(this, _apply, apply);
      __privateSet(this, _isolate, isolate);
      __privateSet(this, _channel, `__puppeteer__${__privateGet(this, _frame4)._id}_page_exposeFunction_${this.name}`);
    }
    static async from(frame, name, apply, isolate = false) {
      var _a3;
      const func = new _ExposeableFunction(frame, name, apply, isolate);
      await __privateMethod(_a3 = func, _ExposeableFunction_instances, initialize_fn5).call(_a3);
      return func;
    }
    [Symbol.dispose]() {
      void this[Symbol.asyncDispose]().catch(debugError);
    }
    async [Symbol.asyncDispose]() {
      __privateGet(this, _disposables2).dispose();
      await Promise.all(__privateGet(this, _scripts).map(async ([frame, script]) => {
        const realm = __privateGet(this, _isolate) ? frame.isolatedRealm() : frame.mainRealm();
        try {
          await Promise.all([
            realm.evaluate((name) => {
              delete globalThis[name];
            }, this.name),
            ...frame.childFrames().map((childFrame) => {
              return childFrame.evaluate((name) => {
                delete globalThis[name];
              }, this.name);
            }),
            frame.browsingContext.removePreloadScript(script)
          ]);
        } catch (error) {
          debugError(error);
        }
      }));
    }
  };
  _frame4 = new WeakMap();
  _apply = new WeakMap();
  _isolate = new WeakMap();
  _channel = new WeakMap();
  _scripts = new WeakMap();
  _disposables2 = new WeakMap();
  _ExposeableFunction_instances = new WeakSet();
  initialize_fn5 = async function() {
    const connection = __privateGet(this, _ExposeableFunction_instances, connection_get);
    const channel = {
      type: "channel",
      value: {
        channel: __privateGet(this, _channel),
        ownership: "root"
      }
    };
    const connectionEmitter = __privateGet(this, _disposables2).use(new EventEmitter$1(connection));
    connectionEmitter.on(protocolExports.ChromiumBidi.Script.EventNames.Message, __privateGet(this, _handleMessage));
    const functionDeclaration = stringifyFunction(interpolateFunction((callback) => {
      Object.assign(globalThis, {
        [PLACEHOLDER("name")]: function(...args) {
          return new Promise((resolve, reject) => {
            callback([resolve, reject, args]);
          });
        }
      });
    }, { name: JSON.stringify(this.name) }));
    const frames = [__privateGet(this, _frame4)];
    for (const frame of frames) {
      frames.push(...frame.childFrames());
    }
    await Promise.all(frames.map(async (frame) => {
      const realm = __privateGet(this, _isolate) ? frame.isolatedRealm() : frame.mainRealm();
      try {
        const [script] = await Promise.all([
          frame.browsingContext.addPreloadScript(functionDeclaration, {
            arguments: [channel],
            sandbox: realm.sandbox
          }),
          realm.realm.callFunction(functionDeclaration, false, {
            arguments: [channel]
          })
        ]);
        __privateGet(this, _scripts).push([frame, script]);
      } catch (error) {
        debugError(error);
      }
    }));
  };
  connection_get = function() {
    return __privateGet(this, _frame4).page().browser().connection;
  };
  _handleMessage = new WeakMap();
  getRealm_fn = function(source2) {
    const frame = __privateMethod(this, _ExposeableFunction_instances, findFrame_fn).call(this, source2.context);
    if (!frame) {
      return;
    }
    return frame.realm(source2.realm);
  };
  findFrame_fn = function(id) {
    const frames = [__privateGet(this, _frame4)];
    for (const frame of frames) {
      if (frame._id === id) {
        return frame;
      }
      frames.push(...frame.childFrames());
    }
    return;
  };
  let ExposeableFunction = _ExposeableFunction;
  var __runInitializers$6 = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i2 = 0; i2 < initializers.length; i2++) {
      value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate$6 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind2 = contextIn.kind, key = kind2 === "getter" ? "get" : kind2 === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function(f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i2])(kind2 === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind2 === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_ = accept(result.get)) descriptor.get = _;
        if (_ = accept(result.set)) descriptor.set = _;
        if (_ = accept(result.init)) initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind2 === "field") initializers.unshift(_);
        else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  let BidiHTTPResponse = (() => {
    var _data, _request3, _securityDetails2, _cdpSupported, _BidiHTTPResponse_instances, initialize_fn8, _a3;
    let _classSuper = HTTPResponse;
    let _instanceExtraInitializers = [];
    let _remoteAddress_decorators;
    return _a3 = class extends _classSuper {
      constructor(data, request, cdpSupported) {
        super();
        __privateAdd(this, _BidiHTTPResponse_instances);
        __privateAdd(this, _data, __runInitializers$6(this, _instanceExtraInitializers));
        __privateAdd(this, _request3);
        __privateAdd(this, _securityDetails2);
        __privateAdd(this, _cdpSupported, false);
        __privateSet(this, _data, data);
        __privateSet(this, _request3, request);
        __privateSet(this, _cdpSupported, cdpSupported);
        const securityDetails = data["goog:securityDetails"];
        if (cdpSupported && securityDetails) {
          __privateSet(this, _securityDetails2, new SecurityDetails(securityDetails));
        }
      }
      static from(data, request, cdpSupported) {
        var _a4;
        const response = new _a3(data, request, cdpSupported);
        __privateMethod(_a4 = response, _BidiHTTPResponse_instances, initialize_fn8).call(_a4);
        return response;
      }
      remoteAddress() {
        return {
          ip: "",
          port: -1
        };
      }
      url() {
        return __privateGet(this, _data).url;
      }
      status() {
        return __privateGet(this, _data).status;
      }
      statusText() {
        return __privateGet(this, _data).statusText;
      }
      headers() {
        const headers = {};
        for (const header of __privateGet(this, _data).headers) {
          if (header.value.type === "string") {
            headers[header.name.toLowerCase()] = header.value.value;
          }
        }
        return headers;
      }
      request() {
        return __privateGet(this, _request3);
      }
      fromCache() {
        return __privateGet(this, _data).fromCache;
      }
      timing() {
        const bidiTiming = __privateGet(this, _request3).timing();
        return {
          requestTime: bidiTiming.requestTime,
          proxyStart: -1,
          proxyEnd: -1,
          dnsStart: bidiTiming.dnsStart,
          dnsEnd: bidiTiming.dnsEnd,
          connectStart: bidiTiming.connectStart,
          connectEnd: bidiTiming.connectEnd,
          sslStart: bidiTiming.tlsStart,
          sslEnd: -1,
          workerStart: -1,
          workerReady: -1,
          workerFetchStart: -1,
          workerRespondWithSettled: -1,
          workerRouterEvaluationStart: -1,
          workerCacheLookupStart: -1,
          sendStart: bidiTiming.requestStart,
          sendEnd: -1,
          pushStart: -1,
          pushEnd: -1,
          receiveHeadersStart: bidiTiming.responseStart,
          receiveHeadersEnd: bidiTiming.responseEnd
        };
      }
      frame() {
        return __privateGet(this, _request3).frame();
      }
      fromServiceWorker() {
        return false;
      }
      securityDetails() {
        if (!__privateGet(this, _cdpSupported)) {
          throw new UnsupportedOperation();
        }
        return __privateGet(this, _securityDetails2) ?? null;
      }
      content() {
        throw new UnsupportedOperation();
      }
    }, _data = new WeakMap(), _request3 = new WeakMap(), _securityDetails2 = new WeakMap(), _cdpSupported = new WeakMap(), _BidiHTTPResponse_instances = new WeakSet(), initialize_fn8 = function() {
      var _a4, _b2;
      if (__privateGet(this, _data).fromCache) {
        __privateGet(this, _request3)._fromMemoryCache = true;
        (_a4 = __privateGet(this, _request3).frame()) == null ? void 0 : _a4.page().trustedEmitter.emit("requestservedfromcache", __privateGet(this, _request3));
      }
      (_b2 = __privateGet(this, _request3).frame()) == null ? void 0 : _b2.page().trustedEmitter.emit("response", this);
    }, (() => {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      _remoteAddress_decorators = [invokeAtMostOnceForArguments];
      __esDecorate$6(_a3, null, _remoteAddress_decorators, { kind: "method", name: "remoteAddress", static: false, private: false, access: { has: (obj) => "remoteAddress" in obj, get: (obj) => obj.remoteAddress }, metadata: _metadata }, null, _instanceExtraInitializers);
      if (_metadata) Object.defineProperty(_a3, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    })(), _a3;
  })();
  var _a;
  const requests = /* @__PURE__ */ new WeakMap();
  class BidiHTTPRequest extends HTTPRequest {
    constructor(request, frame, redirect) {
      super();
      __privateAdd(this, _BidiHTTPRequest_instances);
      __privateAdd(this, _redirectChain);
      __privateAdd(this, _response, null);
      __publicField(this, "id");
      __privateAdd(this, _frame5);
      __privateAdd(this, _request2);
      __privateAdd(this, _authenticationHandled, false);
      __privateAdd(this, _handleAuthentication, async () => {
        if (!__privateGet(this, _frame5)) {
          return;
        }
        const credentials = __privateGet(this, _frame5).page()._credentials;
        if (credentials && !__privateGet(this, _authenticationHandled)) {
          __privateSet(this, _authenticationHandled, true);
          void __privateGet(this, _request2).continueWithAuth({
            action: "provideCredentials",
            credentials: {
              type: "password",
              username: credentials.username,
              password: credentials.password
            }
          });
        } else {
          void __privateGet(this, _request2).continueWithAuth({
            action: "cancel"
          });
        }
      });
      requests.set(request, this);
      this.interception.enabled = request.isBlocked;
      __privateSet(this, _request2, request);
      __privateSet(this, _frame5, frame);
      __privateSet(this, _redirectChain, redirect ? __privateGet(redirect, _redirectChain) : []);
      this.id = request.id;
    }
    static from(bidiRequest, frame, redirect) {
      var _a3;
      const request = new _a(bidiRequest, frame, redirect);
      __privateMethod(_a3 = request, _BidiHTTPRequest_instances, initialize_fn6).call(_a3);
      return request;
    }
    get client() {
      return __privateGet(this, _frame5).client;
    }
    url() {
      return __privateGet(this, _request2).url;
    }
    resourceType() {
      if (!__privateGet(this, _frame5).page().browser().cdpSupported) {
        throw new UnsupportedOperation();
      }
      return (__privateGet(this, _request2).resourceType || "other").toLowerCase();
    }
    method() {
      return __privateGet(this, _request2).method;
    }
    postData() {
      if (!__privateGet(this, _frame5).page().browser().cdpSupported) {
        throw new UnsupportedOperation();
      }
      return __privateGet(this, _request2).postData;
    }
    hasPostData() {
      if (!__privateGet(this, _frame5).page().browser().cdpSupported) {
        throw new UnsupportedOperation();
      }
      return __privateGet(this, _request2).hasPostData;
    }
    async fetchPostData() {
      throw new UnsupportedOperation();
    }
    headers() {
      const headers = {};
      for (const header of __privateGet(this, _request2).headers) {
        headers[header.name.toLowerCase()] = header.value.value;
      }
      return {
        ...headers,
        ...__privateGet(this, _BidiHTTPRequest_instances, extraHTTPHeaders_get),
        ...__privateGet(this, _BidiHTTPRequest_instances, userAgentHeaders_get)
      };
    }
    response() {
      return __privateGet(this, _response);
    }
    failure() {
      if (__privateGet(this, _request2).error === void 0) {
        return null;
      }
      return { errorText: __privateGet(this, _request2).error };
    }
    isNavigationRequest() {
      return __privateGet(this, _request2).navigation !== void 0;
    }
    initiator() {
      var _a3;
      return {
        ...__privateGet(this, _request2).initiator,
        type: ((_a3 = __privateGet(this, _request2).initiator) == null ? void 0 : _a3.type) ?? "other"
      };
    }
    redirectChain() {
      return __privateGet(this, _redirectChain).slice();
    }
    frame() {
      return __privateGet(this, _frame5);
    }
    async continue(overrides, priority) {
      return await super.continue({
        headers: __privateGet(this, _BidiHTTPRequest_instances, hasInternalHeaderOverwrite_get) ? this.headers() : void 0,
        ...overrides
      }, priority);
    }
    async _continue(overrides = {}) {
      const headers = getBidiHeaders(overrides.headers);
      this.interception.handled = true;
      return await __privateGet(this, _request2).continueRequest({
        url: overrides.url,
        method: overrides.method,
        body: overrides.postData ? {
          type: "base64",
          value: stringToBase64(overrides.postData)
        } : void 0,
        headers: headers.length > 0 ? headers : void 0
      }).catch((error) => {
        this.interception.handled = false;
        return handleError(error);
      });
    }
    async _abort() {
      this.interception.handled = true;
      return await __privateGet(this, _request2).failRequest().catch((error) => {
        this.interception.handled = false;
        throw error;
      });
    }
    async _respond(response, _priority) {
      this.interception.handled = true;
      let parsedBody;
      if (response.body) {
        parsedBody = HTTPRequest.getResponse(response.body);
      }
      const headers = getBidiHeaders(response.headers);
      const hasContentLength = headers.some((header) => {
        return header.name === "content-length";
      });
      if (response.contentType) {
        headers.push({
          name: "content-type",
          value: {
            type: "string",
            value: response.contentType
          }
        });
      }
      if ((parsedBody == null ? void 0 : parsedBody.contentLength) && !hasContentLength) {
        headers.push({
          name: "content-length",
          value: {
            type: "string",
            value: String(parsedBody.contentLength)
          }
        });
      }
      const status = response.status || 200;
      return await __privateGet(this, _request2).provideResponse({
        statusCode: status,
        headers: headers.length > 0 ? headers : void 0,
        reasonPhrase: STATUS_TEXTS[status],
        body: (parsedBody == null ? void 0 : parsedBody.base64) ? {
          type: "base64",
          value: parsedBody == null ? void 0 : parsedBody.base64
        } : void 0
      }).catch((error) => {
        this.interception.handled = false;
        throw error;
      });
    }
    timing() {
      return __privateGet(this, _request2).timing();
    }
  }
  _redirectChain = new WeakMap();
  _response = new WeakMap();
  _frame5 = new WeakMap();
  _request2 = new WeakMap();
  _BidiHTTPRequest_instances = new WeakSet();
  initialize_fn6 = function() {
    __privateGet(this, _request2).on("redirect", (request) => {
      const httpRequest = _a.from(request, __privateGet(this, _frame5), this);
      __privateGet(this, _redirectChain).push(this);
      request.once("success", () => {
        __privateGet(this, _frame5).page().trustedEmitter.emit("requestfinished", httpRequest);
      });
      request.once("error", () => {
        __privateGet(this, _frame5).page().trustedEmitter.emit("requestfailed", httpRequest);
      });
      void httpRequest.finalizeInterceptions();
    });
    __privateGet(this, _request2).once("success", (data) => {
      __privateSet(this, _response, BidiHTTPResponse.from(data, this, __privateGet(this, _frame5).page().browser().cdpSupported));
    });
    __privateGet(this, _request2).on("authenticate", __privateGet(this, _handleAuthentication));
    __privateGet(this, _frame5).page().trustedEmitter.emit("request", this);
    if (__privateGet(this, _BidiHTTPRequest_instances, hasInternalHeaderOverwrite_get)) {
      this.interception.handlers.push(async () => {
        await this.continue({
          headers: this.headers()
        }, 0);
      });
    }
  };
  hasInternalHeaderOverwrite_get = function() {
    return Boolean(Object.keys(__privateGet(this, _BidiHTTPRequest_instances, extraHTTPHeaders_get)).length || Object.keys(__privateGet(this, _BidiHTTPRequest_instances, userAgentHeaders_get)).length);
  };
  extraHTTPHeaders_get = function() {
    var _a3;
    return ((_a3 = __privateGet(this, _frame5)) == null ? void 0 : _a3.page()._extraHTTPHeaders) ?? {};
  };
  userAgentHeaders_get = function() {
    var _a3;
    return ((_a3 = __privateGet(this, _frame5)) == null ? void 0 : _a3.page()._userAgentHeaders) ?? {};
  };
  _authenticationHandled = new WeakMap();
  _handleAuthentication = new WeakMap();
  _a = BidiHTTPRequest;
  function getBidiHeaders(rawHeaders) {
    const headers = [];
    for (const [name, value] of Object.entries(rawHeaders ?? [])) {
      if (!Object.is(value, void 0)) {
        const values = Array.isArray(value) ? value : [value];
        for (const value2 of values) {
          headers.push({
            name: name.toLowerCase(),
            value: {
              type: "string",
              value: String(value2)
            }
          });
        }
      }
    }
    return headers;
  }
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class UnserializableError extends Error {
  }
  class BidiSerializer {
    static serialize(arg) {
      switch (typeof arg) {
        case "symbol":
        case "function":
          throw new UnserializableError(`Unable to serializable ${typeof arg}`);
        case "object":
          return __privateMethod(this, _BidiSerializer_static, serializeObject_fn).call(this, arg);
        case "undefined":
          return {
            type: "undefined"
          };
        case "number":
          return __privateMethod(this, _BidiSerializer_static, serializeNumber_fn).call(this, arg);
        case "bigint":
          return {
            type: "bigint",
            value: arg.toString()
          };
        case "string":
          return {
            type: "string",
            value: arg
          };
        case "boolean":
          return {
            type: "boolean",
            value: arg
          };
      }
    }
  }
  _BidiSerializer_static = new WeakSet();
  serializeNumber_fn = function(arg) {
    let value;
    if (Object.is(arg, -0)) {
      value = "-0";
    } else if (Object.is(arg, Infinity)) {
      value = "Infinity";
    } else if (Object.is(arg, -Infinity)) {
      value = "-Infinity";
    } else if (Object.is(arg, NaN)) {
      value = "NaN";
    } else {
      value = arg;
    }
    return {
      type: "number",
      value
    };
  };
  serializeObject_fn = function(arg) {
    if (arg === null) {
      return {
        type: "null"
      };
    } else if (Array.isArray(arg)) {
      const parsedArray = arg.map((subArg) => {
        return this.serialize(subArg);
      });
      return {
        type: "array",
        value: parsedArray
      };
    } else if (isPlainObject(arg)) {
      try {
        JSON.stringify(arg);
      } catch (error) {
        if (error instanceof TypeError && error.message.startsWith("Converting circular structure to JSON")) {
          error.message += " Recursive objects are not allowed.";
        }
        throw error;
      }
      const parsedObject = [];
      for (const key in arg) {
        parsedObject.push([this.serialize(key), this.serialize(arg[key])]);
      }
      return {
        type: "object",
        value: parsedObject
      };
    } else if (isRegExp(arg)) {
      return {
        type: "regexp",
        value: {
          pattern: arg.source,
          flags: arg.flags
        }
      };
    } else if (isDate(arg)) {
      return {
        type: "date",
        value: arg.toISOString()
      };
    }
    throw new UnserializableError("Custom object serialization not possible. Use plain objects instead.");
  };
  __privateAdd(BidiSerializer, _BidiSerializer_static);
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  function createEvaluationError(details) {
    if (details.exception.type !== "error") {
      return BidiDeserializer.deserialize(details.exception);
    }
    const [name = "", ...parts] = details.text.split(": ");
    const message = parts.join(": ");
    const error = new Error(message);
    error.name = name;
    const stackLines = [];
    if (details.stackTrace && stackLines.length < Error.stackTraceLimit) {
      for (const frame of details.stackTrace.callFrames.reverse()) {
        if (PuppeteerURL.isPuppeteerURL(frame.url) && frame.url !== PuppeteerURL.INTERNAL_URL) {
          const url = PuppeteerURL.parse(frame.url);
          stackLines.unshift(`    at ${frame.functionName || url.functionName} (${url.functionName} at ${url.siteString}, <anonymous>:${frame.lineNumber}:${frame.columnNumber})`);
        } else {
          stackLines.push(`    at ${frame.functionName || "<anonymous>"} (${frame.url}:${frame.lineNumber}:${frame.columnNumber})`);
        }
        if (stackLines.length >= Error.stackTraceLimit) {
          break;
        }
      }
    }
    error.stack = [details.text, ...stackLines].join("\n");
    return error;
  }
  function rewriteNavigationError(message, ms2) {
    return (error) => {
      if (error instanceof ProtocolError) {
        error.message += ` at ${message}`;
      } else if (error instanceof TimeoutError) {
        error.message = `Navigation timeout of ${ms2} ms exceeded`;
      }
      throw error;
    };
  }
  var __addDisposableResource$3 = function(env, value, async2) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async2) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async2) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({ value, dispose, async: async2 });
    } else if (async2) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources$3 = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  class BidiRealm extends Realm$2 {
    constructor(realm, timeoutSettings) {
      super(timeoutSettings);
      __privateAdd(this, _BidiRealm_instances);
      __publicField(this, "realm");
      __publicField(this, "internalPuppeteerUtil");
      this.realm = realm;
    }
    initialize() {
      this.realm.on("destroyed", ({ reason }) => {
        this.taskManager.terminateAll(new Error(reason));
        this.dispose();
      });
      this.realm.on("updated", () => {
        this.internalPuppeteerUtil = void 0;
        void this.taskManager.rerunAll();
      });
    }
    get puppeteerUtil() {
      const promise = Promise.resolve();
      scriptInjector.inject((script) => {
        if (this.internalPuppeteerUtil) {
          void this.internalPuppeteerUtil.then((handle) => {
            void handle.dispose();
          });
        }
        this.internalPuppeteerUtil = promise.then(() => {
          return this.evaluateHandle(script);
        });
      }, !this.internalPuppeteerUtil);
      return this.internalPuppeteerUtil;
    }
    async evaluateHandle(pageFunction, ...args) {
      return await __privateMethod(this, _BidiRealm_instances, evaluate_fn2).call(this, false, pageFunction, ...args);
    }
    async evaluate(pageFunction, ...args) {
      return await __privateMethod(this, _BidiRealm_instances, evaluate_fn2).call(this, true, pageFunction, ...args);
    }
    createHandle(result) {
      if ((result.type === "node" || result.type === "window") && this instanceof BidiFrameRealm) {
        return BidiElementHandle.from(result, this);
      }
      return BidiJSHandle.from(result, this);
    }
    async serializeAsync(arg) {
      if (arg instanceof LazyArg) {
        arg = await arg.get(this);
      }
      return this.serialize(arg);
    }
    serialize(arg) {
      if (arg instanceof BidiJSHandle || arg instanceof BidiElementHandle) {
        if (arg.realm !== this) {
          if (!(arg.realm instanceof BidiFrameRealm) || !(this instanceof BidiFrameRealm)) {
            throw new Error("Trying to evaluate JSHandle from different global types. Usually this means you're using a handle from a worker in a page or vice versa.");
          }
          if (arg.realm.environment !== this.environment) {
            throw new Error("Trying to evaluate JSHandle from different frames. Usually this means you're using a handle from a page on a different page.");
          }
        }
        if (arg.disposed) {
          throw new Error("JSHandle is disposed!");
        }
        return arg.remoteValue();
      }
      return BidiSerializer.serialize(arg);
    }
    async destroyHandles(handles) {
      if (this.disposed) {
        return;
      }
      const handleIds = handles.map(({ id }) => {
        return id;
      }).filter((id) => {
        return id !== void 0;
      });
      if (handleIds.length === 0) {
        return;
      }
      await this.realm.disown(handleIds).catch((error) => {
        debugError(error);
      });
    }
    async adoptHandle(handle) {
      return await this.evaluateHandle((node) => {
        return node;
      }, handle);
    }
    async transferHandle(handle) {
      if (handle.realm === this) {
        return handle;
      }
      const transferredHandle = this.adoptHandle(handle);
      await handle.dispose();
      return await transferredHandle;
    }
  }
  _BidiRealm_instances = new WeakSet();
  evaluate_fn2 = async function(returnByValue, pageFunction, ...args) {
    var _a3;
    const sourceUrlComment = getSourceUrlComment(((_a3 = getSourcePuppeteerURLIfAvailable(pageFunction)) == null ? void 0 : _a3.toString()) ?? PuppeteerURL.INTERNAL_URL);
    let responsePromise;
    const resultOwnership = returnByValue ? "none" : "root";
    const serializationOptions = returnByValue ? {} : {
      maxObjectDepth: 0,
      maxDomDepth: 0
    };
    if (isString(pageFunction)) {
      const expression = SOURCE_URL_REGEX.test(pageFunction) ? pageFunction : `${pageFunction}
${sourceUrlComment}
`;
      responsePromise = this.realm.evaluate(expression, true, {
        resultOwnership,
        userActivation: true,
        serializationOptions
      });
    } else {
      let functionDeclaration = stringifyFunction(pageFunction);
      functionDeclaration = SOURCE_URL_REGEX.test(functionDeclaration) ? functionDeclaration : `${functionDeclaration}
${sourceUrlComment}
`;
      responsePromise = this.realm.callFunction(
        functionDeclaration,
        /* awaitPromise= */
        true,
        {
          // LazyArgs are used only internally and should not affect the order
          // evaluate calls for the public APIs.
          arguments: args.some((arg) => {
            return arg instanceof LazyArg;
          }) ? await Promise.all(args.map((arg) => {
            return this.serializeAsync(arg);
          })) : args.map((arg) => {
            return this.serialize(arg);
          }),
          resultOwnership,
          userActivation: true,
          serializationOptions
        }
      );
    }
    const result = await responsePromise;
    if ("type" in result && result.type === "exception") {
      throw createEvaluationError(result.exceptionDetails);
    }
    return returnByValue ? BidiDeserializer.deserialize(result.result) : this.createHandle(result.result);
  };
  const _BidiFrameRealm = class _BidiFrameRealm extends BidiRealm {
    constructor(realm, frame) {
      super(realm, frame.timeoutSettings);
      __privateAdd(this, _BidiFrameRealm_instances);
      __privateAdd(this, _frame6);
      __privateAdd(this, _bindingsInstalled2, false);
      __privateSet(this, _frame6, frame);
    }
    static from(realm, frame) {
      var _a3;
      const frameRealm = new _BidiFrameRealm(realm, frame);
      __privateMethod(_a3 = frameRealm, _BidiFrameRealm_instances, initialize_fn7).call(_a3);
      return frameRealm;
    }
    get puppeteerUtil() {
      let promise = Promise.resolve();
      if (!__privateGet(this, _bindingsInstalled2)) {
        promise = Promise.all([
          ExposeableFunction.from(this.environment, "__ariaQuerySelector", ARIAQueryHandler.queryOne, !!this.sandbox),
          ExposeableFunction.from(this.environment, "__ariaQuerySelectorAll", async (element, selector) => {
            const results = ARIAQueryHandler.queryAll(element, selector);
            return await element.realm.evaluateHandle((...elements) => {
              return elements;
            }, ...await AsyncIterableUtil.collect(results));
          }, !!this.sandbox)
        ]);
        __privateSet(this, _bindingsInstalled2, true);
      }
      return promise.then(() => {
        return super.puppeteerUtil;
      });
    }
    get sandbox() {
      return this.realm.sandbox;
    }
    get environment() {
      return __privateGet(this, _frame6);
    }
    async adoptBackendNode(backendNodeId) {
      const env_1 = { stack: [], error: void 0, hasError: false };
      try {
        const { object } = await __privateGet(this, _frame6).client.send("DOM.resolveNode", {
          backendNodeId,
          executionContextId: await this.realm.resolveExecutionContextId()
        });
        const handle = __addDisposableResource$3(env_1, BidiElementHandle.from({
          handle: object.objectId,
          type: "node"
        }, this), false);
        return await handle.evaluateHandle((element) => {
          return element;
        });
      } catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
      } finally {
        __disposeResources$3(env_1);
      }
    }
  };
  _frame6 = new WeakMap();
  _BidiFrameRealm_instances = new WeakSet();
  initialize_fn7 = function() {
    __superGet(_BidiFrameRealm.prototype, this, "initialize").call(this);
    this.realm.on("updated", () => {
      this.environment.clearDocumentHandle();
      __privateSet(this, _bindingsInstalled2, false);
    });
  };
  _bindingsInstalled2 = new WeakMap();
  let BidiFrameRealm = _BidiFrameRealm;
  const _BidiWorkerRealm = class _BidiWorkerRealm extends BidiRealm {
    constructor(realm, frame) {
      super(realm, frame.timeoutSettings);
      __privateAdd(this, _worker);
      __privateSet(this, _worker, frame);
    }
    static from(realm, worker) {
      const workerRealm = new _BidiWorkerRealm(realm, worker);
      workerRealm.initialize();
      return workerRealm;
    }
    get environment() {
      return __privateGet(this, _worker);
    }
    async adoptBackendNode() {
      throw new Error("Cannot adopt DOM nodes into a worker.");
    }
  };
  _worker = new WeakMap();
  let BidiWorkerRealm = _BidiWorkerRealm;
  /**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  const _BidiWebWorker = class _BidiWebWorker extends WebWorker {
    constructor(frame, realm) {
      super(realm.origin);
      __privateAdd(this, _frame7);
      __privateAdd(this, _realm3);
      __privateSet(this, _frame7, frame);
      __privateSet(this, _realm3, BidiWorkerRealm.from(realm, this));
    }
    static from(frame, realm) {
      const worker = new _BidiWebWorker(frame, realm);
      return worker;
    }
    get frame() {
      return __privateGet(this, _frame7);
    }
    mainRealm() {
      return __privateGet(this, _realm3);
    }
    get client() {
      throw new UnsupportedOperation();
    }
  };
  _frame7 = new WeakMap();
  _realm3 = new WeakMap();
  let BidiWebWorker = _BidiWebWorker;
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var __runInitializers$5 = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i2 = 0; i2 < initializers.length; i2++) {
      value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate$5 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind2 = contextIn.kind, key = kind2 === "getter" ? "get" : kind2 === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function(f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i2])(kind2 === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind2 === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_ = accept(result.get)) descriptor.get = _;
        if (_ = accept(result.set)) descriptor.set = _;
        if (_ = accept(result.init)) initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind2 === "field") initializers.unshift(_);
        else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  var __setFunctionName$1 = function(f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
  };
  function convertConsoleMessageLevel(method) {
    switch (method) {
      case "group":
        return "startGroup";
      case "groupCollapsed":
        return "startGroupCollapsed";
      case "groupEnd":
        return "endGroup";
      default:
        return method;
    }
  }
  let BidiFrame = (() => {
    var _parent, _frames2, _BidiFrame_instances, initialize_fn8, createFrameTarget_fn, detached$_fn, _exposedFunctions2, waitForLoad$_get, waitForNetworkIdle$_get, _a3;
    let _classSuper = Frame;
    let _instanceExtraInitializers = [];
    let _goto_decorators;
    let _setContent_decorators;
    let _waitForNavigation_decorators;
    let _private_waitForLoad$_decorators;
    let _private_waitForLoad$_descriptor;
    let _private_waitForNetworkIdle$_decorators;
    let _private_waitForNetworkIdle$_descriptor;
    let _setFiles_decorators;
    let _locateNodes_decorators;
    return _a3 = class extends _classSuper {
      constructor(parent, browsingContext) {
        super();
        __privateAdd(this, _BidiFrame_instances);
        __privateAdd(this, _parent, __runInitializers$5(this, _instanceExtraInitializers));
        __publicField(this, "browsingContext");
        __privateAdd(this, _frames2, /* @__PURE__ */ new WeakMap());
        __publicField(this, "realms");
        __publicField(this, "_id");
        __publicField(this, "client");
        __publicField(this, "accessibility");
        __privateAdd(this, _exposedFunctions2, /* @__PURE__ */ new Map());
        __privateSet(this, _parent, parent);
        this.browsingContext = browsingContext;
        this._id = browsingContext.id;
        this.client = new BidiCdpSession(this);
        this.realms = {
          default: BidiFrameRealm.from(this.browsingContext.defaultRealm, this),
          internal: BidiFrameRealm.from(this.browsingContext.createWindowRealm(`__puppeteer_internal_${Math.ceil(Math.random() * 1e4)}`), this)
        };
        this.accessibility = new Accessibility(this.realms.default, this._id);
      }
      static from(parent, browsingContext) {
        var _a4;
        const frame = new _a3(parent, browsingContext);
        __privateMethod(_a4 = frame, _BidiFrame_instances, initialize_fn8).call(_a4);
        return frame;
      }
      get timeoutSettings() {
        return this.page()._timeoutSettings;
      }
      mainRealm() {
        return this.realms.default;
      }
      isolatedRealm() {
        return this.realms.internal;
      }
      realm(id) {
        for (const realm of Object.values(this.realms)) {
          if (realm.realm.id === id) {
            return realm;
          }
        }
        return;
      }
      page() {
        let parent = __privateGet(this, _parent);
        while (parent instanceof _a3) {
          parent = __privateGet(parent, _parent);
        }
        return parent;
      }
      url() {
        return this.browsingContext.url;
      }
      parentFrame() {
        if (__privateGet(this, _parent) instanceof _a3) {
          return __privateGet(this, _parent);
        }
        return null;
      }
      childFrames() {
        return [...this.browsingContext.children].map((child) => {
          return __privateGet(this, _frames2).get(child);
        });
      }
      async goto(url, options = {}) {
        const [response] = await Promise.all([
          this.waitForNavigation(options),
          // Some implementations currently only report errors when the
          // readiness=interactive.
          //
          // Related: https://bugzilla.mozilla.org/show_bug.cgi?id=1846601
          this.browsingContext.navigate(
            url,
            "interactive"
            /* Bidi.BrowsingContext.ReadinessState.Interactive */
          ).catch((error) => {
            if (isErrorLike(error) && error.message.includes("net::ERR_HTTP_RESPONSE_CODE_FAILURE")) {
              return;
            }
            if (error.message.includes("navigation canceled")) {
              return;
            }
            if (error.message.includes("Navigation was aborted by another navigation")) {
              return;
            }
            throw error;
          })
        ]).catch(rewriteNavigationError(url, options.timeout ?? this.timeoutSettings.navigationTimeout()));
        return response;
      }
      async setContent(html, options = {}) {
        await Promise.all([
          this.setFrameContent(html),
          firstValueFrom(combineLatest([
            __privateGet(this, _BidiFrame_instances, waitForLoad$_get).call(this, options),
            __privateGet(this, _BidiFrame_instances, waitForNetworkIdle$_get).call(this, options)
          ]))
        ]);
      }
      async waitForNavigation(options = {}) {
        const { timeout: ms2 = this.timeoutSettings.navigationTimeout(), signal } = options;
        const frames = this.childFrames().map((frame) => {
          var _a4;
          return __privateMethod(_a4 = frame, _BidiFrame_instances, detached$_fn).call(_a4);
        });
        return await firstValueFrom(combineLatest([
          race(fromEmitterEvent(this.browsingContext, "navigation"), fromEmitterEvent(this.browsingContext, "historyUpdated").pipe(map(() => {
            return { navigation: null };
          }))).pipe(first()).pipe(switchMap(({ navigation }) => {
            if (navigation === null) {
              return of(null);
            }
            return __privateGet(this, _BidiFrame_instances, waitForLoad$_get).call(this, options).pipe(delayWhen(() => {
              if (frames.length === 0) {
                return of(void 0);
              }
              return combineLatest(frames);
            }), raceWith(fromEmitterEvent(navigation, "fragment"), fromEmitterEvent(navigation, "failed"), fromEmitterEvent(navigation, "aborted").pipe(map(({ url }) => {
              throw new Error(`Navigation aborted: ${url}`);
            }))), switchMap(() => {
              if (navigation.request) {
                let requestFinished$ = function(request) {
                  if (navigation === null) {
                    return of(null);
                  }
                  if (request.response || request.error) {
                    return of(navigation);
                  }
                  if (request.redirect) {
                    return requestFinished$(request.redirect);
                  }
                  return fromEmitterEvent(request, "success").pipe(raceWith(fromEmitterEvent(request, "error")), raceWith(fromEmitterEvent(request, "redirect"))).pipe(switchMap(() => {
                    return requestFinished$(request);
                  }));
                };
                return requestFinished$(navigation.request);
              }
              return of(navigation);
            }));
          })),
          __privateGet(this, _BidiFrame_instances, waitForNetworkIdle$_get).call(this, options)
        ]).pipe(map(([navigation]) => {
          if (!navigation) {
            return null;
          }
          const request = navigation.request;
          if (!request) {
            return null;
          }
          const lastRequest = request.lastRedirect ?? request;
          const httpRequest = requests.get(lastRequest);
          return httpRequest.response();
        }), raceWith(timeout(ms2), fromAbortSignal(signal), __privateMethod(this, _BidiFrame_instances, detached$_fn).call(this).pipe(map(() => {
          throw new TargetCloseError("Frame detached.");
        })))));
      }
      waitForDevicePrompt() {
        throw new UnsupportedOperation();
      }
      get detached() {
        return this.browsingContext.closed;
      }
      async exposeFunction(name, apply) {
        if (__privateGet(this, _exposedFunctions2).has(name)) {
          throw new Error(`Failed to add page binding with name ${name}: globalThis['${name}'] already exists!`);
        }
        const exposeable = await ExposeableFunction.from(this, name, apply);
        __privateGet(this, _exposedFunctions2).set(name, exposeable);
      }
      async removeExposedFunction(name) {
        const exposedFunction = __privateGet(this, _exposedFunctions2).get(name);
        if (!exposedFunction) {
          throw new Error(`Failed to remove page binding with name ${name}: window['${name}'] does not exists!`);
        }
        __privateGet(this, _exposedFunctions2).delete(name);
        await exposedFunction[Symbol.asyncDispose]();
      }
      async createCDPSession() {
        if (!this.page().browser().cdpSupported) {
          throw new UnsupportedOperation();
        }
        const cdpConnection = this.page().browser().cdpConnection;
        return await cdpConnection._createSession({ targetId: this._id });
      }
      async setFiles(element, files) {
        await this.browsingContext.setFiles(
          // SAFETY: ElementHandles are always remote references.
          element.remoteValue(),
          files
        );
      }
      async locateNodes(element, locator) {
        return await this.browsingContext.locateNodes(
          locator,
          // SAFETY: ElementHandles are always remote references.
          [element.remoteValue()]
        );
      }
    }, _parent = new WeakMap(), _frames2 = new WeakMap(), _BidiFrame_instances = new WeakSet(), initialize_fn8 = function() {
      for (const browsingContext of this.browsingContext.children) {
        __privateMethod(this, _BidiFrame_instances, createFrameTarget_fn).call(this, browsingContext);
      }
      this.browsingContext.on("browsingcontext", ({ browsingContext }) => {
        __privateMethod(this, _BidiFrame_instances, createFrameTarget_fn).call(this, browsingContext);
      });
      this.browsingContext.on("closed", () => {
        for (const session of BidiCdpSession.sessions.values()) {
          if (session.frame === this) {
            session.onClose();
          }
        }
        this.page().trustedEmitter.emit("framedetached", this);
      });
      this.browsingContext.on("request", ({ request }) => {
        const httpRequest = BidiHTTPRequest.from(request, this);
        request.once("success", () => {
          this.page().trustedEmitter.emit("requestfinished", httpRequest);
        });
        request.once("error", () => {
          this.page().trustedEmitter.emit("requestfailed", httpRequest);
        });
        void httpRequest.finalizeInterceptions();
      });
      this.browsingContext.on("navigation", ({ navigation }) => {
        navigation.once("fragment", () => {
          this.page().trustedEmitter.emit("framenavigated", this);
        });
      });
      this.browsingContext.on("load", () => {
        this.page().trustedEmitter.emit("load", void 0);
      });
      this.browsingContext.on("DOMContentLoaded", () => {
        this._hasStartedLoading = true;
        this.page().trustedEmitter.emit("domcontentloaded", void 0);
        this.page().trustedEmitter.emit("framenavigated", this);
      });
      this.browsingContext.on("userprompt", ({ userPrompt }) => {
        this.page().trustedEmitter.emit("dialog", BidiDialog.from(userPrompt));
      });
      this.browsingContext.on("log", ({ entry }) => {
        if (this._id !== entry.source.context) {
          return;
        }
        if (isConsoleLogEntry(entry)) {
          const args = entry.args.map((arg) => {
            return this.mainRealm().createHandle(arg);
          });
          const text = args.reduce((value, arg) => {
            const parsedValue = arg instanceof BidiJSHandle && arg.isPrimitiveValue ? BidiDeserializer.deserialize(arg.remoteValue()) : arg.toString();
            return `${value} ${parsedValue}`;
          }, "").slice(1);
          this.page().trustedEmitter.emit("console", new ConsoleMessage(convertConsoleMessageLevel(entry.method), text, args, getStackTraceLocations(entry.stackTrace), this));
        } else if (isJavaScriptLogEntry(entry)) {
          const error = new Error(entry.text ?? "");
          const messageHeight = error.message.split("\n").length;
          const messageLines = error.stack.split("\n").splice(0, messageHeight);
          const stackLines = [];
          if (entry.stackTrace) {
            for (const frame of entry.stackTrace.callFrames) {
              stackLines.push(`    at ${frame.functionName || "<anonymous>"} (${frame.url}:${frame.lineNumber + 1}:${frame.columnNumber + 1})`);
              if (stackLines.length >= Error.stackTraceLimit) {
                break;
              }
            }
          }
          error.stack = [...messageLines, ...stackLines].join("\n");
          this.page().trustedEmitter.emit("pageerror", error);
        } else {
          debugError(`Unhandled LogEntry with type "${entry.type}", text "${entry.text}" and level "${entry.level}"`);
        }
      });
      this.browsingContext.on("worker", ({ realm }) => {
        const worker = BidiWebWorker.from(this, realm);
        realm.on("destroyed", () => {
          this.page().trustedEmitter.emit("workerdestroyed", worker);
        });
        this.page().trustedEmitter.emit("workercreated", worker);
      });
    }, createFrameTarget_fn = function(browsingContext) {
      const frame = _a3.from(this, browsingContext);
      __privateGet(this, _frames2).set(browsingContext, frame);
      this.page().trustedEmitter.emit("frameattached", frame);
      browsingContext.on("closed", () => {
        __privateGet(this, _frames2).delete(browsingContext);
      });
      return frame;
    }, detached$_fn = function() {
      return defer(() => {
        if (this.detached) {
          return of(this);
        }
        return fromEmitterEvent(
          this.page().trustedEmitter,
          "framedetached"
          /* PageEvent.FrameDetached */
        ).pipe(filter((detachedFrame) => {
          return detachedFrame === this;
        }));
      });
    }, _exposedFunctions2 = new WeakMap(), waitForLoad$_get = function() {
      return _private_waitForLoad$_descriptor.value;
    }, waitForNetworkIdle$_get = function() {
      return _private_waitForNetworkIdle$_descriptor.value;
    }, (() => {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      _goto_decorators = [throwIfDetached];
      _setContent_decorators = [throwIfDetached];
      _waitForNavigation_decorators = [throwIfDetached];
      _private_waitForLoad$_decorators = [throwIfDetached];
      _private_waitForNetworkIdle$_decorators = [throwIfDetached];
      _setFiles_decorators = [throwIfDetached];
      _locateNodes_decorators = [throwIfDetached];
      __esDecorate$5(_a3, null, _goto_decorators, { kind: "method", name: "goto", static: false, private: false, access: { has: (obj) => "goto" in obj, get: (obj) => obj.goto }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$5(_a3, null, _setContent_decorators, { kind: "method", name: "setContent", static: false, private: false, access: { has: (obj) => "setContent" in obj, get: (obj) => obj.setContent }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$5(_a3, null, _waitForNavigation_decorators, { kind: "method", name: "waitForNavigation", static: false, private: false, access: { has: (obj) => "waitForNavigation" in obj, get: (obj) => obj.waitForNavigation }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$5(_a3, _private_waitForLoad$_descriptor = { value: __setFunctionName$1(function(options = {}) {
        let { waitUntil = "load" } = options;
        const { timeout: ms2 = this.timeoutSettings.navigationTimeout() } = options;
        if (!Array.isArray(waitUntil)) {
          waitUntil = [waitUntil];
        }
        const events2 = /* @__PURE__ */ new Set();
        for (const lifecycleEvent of waitUntil) {
          switch (lifecycleEvent) {
            case "load": {
              events2.add("load");
              break;
            }
            case "domcontentloaded": {
              events2.add("DOMContentLoaded");
              break;
            }
          }
        }
        if (events2.size === 0) {
          return of(void 0);
        }
        return combineLatest([...events2].map((event) => {
          return fromEmitterEvent(this.browsingContext, event);
        })).pipe(map(() => {
        }), first(), raceWith(timeout(ms2), __privateMethod(this, _BidiFrame_instances, detached$_fn).call(this).pipe(map(() => {
          throw new Error("Frame detached.");
        }))));
      }, "#waitForLoad$") }, _private_waitForLoad$_decorators, { kind: "method", name: "#waitForLoad$", static: false, private: true, access: { has: (obj) => __privateIn(_BidiFrame_instances, obj), get: (obj) => __privateGet(obj, _BidiFrame_instances, waitForLoad$_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$5(_a3, _private_waitForNetworkIdle$_descriptor = { value: __setFunctionName$1(function(options = {}) {
        let { waitUntil = "load" } = options;
        if (!Array.isArray(waitUntil)) {
          waitUntil = [waitUntil];
        }
        let concurrency = Infinity;
        for (const event of waitUntil) {
          switch (event) {
            case "networkidle0": {
              concurrency = Math.min(0, concurrency);
              break;
            }
            case "networkidle2": {
              concurrency = Math.min(2, concurrency);
              break;
            }
          }
        }
        if (concurrency === Infinity) {
          return of(void 0);
        }
        return this.page().waitForNetworkIdle$({
          idleTime: 500,
          timeout: options.timeout ?? this.timeoutSettings.timeout(),
          concurrency
        });
      }, "#waitForNetworkIdle$") }, _private_waitForNetworkIdle$_decorators, { kind: "method", name: "#waitForNetworkIdle$", static: false, private: true, access: { has: (obj) => __privateIn(_BidiFrame_instances, obj), get: (obj) => __privateGet(obj, _BidiFrame_instances, waitForNetworkIdle$_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$5(_a3, null, _setFiles_decorators, { kind: "method", name: "setFiles", static: false, private: false, access: { has: (obj) => "setFiles" in obj, get: (obj) => obj.setFiles }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$5(_a3, null, _locateNodes_decorators, { kind: "method", name: "locateNodes", static: false, private: false, access: { has: (obj) => "locateNodes" in obj, get: (obj) => obj.locateNodes }, metadata: _metadata }, null, _instanceExtraInitializers);
      if (_metadata) Object.defineProperty(_a3, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    })(), _a3;
  })();
  function isConsoleLogEntry(event) {
    return event.type === "console";
  }
  function isJavaScriptLogEntry(event) {
    return event.type === "javascript";
  }
  function getStackTraceLocations(stackTrace) {
    const stackTraceLocations = [];
    if (stackTrace) {
      for (const callFrame of stackTrace.callFrames) {
        stackTraceLocations.push({
          url: callFrame.url,
          lineNumber: callFrame.lineNumber,
          columnNumber: callFrame.columnNumber
        });
      }
    }
    return stackTraceLocations;
  }
  /**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var SourceActionsType;
  (function(SourceActionsType2) {
    SourceActionsType2["None"] = "none";
    SourceActionsType2["Key"] = "key";
    SourceActionsType2["Pointer"] = "pointer";
    SourceActionsType2["Wheel"] = "wheel";
  })(SourceActionsType || (SourceActionsType = {}));
  var ActionType;
  (function(ActionType2) {
    ActionType2["Pause"] = "pause";
    ActionType2["KeyDown"] = "keyDown";
    ActionType2["KeyUp"] = "keyUp";
    ActionType2["PointerUp"] = "pointerUp";
    ActionType2["PointerDown"] = "pointerDown";
    ActionType2["PointerMove"] = "pointerMove";
    ActionType2["Scroll"] = "scroll";
  })(ActionType || (ActionType = {}));
  const getBidiKeyValue = (key) => {
    switch (key) {
      case "\r":
      case "\n":
        key = "Enter";
        break;
    }
    if ([...key].length === 1) {
      return key;
    }
    switch (key) {
      case "Cancel":
        return "";
      case "Help":
        return "";
      case "Backspace":
        return "";
      case "Tab":
        return "";
      case "Clear":
        return "";
      case "Enter":
        return "";
      case "Shift":
      case "ShiftLeft":
        return "";
      case "Control":
      case "ControlLeft":
        return "";
      case "Alt":
      case "AltLeft":
        return "";
      case "Pause":
        return "";
      case "Escape":
        return "";
      case "PageUp":
        return "";
      case "PageDown":
        return "";
      case "End":
        return "";
      case "Home":
        return "";
      case "ArrowLeft":
        return "";
      case "ArrowUp":
        return "";
      case "ArrowRight":
        return "";
      case "ArrowDown":
        return "";
      case "Insert":
        return "";
      case "Delete":
        return "";
      case "NumpadEqual":
        return "";
      case "Numpad0":
        return "";
      case "Numpad1":
        return "";
      case "Numpad2":
        return "";
      case "Numpad3":
        return "";
      case "Numpad4":
        return "";
      case "Numpad5":
        return "";
      case "Numpad6":
        return "";
      case "Numpad7":
        return "";
      case "Numpad8":
        return "";
      case "Numpad9":
        return "";
      case "NumpadMultiply":
        return "";
      case "NumpadAdd":
        return "";
      case "NumpadSubtract":
        return "";
      case "NumpadDecimal":
        return "";
      case "NumpadDivide":
        return "";
      case "F1":
        return "";
      case "F2":
        return "";
      case "F3":
        return "";
      case "F4":
        return "";
      case "F5":
        return "";
      case "F6":
        return "";
      case "F7":
        return "";
      case "F8":
        return "";
      case "F9":
        return "";
      case "F10":
        return "";
      case "F11":
        return "";
      case "F12":
        return "";
      case "Meta":
      case "MetaLeft":
        return "";
      case "ShiftRight":
        return "";
      case "ControlRight":
        return "";
      case "AltRight":
        return "";
      case "MetaRight":
        return "";
      case "Digit0":
        return "0";
      case "Digit1":
        return "1";
      case "Digit2":
        return "2";
      case "Digit3":
        return "3";
      case "Digit4":
        return "4";
      case "Digit5":
        return "5";
      case "Digit6":
        return "6";
      case "Digit7":
        return "7";
      case "Digit8":
        return "8";
      case "Digit9":
        return "9";
      case "KeyA":
        return "a";
      case "KeyB":
        return "b";
      case "KeyC":
        return "c";
      case "KeyD":
        return "d";
      case "KeyE":
        return "e";
      case "KeyF":
        return "f";
      case "KeyG":
        return "g";
      case "KeyH":
        return "h";
      case "KeyI":
        return "i";
      case "KeyJ":
        return "j";
      case "KeyK":
        return "k";
      case "KeyL":
        return "l";
      case "KeyM":
        return "m";
      case "KeyN":
        return "n";
      case "KeyO":
        return "o";
      case "KeyP":
        return "p";
      case "KeyQ":
        return "q";
      case "KeyR":
        return "r";
      case "KeyS":
        return "s";
      case "KeyT":
        return "t";
      case "KeyU":
        return "u";
      case "KeyV":
        return "v";
      case "KeyW":
        return "w";
      case "KeyX":
        return "x";
      case "KeyY":
        return "y";
      case "KeyZ":
        return "z";
      case "Semicolon":
        return ";";
      case "Equal":
        return "=";
      case "Comma":
        return ",";
      case "Minus":
        return "-";
      case "Period":
        return ".";
      case "Slash":
        return "/";
      case "Backquote":
        return "`";
      case "BracketLeft":
        return "[";
      case "Backslash":
        return "\\";
      case "BracketRight":
        return "]";
      case "Quote":
        return '"';
      default:
        throw new Error(`Unknown key: "${key}"`);
    }
  };
  class BidiKeyboard extends Keyboard {
    constructor(page) {
      super();
      __privateAdd(this, _page2);
      __privateSet(this, _page2, page);
    }
    async down(key, _options) {
      await __privateGet(this, _page2).mainFrame().browsingContext.performActions([
        {
          type: SourceActionsType.Key,
          id: "__puppeteer_keyboard",
          actions: [
            {
              type: ActionType.KeyDown,
              value: getBidiKeyValue(key)
            }
          ]
        }
      ]);
    }
    async up(key) {
      await __privateGet(this, _page2).mainFrame().browsingContext.performActions([
        {
          type: SourceActionsType.Key,
          id: "__puppeteer_keyboard",
          actions: [
            {
              type: ActionType.KeyUp,
              value: getBidiKeyValue(key)
            }
          ]
        }
      ]);
    }
    async press(key, options = {}) {
      const { delay = 0 } = options;
      const actions = [
        {
          type: ActionType.KeyDown,
          value: getBidiKeyValue(key)
        }
      ];
      if (delay > 0) {
        actions.push({
          type: ActionType.Pause,
          duration: delay
        });
      }
      actions.push({
        type: ActionType.KeyUp,
        value: getBidiKeyValue(key)
      });
      await __privateGet(this, _page2).mainFrame().browsingContext.performActions([
        {
          type: SourceActionsType.Key,
          id: "__puppeteer_keyboard",
          actions
        }
      ]);
    }
    async type(text, options = {}) {
      const { delay = 0 } = options;
      const values = [...text].map(getBidiKeyValue);
      const actions = [];
      if (delay <= 0) {
        for (const value of values) {
          actions.push({
            type: ActionType.KeyDown,
            value
          }, {
            type: ActionType.KeyUp,
            value
          });
        }
      } else {
        for (const value of values) {
          actions.push({
            type: ActionType.KeyDown,
            value
          }, {
            type: ActionType.Pause,
            duration: delay
          }, {
            type: ActionType.KeyUp,
            value
          });
        }
      }
      await __privateGet(this, _page2).mainFrame().browsingContext.performActions([
        {
          type: SourceActionsType.Key,
          id: "__puppeteer_keyboard",
          actions
        }
      ]);
    }
    async sendCharacter(char) {
      if ([...char].length > 1) {
        throw new Error("Cannot send more than 1 character.");
      }
      const frame = await __privateGet(this, _page2).focusedFrame();
      await frame.isolatedRealm().evaluate(async (char2) => {
        document.execCommand("insertText", false, char2);
      }, char);
    }
  }
  _page2 = new WeakMap();
  const getBidiButton = (button) => {
    switch (button) {
      case MouseButton.Left:
        return 0;
      case MouseButton.Middle:
        return 1;
      case MouseButton.Right:
        return 2;
      case MouseButton.Back:
        return 3;
      case MouseButton.Forward:
        return 4;
    }
  };
  class BidiMouse extends Mouse {
    constructor(page) {
      super();
      __privateAdd(this, _page3);
      __privateAdd(this, _lastMovePoint, { x: 0, y: 0 });
      __privateSet(this, _page3, page);
    }
    async reset() {
      __privateSet(this, _lastMovePoint, { x: 0, y: 0 });
      await __privateGet(this, _page3).mainFrame().browsingContext.releaseActions();
    }
    async move(x, y, options = {}) {
      const from2 = __privateGet(this, _lastMovePoint);
      const to = {
        x: Math.round(x),
        y: Math.round(y)
      };
      const actions = [];
      const steps = options.steps ?? 0;
      for (let i2 = 0; i2 < steps; ++i2) {
        actions.push({
          type: ActionType.PointerMove,
          x: from2.x + (to.x - from2.x) * (i2 / steps),
          y: from2.y + (to.y - from2.y) * (i2 / steps),
          origin: options.origin
        });
      }
      actions.push({
        type: ActionType.PointerMove,
        ...to,
        origin: options.origin
      });
      __privateSet(this, _lastMovePoint, to);
      await __privateGet(this, _page3).mainFrame().browsingContext.performActions([
        {
          type: SourceActionsType.Pointer,
          id: "__puppeteer_mouse",
          actions
        }
      ]);
    }
    async down(options = {}) {
      await __privateGet(this, _page3).mainFrame().browsingContext.performActions([
        {
          type: SourceActionsType.Pointer,
          id: "__puppeteer_mouse",
          actions: [
            {
              type: ActionType.PointerDown,
              button: getBidiButton(options.button ?? MouseButton.Left)
            }
          ]
        }
      ]);
    }
    async up(options = {}) {
      await __privateGet(this, _page3).mainFrame().browsingContext.performActions([
        {
          type: SourceActionsType.Pointer,
          id: "__puppeteer_mouse",
          actions: [
            {
              type: ActionType.PointerUp,
              button: getBidiButton(options.button ?? MouseButton.Left)
            }
          ]
        }
      ]);
    }
    async click(x, y, options = {}) {
      const actions = [
        {
          type: ActionType.PointerMove,
          x: Math.round(x),
          y: Math.round(y),
          origin: options.origin
        }
      ];
      const pointerDownAction = {
        type: ActionType.PointerDown,
        button: getBidiButton(options.button ?? MouseButton.Left)
      };
      const pointerUpAction = {
        type: ActionType.PointerUp,
        button: pointerDownAction.button
      };
      for (let i2 = 1; i2 < (options.count ?? 1); ++i2) {
        actions.push(pointerDownAction, pointerUpAction);
      }
      actions.push(pointerDownAction);
      if (options.delay) {
        actions.push({
          type: ActionType.Pause,
          duration: options.delay
        });
      }
      actions.push(pointerUpAction);
      await __privateGet(this, _page3).mainFrame().browsingContext.performActions([
        {
          type: SourceActionsType.Pointer,
          id: "__puppeteer_mouse",
          actions
        }
      ]);
    }
    async wheel(options = {}) {
      await __privateGet(this, _page3).mainFrame().browsingContext.performActions([
        {
          type: SourceActionsType.Wheel,
          id: "__puppeteer_wheel",
          actions: [
            {
              type: ActionType.Scroll,
              ...__privateGet(this, _lastMovePoint) ?? {
                x: 0,
                y: 0
              },
              deltaX: options.deltaX ?? 0,
              deltaY: options.deltaY ?? 0
            }
          ]
        }
      ]);
    }
    drag() {
      throw new UnsupportedOperation();
    }
    dragOver() {
      throw new UnsupportedOperation();
    }
    dragEnter() {
      throw new UnsupportedOperation();
    }
    drop() {
      throw new UnsupportedOperation();
    }
    dragAndDrop() {
      throw new UnsupportedOperation();
    }
  }
  _page3 = new WeakMap();
  _lastMovePoint = new WeakMap();
  class BidiTouchHandle {
    constructor(page, touchScreen, id, x, y, properties) {
      __privateAdd(this, _started2, false);
      __privateAdd(this, _x);
      __privateAdd(this, _y);
      __privateAdd(this, _bidiId);
      __privateAdd(this, _page4);
      __privateAdd(this, _touchScreen2);
      __privateAdd(this, _properties);
      __privateSet(this, _page4, page);
      __privateSet(this, _touchScreen2, touchScreen);
      __privateSet(this, _x, Math.round(x));
      __privateSet(this, _y, Math.round(y));
      __privateSet(this, _properties, properties);
      __privateSet(this, _bidiId, `${"__puppeteer_finger"}_${id}`);
    }
    async start(options = {}) {
      if (__privateGet(this, _started2)) {
        throw new TouchError("Touch has already started");
      }
      await __privateGet(this, _page4).mainFrame().browsingContext.performActions([
        {
          type: SourceActionsType.Pointer,
          id: __privateGet(this, _bidiId),
          parameters: {
            pointerType: "touch"
          },
          actions: [
            {
              type: ActionType.PointerMove,
              x: __privateGet(this, _x),
              y: __privateGet(this, _y),
              origin: options.origin
            },
            {
              ...__privateGet(this, _properties),
              type: ActionType.PointerDown,
              button: 0
            }
          ]
        }
      ]);
      __privateSet(this, _started2, true);
    }
    move(x, y) {
      const newX = Math.round(x);
      const newY = Math.round(y);
      return __privateGet(this, _page4).mainFrame().browsingContext.performActions([
        {
          type: SourceActionsType.Pointer,
          id: __privateGet(this, _bidiId),
          parameters: {
            pointerType: "touch"
          },
          actions: [
            {
              ...__privateGet(this, _properties),
              type: ActionType.PointerMove,
              x: newX,
              y: newY
            }
          ]
        }
      ]);
    }
    async end() {
      await __privateGet(this, _page4).mainFrame().browsingContext.performActions([
        {
          type: SourceActionsType.Pointer,
          id: __privateGet(this, _bidiId),
          parameters: {
            pointerType: "touch"
          },
          actions: [
            {
              type: ActionType.PointerUp,
              button: 0
            }
          ]
        }
      ]);
      __privateGet(this, _touchScreen2).removeHandle(this);
    }
  }
  _started2 = new WeakMap();
  _x = new WeakMap();
  _y = new WeakMap();
  _bidiId = new WeakMap();
  _page4 = new WeakMap();
  _touchScreen2 = new WeakMap();
  _properties = new WeakMap();
  class BidiTouchscreen extends Touchscreen {
    constructor(page) {
      super();
      __privateAdd(this, _page5);
      __privateSet(this, _page5, page);
    }
    async touchStart(x, y, options = {}) {
      const id = this.idGenerator();
      const properties = {
        width: 0.5 * 2,
        // 2 times default touch radius.
        height: 0.5 * 2,
        // 2 times default touch radius.
        pressure: 0.5,
        altitudeAngle: Math.PI / 2
      };
      const touch = new BidiTouchHandle(__privateGet(this, _page5), this, id, x, y, properties);
      await touch.start(options);
      this.touches.push(touch);
      return touch;
    }
  }
  _page5 = new WeakMap();
  /**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var __esDecorate$4 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind2 = contextIn.kind, key = kind2 === "getter" ? "get" : kind2 === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function(f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i2])(kind2 === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind2 === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_ = accept(result.get)) descriptor.get = _;
        if (_ = accept(result.set)) descriptor.set = _;
        if (_ = accept(result.init)) initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind2 === "field") initializers.unshift(_);
        else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  var __runInitializers$4 = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i2 = 0; i2 < initializers.length; i2++) {
      value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __addDisposableResource$2 = function(env, value, async2) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async2) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async2) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({ value, dispose, async: async2 });
    } else if (async2) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources$2 = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  let BidiPage = (() => {
    var _trustedEmitter_accessor_storage, _browserContext2, _frame9, _viewport2, _workers5, _cdpEmulationManager, _emulatedNetworkConditions2, _BidiPage_instances, initialize_fn8, _userAgentInterception, _userAgentPreloadScript, _userInterception, _extraHeadersInterception, _authInterception, toggleInterception_fn, applyNetworkConditions_fn2, go_fn2, _a3;
    let _classSuper = Page$4;
    let _trustedEmitter_decorators;
    let _trustedEmitter_initializers = [];
    let _trustedEmitter_extraInitializers = [];
    return _a3 = class extends _classSuper {
      constructor(browserContext2, browsingContext) {
        super();
        __privateAdd(this, _BidiPage_instances);
        __privateAdd(this, _trustedEmitter_accessor_storage, __runInitializers$4(this, _trustedEmitter_initializers, new EventEmitter$1()));
        __privateAdd(this, _browserContext2, __runInitializers$4(this, _trustedEmitter_extraInitializers));
        __privateAdd(this, _frame9);
        __privateAdd(this, _viewport2, null);
        __privateAdd(this, _workers5, /* @__PURE__ */ new Set());
        __publicField(this, "keyboard");
        __publicField(this, "mouse");
        __publicField(this, "touchscreen");
        __publicField(this, "tracing");
        __publicField(this, "coverage");
        __privateAdd(this, _cdpEmulationManager);
        __privateAdd(this, _emulatedNetworkConditions2);
        /**
         * @internal
         */
        __publicField(this, "_userAgentHeaders", {});
        __privateAdd(this, _userAgentInterception);
        __privateAdd(this, _userAgentPreloadScript);
        __privateAdd(this, _userInterception);
        /**
         * @internal
         */
        __publicField(this, "_extraHTTPHeaders", {});
        __privateAdd(this, _extraHeadersInterception);
        /**
         * @internal
         */
        __publicField(this, "_credentials", null);
        __privateAdd(this, _authInterception);
        __privateSet(this, _browserContext2, browserContext2);
        __privateSet(this, _frame9, BidiFrame.from(this, browsingContext));
        __privateSet(this, _cdpEmulationManager, new EmulationManager(__privateGet(this, _frame9).client));
        this.tracing = new Tracing(__privateGet(this, _frame9).client);
        this.coverage = new Coverage(__privateGet(this, _frame9).client);
        this.keyboard = new BidiKeyboard(this);
        this.mouse = new BidiMouse(this);
        this.touchscreen = new BidiTouchscreen(this);
      }
      static from(browserContext2, browsingContext) {
        var _a4;
        const page = new _a3(browserContext2, browsingContext);
        __privateMethod(_a4 = page, _BidiPage_instances, initialize_fn8).call(_a4);
        return page;
      }
      get trustedEmitter() {
        return __privateGet(this, _trustedEmitter_accessor_storage);
      }
      set trustedEmitter(value) {
        __privateSet(this, _trustedEmitter_accessor_storage, value);
      }
      _client() {
        return __privateGet(this, _frame9).client;
      }
      async setUserAgent(userAgent, userAgentMetadata) {
        if (!__privateGet(this, _browserContext2).browser().cdpSupported && userAgentMetadata) {
          throw new UnsupportedOperation("Current Browser does not support `userAgentMetadata`");
        } else if (__privateGet(this, _browserContext2).browser().cdpSupported && userAgentMetadata) {
          return await this._client().send("Network.setUserAgentOverride", {
            userAgent,
            userAgentMetadata
          });
        }
        const enable = userAgent !== "";
        userAgent = userAgent ?? await __privateGet(this, _browserContext2).browser().userAgent();
        this._userAgentHeaders = enable ? {
          "User-Agent": userAgent
        } : {};
        __privateSet(this, _userAgentInterception, await __privateMethod(this, _BidiPage_instances, toggleInterception_fn).call(this, [
          "beforeRequestSent"
          /* Bidi.Network.InterceptPhase.BeforeRequestSent */
        ], __privateGet(this, _userAgentInterception), enable));
        const changeUserAgent = (userAgent2) => {
          Object.defineProperty(navigator, "userAgent", {
            value: userAgent2
          });
        };
        const frames = [__privateGet(this, _frame9)];
        for (const frame of frames) {
          frames.push(...frame.childFrames());
        }
        if (__privateGet(this, _userAgentPreloadScript)) {
          await this.removeScriptToEvaluateOnNewDocument(__privateGet(this, _userAgentPreloadScript));
        }
        const [evaluateToken] = await Promise.all([
          enable ? this.evaluateOnNewDocument(changeUserAgent, userAgent) : void 0,
          // When we disable the UserAgent we want to
          // evaluate the original value in all Browsing Contexts
          frames.map((frame) => {
            return frame.evaluate(changeUserAgent, userAgent);
          })
        ]);
        __privateSet(this, _userAgentPreloadScript, evaluateToken == null ? void 0 : evaluateToken.identifier);
      }
      async setBypassCSP(enabled) {
        await this._client().send("Page.setBypassCSP", { enabled });
      }
      async queryObjects(prototypeHandle) {
        assert$1(!prototypeHandle.disposed, "Prototype JSHandle is disposed!");
        assert$1(prototypeHandle.id, "Prototype JSHandle must not be referencing primitive value");
        const response = await __privateGet(this, _frame9).client.send("Runtime.queryObjects", {
          prototypeObjectId: prototypeHandle.id
        });
        return __privateGet(this, _frame9).mainRealm().createHandle({
          type: "array",
          handle: response.objects.objectId
        });
      }
      browser() {
        return this.browserContext().browser();
      }
      browserContext() {
        return __privateGet(this, _browserContext2);
      }
      mainFrame() {
        return __privateGet(this, _frame9);
      }
      async focusedFrame() {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
          const handle = __addDisposableResource$2(env_1, await this.mainFrame().isolatedRealm().evaluateHandle(() => {
            let win = window;
            while (win.document.activeElement instanceof win.HTMLIFrameElement || win.document.activeElement instanceof win.HTMLFrameElement) {
              if (win.document.activeElement.contentWindow === null) {
                break;
              }
              win = win.document.activeElement.contentWindow;
            }
            return win;
          }), false);
          const value = handle.remoteValue();
          assert$1(value.type === "window");
          const frame = this.frames().find((frame2) => {
            return frame2._id === value.value.context;
          });
          assert$1(frame);
          return frame;
        } catch (e_1) {
          env_1.error = e_1;
          env_1.hasError = true;
        } finally {
          __disposeResources$2(env_1);
        }
      }
      frames() {
        const frames = [__privateGet(this, _frame9)];
        for (const frame of frames) {
          frames.push(...frame.childFrames());
        }
        return frames;
      }
      isClosed() {
        return __privateGet(this, _frame9).detached;
      }
      async close(options) {
        const env_2 = { stack: [], error: void 0, hasError: false };
        try {
          const _guard = __addDisposableResource$2(env_2, await __privateGet(this, _browserContext2).waitForScreenshotOperations(), false);
          try {
            await __privateGet(this, _frame9).browsingContext.close(options == null ? void 0 : options.runBeforeUnload);
          } catch {
            return;
          }
        } catch (e_2) {
          env_2.error = e_2;
          env_2.hasError = true;
        } finally {
          __disposeResources$2(env_2);
        }
      }
      async reload(options = {}) {
        const [response] = await Promise.all([
          __privateGet(this, _frame9).waitForNavigation(options),
          __privateGet(this, _frame9).browsingContext.reload()
        ]).catch(rewriteNavigationError(this.url(), options.timeout ?? this._timeoutSettings.navigationTimeout()));
        return response;
      }
      setDefaultNavigationTimeout(timeout2) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout2);
      }
      setDefaultTimeout(timeout2) {
        this._timeoutSettings.setDefaultTimeout(timeout2);
      }
      getDefaultTimeout() {
        return this._timeoutSettings.timeout();
      }
      getDefaultNavigationTimeout() {
        return this._timeoutSettings.navigationTimeout();
      }
      isJavaScriptEnabled() {
        return __privateGet(this, _cdpEmulationManager).javascriptEnabled;
      }
      async setGeolocation(options) {
        return await __privateGet(this, _cdpEmulationManager).setGeolocation(options);
      }
      async setJavaScriptEnabled(enabled) {
        return await __privateGet(this, _cdpEmulationManager).setJavaScriptEnabled(enabled);
      }
      async emulateMediaType(type) {
        return await __privateGet(this, _cdpEmulationManager).emulateMediaType(type);
      }
      async emulateCPUThrottling(factor) {
        return await __privateGet(this, _cdpEmulationManager).emulateCPUThrottling(factor);
      }
      async emulateMediaFeatures(features) {
        return await __privateGet(this, _cdpEmulationManager).emulateMediaFeatures(features);
      }
      async emulateTimezone(timezoneId) {
        return await __privateGet(this, _cdpEmulationManager).emulateTimezone(timezoneId);
      }
      async emulateIdleState(overrides) {
        return await __privateGet(this, _cdpEmulationManager).emulateIdleState(overrides);
      }
      async emulateVisionDeficiency(type) {
        return await __privateGet(this, _cdpEmulationManager).emulateVisionDeficiency(type);
      }
      async setViewport(viewport) {
        if (!this.browser().cdpSupported) {
          await __privateGet(this, _frame9).browsingContext.setViewport({
            viewport: (viewport == null ? void 0 : viewport.width) && (viewport == null ? void 0 : viewport.height) ? {
              width: viewport.width,
              height: viewport.height
            } : null,
            devicePixelRatio: (viewport == null ? void 0 : viewport.deviceScaleFactor) ? viewport.deviceScaleFactor : null
          });
          __privateSet(this, _viewport2, viewport);
          return;
        }
        const needsReload = await __privateGet(this, _cdpEmulationManager).emulateViewport(viewport);
        __privateSet(this, _viewport2, viewport);
        if (needsReload) {
          await this.reload();
        }
      }
      viewport() {
        return __privateGet(this, _viewport2);
      }
      async pdf(options = {}) {
        const { timeout: ms2 = this._timeoutSettings.timeout(), path = void 0 } = options;
        const { printBackground: background, margin, landscape, width, height, pageRanges: ranges, scale, preferCSSPageSize } = parsePDFOptions(options, "cm");
        const pageRanges = ranges ? ranges.split(", ") : [];
        await firstValueFrom(from(this.mainFrame().isolatedRealm().evaluate(() => {
          return document.fonts.ready;
        })).pipe(raceWith(timeout(ms2))));
        const data = await firstValueFrom(from(__privateGet(this, _frame9).browsingContext.print({
          background,
          margin,
          orientation: landscape ? "landscape" : "portrait",
          page: {
            width,
            height
          },
          pageRanges,
          scale,
          shrinkToFit: !preferCSSPageSize
        })).pipe(raceWith(timeout(ms2))));
        const typedArray = stringToTypedArray(data, true);
        await this._maybeWriteTypedArrayToFile(path, typedArray);
        return typedArray;
      }
      async createPDFStream(options) {
        const typedArray = await this.pdf(options);
        return new ReadableStream({
          start(controller) {
            controller.enqueue(typedArray);
            controller.close();
          }
        });
      }
      async _screenshot(options) {
        const { clip, type, captureBeyondViewport, quality } = options;
        if (options.omitBackground !== void 0 && options.omitBackground) {
          throw new UnsupportedOperation(`BiDi does not support 'omitBackground'.`);
        }
        if (options.optimizeForSpeed !== void 0 && options.optimizeForSpeed) {
          throw new UnsupportedOperation(`BiDi does not support 'optimizeForSpeed'.`);
        }
        if (options.fromSurface !== void 0 && !options.fromSurface) {
          throw new UnsupportedOperation(`BiDi does not support 'fromSurface'.`);
        }
        if (clip !== void 0 && clip.scale !== void 0 && clip.scale !== 1) {
          throw new UnsupportedOperation(`BiDi does not support 'scale' in 'clip'.`);
        }
        let box;
        if (clip) {
          if (captureBeyondViewport) {
            box = clip;
          } else {
            const [pageLeft, pageTop] = await this.evaluate(() => {
              if (!window.visualViewport) {
                throw new Error("window.visualViewport is not supported.");
              }
              return [
                window.visualViewport.pageLeft,
                window.visualViewport.pageTop
              ];
            });
            box = {
              ...clip,
              x: clip.x - pageLeft,
              y: clip.y - pageTop
            };
          }
        }
        const data = await __privateGet(this, _frame9).browsingContext.captureScreenshot({
          origin: captureBeyondViewport ? "document" : "viewport",
          format: {
            type: `image/${type}`,
            ...quality !== void 0 ? { quality: quality / 100 } : {}
          },
          ...box ? { clip: { type: "box", ...box } } : {}
        });
        return data;
      }
      async createCDPSession() {
        return await __privateGet(this, _frame9).createCDPSession();
      }
      async bringToFront() {
        await __privateGet(this, _frame9).browsingContext.activate();
      }
      async evaluateOnNewDocument(pageFunction, ...args) {
        const expression = evaluationExpression(pageFunction, ...args);
        const script = await __privateGet(this, _frame9).browsingContext.addPreloadScript(expression);
        return { identifier: script };
      }
      async removeScriptToEvaluateOnNewDocument(id) {
        await __privateGet(this, _frame9).browsingContext.removePreloadScript(id);
      }
      async exposeFunction(name, pptrFunction) {
        return await this.mainFrame().exposeFunction(name, "default" in pptrFunction ? pptrFunction.default : pptrFunction);
      }
      isDragInterceptionEnabled() {
        return false;
      }
      async setCacheEnabled(enabled) {
        if (!__privateGet(this, _browserContext2).browser().cdpSupported) {
          await __privateGet(this, _frame9).browsingContext.setCacheBehavior(enabled ? "default" : "bypass");
          return;
        }
        await this._client().send("Network.setCacheDisabled", {
          cacheDisabled: !enabled
        });
      }
      async cookies(...urls) {
        const normalizedUrls = (urls.length ? urls : [this.url()]).map((url) => {
          return new URL(url);
        });
        const cookies = await __privateGet(this, _frame9).browsingContext.getCookies();
        return cookies.map((cookie) => {
          return bidiToPuppeteerCookie(cookie);
        }).filter((cookie) => {
          return normalizedUrls.some((url) => {
            return testUrlMatchCookie(cookie, url);
          });
        });
      }
      isServiceWorkerBypassed() {
        throw new UnsupportedOperation();
      }
      target() {
        throw new UnsupportedOperation();
      }
      waitForFileChooser() {
        throw new UnsupportedOperation();
      }
      workers() {
        return [...__privateGet(this, _workers5)];
      }
      async setRequestInterception(enable) {
        __privateSet(this, _userInterception, await __privateMethod(this, _BidiPage_instances, toggleInterception_fn).call(this, [
          "beforeRequestSent"
          /* Bidi.Network.InterceptPhase.BeforeRequestSent */
        ], __privateGet(this, _userInterception), enable));
      }
      async setExtraHTTPHeaders(headers) {
        const extraHTTPHeaders = {};
        for (const [key, value] of Object.entries(headers)) {
          assert$1(isString(value), `Expected value of header "${key}" to be String, but "${typeof value}" is found.`);
          extraHTTPHeaders[key.toLowerCase()] = value;
        }
        this._extraHTTPHeaders = extraHTTPHeaders;
        __privateSet(this, _extraHeadersInterception, await __privateMethod(this, _BidiPage_instances, toggleInterception_fn).call(this, [
          "beforeRequestSent"
          /* Bidi.Network.InterceptPhase.BeforeRequestSent */
        ], __privateGet(this, _extraHeadersInterception), Boolean(Object.keys(this._extraHTTPHeaders).length)));
      }
      async authenticate(credentials) {
        __privateSet(this, _authInterception, await __privateMethod(this, _BidiPage_instances, toggleInterception_fn).call(this, [
          "authRequired"
          /* Bidi.Network.InterceptPhase.AuthRequired */
        ], __privateGet(this, _authInterception), Boolean(credentials)));
        this._credentials = credentials;
      }
      setDragInterception() {
        throw new UnsupportedOperation();
      }
      setBypassServiceWorker() {
        throw new UnsupportedOperation();
      }
      async setOfflineMode(enabled) {
        if (!__privateGet(this, _browserContext2).browser().cdpSupported) {
          throw new UnsupportedOperation();
        }
        if (!__privateGet(this, _emulatedNetworkConditions2)) {
          __privateSet(this, _emulatedNetworkConditions2, {
            offline: false,
            upload: -1,
            download: -1,
            latency: 0
          });
        }
        __privateGet(this, _emulatedNetworkConditions2).offline = enabled;
        return await __privateMethod(this, _BidiPage_instances, applyNetworkConditions_fn2).call(this);
      }
      async emulateNetworkConditions(networkConditions) {
        if (!__privateGet(this, _browserContext2).browser().cdpSupported) {
          throw new UnsupportedOperation();
        }
        if (!__privateGet(this, _emulatedNetworkConditions2)) {
          __privateSet(this, _emulatedNetworkConditions2, {
            offline: false,
            upload: -1,
            download: -1,
            latency: 0
          });
        }
        __privateGet(this, _emulatedNetworkConditions2).upload = networkConditions ? networkConditions.upload : -1;
        __privateGet(this, _emulatedNetworkConditions2).download = networkConditions ? networkConditions.download : -1;
        __privateGet(this, _emulatedNetworkConditions2).latency = networkConditions ? networkConditions.latency : 0;
        return await __privateMethod(this, _BidiPage_instances, applyNetworkConditions_fn2).call(this);
      }
      async setCookie(...cookies) {
        const pageURL = this.url();
        const pageUrlStartsWithHTTP = pageURL.startsWith("http");
        for (const cookie of cookies) {
          let cookieUrl = cookie.url || "";
          if (!cookieUrl && pageUrlStartsWithHTTP) {
            cookieUrl = pageURL;
          }
          assert$1(cookieUrl !== "about:blank", `Blank page can not have cookie "${cookie.name}"`);
          assert$1(!String.prototype.startsWith.call(cookieUrl || "", "data:"), `Data URL page can not have cookie "${cookie.name}"`);
          assert$1(cookie.partitionKey === void 0 || typeof cookie.partitionKey === "string", "BiDi only allows domain partition keys");
          const normalizedUrl = URL.canParse(cookieUrl) ? new URL(cookieUrl) : void 0;
          const domain = cookie.domain ?? (normalizedUrl == null ? void 0 : normalizedUrl.hostname);
          assert$1(domain !== void 0, `At least one of the url and domain needs to be specified`);
          const bidiCookie = {
            domain,
            name: cookie.name,
            value: {
              type: "string",
              value: cookie.value
            },
            ...cookie.path !== void 0 ? { path: cookie.path } : {},
            ...cookie.httpOnly !== void 0 ? { httpOnly: cookie.httpOnly } : {},
            ...cookie.secure !== void 0 ? { secure: cookie.secure } : {},
            ...cookie.sameSite !== void 0 ? { sameSite: convertCookiesSameSiteCdpToBiDi(cookie.sameSite) } : {},
            ...{ expiry: convertCookiesExpiryCdpToBiDi(cookie.expires) },
            // Chrome-specific properties.
            ...cdpSpecificCookiePropertiesFromPuppeteerToBidi(cookie, "sameParty", "sourceScheme", "priority", "url")
          };
          if (cookie.partitionKey !== void 0) {
            await this.browserContext().userContext.setCookie(bidiCookie, cookie.partitionKey);
          } else {
            await __privateGet(this, _frame9).browsingContext.setCookie(bidiCookie);
          }
        }
      }
      async deleteCookie(...cookies) {
        await Promise.all(cookies.map(async (deleteCookieRequest) => {
          const cookieUrl = deleteCookieRequest.url ?? this.url();
          const normalizedUrl = URL.canParse(cookieUrl) ? new URL(cookieUrl) : void 0;
          const domain = deleteCookieRequest.domain ?? (normalizedUrl == null ? void 0 : normalizedUrl.hostname);
          assert$1(domain !== void 0, `At least one of the url and domain needs to be specified`);
          const filter2 = {
            domain,
            name: deleteCookieRequest.name,
            ...deleteCookieRequest.path !== void 0 ? { path: deleteCookieRequest.path } : {}
          };
          await __privateGet(this, _frame9).browsingContext.deleteCookie(filter2);
        }));
      }
      async removeExposedFunction(name) {
        await __privateGet(this, _frame9).removeExposedFunction(name);
      }
      metrics() {
        throw new UnsupportedOperation();
      }
      async goBack(options = {}) {
        return await __privateMethod(this, _BidiPage_instances, go_fn2).call(this, -1, options);
      }
      async goForward(options = {}) {
        return await __privateMethod(this, _BidiPage_instances, go_fn2).call(this, 1, options);
      }
      waitForDevicePrompt() {
        throw new UnsupportedOperation();
      }
    }, _trustedEmitter_accessor_storage = new WeakMap(), _browserContext2 = new WeakMap(), _frame9 = new WeakMap(), _viewport2 = new WeakMap(), _workers5 = new WeakMap(), _cdpEmulationManager = new WeakMap(), _emulatedNetworkConditions2 = new WeakMap(), _BidiPage_instances = new WeakSet(), initialize_fn8 = function() {
      __privateGet(this, _frame9).browsingContext.on("closed", () => {
        this.trustedEmitter.emit("close", void 0);
        this.trustedEmitter.removeAllListeners();
      });
      this.trustedEmitter.on("workercreated", (worker) => {
        __privateGet(this, _workers5).add(worker);
      });
      this.trustedEmitter.on("workerdestroyed", (worker) => {
        __privateGet(this, _workers5).delete(worker);
      });
    }, _userAgentInterception = new WeakMap(), _userAgentPreloadScript = new WeakMap(), _userInterception = new WeakMap(), _extraHeadersInterception = new WeakMap(), _authInterception = new WeakMap(), toggleInterception_fn = async function(phases, interception, expected) {
      if (expected && !interception) {
        return await __privateGet(this, _frame9).browsingContext.addIntercept({
          phases
        });
      } else if (!expected && interception) {
        await __privateGet(this, _frame9).browsingContext.userContext.browser.removeIntercept(interception);
        return;
      }
      return interception;
    }, applyNetworkConditions_fn2 = async function() {
      if (!__privateGet(this, _emulatedNetworkConditions2)) {
        return;
      }
      await this._client().send("Network.emulateNetworkConditions", {
        offline: __privateGet(this, _emulatedNetworkConditions2).offline,
        latency: __privateGet(this, _emulatedNetworkConditions2).latency,
        uploadThroughput: __privateGet(this, _emulatedNetworkConditions2).upload,
        downloadThroughput: __privateGet(this, _emulatedNetworkConditions2).download
      });
    }, go_fn2 = async function(delta, options) {
      const controller = new AbortController();
      try {
        const [response] = await Promise.all([
          this.waitForNavigation({
            ...options,
            signal: controller.signal
          }),
          __privateGet(this, _frame9).browsingContext.traverseHistory(delta)
        ]);
        return response;
      } catch (error) {
        controller.abort();
        if (isErrorLike(error)) {
          if (error.message.includes("no such history entry")) {
            return null;
          }
        }
        throw error;
      }
    }, (() => {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      _trustedEmitter_decorators = [bubble()];
      __esDecorate$4(_a3, null, _trustedEmitter_decorators, { kind: "accessor", name: "trustedEmitter", static: false, private: false, access: { has: (obj) => "trustedEmitter" in obj, get: (obj) => obj.trustedEmitter, set: (obj, value) => {
        obj.trustedEmitter = value;
      } }, metadata: _metadata }, _trustedEmitter_initializers, _trustedEmitter_extraInitializers);
      if (_metadata) Object.defineProperty(_a3, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    })(), _a3;
  })();
  function evaluationExpression(fun, ...args) {
    return `() => {${evaluationString(fun, ...args)}}`;
  }
  function testUrlMatchCookieHostname(cookie, normalizedUrl) {
    const cookieDomain = cookie.domain.toLowerCase();
    const urlHostname = normalizedUrl.hostname.toLowerCase();
    if (cookieDomain === urlHostname) {
      return true;
    }
    return cookieDomain.startsWith(".") && urlHostname.endsWith(cookieDomain);
  }
  function testUrlMatchCookiePath(cookie, normalizedUrl) {
    const uriPath = normalizedUrl.pathname;
    const cookiePath = cookie.path;
    if (uriPath === cookiePath) {
      return true;
    }
    if (uriPath.startsWith(cookiePath)) {
      if (cookiePath.endsWith("/")) {
        return true;
      }
      if (uriPath[cookiePath.length] === "/") {
        return true;
      }
    }
    return false;
  }
  function testUrlMatchCookie(cookie, url) {
    const normalizedUrl = new URL(url);
    assert$1(cookie !== void 0);
    if (!testUrlMatchCookieHostname(cookie, normalizedUrl)) {
      return false;
    }
    return testUrlMatchCookiePath(cookie, normalizedUrl);
  }
  function bidiToPuppeteerCookie(bidiCookie, returnCompositePartitionKey = false) {
    const partitionKey = bidiCookie[CDP_SPECIFIC_PREFIX + "partitionKey"];
    function getParitionKey() {
      if (typeof partitionKey === "string") {
        return { partitionKey };
      }
      if (typeof partitionKey === "object" && partitionKey !== null) {
        if (returnCompositePartitionKey) {
          return {
            partitionKey: {
              sourceOrigin: partitionKey.topLevelSite,
              hasCrossSiteAncestor: partitionKey.hasCrossSiteAncestor ?? false
            }
          };
        }
        return {
          // TODO: a breaking change in Puppeteer is required to change
          // partitionKey type and report the composite partition key.
          partitionKey: partitionKey.topLevelSite
        };
      }
      return {};
    }
    return {
      name: bidiCookie.name,
      // Presents binary value as base64 string.
      value: bidiCookie.value.value,
      domain: bidiCookie.domain,
      path: bidiCookie.path,
      size: bidiCookie.size,
      httpOnly: bidiCookie.httpOnly,
      secure: bidiCookie.secure,
      sameSite: convertCookiesSameSiteBiDiToCdp(bidiCookie.sameSite),
      expires: bidiCookie.expiry ?? -1,
      session: bidiCookie.expiry === void 0 || bidiCookie.expiry <= 0,
      // Extending with CDP-specific properties with `goog:` prefix.
      ...cdpSpecificCookiePropertiesFromBidiToPuppeteer(bidiCookie, "sameParty", "sourceScheme", "partitionKeyOpaque", "priority"),
      ...getParitionKey()
    };
  }
  const CDP_SPECIFIC_PREFIX = "goog:";
  function cdpSpecificCookiePropertiesFromBidiToPuppeteer(bidiCookie, ...propertyNames) {
    const result = {};
    for (const property of propertyNames) {
      if (bidiCookie[CDP_SPECIFIC_PREFIX + property] !== void 0) {
        result[property] = bidiCookie[CDP_SPECIFIC_PREFIX + property];
      }
    }
    return result;
  }
  function cdpSpecificCookiePropertiesFromPuppeteerToBidi(cookieParam, ...propertyNames) {
    const result = {};
    for (const property of propertyNames) {
      if (cookieParam[property] !== void 0) {
        result[CDP_SPECIFIC_PREFIX + property] = cookieParam[property];
      }
    }
    return result;
  }
  function convertCookiesSameSiteBiDiToCdp(sameSite) {
    return sameSite === "strict" ? "Strict" : sameSite === "lax" ? "Lax" : "None";
  }
  function convertCookiesSameSiteCdpToBiDi(sameSite) {
    return sameSite === "Strict" ? "strict" : sameSite === "Lax" ? "lax" : "none";
  }
  function convertCookiesExpiryCdpToBiDi(expiry) {
    return [void 0, -1].includes(expiry) ? void 0 : expiry;
  }
  function convertCookiesPartitionKeyFromPuppeteerToBiDi(partitionKey) {
    if (partitionKey === void 0 || typeof partitionKey === "string") {
      return partitionKey;
    }
    if (partitionKey.hasCrossSiteAncestor) {
      throw new UnsupportedOperation("WebDriver BiDi does not support `hasCrossSiteAncestor` yet.");
    }
    return partitionKey.sourceOrigin;
  }
  /**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  class BidiBrowserTarget extends Target {
    constructor(browser2) {
      super();
      __privateAdd(this, _browser2);
      __privateSet(this, _browser2, browser2);
    }
    asPage() {
      throw new UnsupportedOperation();
    }
    url() {
      return "";
    }
    createCDPSession() {
      throw new UnsupportedOperation();
    }
    type() {
      return TargetType.BROWSER;
    }
    browser() {
      return __privateGet(this, _browser2);
    }
    browserContext() {
      return __privateGet(this, _browser2).defaultBrowserContext();
    }
    opener() {
      throw new UnsupportedOperation();
    }
  }
  _browser2 = new WeakMap();
  class BidiPageTarget extends Target {
    constructor(page) {
      super();
      __privateAdd(this, _page6);
      __privateSet(this, _page6, page);
    }
    async page() {
      return __privateGet(this, _page6);
    }
    async asPage() {
      return BidiPage.from(this.browserContext(), __privateGet(this, _page6).mainFrame().browsingContext);
    }
    url() {
      return __privateGet(this, _page6).url();
    }
    createCDPSession() {
      return __privateGet(this, _page6).createCDPSession();
    }
    type() {
      return TargetType.PAGE;
    }
    browser() {
      return this.browserContext().browser();
    }
    browserContext() {
      return __privateGet(this, _page6).browserContext();
    }
    opener() {
      throw new UnsupportedOperation();
    }
  }
  _page6 = new WeakMap();
  class BidiFrameTarget extends Target {
    constructor(frame) {
      super();
      __privateAdd(this, _frame8);
      __privateAdd(this, _page7);
      __privateSet(this, _frame8, frame);
    }
    async page() {
      if (__privateGet(this, _page7) === void 0) {
        __privateSet(this, _page7, BidiPage.from(this.browserContext(), __privateGet(this, _frame8).browsingContext));
      }
      return __privateGet(this, _page7);
    }
    async asPage() {
      return BidiPage.from(this.browserContext(), __privateGet(this, _frame8).browsingContext);
    }
    url() {
      return __privateGet(this, _frame8).url();
    }
    createCDPSession() {
      return __privateGet(this, _frame8).createCDPSession();
    }
    type() {
      return TargetType.PAGE;
    }
    browser() {
      return this.browserContext().browser();
    }
    browserContext() {
      return __privateGet(this, _frame8).page().browserContext();
    }
    opener() {
      throw new UnsupportedOperation();
    }
  }
  _frame8 = new WeakMap();
  _page7 = new WeakMap();
  class BidiWorkerTarget extends Target {
    constructor(worker) {
      super();
      __privateAdd(this, _worker2);
      __privateSet(this, _worker2, worker);
    }
    async page() {
      throw new UnsupportedOperation();
    }
    async asPage() {
      throw new UnsupportedOperation();
    }
    url() {
      return __privateGet(this, _worker2).url();
    }
    createCDPSession() {
      throw new UnsupportedOperation();
    }
    type() {
      return TargetType.OTHER;
    }
    browser() {
      return this.browserContext().browser();
    }
    browserContext() {
      return __privateGet(this, _worker2).frame.page().browserContext();
    }
    opener() {
      throw new UnsupportedOperation();
    }
  }
  _worker2 = new WeakMap();
  /**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var __esDecorate$3 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind2 = contextIn.kind, key = kind2 === "getter" ? "get" : kind2 === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function(f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i2])(kind2 === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind2 === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_ = accept(result.get)) descriptor.get = _;
        if (_ = accept(result.set)) descriptor.set = _;
        if (_ = accept(result.init)) initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind2 === "field") initializers.unshift(_);
        else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  var __runInitializers$3 = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i2 = 0; i2 < initializers.length; i2++) {
      value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __addDisposableResource$1 = function(env, value, async2) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async2) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async2) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({ value, dispose, async: async2 });
    } else if (async2) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources$1 = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  let BidiBrowserContext = (() => {
    var _trustedEmitter_accessor_storage, _browser3, _defaultViewport3, _pages, _targets, _overrides, _BidiBrowserContext_instances, initialize_fn8, createPage_fn, _a3;
    let _classSuper = BrowserContext$1;
    let _trustedEmitter_decorators;
    let _trustedEmitter_initializers = [];
    let _trustedEmitter_extraInitializers = [];
    return _a3 = class extends _classSuper {
      constructor(browser2, userContext, options) {
        super();
        __privateAdd(this, _BidiBrowserContext_instances);
        __privateAdd(this, _trustedEmitter_accessor_storage, __runInitializers$3(this, _trustedEmitter_initializers, new EventEmitter$1()));
        __privateAdd(this, _browser3, __runInitializers$3(this, _trustedEmitter_extraInitializers));
        __privateAdd(this, _defaultViewport3);
        // This is public because of cookies.
        __publicField(this, "userContext");
        __privateAdd(this, _pages, /* @__PURE__ */ new WeakMap());
        __privateAdd(this, _targets, /* @__PURE__ */ new Map());
        __privateAdd(this, _overrides, []);
        __privateSet(this, _browser3, browser2);
        this.userContext = userContext;
        __privateSet(this, _defaultViewport3, options.defaultViewport);
      }
      static from(browser2, userContext, options) {
        var _a4;
        const context = new _a3(browser2, userContext, options);
        __privateMethod(_a4 = context, _BidiBrowserContext_instances, initialize_fn8).call(_a4);
        return context;
      }
      get trustedEmitter() {
        return __privateGet(this, _trustedEmitter_accessor_storage);
      }
      set trustedEmitter(value) {
        __privateSet(this, _trustedEmitter_accessor_storage, value);
      }
      targets() {
        return [...__privateGet(this, _targets).values()].flatMap(([target, frames]) => {
          return [target, ...frames.values()];
        });
      }
      async newPage() {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
          const _guard = __addDisposableResource$1(env_1, await this.waitForScreenshotOperations(), false);
          const context = await this.userContext.createBrowsingContext(
            "tab"
            /* Bidi.BrowsingContext.CreateType.Tab */
          );
          const page = __privateGet(this, _pages).get(context);
          if (!page) {
            throw new Error("Page is not found");
          }
          if (__privateGet(this, _defaultViewport3)) {
            try {
              await page.setViewport(__privateGet(this, _defaultViewport3));
            } catch {
            }
          }
          return page;
        } catch (e_1) {
          env_1.error = e_1;
          env_1.hasError = true;
        } finally {
          __disposeResources$1(env_1);
        }
      }
      async close() {
        assert$1(this.userContext.id !== UserContext.DEFAULT, "Default BrowserContext cannot be closed!");
        try {
          await this.userContext.remove();
        } catch (error) {
          debugError(error);
        }
        __privateGet(this, _targets).clear();
      }
      browser() {
        return __privateGet(this, _browser3);
      }
      async pages() {
        return [...this.userContext.browsingContexts].map((context) => {
          return __privateGet(this, _pages).get(context);
        });
      }
      async overridePermissions(origin, permissions) {
        const permissionsSet = new Set(permissions.map((permission) => {
          const protocolPermission = WEB_PERMISSION_TO_PROTOCOL_PERMISSION.get(permission);
          if (!protocolPermission) {
            throw new Error("Unknown permission: " + permission);
          }
          return permission;
        }));
        await Promise.all(Array.from(WEB_PERMISSION_TO_PROTOCOL_PERMISSION.keys()).map((permission) => {
          const result = this.userContext.setPermissions(
            origin,
            {
              name: permission
            },
            permissionsSet.has(permission) ? "granted" : "denied"
            /* Bidi.Permissions.PermissionState.Denied */
          );
          __privateGet(this, _overrides).push({ origin, permission });
          if (!permissionsSet.has(permission)) {
            return result.catch(debugError);
          }
          return result;
        }));
      }
      async clearPermissionOverrides() {
        const promises = __privateGet(this, _overrides).map(({ permission, origin }) => {
          return this.userContext.setPermissions(
            origin,
            {
              name: permission
            },
            "prompt"
            /* Bidi.Permissions.PermissionState.Prompt */
          ).catch(debugError);
        });
        __privateSet(this, _overrides, []);
        await Promise.all(promises);
      }
      get id() {
        if (this.userContext.id === UserContext.DEFAULT) {
          return void 0;
        }
        return this.userContext.id;
      }
      async cookies() {
        const cookies = await this.userContext.getCookies();
        return cookies.map((cookie) => {
          return bidiToPuppeteerCookie(cookie, true);
        });
      }
      async setCookie(...cookies) {
        await Promise.all(cookies.map(async (cookie) => {
          const bidiCookie = {
            domain: cookie.domain,
            name: cookie.name,
            value: {
              type: "string",
              value: cookie.value
            },
            ...cookie.path !== void 0 ? { path: cookie.path } : {},
            ...cookie.httpOnly !== void 0 ? { httpOnly: cookie.httpOnly } : {},
            ...cookie.secure !== void 0 ? { secure: cookie.secure } : {},
            ...cookie.sameSite !== void 0 ? { sameSite: convertCookiesSameSiteCdpToBiDi(cookie.sameSite) } : {},
            ...{ expiry: convertCookiesExpiryCdpToBiDi(cookie.expires) },
            // Chrome-specific properties.
            ...cdpSpecificCookiePropertiesFromPuppeteerToBidi(cookie, "sameParty", "sourceScheme", "priority", "url")
          };
          return await this.userContext.setCookie(bidiCookie, convertCookiesPartitionKeyFromPuppeteerToBiDi(cookie.partitionKey));
        }));
      }
    }, _trustedEmitter_accessor_storage = new WeakMap(), _browser3 = new WeakMap(), _defaultViewport3 = new WeakMap(), _pages = new WeakMap(), _targets = new WeakMap(), _overrides = new WeakMap(), _BidiBrowserContext_instances = new WeakSet(), initialize_fn8 = function() {
      for (const browsingContext of this.userContext.browsingContexts) {
        __privateMethod(this, _BidiBrowserContext_instances, createPage_fn).call(this, browsingContext);
      }
      this.userContext.on("browsingcontext", ({ browsingContext }) => {
        const page = __privateMethod(this, _BidiBrowserContext_instances, createPage_fn).call(this, browsingContext);
        if (browsingContext.originalOpener) {
          for (const context of this.userContext.browsingContexts) {
            if (context.id === browsingContext.originalOpener) {
              __privateGet(this, _pages).get(context).trustedEmitter.emit("popup", page);
            }
          }
        }
      });
      this.userContext.on("closed", () => {
        this.trustedEmitter.removeAllListeners();
      });
    }, createPage_fn = function(browsingContext) {
      const page = BidiPage.from(this, browsingContext);
      __privateGet(this, _pages).set(browsingContext, page);
      page.trustedEmitter.on("close", () => {
        __privateGet(this, _pages).delete(browsingContext);
      });
      const pageTarget = new BidiPageTarget(page);
      const pageTargets = /* @__PURE__ */ new Map();
      __privateGet(this, _targets).set(page, [pageTarget, pageTargets]);
      page.trustedEmitter.on("frameattached", (frame) => {
        const bidiFrame = frame;
        const target = new BidiFrameTarget(bidiFrame);
        pageTargets.set(bidiFrame, target);
        this.trustedEmitter.emit("targetcreated", target);
      });
      page.trustedEmitter.on("framenavigated", (frame) => {
        const bidiFrame = frame;
        const target = pageTargets.get(bidiFrame);
        if (target === void 0) {
          this.trustedEmitter.emit("targetchanged", pageTarget);
        } else {
          this.trustedEmitter.emit("targetchanged", target);
        }
      });
      page.trustedEmitter.on("framedetached", (frame) => {
        const bidiFrame = frame;
        const target = pageTargets.get(bidiFrame);
        if (target === void 0) {
          return;
        }
        pageTargets.delete(bidiFrame);
        this.trustedEmitter.emit("targetdestroyed", target);
      });
      page.trustedEmitter.on("workercreated", (worker) => {
        const bidiWorker = worker;
        const target = new BidiWorkerTarget(bidiWorker);
        pageTargets.set(bidiWorker, target);
        this.trustedEmitter.emit("targetcreated", target);
      });
      page.trustedEmitter.on("workerdestroyed", (worker) => {
        const bidiWorker = worker;
        const target = pageTargets.get(bidiWorker);
        if (target === void 0) {
          return;
        }
        pageTargets.delete(worker);
        this.trustedEmitter.emit("targetdestroyed", target);
      });
      page.trustedEmitter.on("close", () => {
        __privateGet(this, _targets).delete(page);
        this.trustedEmitter.emit("targetdestroyed", pageTarget);
      });
      this.trustedEmitter.emit("targetcreated", pageTarget);
      return page;
    }, (() => {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      _trustedEmitter_decorators = [bubble()];
      __esDecorate$3(_a3, null, _trustedEmitter_decorators, { kind: "accessor", name: "trustedEmitter", static: false, private: false, access: { has: (obj) => "trustedEmitter" in obj, get: (obj) => obj.trustedEmitter, set: (obj, value) => {
        obj.trustedEmitter = value;
      } }, metadata: _metadata }, _trustedEmitter_initializers, _trustedEmitter_extraInitializers);
      if (_metadata) Object.defineProperty(_a3, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    })(), _a3;
  })();
  /**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var __runInitializers$2 = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i2 = 0; i2 < initializers.length; i2++) {
      value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate$2 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind2 = contextIn.kind, key = kind2 === "getter" ? "get" : kind2 === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function(f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i2])(kind2 === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind2 === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_ = accept(result.get)) descriptor.get = _;
        if (_ = accept(result.set)) descriptor.set = _;
        if (_ = accept(result.init)) initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind2 === "field") initializers.unshift(_);
        else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  var __addDisposableResource = function(env, value, async2) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async2) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async2) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({ value, dispose, async: async2 });
    } else if (async2) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  let Browser = (() => {
    var _closed5, _reason, _disposables3, _userContexts, _sharedWorkers, _Browser_instances, initialize_fn8, syncUserContexts_fn, syncBrowsingContexts_fn, createUserContext_fn, _a3;
    let _classSuper = EventEmitter$1;
    let _instanceExtraInitializers = [];
    let _dispose_decorators;
    let _close_decorators;
    let _addPreloadScript_decorators;
    let _removeIntercept_decorators;
    let _removePreloadScript_decorators;
    let _createUserContext_decorators;
    return _a3 = class extends _classSuper {
      constructor(session) {
        super();
        __privateAdd(this, _Browser_instances);
        __privateAdd(this, _closed5, (__runInitializers$2(this, _instanceExtraInitializers), false));
        __privateAdd(this, _reason);
        __privateAdd(this, _disposables3, new DisposableStack());
        __privateAdd(this, _userContexts, /* @__PURE__ */ new Map());
        __publicField(this, "session");
        __privateAdd(this, _sharedWorkers, /* @__PURE__ */ new Map());
        this.session = session;
      }
      static async from(session) {
        var _a4;
        const browser2 = new _a3(session);
        await __privateMethod(_a4 = browser2, _Browser_instances, initialize_fn8).call(_a4);
        return browser2;
      }
      get closed() {
        return __privateGet(this, _closed5);
      }
      get defaultUserContext() {
        return __privateGet(this, _userContexts).get(UserContext.DEFAULT);
      }
      get disconnected() {
        return __privateGet(this, _reason) !== void 0;
      }
      get disposed() {
        return this.disconnected;
      }
      get userContexts() {
        return __privateGet(this, _userContexts).values();
      }
      dispose(reason, closed = false) {
        __privateSet(this, _closed5, closed);
        __privateSet(this, _reason, reason);
        this[disposeSymbol]();
      }
      async close() {
        try {
          await this.session.send("browser.close", {});
        } finally {
          this.dispose("Browser already closed.", true);
        }
      }
      async addPreloadScript(functionDeclaration, options = {}) {
        var _a4;
        const { result: { script } } = await this.session.send("script.addPreloadScript", {
          functionDeclaration,
          ...options,
          contexts: (_a4 = options.contexts) == null ? void 0 : _a4.map((context) => {
            return context.id;
          })
        });
        return script;
      }
      async removeIntercept(intercept) {
        await this.session.send("network.removeIntercept", {
          intercept
        });
      }
      async removePreloadScript(script) {
        await this.session.send("script.removePreloadScript", {
          script
        });
      }
      async createUserContext() {
        const { result: { userContext: context } } = await this.session.send("browser.createUserContext", {});
        return __privateMethod(this, _Browser_instances, createUserContext_fn).call(this, context);
      }
      [(_dispose_decorators = [inertIfDisposed], _close_decorators = [throwIfDisposed((browser2) => {
        return __privateGet(browser2, _reason);
      })], _addPreloadScript_decorators = [throwIfDisposed((browser2) => {
        return __privateGet(browser2, _reason);
      })], _removeIntercept_decorators = [throwIfDisposed((browser2) => {
        return __privateGet(browser2, _reason);
      })], _removePreloadScript_decorators = [throwIfDisposed((browser2) => {
        return __privateGet(browser2, _reason);
      })], _createUserContext_decorators = [throwIfDisposed((browser2) => {
        return __privateGet(browser2, _reason);
      })], disposeSymbol)]() {
        __privateGet(this, _reason) ?? __privateSet(this, _reason, "Browser was disconnected, probably because the session ended.");
        if (this.closed) {
          this.emit("closed", { reason: __privateGet(this, _reason) });
        }
        this.emit("disconnected", { reason: __privateGet(this, _reason) });
        __privateGet(this, _disposables3).dispose();
        super[disposeSymbol]();
      }
    }, _closed5 = new WeakMap(), _reason = new WeakMap(), _disposables3 = new WeakMap(), _userContexts = new WeakMap(), _sharedWorkers = new WeakMap(), _Browser_instances = new WeakSet(), initialize_fn8 = async function() {
      const sessionEmitter = __privateGet(this, _disposables3).use(new EventEmitter$1(this.session));
      sessionEmitter.once("ended", ({ reason }) => {
        this.dispose(reason);
      });
      sessionEmitter.on("script.realmCreated", (info) => {
        if (info.type !== "shared-worker") {
          return;
        }
        __privateGet(this, _sharedWorkers).set(info.realm, SharedWorkerRealm.from(this, info.realm, info.origin));
      });
      await __privateMethod(this, _Browser_instances, syncUserContexts_fn).call(this);
      await __privateMethod(this, _Browser_instances, syncBrowsingContexts_fn).call(this);
    }, syncUserContexts_fn = async function() {
      const { result: { userContexts } } = await this.session.send("browser.getUserContexts", {});
      for (const context of userContexts) {
        __privateMethod(this, _Browser_instances, createUserContext_fn).call(this, context.userContext);
      }
    }, syncBrowsingContexts_fn = async function() {
      const contextIds = /* @__PURE__ */ new Set();
      let contexts;
      {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
          const sessionEmitter = __addDisposableResource(env_1, new EventEmitter$1(this.session), false);
          sessionEmitter.on("browsingContext.contextCreated", (info) => {
            contextIds.add(info.context);
          });
          const { result } = await this.session.send("browsingContext.getTree", {});
          contexts = result.contexts;
        } catch (e_1) {
          env_1.error = e_1;
          env_1.hasError = true;
        } finally {
          __disposeResources(env_1);
        }
      }
      for (const info of contexts) {
        if (!contextIds.has(info.context)) {
          this.session.emit("browsingContext.contextCreated", info);
        }
        if (info.children) {
          contexts.push(...info.children);
        }
      }
    }, createUserContext_fn = function(id) {
      const userContext = UserContext.create(this, id);
      __privateGet(this, _userContexts).set(userContext.id, userContext);
      const userContextEmitter = __privateGet(this, _disposables3).use(new EventEmitter$1(userContext));
      userContextEmitter.once("closed", () => {
        userContextEmitter.removeAllListeners();
        __privateGet(this, _userContexts).delete(userContext.id);
      });
      return userContext;
    }, (() => {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      __esDecorate$2(_a3, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: (obj) => "dispose" in obj, get: (obj) => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$2(_a3, null, _close_decorators, { kind: "method", name: "close", static: false, private: false, access: { has: (obj) => "close" in obj, get: (obj) => obj.close }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$2(_a3, null, _addPreloadScript_decorators, { kind: "method", name: "addPreloadScript", static: false, private: false, access: { has: (obj) => "addPreloadScript" in obj, get: (obj) => obj.addPreloadScript }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$2(_a3, null, _removeIntercept_decorators, { kind: "method", name: "removeIntercept", static: false, private: false, access: { has: (obj) => "removeIntercept" in obj, get: (obj) => obj.removeIntercept }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$2(_a3, null, _removePreloadScript_decorators, { kind: "method", name: "removePreloadScript", static: false, private: false, access: { has: (obj) => "removePreloadScript" in obj, get: (obj) => obj.removePreloadScript }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$2(_a3, null, _createUserContext_decorators, { kind: "method", name: "createUserContext", static: false, private: false, access: { has: (obj) => "createUserContext" in obj, get: (obj) => obj.createUserContext }, metadata: _metadata }, null, _instanceExtraInitializers);
      if (_metadata) Object.defineProperty(_a3, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    })(), _a3;
  })();
  /**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var __runInitializers$1 = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i2 = 0; i2 < initializers.length; i2++) {
      value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate$1 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind2 = contextIn.kind, key = kind2 === "getter" ? "get" : kind2 === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function(f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i2])(kind2 === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind2 === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_ = accept(result.get)) descriptor.get = _;
        if (_ = accept(result.set)) descriptor.set = _;
        if (_ = accept(result.init)) initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind2 === "field") initializers.unshift(_);
        else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  let Session = (() => {
    var _reason, _disposables3, _info, _connection_accessor_storage, _Session_instances, initialize_fn8, _a3;
    let _classSuper = EventEmitter$1;
    let _instanceExtraInitializers = [];
    let _connection_decorators;
    let _connection_initializers = [];
    let _connection_extraInitializers = [];
    let _dispose_decorators;
    let _send_decorators;
    let _subscribe_decorators;
    let _addIntercepts_decorators;
    let _end_decorators;
    return _a3 = class extends _classSuper {
      constructor(connection, info) {
        super();
        __privateAdd(this, _Session_instances);
        __privateAdd(this, _reason, __runInitializers$1(this, _instanceExtraInitializers));
        __privateAdd(this, _disposables3, new DisposableStack());
        __privateAdd(this, _info);
        __publicField(this, "browser");
        __privateAdd(this, _connection_accessor_storage, __runInitializers$1(this, _connection_initializers, void 0));
        __runInitializers$1(this, _connection_extraInitializers);
        __privateSet(this, _info, info);
        this.connection = connection;
      }
      static async from(connection, capabilities) {
        var _a4;
        const { result } = await connection.send("session.new", {
          capabilities
        });
        const session = new _a3(connection, result);
        await __privateMethod(_a4 = session, _Session_instances, initialize_fn8).call(_a4);
        return session;
      }
      get connection() {
        return __privateGet(this, _connection_accessor_storage);
      }
      set connection(value) {
        __privateSet(this, _connection_accessor_storage, value);
      }
      get capabilities() {
        return __privateGet(this, _info).capabilities;
      }
      get disposed() {
        return this.ended;
      }
      get ended() {
        return __privateGet(this, _reason) !== void 0;
      }
      get id() {
        return __privateGet(this, _info).sessionId;
      }
      dispose(reason) {
        __privateSet(this, _reason, reason);
        this[disposeSymbol]();
      }
      /**
       * Currently, there is a 1:1 relationship between the session and the
       * session. In the future, we might support multiple sessions and in that
       * case we always needs to make sure that the session for the right session
       * object is used, so we implement this method here, although it's not defined
       * in the spec.
       */
      async send(method, params) {
        return await this.connection.send(method, params);
      }
      async subscribe(events2, contexts) {
        await this.send("session.subscribe", {
          events: events2,
          contexts
        });
      }
      async addIntercepts(events2, contexts) {
        await this.send("session.subscribe", {
          events: events2,
          contexts
        });
      }
      async end() {
        try {
          await this.send("session.end", {});
        } finally {
          this.dispose(`Session already ended.`);
        }
      }
      [(_connection_decorators = [bubble()], _dispose_decorators = [inertIfDisposed], _send_decorators = [throwIfDisposed((session) => {
        return __privateGet(session, _reason);
      })], _subscribe_decorators = [throwIfDisposed((session) => {
        return __privateGet(session, _reason);
      })], _addIntercepts_decorators = [throwIfDisposed((session) => {
        return __privateGet(session, _reason);
      })], _end_decorators = [throwIfDisposed((session) => {
        return __privateGet(session, _reason);
      })], disposeSymbol)]() {
        __privateGet(this, _reason) ?? __privateSet(this, _reason, "Session already destroyed, probably because the connection broke.");
        this.emit("ended", { reason: __privateGet(this, _reason) });
        __privateGet(this, _disposables3).dispose();
        super[disposeSymbol]();
      }
    }, _reason = new WeakMap(), _disposables3 = new WeakMap(), _info = new WeakMap(), _connection_accessor_storage = new WeakMap(), _Session_instances = new WeakSet(), initialize_fn8 = async function() {
      this.browser = await Browser.from(this);
      const browserEmitter = __privateGet(this, _disposables3).use(this.browser);
      browserEmitter.once("closed", ({ reason }) => {
        this.dispose(reason);
      });
      const seen = /* @__PURE__ */ new WeakSet();
      this.on("browsingContext.fragmentNavigated", (info) => {
        if (seen.has(info)) {
          return;
        }
        seen.add(info);
        this.emit("browsingContext.navigationStarted", info);
        this.emit("browsingContext.fragmentNavigated", info);
      });
    }, (() => {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      __esDecorate$1(_a3, null, _connection_decorators, { kind: "accessor", name: "connection", static: false, private: false, access: { has: (obj) => "connection" in obj, get: (obj) => obj.connection, set: (obj, value) => {
        obj.connection = value;
      } }, metadata: _metadata }, _connection_initializers, _connection_extraInitializers);
      __esDecorate$1(_a3, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: (obj) => "dispose" in obj, get: (obj) => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$1(_a3, null, _send_decorators, { kind: "method", name: "send", static: false, private: false, access: { has: (obj) => "send" in obj, get: (obj) => obj.send }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$1(_a3, null, _subscribe_decorators, { kind: "method", name: "subscribe", static: false, private: false, access: { has: (obj) => "subscribe" in obj, get: (obj) => obj.subscribe }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$1(_a3, null, _addIntercepts_decorators, { kind: "method", name: "addIntercepts", static: false, private: false, access: { has: (obj) => "addIntercepts" in obj, get: (obj) => obj.addIntercepts }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate$1(_a3, null, _end_decorators, { kind: "method", name: "end", static: false, private: false, access: { has: (obj) => "end" in obj, get: (obj) => obj.end }, metadata: _metadata }, null, _instanceExtraInitializers);
      if (_metadata) Object.defineProperty(_a3, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    })(), _a3;
  })();
  /**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  var __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind2 = contextIn.kind, key = kind2 === "getter" ? "get" : kind2 === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function(f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i2])(kind2 === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind2 === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_ = accept(result.get)) descriptor.get = _;
        if (_ = accept(result.set)) descriptor.set = _;
        if (_ = accept(result.init)) initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind2 === "field") initializers.unshift(_);
        else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  var __runInitializers = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i2 = 0; i2 < initializers.length; i2++) {
      value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __setFunctionName = function(f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
  };
  let BidiBrowser = (() => {
    var _a3, _trustedEmitter_accessor_storage, _BidiBrowser_instances, trustedEmitter_get, trustedEmitter_set, _process2, _closeCallback2, _browserCore, _defaultViewport3, _browserContexts, _target2, _cdpConnection, initialize_fn8, browserName_get, browserVersion_get, createBrowserContext_fn;
    let _classSuper = Browser$1;
    let _private_trustedEmitter_decorators;
    let _private_trustedEmitter_initializers = [];
    let _private_trustedEmitter_extraInitializers = [];
    let _private_trustedEmitter_descriptor;
    return _a3 = class extends _classSuper {
      constructor(browserCore, opts) {
        super();
        __privateAdd(this, _BidiBrowser_instances);
        __publicField(this, "protocol", "webDriverBiDi");
        __privateAdd(this, _trustedEmitter_accessor_storage, __runInitializers(this, _private_trustedEmitter_initializers, new EventEmitter$1()));
        __privateAdd(this, _process2, __runInitializers(this, _private_trustedEmitter_extraInitializers));
        __privateAdd(this, _closeCallback2);
        __privateAdd(this, _browserCore);
        __privateAdd(this, _defaultViewport3);
        __privateAdd(this, _browserContexts, /* @__PURE__ */ new WeakMap());
        __privateAdd(this, _target2, new BidiBrowserTarget(this));
        __privateAdd(this, _cdpConnection);
        __privateSet(this, _process2, opts.process);
        __privateSet(this, _closeCallback2, opts.closeCallback);
        __privateSet(this, _browserCore, browserCore);
        __privateSet(this, _defaultViewport3, opts.defaultViewport);
        __privateSet(this, _cdpConnection, opts.cdpConnection);
      }
      static async create(opts) {
        var _a4, _b2, _c2;
        const session = await Session.from(opts.connection, {
          firstMatch: (_a4 = opts.capabilities) == null ? void 0 : _a4.firstMatch,
          alwaysMatch: {
            ...(_b2 = opts.capabilities) == null ? void 0 : _b2.alwaysMatch,
            // Capabilities that come from Puppeteer's API take precedence.
            acceptInsecureCerts: opts.acceptInsecureCerts,
            unhandledPromptBehavior: {
              default: "ignore"
            },
            webSocketUrl: true,
            // Puppeteer with WebDriver BiDi does not support prerendering
            // yet because WebDriver BiDi behavior is not specified. See
            // https://github.com/w3c/webdriver-bidi/issues/321.
            "goog:prerenderingDisabled": true
          }
        });
        await session.subscribe(session.capabilities.browserName.toLocaleLowerCase().includes("firefox") ? _a3.subscribeModules : [..._a3.subscribeModules, ..._a3.subscribeCdpEvents]);
        const browser2 = new _a3(session.browser, opts);
        __privateMethod(_c2 = browser2, _BidiBrowser_instances, initialize_fn8).call(_c2);
        return browser2;
      }
      get cdpSupported() {
        return __privateGet(this, _cdpConnection) !== void 0;
      }
      get cdpConnection() {
        return __privateGet(this, _cdpConnection);
      }
      async userAgent() {
        return __privateGet(this, _browserCore).session.capabilities.userAgent;
      }
      get connection() {
        return __privateGet(this, _browserCore).session.connection;
      }
      wsEndpoint() {
        return this.connection.url;
      }
      async close() {
        var _a4;
        if (this.connection.closed) {
          return;
        }
        try {
          await __privateGet(this, _browserCore).close();
          await ((_a4 = __privateGet(this, _closeCallback2)) == null ? void 0 : _a4.call(null));
        } catch (error) {
          debugError(error);
        } finally {
          this.connection.dispose();
        }
      }
      get connected() {
        return !__privateGet(this, _browserCore).disconnected;
      }
      process() {
        return __privateGet(this, _process2) ?? null;
      }
      async createBrowserContext(_options) {
        const userContext = await __privateGet(this, _browserCore).createUserContext();
        return __privateMethod(this, _BidiBrowser_instances, createBrowserContext_fn).call(this, userContext);
      }
      async version() {
        return `${__privateGet(this, _BidiBrowser_instances, browserName_get)}/${__privateGet(this, _BidiBrowser_instances, browserVersion_get)}`;
      }
      browserContexts() {
        return [...__privateGet(this, _browserCore).userContexts].map((context) => {
          return __privateGet(this, _browserContexts).get(context);
        });
      }
      defaultBrowserContext() {
        return __privateGet(this, _browserContexts).get(__privateGet(this, _browserCore).defaultUserContext);
      }
      newPage() {
        return this.defaultBrowserContext().newPage();
      }
      targets() {
        return [
          __privateGet(this, _target2),
          ...this.browserContexts().flatMap((context) => {
            return context.targets();
          })
        ];
      }
      target() {
        return __privateGet(this, _target2);
      }
      async disconnect() {
        try {
          await __privateGet(this, _browserCore).session.end();
        } catch (error) {
          debugError(error);
        } finally {
          this.connection.dispose();
        }
      }
      get debugInfo() {
        return {
          pendingProtocolErrors: this.connection.getPendingProtocolErrors()
        };
      }
    }, _trustedEmitter_accessor_storage = new WeakMap(), _BidiBrowser_instances = new WeakSet(), trustedEmitter_get = function() {
      return _private_trustedEmitter_descriptor.get.call(this);
    }, trustedEmitter_set = function(value) {
      return _private_trustedEmitter_descriptor.set.call(this, value);
    }, _process2 = new WeakMap(), _closeCallback2 = new WeakMap(), _browserCore = new WeakMap(), _defaultViewport3 = new WeakMap(), _browserContexts = new WeakMap(), _target2 = new WeakMap(), _cdpConnection = new WeakMap(), initialize_fn8 = function() {
      var _a4;
      for (const userContext of __privateGet(this, _browserCore).userContexts) {
        __privateMethod(this, _BidiBrowser_instances, createBrowserContext_fn).call(this, userContext);
      }
      __privateGet(this, _browserCore).once("disconnected", () => {
        __privateGet(this, _BidiBrowser_instances, trustedEmitter_get).emit("disconnected", void 0);
        __privateGet(this, _BidiBrowser_instances, trustedEmitter_get).removeAllListeners();
      });
      (_a4 = __privateGet(this, _process2)) == null ? void 0 : _a4.once("close", () => {
        __privateGet(this, _browserCore).dispose("Browser process exited.", true);
        this.connection.dispose();
      });
    }, browserName_get = function() {
      return __privateGet(this, _browserCore).session.capabilities.browserName;
    }, browserVersion_get = function() {
      return __privateGet(this, _browserCore).session.capabilities.browserVersion;
    }, createBrowserContext_fn = function(userContext) {
      const browserContext2 = BidiBrowserContext.from(this, userContext, {
        defaultViewport: __privateGet(this, _defaultViewport3)
      });
      __privateGet(this, _browserContexts).set(userContext, browserContext2);
      browserContext2.trustedEmitter.on("targetcreated", (target) => {
        __privateGet(this, _BidiBrowser_instances, trustedEmitter_get).emit("targetcreated", target);
      });
      browserContext2.trustedEmitter.on("targetchanged", (target) => {
        __privateGet(this, _BidiBrowser_instances, trustedEmitter_get).emit("targetchanged", target);
      });
      browserContext2.trustedEmitter.on("targetdestroyed", (target) => {
        __privateGet(this, _BidiBrowser_instances, trustedEmitter_get).emit("targetdestroyed", target);
      });
      return browserContext2;
    }, (() => {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      _private_trustedEmitter_decorators = [bubble()];
      __esDecorate(_a3, _private_trustedEmitter_descriptor = { get: __setFunctionName(function() {
        return __privateGet(this, _trustedEmitter_accessor_storage);
      }, "#trustedEmitter", "get"), set: __setFunctionName(function(value) {
        __privateSet(this, _trustedEmitter_accessor_storage, value);
      }, "#trustedEmitter", "set") }, _private_trustedEmitter_decorators, { kind: "accessor", name: "#trustedEmitter", static: false, private: true, access: { has: (obj) => __privateIn(_BidiBrowser_instances, obj), get: (obj) => __privateGet(obj, _BidiBrowser_instances, trustedEmitter_get), set: (obj, value) => {
        __privateSet(obj, _BidiBrowser_instances, value, trustedEmitter_set);
      } }, metadata: _metadata }, _private_trustedEmitter_initializers, _private_trustedEmitter_extraInitializers);
      if (_metadata) Object.defineProperty(_a3, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    })(), __publicField(_a3, "subscribeModules", [
      "browsingContext",
      "network",
      "log",
      "script"
    ]), __publicField(_a3, "subscribeCdpEvents", [
      // Coverage
      "goog:cdp.Debugger.scriptParsed",
      "goog:cdp.CSS.styleSheetAdded",
      "goog:cdp.Runtime.executionContextsCleared",
      // Tracing
      "goog:cdp.Tracing.tracingComplete",
      // TODO: subscribe to all CDP events in the future.
      "goog:cdp.Network.requestWillBeSent",
      "goog:cdp.Debugger.scriptParsed",
      "goog:cdp.Page.screencastFrame"
    ]), _a3;
  })();
  /**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  const bidi = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    BidiBrowser,
    BidiBrowserContext,
    BidiConnection,
    BidiElementHandle,
    BidiFrame,
    BidiFrameRealm,
    BidiHTTPRequest,
    BidiHTTPResponse,
    BidiJSHandle,
    BidiKeyboard,
    BidiMouse,
    BidiPage,
    BidiRealm,
    BidiTouchscreen,
    BidiWorkerRealm,
    bidiToPuppeteerCookie,
    cdpSpecificCookiePropertiesFromPuppeteerToBidi,
    connectBidiOverCdp,
    convertCookiesExpiryCdpToBiDi,
    convertCookiesPartitionKeyFromPuppeteerToBiDi,
    convertCookiesSameSiteCdpToBiDi,
    requests
  }, Symbol.toStringTag, { value: "Module" }));
  var browser;
  var hasRequiredBrowser;
  function requireBrowser() {
    if (hasRequiredBrowser) return browser;
    hasRequiredBrowser = 1;
    browser = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
    return browser;
  }
  var browserExports = requireBrowser();
  const NodeWebSocket = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
  /**
   * @license
   * Copyright 2018 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   */
  const _NodeWebSocketTransport = class _NodeWebSocketTransport {
    constructor(ws) {
      __privateAdd(this, _ws2);
      __publicField(this, "onmessage");
      __publicField(this, "onclose");
      __privateSet(this, _ws2, ws);
      __privateGet(this, _ws2).addEventListener("message", (event) => {
        if (this.onmessage) {
          this.onmessage.call(null, event.data);
        }
      });
      __privateGet(this, _ws2).addEventListener("close", () => {
        if (this.onclose) {
          this.onclose.call(null);
        }
      });
      __privateGet(this, _ws2).addEventListener("error", () => {
      });
    }
    static create(url, headers) {
      return new Promise((resolve, reject) => {
        const ws = new NodeWebSocket(url, [], {
          followRedirects: true,
          perMessageDeflate: false,
          // @ts-expect-error https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketaddress-protocols-options
          allowSynchronousEvents: false,
          maxPayload: 256 * 1024 * 1024,
          // 256Mb
          headers: {
            "User-Agent": `Puppeteer ${packageVersion}`,
            ...headers
          }
        });
        ws.addEventListener("open", () => {
          return resolve(new _NodeWebSocketTransport(ws));
        });
        ws.addEventListener("error", reject);
      });
    }
    send(message) {
      __privateGet(this, _ws2).send(message);
    }
    close() {
      __privateGet(this, _ws2).close();
    }
  };
  _ws2 = new WeakMap();
  let NodeWebSocketTransport = _NodeWebSocketTransport;
  const NodeWebSocketTransport$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    NodeWebSocketTransport
  }, Symbol.toStringTag, { value: "Module" }));
})();
//# sourceMappingURL=background.iife.js.map
